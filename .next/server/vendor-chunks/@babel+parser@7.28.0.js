"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@babel+parser@7.28.0";
exports.ids = ["vendor-chunks/@babel+parser@7.28.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@babel+parser@7.28.0/node_modules/@babel/parser/lib/index.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.pnpm/@babel+parser@7.28.0/node_modules/@babel/parser/lib/index.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nfunction _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (-1 !== e.indexOf(n)) continue;\n    t[n] = r[n];\n  }\n  return t;\n}\nclass Position {\n  constructor(line, col, index) {\n    this.line = void 0;\n    this.column = void 0;\n    this.index = void 0;\n    this.line = line;\n    this.column = col;\n    this.index = index;\n  }\n}\nclass SourceLocation {\n  constructor(start, end) {\n    this.start = void 0;\n    this.end = void 0;\n    this.filename = void 0;\n    this.identifierName = void 0;\n    this.start = start;\n    this.end = end;\n  }\n}\nfunction createPositionWithColumnOffset(position, columnOffset) {\n  const {\n    line,\n    column,\n    index\n  } = position;\n  return new Position(line, column + columnOffset, index + columnOffset);\n}\nconst code = \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\";\nvar ModuleErrors = {\n  ImportMetaOutsideModule: {\n    message: `import.meta may appear only with 'sourceType: \"module\"'`,\n    code\n  },\n  ImportOutsideModule: {\n    message: `'import' and 'export' may appear only with 'sourceType: \"module\"'`,\n    code\n  }\n};\nconst NodeDescriptions = {\n  ArrayPattern: \"array destructuring pattern\",\n  AssignmentExpression: \"assignment expression\",\n  AssignmentPattern: \"assignment expression\",\n  ArrowFunctionExpression: \"arrow function expression\",\n  ConditionalExpression: \"conditional expression\",\n  CatchClause: \"catch clause\",\n  ForOfStatement: \"for-of statement\",\n  ForInStatement: \"for-in statement\",\n  ForStatement: \"for-loop\",\n  FormalParameters: \"function parameter list\",\n  Identifier: \"identifier\",\n  ImportSpecifier: \"import specifier\",\n  ImportDefaultSpecifier: \"import default specifier\",\n  ImportNamespaceSpecifier: \"import namespace specifier\",\n  ObjectPattern: \"object destructuring pattern\",\n  ParenthesizedExpression: \"parenthesized expression\",\n  RestElement: \"rest element\",\n  UpdateExpression: {\n    true: \"prefix operation\",\n    false: \"postfix operation\"\n  },\n  VariableDeclarator: \"variable declaration\",\n  YieldExpression: \"yield expression\"\n};\nconst toNodeDescription = node => node.type === \"UpdateExpression\" ? NodeDescriptions.UpdateExpression[`${node.prefix}`] : NodeDescriptions[node.type];\nvar StandardErrors = {\n  AccessorIsGenerator: ({\n    kind\n  }) => `A ${kind}ter cannot be a generator.`,\n  ArgumentsInClass: \"'arguments' is only allowed in functions and class methods.\",\n  AsyncFunctionInSingleStatementContext: \"Async functions can only be declared at the top level or inside a block.\",\n  AwaitBindingIdentifier: \"Can not use 'await' as identifier inside an async function.\",\n  AwaitBindingIdentifierInStaticBlock: \"Can not use 'await' as identifier inside a static block.\",\n  AwaitExpressionFormalParameter: \"'await' is not allowed in async function parameters.\",\n  AwaitUsingNotInAsyncContext: \"'await using' is only allowed within async functions and at the top levels of modules.\",\n  AwaitNotInAsyncContext: \"'await' is only allowed within async functions and at the top levels of modules.\",\n  BadGetterArity: \"A 'get' accessor must not have any formal parameters.\",\n  BadSetterArity: \"A 'set' accessor must have exactly one formal parameter.\",\n  BadSetterRestParameter: \"A 'set' accessor function argument must not be a rest parameter.\",\n  ConstructorClassField: \"Classes may not have a field named 'constructor'.\",\n  ConstructorClassPrivateField: \"Classes may not have a private field named '#constructor'.\",\n  ConstructorIsAccessor: \"Class constructor may not be an accessor.\",\n  ConstructorIsAsync: \"Constructor can't be an async function.\",\n  ConstructorIsGenerator: \"Constructor can't be a generator.\",\n  DeclarationMissingInitializer: ({\n    kind\n  }) => `Missing initializer in ${kind} declaration.`,\n  DecoratorArgumentsOutsideParentheses: \"Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.\",\n  DecoratorBeforeExport: \"Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.\",\n  DecoratorsBeforeAfterExport: \"Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.\",\n  DecoratorConstructor: \"Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?\",\n  DecoratorExportClass: \"Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.\",\n  DecoratorSemicolon: \"Decorators must not be followed by a semicolon.\",\n  DecoratorStaticBlock: \"Decorators can't be used with a static block.\",\n  DeferImportRequiresNamespace: 'Only `import defer * as x from \"./module\"` is valid.',\n  DeletePrivateField: \"Deleting a private field is not allowed.\",\n  DestructureNamedImport: \"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\",\n  DuplicateConstructor: \"Duplicate constructor in the same class.\",\n  DuplicateDefaultExport: \"Only one default export allowed per module.\",\n  DuplicateExport: ({\n    exportName\n  }) => `\\`${exportName}\\` has already been exported. Exported identifiers must be unique.`,\n  DuplicateProto: \"Redefinition of __proto__ property.\",\n  DuplicateRegExpFlags: \"Duplicate regular expression flag.\",\n  ElementAfterRest: \"Rest element must be last element.\",\n  EscapedCharNotAnIdentifier: \"Invalid Unicode escape.\",\n  ExportBindingIsString: ({\n    localName,\n    exportName\n  }) => `A string literal cannot be used as an exported binding without \\`from\\`.\\n- Did you mean \\`export { '${localName}' as '${exportName}' } from 'some-module'\\`?`,\n  ExportDefaultFromAsIdentifier: \"'from' is not allowed as an identifier after 'export default'.\",\n  ForInOfLoopInitializer: ({\n    type\n  }) => `'${type === \"ForInStatement\" ? \"for-in\" : \"for-of\"}' loop variable declaration may not have an initializer.`,\n  ForInUsing: \"For-in loop may not start with 'using' declaration.\",\n  ForOfAsync: \"The left-hand side of a for-of loop may not be 'async'.\",\n  ForOfLet: \"The left-hand side of a for-of loop may not start with 'let'.\",\n  GeneratorInSingleStatementContext: \"Generators can only be declared at the top level or inside a block.\",\n  IllegalBreakContinue: ({\n    type\n  }) => `Unsyntactic ${type === \"BreakStatement\" ? \"break\" : \"continue\"}.`,\n  IllegalLanguageModeDirective: \"Illegal 'use strict' directive in function with non-simple parameter list.\",\n  IllegalReturn: \"'return' outside of function.\",\n  ImportAttributesUseAssert: \"The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedImportAssert` parser plugin to suppress this error.\",\n  ImportBindingIsString: ({\n    importName\n  }) => `A string literal cannot be used as an imported binding.\\n- Did you mean \\`import { \"${importName}\" as foo }\\`?`,\n  ImportCallArity: `\\`import()\\` requires exactly one or two arguments.`,\n  ImportCallNotNewExpression: \"Cannot use new with import(...).\",\n  ImportCallSpreadArgument: \"`...` is not allowed in `import()`.\",\n  ImportJSONBindingNotDefault: \"A JSON module can only be imported with `default`.\",\n  ImportReflectionHasAssertion: \"`import module x` cannot have assertions.\",\n  ImportReflectionNotBinding: 'Only `import module x from \"./module\"` is valid.',\n  IncompatibleRegExpUVFlags: \"The 'u' and 'v' regular expression flags cannot be enabled at the same time.\",\n  InvalidBigIntLiteral: \"Invalid BigIntLiteral.\",\n  InvalidCodePoint: \"Code point out of bounds.\",\n  InvalidCoverDiscardElement: \"'void' must be followed by an expression when not used in a binding position.\",\n  InvalidCoverInitializedName: \"Invalid shorthand property initializer.\",\n  InvalidDecimal: \"Invalid decimal.\",\n  InvalidDigit: ({\n    radix\n  }) => `Expected number in radix ${radix}.`,\n  InvalidEscapeSequence: \"Bad character escape sequence.\",\n  InvalidEscapeSequenceTemplate: \"Invalid escape sequence in template.\",\n  InvalidEscapedReservedWord: ({\n    reservedWord\n  }) => `Escape sequence in keyword ${reservedWord}.`,\n  InvalidIdentifier: ({\n    identifierName\n  }) => `Invalid identifier ${identifierName}.`,\n  InvalidLhs: ({\n    ancestor\n  }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,\n  InvalidLhsBinding: ({\n    ancestor\n  }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,\n  InvalidLhsOptionalChaining: ({\n    ancestor\n  }) => `Invalid optional chaining in the left-hand side of ${toNodeDescription(ancestor)}.`,\n  InvalidNumber: \"Invalid number.\",\n  InvalidOrMissingExponent: \"Floating-point numbers require a valid exponent after the 'e'.\",\n  InvalidOrUnexpectedToken: ({\n    unexpected\n  }) => `Unexpected character '${unexpected}'.`,\n  InvalidParenthesizedAssignment: \"Invalid parenthesized assignment pattern.\",\n  InvalidPrivateFieldResolution: ({\n    identifierName\n  }) => `Private name #${identifierName} is not defined.`,\n  InvalidPropertyBindingPattern: \"Binding member expression.\",\n  InvalidRecordProperty: \"Only properties and spread elements are allowed in record definitions.\",\n  InvalidRestAssignmentPattern: \"Invalid rest operator's argument.\",\n  LabelRedeclaration: ({\n    labelName\n  }) => `Label '${labelName}' is already declared.`,\n  LetInLexicalBinding: \"'let' is disallowed as a lexically bound name.\",\n  LineTerminatorBeforeArrow: \"No line break is allowed before '=>'.\",\n  MalformedRegExpFlags: \"Invalid regular expression flag.\",\n  MissingClassName: \"A class name is required.\",\n  MissingEqInAssignment: \"Only '=' operator can be used for specifying default value.\",\n  MissingSemicolon: \"Missing semicolon.\",\n  MissingPlugin: ({\n    missingPlugin\n  }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map(name => JSON.stringify(name)).join(\", \")}.`,\n  MissingOneOfPlugins: ({\n    missingPlugin\n  }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map(name => JSON.stringify(name)).join(\", \")}.`,\n  MissingUnicodeEscape: \"Expecting Unicode escape sequence \\\\uXXXX.\",\n  MixingCoalesceWithLogical: \"Nullish coalescing operator(??) requires parens when mixing with logical operators.\",\n  ModuleAttributeDifferentFromType: \"The only accepted module attribute is `type`.\",\n  ModuleAttributeInvalidValue: \"Only string literals are allowed as module attribute values.\",\n  ModuleAttributesWithDuplicateKeys: ({\n    key\n  }) => `Duplicate key \"${key}\" is not allowed in module attributes.`,\n  ModuleExportNameHasLoneSurrogate: ({\n    surrogateCharCode\n  }) => `An export name cannot include a lone surrogate, found '\\\\u${surrogateCharCode.toString(16)}'.`,\n  ModuleExportUndefined: ({\n    localName\n  }) => `Export '${localName}' is not defined.`,\n  MultipleDefaultsInSwitch: \"Multiple default clauses.\",\n  NewlineAfterThrow: \"Illegal newline after throw.\",\n  NoCatchOrFinally: \"Missing catch or finally clause.\",\n  NumberIdentifier: \"Identifier directly after number.\",\n  NumericSeparatorInEscapeSequence: \"Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.\",\n  ObsoleteAwaitStar: \"'await*' has been removed from the async functions proposal. Use Promise.all() instead.\",\n  OptionalChainingNoNew: \"Constructors in/after an Optional Chain are not allowed.\",\n  OptionalChainingNoTemplate: \"Tagged Template Literals are not allowed in optionalChain.\",\n  OverrideOnConstructor: \"'override' modifier cannot appear on a constructor declaration.\",\n  ParamDupe: \"Argument name clash.\",\n  PatternHasAccessor: \"Object pattern can't contain getter or setter.\",\n  PatternHasMethod: \"Object pattern can't contain methods.\",\n  PrivateInExpectedIn: ({\n    identifierName\n  }) => `Private names are only allowed in property accesses (\\`obj.#${identifierName}\\`) or in \\`in\\` expressions (\\`#${identifierName} in obj\\`).`,\n  PrivateNameRedeclaration: ({\n    identifierName\n  }) => `Duplicate private name #${identifierName}.`,\n  RecordExpressionBarIncorrectEndSyntaxType: \"Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  RecordExpressionBarIncorrectStartSyntaxType: \"Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  RecordExpressionHashIncorrectStartSyntaxType: \"Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.\",\n  RecordNoProto: \"'__proto__' is not allowed in Record expressions.\",\n  RestTrailingComma: \"Unexpected trailing comma after rest element.\",\n  SloppyFunction: \"In non-strict mode code, functions can only be declared at top level or inside a block.\",\n  SloppyFunctionAnnexB: \"In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.\",\n  SourcePhaseImportRequiresDefault: 'Only `import source x from \"./module\"` is valid.',\n  StaticPrototype: \"Classes may not have static property named prototype.\",\n  SuperNotAllowed: \"`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?\",\n  SuperPrivateField: \"Private fields can't be accessed on super.\",\n  TrailingDecorator: \"Decorators must be attached to a class element.\",\n  TupleExpressionBarIncorrectEndSyntaxType: \"Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  TupleExpressionBarIncorrectStartSyntaxType: \"Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  TupleExpressionHashIncorrectStartSyntaxType: \"Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.\",\n  UnexpectedArgumentPlaceholder: \"Unexpected argument placeholder.\",\n  UnexpectedAwaitAfterPipelineBody: 'Unexpected \"await\" after pipeline body; await must have parentheses in minimal proposal.',\n  UnexpectedDigitAfterHash: \"Unexpected digit after hash token.\",\n  UnexpectedImportExport: \"'import' and 'export' may only appear at the top level.\",\n  UnexpectedKeyword: ({\n    keyword\n  }) => `Unexpected keyword '${keyword}'.`,\n  UnexpectedLeadingDecorator: \"Leading decorators must be attached to a class declaration.\",\n  UnexpectedLexicalDeclaration: \"Lexical declaration cannot appear in a single-statement context.\",\n  UnexpectedNewTarget: \"`new.target` can only be used in functions or class properties.\",\n  UnexpectedNumericSeparator: \"A numeric separator is only allowed between two digits.\",\n  UnexpectedPrivateField: \"Unexpected private name.\",\n  UnexpectedReservedWord: ({\n    reservedWord\n  }) => `Unexpected reserved word '${reservedWord}'.`,\n  UnexpectedSuper: \"'super' is only allowed in object methods and classes.\",\n  UnexpectedToken: ({\n    expected,\n    unexpected\n  }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : \"\"}${expected ? `, expected \"${expected}\"` : \"\"}`,\n  UnexpectedTokenUnaryExponentiation: \"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.\",\n  UnexpectedUsingDeclaration: \"Using declaration cannot appear in the top level when source type is `script` or in the bare case statement.\",\n  UnexpectedVoidPattern: \"Unexpected void binding.\",\n  UnsupportedBind: \"Binding should be performed on object property.\",\n  UnsupportedDecoratorExport: \"A decorated export must export a class declaration.\",\n  UnsupportedDefaultExport: \"Only expressions, functions or classes are allowed as the `default` export.\",\n  UnsupportedImport: \"`import` can only be used in `import()` or `import.meta`.\",\n  UnsupportedMetaProperty: ({\n    target,\n    onlyValidPropertyName\n  }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,\n  UnsupportedParameterDecorator: \"Decorators cannot be used to decorate parameters.\",\n  UnsupportedPropertyDecorator: \"Decorators cannot be used to decorate object literal properties.\",\n  UnsupportedSuper: \"'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).\",\n  UnterminatedComment: \"Unterminated comment.\",\n  UnterminatedRegExp: \"Unterminated regular expression.\",\n  UnterminatedString: \"Unterminated string constant.\",\n  UnterminatedTemplate: \"Unterminated template.\",\n  UsingDeclarationExport: \"Using declaration cannot be exported.\",\n  UsingDeclarationHasBindingPattern: \"Using declaration cannot have destructuring patterns.\",\n  VarRedeclaration: ({\n    identifierName\n  }) => `Identifier '${identifierName}' has already been declared.`,\n  VoidPatternCatchClauseParam: \"A void binding can not be the catch clause parameter. Use `try { ... } catch { ... }` if you want to discard the caught error.\",\n  VoidPatternInitializer: \"A void binding may not have an initializer.\",\n  YieldBindingIdentifier: \"Can not use 'yield' as identifier inside a generator.\",\n  YieldInParameter: \"Yield expression is not allowed in formal parameters.\",\n  YieldNotInGeneratorFunction: \"'yield' is only allowed within generator functions.\",\n  ZeroDigitNumericSeparator: \"Numeric separator can not be used after leading 0.\"\n};\nvar StrictModeErrors = {\n  StrictDelete: \"Deleting local variable in strict mode.\",\n  StrictEvalArguments: ({\n    referenceName\n  }) => `Assigning to '${referenceName}' in strict mode.`,\n  StrictEvalArgumentsBinding: ({\n    bindingName\n  }) => `Binding '${bindingName}' in strict mode.`,\n  StrictFunction: \"In strict mode code, functions can only be declared at top level or inside a block.\",\n  StrictNumericEscape: \"The only valid numeric escape in strict mode is '\\\\0'.\",\n  StrictOctalLiteral: \"Legacy octal literals are not allowed in strict mode.\",\n  StrictWith: \"'with' in strict mode.\"\n};\nvar ParseExpressionErrors = {\n  ParseExpressionEmptyInput: \"Unexpected parseExpression() input: The input is empty or contains only comments.\",\n  ParseExpressionExpectsEOF: ({\n    unexpected\n  }) => `Unexpected parseExpression() input: The input should contain exactly one expression, but the first expression is followed by the unexpected character \\`${String.fromCodePoint(unexpected)}\\`.`\n};\nconst UnparenthesizedPipeBodyDescriptions = new Set([\"ArrowFunctionExpression\", \"AssignmentExpression\", \"ConditionalExpression\", \"YieldExpression\"]);\nvar PipelineOperatorErrors = Object.assign({\n  PipeBodyIsTighter: \"Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.\",\n  PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a \"proposal\": \"hack\" or \"smart\" option.',\n  PipeTopicUnbound: \"Topic reference is unbound; it must be inside a pipe body.\",\n  PipeTopicUnconfiguredToken: ({\n    token\n  }) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { \"proposal\": \"hack\", \"topicToken\": \"${token}\" }.`,\n  PipeTopicUnused: \"Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.\",\n  PipeUnparenthesizedBody: ({\n    type\n  }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({\n    type\n  })}; please wrap it in parentheses.`\n}, {\n  PipelineBodyNoArrow: 'Unexpected arrow \"=>\" after pipeline body; arrow function in pipeline body must be parenthesized.',\n  PipelineBodySequenceExpression: \"Pipeline body may not be a comma-separated sequence expression.\",\n  PipelineHeadSequenceExpression: \"Pipeline head should not be a comma-separated sequence expression.\",\n  PipelineTopicUnused: \"Pipeline is in topic style but does not use topic reference.\",\n  PrimaryTopicNotAllowed: \"Topic reference was used in a lexical context without topic binding.\",\n  PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a \"proposal\": \"hack\" or \"smart\" option.'\n});\nconst _excluded = [\"message\"];\nfunction defineHidden(obj, key, value) {\n  Object.defineProperty(obj, key, {\n    enumerable: false,\n    configurable: true,\n    value\n  });\n}\nfunction toParseErrorConstructor({\n  toMessage,\n  code,\n  reasonCode,\n  syntaxPlugin\n}) {\n  const hasMissingPlugin = reasonCode === \"MissingPlugin\" || reasonCode === \"MissingOneOfPlugins\";\n  {\n    const oldReasonCodes = {\n      AccessorCannotDeclareThisParameter: \"AccesorCannotDeclareThisParameter\",\n      AccessorCannotHaveTypeParameters: \"AccesorCannotHaveTypeParameters\",\n      ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: \"ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference\",\n      SetAccessorCannotHaveOptionalParameter: \"SetAccesorCannotHaveOptionalParameter\",\n      SetAccessorCannotHaveRestParameter: \"SetAccesorCannotHaveRestParameter\",\n      SetAccessorCannotHaveReturnType: \"SetAccesorCannotHaveReturnType\"\n    };\n    if (oldReasonCodes[reasonCode]) {\n      reasonCode = oldReasonCodes[reasonCode];\n    }\n  }\n  return function constructor(loc, details) {\n    const error = new SyntaxError();\n    error.code = code;\n    error.reasonCode = reasonCode;\n    error.loc = loc;\n    error.pos = loc.index;\n    error.syntaxPlugin = syntaxPlugin;\n    if (hasMissingPlugin) {\n      error.missingPlugin = details.missingPlugin;\n    }\n    defineHidden(error, \"clone\", function clone(overrides = {}) {\n      var _overrides$loc;\n      const {\n        line,\n        column,\n        index\n      } = (_overrides$loc = overrides.loc) != null ? _overrides$loc : loc;\n      return constructor(new Position(line, column, index), Object.assign({}, details, overrides.details));\n    });\n    defineHidden(error, \"details\", details);\n    Object.defineProperty(error, \"message\", {\n      configurable: true,\n      get() {\n        const message = `${toMessage(details)} (${loc.line}:${loc.column})`;\n        this.message = message;\n        return message;\n      },\n      set(value) {\n        Object.defineProperty(this, \"message\", {\n          value,\n          writable: true\n        });\n      }\n    });\n    return error;\n  };\n}\nfunction ParseErrorEnum(argument, syntaxPlugin) {\n  if (Array.isArray(argument)) {\n    return parseErrorTemplates => ParseErrorEnum(parseErrorTemplates, argument[0]);\n  }\n  const ParseErrorConstructors = {};\n  for (const reasonCode of Object.keys(argument)) {\n    const template = argument[reasonCode];\n    const _ref = typeof template === \"string\" ? {\n        message: () => template\n      } : typeof template === \"function\" ? {\n        message: template\n      } : template,\n      {\n        message\n      } = _ref,\n      rest = _objectWithoutPropertiesLoose(_ref, _excluded);\n    const toMessage = typeof message === \"string\" ? () => message : message;\n    ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({\n      code: \"BABEL_PARSER_SYNTAX_ERROR\",\n      reasonCode,\n      toMessage\n    }, syntaxPlugin ? {\n      syntaxPlugin\n    } : {}, rest));\n  }\n  return ParseErrorConstructors;\n}\nconst Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum(ParseExpressionErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));\nfunction createDefaultOptions() {\n  return {\n    sourceType: \"script\",\n    sourceFilename: undefined,\n    startIndex: 0,\n    startColumn: 0,\n    startLine: 1,\n    allowAwaitOutsideFunction: false,\n    allowReturnOutsideFunction: false,\n    allowNewTargetOutsideFunction: false,\n    allowImportExportEverywhere: false,\n    allowSuperOutsideMethod: false,\n    allowUndeclaredExports: false,\n    allowYieldOutsideFunction: false,\n    plugins: [],\n    strictMode: null,\n    ranges: false,\n    tokens: false,\n    createImportExpressions: false,\n    createParenthesizedExpressions: false,\n    errorRecovery: false,\n    attachComment: true,\n    annexB: true\n  };\n}\nfunction getOptions(opts) {\n  const options = createDefaultOptions();\n  if (opts == null) {\n    return options;\n  }\n  if (opts.annexB != null && opts.annexB !== false) {\n    throw new Error(\"The `annexB` option can only be set to `false`.\");\n  }\n  for (const key of Object.keys(options)) {\n    if (opts[key] != null) options[key] = opts[key];\n  }\n  if (options.startLine === 1) {\n    if (opts.startIndex == null && options.startColumn > 0) {\n      options.startIndex = options.startColumn;\n    } else if (opts.startColumn == null && options.startIndex > 0) {\n      options.startColumn = options.startIndex;\n    }\n  } else if (opts.startColumn == null || opts.startIndex == null) {\n    if (opts.startIndex != null) {\n      throw new Error(\"With a `startLine > 1` you must also specify `startIndex` and `startColumn`.\");\n    }\n  }\n  if (options.sourceType === \"commonjs\") {\n    if (opts.allowAwaitOutsideFunction != null) {\n      throw new Error(\"The `allowAwaitOutsideFunction` option cannot be used with `sourceType: 'commonjs'`.\");\n    }\n    if (opts.allowReturnOutsideFunction != null) {\n      throw new Error(\"`sourceType: 'commonjs'` implies `allowReturnOutsideFunction: true`, please remove the `allowReturnOutsideFunction` option or use `sourceType: 'script'`.\");\n    }\n    if (opts.allowNewTargetOutsideFunction != null) {\n      throw new Error(\"`sourceType: 'commonjs'` implies `allowNewTargetOutsideFunction: true`, please remove the `allowNewTargetOutsideFunction` option or use `sourceType: 'script'`.\");\n    }\n  }\n  return options;\n}\nconst {\n  defineProperty\n} = Object;\nconst toUnenumerable = (object, key) => {\n  if (object) {\n    defineProperty(object, key, {\n      enumerable: false,\n      value: object[key]\n    });\n  }\n};\nfunction toESTreeLocation(node) {\n  toUnenumerable(node.loc.start, \"index\");\n  toUnenumerable(node.loc.end, \"index\");\n  return node;\n}\nvar estree = superClass => class ESTreeParserMixin extends superClass {\n  parse() {\n    const file = toESTreeLocation(super.parse());\n    if (this.optionFlags & 256) {\n      file.tokens = file.tokens.map(toESTreeLocation);\n    }\n    return file;\n  }\n  parseRegExpLiteral({\n    pattern,\n    flags\n  }) {\n    let regex = null;\n    try {\n      regex = new RegExp(pattern, flags);\n    } catch (_) {}\n    const node = this.estreeParseLiteral(regex);\n    node.regex = {\n      pattern,\n      flags\n    };\n    return node;\n  }\n  parseBigIntLiteral(value) {\n    let bigInt;\n    try {\n      bigInt = BigInt(value);\n    } catch (_unused) {\n      bigInt = null;\n    }\n    const node = this.estreeParseLiteral(bigInt);\n    node.bigint = String(node.value || value);\n    return node;\n  }\n  parseDecimalLiteral(value) {\n    const decimal = null;\n    const node = this.estreeParseLiteral(decimal);\n    node.decimal = String(node.value || value);\n    return node;\n  }\n  estreeParseLiteral(value) {\n    return this.parseLiteral(value, \"Literal\");\n  }\n  parseStringLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n  parseNumericLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n  parseNullLiteral() {\n    return this.estreeParseLiteral(null);\n  }\n  parseBooleanLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n  estreeParseChainExpression(node, endLoc) {\n    const chain = this.startNodeAtNode(node);\n    chain.expression = node;\n    return this.finishNodeAt(chain, \"ChainExpression\", endLoc);\n  }\n  directiveToStmt(directive) {\n    const expression = directive.value;\n    delete directive.value;\n    this.castNodeTo(expression, \"Literal\");\n    expression.raw = expression.extra.raw;\n    expression.value = expression.extra.expressionValue;\n    const stmt = this.castNodeTo(directive, \"ExpressionStatement\");\n    stmt.expression = expression;\n    stmt.directive = expression.extra.rawValue;\n    delete expression.extra;\n    return stmt;\n  }\n  fillOptionalPropertiesForTSESLint(node) {}\n  cloneEstreeStringLiteral(node) {\n    const {\n      start,\n      end,\n      loc,\n      range,\n      raw,\n      value\n    } = node;\n    const cloned = Object.create(node.constructor.prototype);\n    cloned.type = \"Literal\";\n    cloned.start = start;\n    cloned.end = end;\n    cloned.loc = loc;\n    cloned.range = range;\n    cloned.raw = raw;\n    cloned.value = value;\n    return cloned;\n  }\n  initFunction(node, isAsync) {\n    super.initFunction(node, isAsync);\n    node.expression = false;\n  }\n  checkDeclaration(node) {\n    if (node != null && this.isObjectProperty(node)) {\n      this.checkDeclaration(node.value);\n    } else {\n      super.checkDeclaration(node);\n    }\n  }\n  getObjectOrClassMethodParams(method) {\n    return method.value.params;\n  }\n  isValidDirective(stmt) {\n    var _stmt$expression$extr;\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"Literal\" && typeof stmt.expression.value === \"string\" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);\n  }\n  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {\n    super.parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse);\n    const directiveStatements = node.directives.map(d => this.directiveToStmt(d));\n    node.body = directiveStatements.concat(node.body);\n    delete node.directives;\n  }\n  parsePrivateName() {\n    const node = super.parsePrivateName();\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return node;\n      }\n    }\n    return this.convertPrivateNameToPrivateIdentifier(node);\n  }\n  convertPrivateNameToPrivateIdentifier(node) {\n    const name = super.getPrivateNameSV(node);\n    node = node;\n    delete node.id;\n    node.name = name;\n    return this.castNodeTo(node, \"PrivateIdentifier\");\n  }\n  isPrivateName(node) {\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return super.isPrivateName(node);\n      }\n    }\n    return node.type === \"PrivateIdentifier\";\n  }\n  getPrivateNameSV(node) {\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return super.getPrivateNameSV(node);\n      }\n    }\n    return node.name;\n  }\n  parseLiteral(value, type) {\n    const node = super.parseLiteral(value, type);\n    node.raw = node.extra.raw;\n    delete node.extra;\n    return node;\n  }\n  parseFunctionBody(node, allowExpression, isMethod = false) {\n    super.parseFunctionBody(node, allowExpression, isMethod);\n    node.expression = node.body.type !== \"BlockStatement\";\n  }\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\n    let funcNode = this.startNode();\n    funcNode.kind = node.kind;\n    funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);\n    delete funcNode.kind;\n    const {\n      typeParameters\n    } = node;\n    if (typeParameters) {\n      delete node.typeParameters;\n      funcNode.typeParameters = typeParameters;\n      this.resetStartLocationFromNode(funcNode, typeParameters);\n    }\n    const valueNode = this.castNodeTo(funcNode, \"FunctionExpression\");\n    node.value = valueNode;\n    if (type === \"ClassPrivateMethod\") {\n      node.computed = false;\n    }\n    if (type === \"ObjectMethod\") {\n      if (node.kind === \"method\") {\n        node.kind = \"init\";\n      }\n      node.shorthand = false;\n      return this.finishNode(node, \"Property\");\n    } else {\n      return this.finishNode(node, \"MethodDefinition\");\n    }\n  }\n  nameIsConstructor(key) {\n    if (key.type === \"Literal\") return key.value === \"constructor\";\n    return super.nameIsConstructor(key);\n  }\n  parseClassProperty(...args) {\n    const propertyNode = super.parseClassProperty(...args);\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return propertyNode;\n      }\n    }\n    {\n      this.castNodeTo(propertyNode, \"PropertyDefinition\");\n    }\n    return propertyNode;\n  }\n  parseClassPrivateProperty(...args) {\n    const propertyNode = super.parseClassPrivateProperty(...args);\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return propertyNode;\n      }\n    }\n    {\n      this.castNodeTo(propertyNode, \"PropertyDefinition\");\n    }\n    propertyNode.computed = false;\n    return propertyNode;\n  }\n  parseClassAccessorProperty(node) {\n    const accessorPropertyNode = super.parseClassAccessorProperty(node);\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return accessorPropertyNode;\n      }\n    }\n    if (accessorPropertyNode.abstract && this.hasPlugin(\"typescript\")) {\n      delete accessorPropertyNode.abstract;\n      this.castNodeTo(accessorPropertyNode, \"TSAbstractAccessorProperty\");\n    } else {\n      this.castNodeTo(accessorPropertyNode, \"AccessorProperty\");\n    }\n    return accessorPropertyNode;\n  }\n  parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {\n    const node = super.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);\n    if (node) {\n      node.kind = \"init\";\n      this.castNodeTo(node, \"Property\");\n    }\n    return node;\n  }\n  finishObjectProperty(node) {\n    node.kind = \"init\";\n    return this.finishNode(node, \"Property\");\n  }\n  isValidLVal(type, isUnparenthesizedInAssign, binding) {\n    return type === \"Property\" ? \"value\" : super.isValidLVal(type, isUnparenthesizedInAssign, binding);\n  }\n  isAssignable(node, isBinding) {\n    if (node != null && this.isObjectProperty(node)) {\n      return this.isAssignable(node.value, isBinding);\n    }\n    return super.isAssignable(node, isBinding);\n  }\n  toAssignable(node, isLHS = false) {\n    if (node != null && this.isObjectProperty(node)) {\n      const {\n        key,\n        value\n      } = node;\n      if (this.isPrivateName(key)) {\n        this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);\n      }\n      this.toAssignable(value, isLHS);\n    } else {\n      super.toAssignable(node, isLHS);\n    }\n  }\n  toAssignableObjectExpressionProp(prop, isLast, isLHS) {\n    if (prop.type === \"Property\" && (prop.kind === \"get\" || prop.kind === \"set\")) {\n      this.raise(Errors.PatternHasAccessor, prop.key);\n    } else if (prop.type === \"Property\" && prop.method) {\n      this.raise(Errors.PatternHasMethod, prop.key);\n    } else {\n      super.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n    }\n  }\n  finishCallExpression(unfinished, optional) {\n    const node = super.finishCallExpression(unfinished, optional);\n    if (node.callee.type === \"Import\") {\n      var _ref, _ref2;\n      this.castNodeTo(node, \"ImportExpression\");\n      node.source = node.arguments[0];\n      node.options = (_ref = node.arguments[1]) != null ? _ref : null;\n      node.attributes = (_ref2 = node.arguments[1]) != null ? _ref2 : null;\n      delete node.arguments;\n      delete node.callee;\n    } else if (node.type === \"OptionalCallExpression\") {\n      this.castNodeTo(node, \"CallExpression\");\n    } else {\n      node.optional = false;\n    }\n    return node;\n  }\n  toReferencedArguments(node) {\n    if (node.type === \"ImportExpression\") {\n      return;\n    }\n    super.toReferencedArguments(node);\n  }\n  parseExport(unfinished, decorators) {\n    const exportStartLoc = this.state.lastTokStartLoc;\n    const node = super.parseExport(unfinished, decorators);\n    switch (node.type) {\n      case \"ExportAllDeclaration\":\n        node.exported = null;\n        break;\n      case \"ExportNamedDeclaration\":\n        if (node.specifiers.length === 1 && node.specifiers[0].type === \"ExportNamespaceSpecifier\") {\n          this.castNodeTo(node, \"ExportAllDeclaration\");\n          node.exported = node.specifiers[0].exported;\n          delete node.specifiers;\n        }\n      case \"ExportDefaultDeclaration\":\n        {\n          var _declaration$decorato;\n          const {\n            declaration\n          } = node;\n          if ((declaration == null ? void 0 : declaration.type) === \"ClassDeclaration\" && ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0 && declaration.start === node.start) {\n            this.resetStartLocation(node, exportStartLoc);\n          }\n        }\n        break;\n    }\n    return node;\n  }\n  stopParseSubscript(base, state) {\n    const node = super.stopParseSubscript(base, state);\n    if (state.optionalChainMember) {\n      return this.estreeParseChainExpression(node, base.loc.end);\n    }\n    return node;\n  }\n  parseMember(base, startLoc, state, computed, optional) {\n    const node = super.parseMember(base, startLoc, state, computed, optional);\n    if (node.type === \"OptionalMemberExpression\") {\n      this.castNodeTo(node, \"MemberExpression\");\n    } else {\n      node.optional = false;\n    }\n    return node;\n  }\n  isOptionalMemberExpression(node) {\n    if (node.type === \"ChainExpression\") {\n      return node.expression.type === \"MemberExpression\";\n    }\n    return super.isOptionalMemberExpression(node);\n  }\n  hasPropertyAsPrivateName(node) {\n    if (node.type === \"ChainExpression\") {\n      node = node.expression;\n    }\n    return super.hasPropertyAsPrivateName(node);\n  }\n  isObjectProperty(node) {\n    return node.type === \"Property\" && node.kind === \"init\" && !node.method;\n  }\n  isObjectMethod(node) {\n    return node.type === \"Property\" && (node.method || node.kind === \"get\" || node.kind === \"set\");\n  }\n  castNodeTo(node, type) {\n    const result = super.castNodeTo(node, type);\n    this.fillOptionalPropertiesForTSESLint(result);\n    return result;\n  }\n  cloneIdentifier(node) {\n    const cloned = super.cloneIdentifier(node);\n    this.fillOptionalPropertiesForTSESLint(cloned);\n    return cloned;\n  }\n  cloneStringLiteral(node) {\n    if (node.type === \"Literal\") {\n      return this.cloneEstreeStringLiteral(node);\n    }\n    return super.cloneStringLiteral(node);\n  }\n  finishNodeAt(node, type, endLoc) {\n    return toESTreeLocation(super.finishNodeAt(node, type, endLoc));\n  }\n  finishNode(node, type) {\n    const result = super.finishNode(node, type);\n    this.fillOptionalPropertiesForTSESLint(result);\n    return result;\n  }\n  resetStartLocation(node, startLoc) {\n    super.resetStartLocation(node, startLoc);\n    toESTreeLocation(node);\n  }\n  resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {\n    super.resetEndLocation(node, endLoc);\n    toESTreeLocation(node);\n  }\n};\nclass TokContext {\n  constructor(token, preserveSpace) {\n    this.token = void 0;\n    this.preserveSpace = void 0;\n    this.token = token;\n    this.preserveSpace = !!preserveSpace;\n  }\n}\nconst types = {\n  brace: new TokContext(\"{\"),\n  j_oTag: new TokContext(\"<tag\"),\n  j_cTag: new TokContext(\"</tag\"),\n  j_expr: new TokContext(\"<tag>...</tag>\", true)\n};\n{\n  types.template = new TokContext(\"`\", true);\n}\nconst beforeExpr = true;\nconst startsExpr = true;\nconst isLoop = true;\nconst isAssign = true;\nconst prefix = true;\nconst postfix = true;\nclass ExportedTokenType {\n  constructor(label, conf = {}) {\n    this.label = void 0;\n    this.keyword = void 0;\n    this.beforeExpr = void 0;\n    this.startsExpr = void 0;\n    this.rightAssociative = void 0;\n    this.isLoop = void 0;\n    this.isAssign = void 0;\n    this.prefix = void 0;\n    this.postfix = void 0;\n    this.binop = void 0;\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.rightAssociative = !!conf.rightAssociative;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop != null ? conf.binop : null;\n    {\n      this.updateContext = null;\n    }\n  }\n}\nconst keywords$1 = new Map();\nfunction createKeyword(name, options = {}) {\n  options.keyword = name;\n  const token = createToken(name, options);\n  keywords$1.set(name, token);\n  return token;\n}\nfunction createBinop(name, binop) {\n  return createToken(name, {\n    beforeExpr,\n    binop\n  });\n}\nlet tokenTypeCounter = -1;\nconst tokenTypes = [];\nconst tokenLabels = [];\nconst tokenBinops = [];\nconst tokenBeforeExprs = [];\nconst tokenStartsExprs = [];\nconst tokenPrefixes = [];\nfunction createToken(name, options = {}) {\n  var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;\n  ++tokenTypeCounter;\n  tokenLabels.push(name);\n  tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);\n  tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);\n  tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);\n  tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);\n  tokenTypes.push(new ExportedTokenType(name, options));\n  return tokenTypeCounter;\n}\nfunction createKeywordLike(name, options = {}) {\n  var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;\n  ++tokenTypeCounter;\n  keywords$1.set(name, tokenTypeCounter);\n  tokenLabels.push(name);\n  tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);\n  tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);\n  tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);\n  tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);\n  tokenTypes.push(new ExportedTokenType(\"name\", options));\n  return tokenTypeCounter;\n}\nconst tt = {\n  bracketL: createToken(\"[\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketHashL: createToken(\"#[\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketBarL: createToken(\"[|\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketR: createToken(\"]\"),\n  bracketBarR: createToken(\"|]\"),\n  braceL: createToken(\"{\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceBarL: createToken(\"{|\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceHashL: createToken(\"#{\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceR: createToken(\"}\"),\n  braceBarR: createToken(\"|}\"),\n  parenL: createToken(\"(\", {\n    beforeExpr,\n    startsExpr\n  }),\n  parenR: createToken(\")\"),\n  comma: createToken(\",\", {\n    beforeExpr\n  }),\n  semi: createToken(\";\", {\n    beforeExpr\n  }),\n  colon: createToken(\":\", {\n    beforeExpr\n  }),\n  doubleColon: createToken(\"::\", {\n    beforeExpr\n  }),\n  dot: createToken(\".\"),\n  question: createToken(\"?\", {\n    beforeExpr\n  }),\n  questionDot: createToken(\"?.\"),\n  arrow: createToken(\"=>\", {\n    beforeExpr\n  }),\n  template: createToken(\"template\"),\n  ellipsis: createToken(\"...\", {\n    beforeExpr\n  }),\n  backQuote: createToken(\"`\", {\n    startsExpr\n  }),\n  dollarBraceL: createToken(\"${\", {\n    beforeExpr,\n    startsExpr\n  }),\n  templateTail: createToken(\"...`\", {\n    startsExpr\n  }),\n  templateNonTail: createToken(\"...${\", {\n    beforeExpr,\n    startsExpr\n  }),\n  at: createToken(\"@\"),\n  hash: createToken(\"#\", {\n    startsExpr\n  }),\n  interpreterDirective: createToken(\"#!...\"),\n  eq: createToken(\"=\", {\n    beforeExpr,\n    isAssign\n  }),\n  assign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  slashAssign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  xorAssign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  moduloAssign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  incDec: createToken(\"++/--\", {\n    prefix,\n    postfix,\n    startsExpr\n  }),\n  bang: createToken(\"!\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  tilde: createToken(\"~\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  doubleCaret: createToken(\"^^\", {\n    startsExpr\n  }),\n  doubleAt: createToken(\"@@\", {\n    startsExpr\n  }),\n  pipeline: createBinop(\"|>\", 0),\n  nullishCoalescing: createBinop(\"??\", 1),\n  logicalOR: createBinop(\"||\", 1),\n  logicalAND: createBinop(\"&&\", 2),\n  bitwiseOR: createBinop(\"|\", 3),\n  bitwiseXOR: createBinop(\"^\", 4),\n  bitwiseAND: createBinop(\"&\", 5),\n  equality: createBinop(\"==/!=/===/!==\", 6),\n  lt: createBinop(\"</>/<=/>=\", 7),\n  gt: createBinop(\"</>/<=/>=\", 7),\n  relational: createBinop(\"</>/<=/>=\", 7),\n  bitShift: createBinop(\"<</>>/>>>\", 8),\n  bitShiftL: createBinop(\"<</>>/>>>\", 8),\n  bitShiftR: createBinop(\"<</>>/>>>\", 8),\n  plusMin: createToken(\"+/-\", {\n    beforeExpr,\n    binop: 9,\n    prefix,\n    startsExpr\n  }),\n  modulo: createToken(\"%\", {\n    binop: 10,\n    startsExpr\n  }),\n  star: createToken(\"*\", {\n    binop: 10\n  }),\n  slash: createBinop(\"/\", 10),\n  exponent: createToken(\"**\", {\n    beforeExpr,\n    binop: 11,\n    rightAssociative: true\n  }),\n  _in: createKeyword(\"in\", {\n    beforeExpr,\n    binop: 7\n  }),\n  _instanceof: createKeyword(\"instanceof\", {\n    beforeExpr,\n    binop: 7\n  }),\n  _break: createKeyword(\"break\"),\n  _case: createKeyword(\"case\", {\n    beforeExpr\n  }),\n  _catch: createKeyword(\"catch\"),\n  _continue: createKeyword(\"continue\"),\n  _debugger: createKeyword(\"debugger\"),\n  _default: createKeyword(\"default\", {\n    beforeExpr\n  }),\n  _else: createKeyword(\"else\", {\n    beforeExpr\n  }),\n  _finally: createKeyword(\"finally\"),\n  _function: createKeyword(\"function\", {\n    startsExpr\n  }),\n  _if: createKeyword(\"if\"),\n  _return: createKeyword(\"return\", {\n    beforeExpr\n  }),\n  _switch: createKeyword(\"switch\"),\n  _throw: createKeyword(\"throw\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _try: createKeyword(\"try\"),\n  _var: createKeyword(\"var\"),\n  _const: createKeyword(\"const\"),\n  _with: createKeyword(\"with\"),\n  _new: createKeyword(\"new\", {\n    beforeExpr,\n    startsExpr\n  }),\n  _this: createKeyword(\"this\", {\n    startsExpr\n  }),\n  _super: createKeyword(\"super\", {\n    startsExpr\n  }),\n  _class: createKeyword(\"class\", {\n    startsExpr\n  }),\n  _extends: createKeyword(\"extends\", {\n    beforeExpr\n  }),\n  _export: createKeyword(\"export\"),\n  _import: createKeyword(\"import\", {\n    startsExpr\n  }),\n  _null: createKeyword(\"null\", {\n    startsExpr\n  }),\n  _true: createKeyword(\"true\", {\n    startsExpr\n  }),\n  _false: createKeyword(\"false\", {\n    startsExpr\n  }),\n  _typeof: createKeyword(\"typeof\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _void: createKeyword(\"void\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _delete: createKeyword(\"delete\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _do: createKeyword(\"do\", {\n    isLoop,\n    beforeExpr\n  }),\n  _for: createKeyword(\"for\", {\n    isLoop\n  }),\n  _while: createKeyword(\"while\", {\n    isLoop\n  }),\n  _as: createKeywordLike(\"as\", {\n    startsExpr\n  }),\n  _assert: createKeywordLike(\"assert\", {\n    startsExpr\n  }),\n  _async: createKeywordLike(\"async\", {\n    startsExpr\n  }),\n  _await: createKeywordLike(\"await\", {\n    startsExpr\n  }),\n  _defer: createKeywordLike(\"defer\", {\n    startsExpr\n  }),\n  _from: createKeywordLike(\"from\", {\n    startsExpr\n  }),\n  _get: createKeywordLike(\"get\", {\n    startsExpr\n  }),\n  _let: createKeywordLike(\"let\", {\n    startsExpr\n  }),\n  _meta: createKeywordLike(\"meta\", {\n    startsExpr\n  }),\n  _of: createKeywordLike(\"of\", {\n    startsExpr\n  }),\n  _sent: createKeywordLike(\"sent\", {\n    startsExpr\n  }),\n  _set: createKeywordLike(\"set\", {\n    startsExpr\n  }),\n  _source: createKeywordLike(\"source\", {\n    startsExpr\n  }),\n  _static: createKeywordLike(\"static\", {\n    startsExpr\n  }),\n  _using: createKeywordLike(\"using\", {\n    startsExpr\n  }),\n  _yield: createKeywordLike(\"yield\", {\n    startsExpr\n  }),\n  _asserts: createKeywordLike(\"asserts\", {\n    startsExpr\n  }),\n  _checks: createKeywordLike(\"checks\", {\n    startsExpr\n  }),\n  _exports: createKeywordLike(\"exports\", {\n    startsExpr\n  }),\n  _global: createKeywordLike(\"global\", {\n    startsExpr\n  }),\n  _implements: createKeywordLike(\"implements\", {\n    startsExpr\n  }),\n  _intrinsic: createKeywordLike(\"intrinsic\", {\n    startsExpr\n  }),\n  _infer: createKeywordLike(\"infer\", {\n    startsExpr\n  }),\n  _is: createKeywordLike(\"is\", {\n    startsExpr\n  }),\n  _mixins: createKeywordLike(\"mixins\", {\n    startsExpr\n  }),\n  _proto: createKeywordLike(\"proto\", {\n    startsExpr\n  }),\n  _require: createKeywordLike(\"require\", {\n    startsExpr\n  }),\n  _satisfies: createKeywordLike(\"satisfies\", {\n    startsExpr\n  }),\n  _keyof: createKeywordLike(\"keyof\", {\n    startsExpr\n  }),\n  _readonly: createKeywordLike(\"readonly\", {\n    startsExpr\n  }),\n  _unique: createKeywordLike(\"unique\", {\n    startsExpr\n  }),\n  _abstract: createKeywordLike(\"abstract\", {\n    startsExpr\n  }),\n  _declare: createKeywordLike(\"declare\", {\n    startsExpr\n  }),\n  _enum: createKeywordLike(\"enum\", {\n    startsExpr\n  }),\n  _module: createKeywordLike(\"module\", {\n    startsExpr\n  }),\n  _namespace: createKeywordLike(\"namespace\", {\n    startsExpr\n  }),\n  _interface: createKeywordLike(\"interface\", {\n    startsExpr\n  }),\n  _type: createKeywordLike(\"type\", {\n    startsExpr\n  }),\n  _opaque: createKeywordLike(\"opaque\", {\n    startsExpr\n  }),\n  name: createToken(\"name\", {\n    startsExpr\n  }),\n  placeholder: createToken(\"%%\", {\n    startsExpr\n  }),\n  string: createToken(\"string\", {\n    startsExpr\n  }),\n  num: createToken(\"num\", {\n    startsExpr\n  }),\n  bigint: createToken(\"bigint\", {\n    startsExpr\n  }),\n  decimal: createToken(\"decimal\", {\n    startsExpr\n  }),\n  regexp: createToken(\"regexp\", {\n    startsExpr\n  }),\n  privateName: createToken(\"#name\", {\n    startsExpr\n  }),\n  eof: createToken(\"eof\"),\n  jsxName: createToken(\"jsxName\"),\n  jsxText: createToken(\"jsxText\", {\n    beforeExpr\n  }),\n  jsxTagStart: createToken(\"jsxTagStart\", {\n    startsExpr\n  }),\n  jsxTagEnd: createToken(\"jsxTagEnd\")\n};\nfunction tokenIsIdentifier(token) {\n  return token >= 93 && token <= 133;\n}\nfunction tokenKeywordOrIdentifierIsKeyword(token) {\n  return token <= 92;\n}\nfunction tokenIsKeywordOrIdentifier(token) {\n  return token >= 58 && token <= 133;\n}\nfunction tokenIsLiteralPropertyName(token) {\n  return token >= 58 && token <= 137;\n}\nfunction tokenComesBeforeExpression(token) {\n  return tokenBeforeExprs[token];\n}\nfunction tokenCanStartExpression(token) {\n  return tokenStartsExprs[token];\n}\nfunction tokenIsAssignment(token) {\n  return token >= 29 && token <= 33;\n}\nfunction tokenIsFlowInterfaceOrTypeOrOpaque(token) {\n  return token >= 129 && token <= 131;\n}\nfunction tokenIsLoop(token) {\n  return token >= 90 && token <= 92;\n}\nfunction tokenIsKeyword(token) {\n  return token >= 58 && token <= 92;\n}\nfunction tokenIsOperator(token) {\n  return token >= 39 && token <= 59;\n}\nfunction tokenIsPostfix(token) {\n  return token === 34;\n}\nfunction tokenIsPrefix(token) {\n  return tokenPrefixes[token];\n}\nfunction tokenIsTSTypeOperator(token) {\n  return token >= 121 && token <= 123;\n}\nfunction tokenIsTSDeclarationStart(token) {\n  return token >= 124 && token <= 130;\n}\nfunction tokenLabelName(token) {\n  return tokenLabels[token];\n}\nfunction tokenOperatorPrecedence(token) {\n  return tokenBinops[token];\n}\nfunction tokenIsRightAssociative(token) {\n  return token === 57;\n}\nfunction tokenIsTemplate(token) {\n  return token >= 24 && token <= 25;\n}\nfunction getExportedToken(token) {\n  return tokenTypes[token];\n}\n{\n  tokenTypes[8].updateContext = context => {\n    context.pop();\n  };\n  tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = context => {\n    context.push(types.brace);\n  };\n  tokenTypes[22].updateContext = context => {\n    if (context[context.length - 1] === types.template) {\n      context.pop();\n    } else {\n      context.push(types.template);\n    }\n  };\n  tokenTypes[143].updateContext = context => {\n    context.push(types.j_expr, types.j_oTag);\n  };\n}\nlet nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u0870-\\u0887\\u0889-\\u088e\\u08a0-\\u08c9\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c5d\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cdd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u1711\\u171f-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4c\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c8a\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7cd\\ua7d0\\ua7d1\\ua7d3\\ua7d5-\\ua7dc\\ua7f2-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\nlet nonASCIIidentifierChars = \"\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u0897-\\u089f\\u08ca-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3c\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0cf3\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ece\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1715\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u180f-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf-\\u1ace\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1dff\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\u30fb\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\\uff65\";\nconst nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nconst nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\nconst astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];\nconst astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];\nfunction isInAstralSet(code, set) {\n  let pos = 0x10000;\n  for (let i = 0, length = set.length; i < length; i += 2) {\n    pos += set[i];\n    if (pos > code) return false;\n    pos += set[i + 1];\n    if (pos >= code) return true;\n  }\n  return false;\n}\nfunction isIdentifierStart(code) {\n  if (code < 65) return code === 36;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  }\n  return isInAstralSet(code, astralIdentifierStartCodes);\n}\nfunction isIdentifierChar(code) {\n  if (code < 48) return code === 36;\n  if (code < 58) return true;\n  if (code < 65) return false;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  }\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n}\nconst reservedWords = {\n  keyword: [\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\", \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"const\", \"while\", \"with\", \"new\", \"this\", \"super\", \"class\", \"extends\", \"export\", \"import\", \"null\", \"true\", \"false\", \"in\", \"instanceof\", \"typeof\", \"void\", \"delete\"],\n  strict: [\"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\"],\n  strictBind: [\"eval\", \"arguments\"]\n};\nconst keywords = new Set(reservedWords.keyword);\nconst reservedWordsStrictSet = new Set(reservedWords.strict);\nconst reservedWordsStrictBindSet = new Set(reservedWords.strictBind);\nfunction isReservedWord(word, inModule) {\n  return inModule && word === \"await\" || word === \"enum\";\n}\nfunction isStrictReservedWord(word, inModule) {\n  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);\n}\nfunction isStrictBindOnlyReservedWord(word) {\n  return reservedWordsStrictBindSet.has(word);\n}\nfunction isStrictBindReservedWord(word, inModule) {\n  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);\n}\nfunction isKeyword(word) {\n  return keywords.has(word);\n}\nfunction isIteratorStart(current, next, next2) {\n  return current === 64 && next === 64 && isIdentifierStart(next2);\n}\nconst reservedWordLikeSet = new Set([\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\", \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"const\", \"while\", \"with\", \"new\", \"this\", \"super\", \"class\", \"extends\", \"export\", \"import\", \"null\", \"true\", \"false\", \"in\", \"instanceof\", \"typeof\", \"void\", \"delete\", \"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\", \"eval\", \"arguments\", \"enum\", \"await\"]);\nfunction canBeReservedWord(word) {\n  return reservedWordLikeSet.has(word);\n}\nclass Scope {\n  constructor(flags) {\n    this.flags = 0;\n    this.names = new Map();\n    this.firstLexicalName = \"\";\n    this.flags = flags;\n  }\n}\nclass ScopeHandler {\n  constructor(parser, inModule) {\n    this.parser = void 0;\n    this.scopeStack = [];\n    this.inModule = void 0;\n    this.undefinedExports = new Map();\n    this.parser = parser;\n    this.inModule = inModule;\n  }\n  get inTopLevel() {\n    return (this.currentScope().flags & 1) > 0;\n  }\n  get inFunction() {\n    return (this.currentVarScopeFlags() & 2) > 0;\n  }\n  get allowSuper() {\n    return (this.currentThisScopeFlags() & 16) > 0;\n  }\n  get allowDirectSuper() {\n    return (this.currentThisScopeFlags() & 32) > 0;\n  }\n  get allowNewTarget() {\n    return (this.currentThisScopeFlags() & 512) > 0;\n  }\n  get inClass() {\n    return (this.currentThisScopeFlags() & 64) > 0;\n  }\n  get inClassAndNotInNonArrowFunction() {\n    const flags = this.currentThisScopeFlags();\n    return (flags & 64) > 0 && (flags & 2) === 0;\n  }\n  get inStaticBlock() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n      if (flags & 128) {\n        return true;\n      }\n      if (flags & (1667 | 64)) {\n        return false;\n      }\n    }\n  }\n  get inNonArrowFunction() {\n    return (this.currentThisScopeFlags() & 2) > 0;\n  }\n  get inBareCaseStatement() {\n    return (this.currentScope().flags & 256) > 0;\n  }\n  get treatFunctionsAsVar() {\n    return this.treatFunctionsAsVarInScope(this.currentScope());\n  }\n  createScope(flags) {\n    return new Scope(flags);\n  }\n  enter(flags) {\n    this.scopeStack.push(this.createScope(flags));\n  }\n  exit() {\n    const scope = this.scopeStack.pop();\n    return scope.flags;\n  }\n  treatFunctionsAsVarInScope(scope) {\n    return !!(scope.flags & (2 | 128) || !this.parser.inModule && scope.flags & 1);\n  }\n  declareName(name, bindingType, loc) {\n    let scope = this.currentScope();\n    if (bindingType & 8 || bindingType & 16) {\n      this.checkRedeclarationInScope(scope, name, bindingType, loc);\n      let type = scope.names.get(name) || 0;\n      if (bindingType & 16) {\n        type = type | 4;\n      } else {\n        if (!scope.firstLexicalName) {\n          scope.firstLexicalName = name;\n        }\n        type = type | 2;\n      }\n      scope.names.set(name, type);\n      if (bindingType & 8) {\n        this.maybeExportDefined(scope, name);\n      }\n    } else if (bindingType & 4) {\n      for (let i = this.scopeStack.length - 1; i >= 0; --i) {\n        scope = this.scopeStack[i];\n        this.checkRedeclarationInScope(scope, name, bindingType, loc);\n        scope.names.set(name, (scope.names.get(name) || 0) | 1);\n        this.maybeExportDefined(scope, name);\n        if (scope.flags & 1667) break;\n      }\n    }\n    if (this.parser.inModule && scope.flags & 1) {\n      this.undefinedExports.delete(name);\n    }\n  }\n  maybeExportDefined(scope, name) {\n    if (this.parser.inModule && scope.flags & 1) {\n      this.undefinedExports.delete(name);\n    }\n  }\n  checkRedeclarationInScope(scope, name, bindingType, loc) {\n    if (this.isRedeclaredInScope(scope, name, bindingType)) {\n      this.parser.raise(Errors.VarRedeclaration, loc, {\n        identifierName: name\n      });\n    }\n  }\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (!(bindingType & 1)) return false;\n    if (bindingType & 8) {\n      return scope.names.has(name);\n    }\n    const type = scope.names.get(name);\n    if (bindingType & 16) {\n      return (type & 2) > 0 || !this.treatFunctionsAsVarInScope(scope) && (type & 1) > 0;\n    }\n    return (type & 2) > 0 && !(scope.flags & 8 && scope.firstLexicalName === name) || !this.treatFunctionsAsVarInScope(scope) && (type & 4) > 0;\n  }\n  checkLocalExport(id) {\n    const {\n      name\n    } = id;\n    const topLevelScope = this.scopeStack[0];\n    if (!topLevelScope.names.has(name)) {\n      this.undefinedExports.set(name, id.loc.start);\n    }\n  }\n  currentScope() {\n    return this.scopeStack[this.scopeStack.length - 1];\n  }\n  currentVarScopeFlags() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n      if (flags & 1667) {\n        return flags;\n      }\n    }\n  }\n  currentThisScopeFlags() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n      if (flags & (1667 | 64) && !(flags & 4)) {\n        return flags;\n      }\n    }\n  }\n}\nclass FlowScope extends Scope {\n  constructor(...args) {\n    super(...args);\n    this.declareFunctions = new Set();\n  }\n}\nclass FlowScopeHandler extends ScopeHandler {\n  createScope(flags) {\n    return new FlowScope(flags);\n  }\n  declareName(name, bindingType, loc) {\n    const scope = this.currentScope();\n    if (bindingType & 2048) {\n      this.checkRedeclarationInScope(scope, name, bindingType, loc);\n      this.maybeExportDefined(scope, name);\n      scope.declareFunctions.add(name);\n      return;\n    }\n    super.declareName(name, bindingType, loc);\n  }\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (super.isRedeclaredInScope(scope, name, bindingType)) return true;\n    if (bindingType & 2048 && !scope.declareFunctions.has(name)) {\n      const type = scope.names.get(name);\n      return (type & 4) > 0 || (type & 2) > 0;\n    }\n    return false;\n  }\n  checkLocalExport(id) {\n    if (!this.scopeStack[0].declareFunctions.has(id.name)) {\n      super.checkLocalExport(id);\n    }\n  }\n}\nconst reservedTypes = new Set([\"_\", \"any\", \"bool\", \"boolean\", \"empty\", \"extends\", \"false\", \"interface\", \"mixed\", \"null\", \"number\", \"static\", \"string\", \"true\", \"typeof\", \"void\"]);\nconst FlowErrors = ParseErrorEnum`flow`({\n  AmbiguousConditionalArrow: \"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.\",\n  AmbiguousDeclareModuleKind: \"Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.\",\n  AssignReservedType: ({\n    reservedType\n  }) => `Cannot overwrite reserved type ${reservedType}.`,\n  DeclareClassElement: \"The `declare` modifier can only appear on class fields.\",\n  DeclareClassFieldInitializer: \"Initializers are not allowed in fields with the `declare` modifier.\",\n  DuplicateDeclareModuleExports: \"Duplicate `declare module.exports` statement.\",\n  EnumBooleanMemberNotInitialized: ({\n    memberName,\n    enumName\n  }) => `Boolean enum members need to be initialized. Use either \\`${memberName} = true,\\` or \\`${memberName} = false,\\` in enum \\`${enumName}\\`.`,\n  EnumDuplicateMemberName: ({\n    memberName,\n    enumName\n  }) => `Enum member names need to be unique, but the name \\`${memberName}\\` has already been used before in enum \\`${enumName}\\`.`,\n  EnumInconsistentMemberValues: ({\n    enumName\n  }) => `Enum \\`${enumName}\\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,\n  EnumInvalidExplicitType: ({\n    invalidEnumType,\n    enumName\n  }) => `Enum type \\`${invalidEnumType}\\` is not valid. Use one of \\`boolean\\`, \\`number\\`, \\`string\\`, or \\`symbol\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidExplicitTypeUnknownSupplied: ({\n    enumName\n  }) => `Supplied enum type is not valid. Use one of \\`boolean\\`, \\`number\\`, \\`string\\`, or \\`symbol\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberInitializerPrimaryType: ({\n    enumName,\n    memberName,\n    explicitType\n  }) => `Enum \\`${enumName}\\` has type \\`${explicitType}\\`, so the initializer of \\`${memberName}\\` needs to be a ${explicitType} literal.`,\n  EnumInvalidMemberInitializerSymbolType: ({\n    enumName,\n    memberName\n  }) => `Symbol enum members cannot be initialized. Use \\`${memberName},\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberInitializerUnknownType: ({\n    enumName,\n    memberName\n  }) => `The enum member initializer for \\`${memberName}\\` needs to be a literal (either a boolean, number, or string) in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberName: ({\n    enumName,\n    memberName,\n    suggestion\n  }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \\`${memberName}\\`, consider using \\`${suggestion}\\`, in enum \\`${enumName}\\`.`,\n  EnumNumberMemberNotInitialized: ({\n    enumName,\n    memberName\n  }) => `Number enum members need to be initialized, e.g. \\`${memberName} = 1\\` in enum \\`${enumName}\\`.`,\n  EnumStringMemberInconsistentlyInitialized: ({\n    enumName\n  }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \\`${enumName}\\`.`,\n  GetterMayNotHaveThisParam: \"A getter cannot have a `this` parameter.\",\n  ImportReflectionHasImportType: \"An `import module` declaration can not use `type` or `typeof` keyword.\",\n  ImportTypeShorthandOnlyInPureImport: \"The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.\",\n  InexactInsideExact: \"Explicit inexact syntax cannot appear inside an explicit exact object type.\",\n  InexactInsideNonObject: \"Explicit inexact syntax cannot appear in class or interface definitions.\",\n  InexactVariance: \"Explicit inexact syntax cannot have variance.\",\n  InvalidNonTypeImportInDeclareModule: \"Imports within a `declare module` body must always be `import type` or `import typeof`.\",\n  MissingTypeParamDefault: \"Type parameter declaration needs a default, since a preceding type parameter declaration has a default.\",\n  NestedDeclareModule: \"`declare module` cannot be used inside another `declare module`.\",\n  NestedFlowComment: \"Cannot have a flow comment inside another flow comment.\",\n  PatternIsOptional: Object.assign({\n    message: \"A binding pattern parameter cannot be optional in an implementation signature.\"\n  }, {\n    reasonCode: \"OptionalBindingPattern\"\n  }),\n  SetterMayNotHaveThisParam: \"A setter cannot have a `this` parameter.\",\n  SpreadVariance: \"Spread properties cannot have variance.\",\n  ThisParamAnnotationRequired: \"A type annotation is required for the `this` parameter.\",\n  ThisParamBannedInConstructor: \"Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.\",\n  ThisParamMayNotBeOptional: \"The `this` parameter cannot be optional.\",\n  ThisParamMustBeFirst: \"The `this` parameter must be the first function parameter.\",\n  ThisParamNoDefault: \"The `this` parameter may not have a default value.\",\n  TypeBeforeInitializer: \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\",\n  TypeCastInPattern: \"The type cast expression is expected to be wrapped with parenthesis.\",\n  UnexpectedExplicitInexactInObject: \"Explicit inexact syntax must appear at the end of an inexact object.\",\n  UnexpectedReservedType: ({\n    reservedType\n  }) => `Unexpected reserved type ${reservedType}.`,\n  UnexpectedReservedUnderscore: \"`_` is only allowed as a type argument to call or new.\",\n  UnexpectedSpaceBetweenModuloChecks: \"Spaces between `%` and `checks` are not allowed here.\",\n  UnexpectedSpreadType: \"Spread operator cannot appear in class or interface definitions.\",\n  UnexpectedSubtractionOperand: 'Unexpected token, expected \"number\" or \"bigint\".',\n  UnexpectedTokenAfterTypeParameter: \"Expected an arrow function after this type parameter declaration.\",\n  UnexpectedTypeParameterBeforeAsyncArrowFunction: \"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.\",\n  UnsupportedDeclareExportKind: ({\n    unsupportedExportKind,\n    suggestion\n  }) => `\\`declare export ${unsupportedExportKind}\\` is not supported. Use \\`${suggestion}\\` instead.`,\n  UnsupportedStatementInDeclareModule: \"Only declares and type imports are allowed inside declare module.\",\n  UnterminatedFlowComment: \"Unterminated flow-comment.\"\n});\nfunction isEsModuleType(bodyElement) {\n  return bodyElement.type === \"DeclareExportAllDeclaration\" || bodyElement.type === \"DeclareExportDeclaration\" && (!bodyElement.declaration || bodyElement.declaration.type !== \"TypeAlias\" && bodyElement.declaration.type !== \"InterfaceDeclaration\");\n}\nfunction hasTypeImportKind(node) {\n  return node.importKind === \"type\" || node.importKind === \"typeof\";\n}\nconst exportSuggestions = {\n  const: \"declare export var\",\n  let: \"declare export var\",\n  type: \"export type\",\n  interface: \"export interface\"\n};\nfunction partition(list, test) {\n  const list1 = [];\n  const list2 = [];\n  for (let i = 0; i < list.length; i++) {\n    (test(list[i], i, list) ? list1 : list2).push(list[i]);\n  }\n  return [list1, list2];\n}\nconst FLOW_PRAGMA_REGEX = /\\*?\\s*@((?:no)?flow)\\b/;\nvar flow = superClass => class FlowParserMixin extends superClass {\n  constructor(...args) {\n    super(...args);\n    this.flowPragma = undefined;\n  }\n  getScopeHandler() {\n    return FlowScopeHandler;\n  }\n  shouldParseTypes() {\n    return this.getPluginOption(\"flow\", \"all\") || this.flowPragma === \"flow\";\n  }\n  finishToken(type, val) {\n    if (type !== 134 && type !== 13 && type !== 28) {\n      if (this.flowPragma === undefined) {\n        this.flowPragma = null;\n      }\n    }\n    super.finishToken(type, val);\n  }\n  addComment(comment) {\n    if (this.flowPragma === undefined) {\n      const matches = FLOW_PRAGMA_REGEX.exec(comment.value);\n      if (!matches) ;else if (matches[1] === \"flow\") {\n        this.flowPragma = \"flow\";\n      } else if (matches[1] === \"noflow\") {\n        this.flowPragma = \"noflow\";\n      } else {\n        throw new Error(\"Unexpected flow pragma\");\n      }\n    }\n    super.addComment(comment);\n  }\n  flowParseTypeInitialiser(tok) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    this.expect(tok || 14);\n    const type = this.flowParseType();\n    this.state.inType = oldInType;\n    return type;\n  }\n  flowParsePredicate() {\n    const node = this.startNode();\n    const moduloLoc = this.state.startLoc;\n    this.next();\n    this.expectContextual(110);\n    if (this.state.lastTokStartLoc.index > moduloLoc.index + 1) {\n      this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, moduloLoc);\n    }\n    if (this.eat(10)) {\n      node.value = super.parseExpression();\n      this.expect(11);\n      return this.finishNode(node, \"DeclaredPredicate\");\n    } else {\n      return this.finishNode(node, \"InferredPredicate\");\n    }\n  }\n  flowParseTypeAndPredicateInitialiser() {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    this.expect(14);\n    let type = null;\n    let predicate = null;\n    if (this.match(54)) {\n      this.state.inType = oldInType;\n      predicate = this.flowParsePredicate();\n    } else {\n      type = this.flowParseType();\n      this.state.inType = oldInType;\n      if (this.match(54)) {\n        predicate = this.flowParsePredicate();\n      }\n    }\n    return [type, predicate];\n  }\n  flowParseDeclareClass(node) {\n    this.next();\n    this.flowParseInterfaceish(node, true);\n    return this.finishNode(node, \"DeclareClass\");\n  }\n  flowParseDeclareFunction(node) {\n    this.next();\n    const id = node.id = this.parseIdentifier();\n    const typeNode = this.startNode();\n    const typeContainer = this.startNode();\n    if (this.match(47)) {\n      typeNode.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      typeNode.typeParameters = null;\n    }\n    this.expect(10);\n    const tmp = this.flowParseFunctionTypeParams();\n    typeNode.params = tmp.params;\n    typeNode.rest = tmp.rest;\n    typeNode.this = tmp._this;\n    this.expect(11);\n    [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n    typeContainer.typeAnnotation = this.finishNode(typeNode, \"FunctionTypeAnnotation\");\n    id.typeAnnotation = this.finishNode(typeContainer, \"TypeAnnotation\");\n    this.resetEndLocation(id);\n    this.semicolon();\n    this.scope.declareName(node.id.name, 2048, node.id.loc.start);\n    return this.finishNode(node, \"DeclareFunction\");\n  }\n  flowParseDeclare(node, insideModule) {\n    if (this.match(80)) {\n      return this.flowParseDeclareClass(node);\n    } else if (this.match(68)) {\n      return this.flowParseDeclareFunction(node);\n    } else if (this.match(74)) {\n      return this.flowParseDeclareVariable(node);\n    } else if (this.eatContextual(127)) {\n      if (this.match(16)) {\n        return this.flowParseDeclareModuleExports(node);\n      } else {\n        if (insideModule) {\n          this.raise(FlowErrors.NestedDeclareModule, this.state.lastTokStartLoc);\n        }\n        return this.flowParseDeclareModule(node);\n      }\n    } else if (this.isContextual(130)) {\n      return this.flowParseDeclareTypeAlias(node);\n    } else if (this.isContextual(131)) {\n      return this.flowParseDeclareOpaqueType(node);\n    } else if (this.isContextual(129)) {\n      return this.flowParseDeclareInterface(node);\n    } else if (this.match(82)) {\n      return this.flowParseDeclareExportDeclaration(node, insideModule);\n    } else {\n      this.unexpected();\n    }\n  }\n  flowParseDeclareVariable(node) {\n    this.next();\n    node.id = this.flowParseTypeAnnotatableIdentifier(true);\n    this.scope.declareName(node.id.name, 5, node.id.loc.start);\n    this.semicolon();\n    return this.finishNode(node, \"DeclareVariable\");\n  }\n  flowParseDeclareModule(node) {\n    this.scope.enter(0);\n    if (this.match(134)) {\n      node.id = super.parseExprAtom();\n    } else {\n      node.id = this.parseIdentifier();\n    }\n    const bodyNode = node.body = this.startNode();\n    const body = bodyNode.body = [];\n    this.expect(5);\n    while (!this.match(8)) {\n      let bodyNode = this.startNode();\n      if (this.match(83)) {\n        this.next();\n        if (!this.isContextual(130) && !this.match(87)) {\n          this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc);\n        }\n        super.parseImport(bodyNode);\n      } else {\n        this.expectContextual(125, FlowErrors.UnsupportedStatementInDeclareModule);\n        bodyNode = this.flowParseDeclare(bodyNode, true);\n      }\n      body.push(bodyNode);\n    }\n    this.scope.exit();\n    this.expect(8);\n    this.finishNode(bodyNode, \"BlockStatement\");\n    let kind = null;\n    let hasModuleExport = false;\n    body.forEach(bodyElement => {\n      if (isEsModuleType(bodyElement)) {\n        if (kind === \"CommonJS\") {\n          this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);\n        }\n        kind = \"ES\";\n      } else if (bodyElement.type === \"DeclareModuleExports\") {\n        if (hasModuleExport) {\n          this.raise(FlowErrors.DuplicateDeclareModuleExports, bodyElement);\n        }\n        if (kind === \"ES\") {\n          this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);\n        }\n        kind = \"CommonJS\";\n        hasModuleExport = true;\n      }\n    });\n    node.kind = kind || \"CommonJS\";\n    return this.finishNode(node, \"DeclareModule\");\n  }\n  flowParseDeclareExportDeclaration(node, insideModule) {\n    this.expect(82);\n    if (this.eat(65)) {\n      if (this.match(68) || this.match(80)) {\n        node.declaration = this.flowParseDeclare(this.startNode());\n      } else {\n        node.declaration = this.flowParseType();\n        this.semicolon();\n      }\n      node.default = true;\n      return this.finishNode(node, \"DeclareExportDeclaration\");\n    } else {\n      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !insideModule) {\n        const label = this.state.value;\n        throw this.raise(FlowErrors.UnsupportedDeclareExportKind, this.state.startLoc, {\n          unsupportedExportKind: label,\n          suggestion: exportSuggestions[label]\n        });\n      }\n      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) {\n        node.declaration = this.flowParseDeclare(this.startNode());\n        node.default = false;\n        return this.finishNode(node, \"DeclareExportDeclaration\");\n      } else if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) {\n        node = this.parseExport(node, null);\n        if (node.type === \"ExportNamedDeclaration\") {\n          node.default = false;\n          delete node.exportKind;\n          return this.castNodeTo(node, \"DeclareExportDeclaration\");\n        } else {\n          return this.castNodeTo(node, \"DeclareExportAllDeclaration\");\n        }\n      }\n    }\n    this.unexpected();\n  }\n  flowParseDeclareModuleExports(node) {\n    this.next();\n    this.expectContextual(111);\n    node.typeAnnotation = this.flowParseTypeAnnotation();\n    this.semicolon();\n    return this.finishNode(node, \"DeclareModuleExports\");\n  }\n  flowParseDeclareTypeAlias(node) {\n    this.next();\n    const finished = this.flowParseTypeAlias(node);\n    this.castNodeTo(finished, \"DeclareTypeAlias\");\n    return finished;\n  }\n  flowParseDeclareOpaqueType(node) {\n    this.next();\n    const finished = this.flowParseOpaqueType(node, true);\n    this.castNodeTo(finished, \"DeclareOpaqueType\");\n    return finished;\n  }\n  flowParseDeclareInterface(node) {\n    this.next();\n    this.flowParseInterfaceish(node, false);\n    return this.finishNode(node, \"DeclareInterface\");\n  }\n  flowParseInterfaceish(node, isClass) {\n    node.id = this.flowParseRestrictedIdentifier(!isClass, true);\n    this.scope.declareName(node.id.name, isClass ? 17 : 8201, node.id.loc.start);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n    node.extends = [];\n    if (this.eat(81)) {\n      do {\n        node.extends.push(this.flowParseInterfaceExtends());\n      } while (!isClass && this.eat(12));\n    }\n    if (isClass) {\n      node.implements = [];\n      node.mixins = [];\n      if (this.eatContextual(117)) {\n        do {\n          node.mixins.push(this.flowParseInterfaceExtends());\n        } while (this.eat(12));\n      }\n      if (this.eatContextual(113)) {\n        do {\n          node.implements.push(this.flowParseInterfaceExtends());\n        } while (this.eat(12));\n      }\n    }\n    node.body = this.flowParseObjectType({\n      allowStatic: isClass,\n      allowExact: false,\n      allowSpread: false,\n      allowProto: isClass,\n      allowInexact: false\n    });\n  }\n  flowParseInterfaceExtends() {\n    const node = this.startNode();\n    node.id = this.flowParseQualifiedTypeIdentifier();\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterInstantiation();\n    } else {\n      node.typeParameters = null;\n    }\n    return this.finishNode(node, \"InterfaceExtends\");\n  }\n  flowParseInterface(node) {\n    this.flowParseInterfaceish(node, false);\n    return this.finishNode(node, \"InterfaceDeclaration\");\n  }\n  checkNotUnderscore(word) {\n    if (word === \"_\") {\n      this.raise(FlowErrors.UnexpectedReservedUnderscore, this.state.startLoc);\n    }\n  }\n  checkReservedType(word, startLoc, declaration) {\n    if (!reservedTypes.has(word)) return;\n    this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, startLoc, {\n      reservedType: word\n    });\n  }\n  flowParseRestrictedIdentifier(liberal, declaration) {\n    this.checkReservedType(this.state.value, this.state.startLoc, declaration);\n    return this.parseIdentifier(liberal);\n  }\n  flowParseTypeAlias(node) {\n    node.id = this.flowParseRestrictedIdentifier(false, true);\n    this.scope.declareName(node.id.name, 8201, node.id.loc.start);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n    node.right = this.flowParseTypeInitialiser(29);\n    this.semicolon();\n    return this.finishNode(node, \"TypeAlias\");\n  }\n  flowParseOpaqueType(node, declare) {\n    this.expectContextual(130);\n    node.id = this.flowParseRestrictedIdentifier(true, true);\n    this.scope.declareName(node.id.name, 8201, node.id.loc.start);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n    node.supertype = null;\n    if (this.match(14)) {\n      node.supertype = this.flowParseTypeInitialiser(14);\n    }\n    node.impltype = null;\n    if (!declare) {\n      node.impltype = this.flowParseTypeInitialiser(29);\n    }\n    this.semicolon();\n    return this.finishNode(node, \"OpaqueType\");\n  }\n  flowParseTypeParameter(requireDefault = false) {\n    const nodeStartLoc = this.state.startLoc;\n    const node = this.startNode();\n    const variance = this.flowParseVariance();\n    const ident = this.flowParseTypeAnnotatableIdentifier();\n    node.name = ident.name;\n    node.variance = variance;\n    node.bound = ident.typeAnnotation;\n    if (this.match(29)) {\n      this.eat(29);\n      node.default = this.flowParseType();\n    } else {\n      if (requireDefault) {\n        this.raise(FlowErrors.MissingTypeParamDefault, nodeStartLoc);\n      }\n    }\n    return this.finishNode(node, \"TypeParameter\");\n  }\n  flowParseTypeParameterDeclaration() {\n    const oldInType = this.state.inType;\n    const node = this.startNode();\n    node.params = [];\n    this.state.inType = true;\n    if (this.match(47) || this.match(143)) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n    let defaultRequired = false;\n    do {\n      const typeParameter = this.flowParseTypeParameter(defaultRequired);\n      node.params.push(typeParameter);\n      if (typeParameter.default) {\n        defaultRequired = true;\n      }\n      if (!this.match(48)) {\n        this.expect(12);\n      }\n    } while (!this.match(48));\n    this.expect(48);\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterDeclaration\");\n  }\n  flowInTopLevelContext(cb) {\n    if (this.curContext() !== types.brace) {\n      const oldContext = this.state.context;\n      this.state.context = [oldContext[0]];\n      try {\n        return cb();\n      } finally {\n        this.state.context = oldContext;\n      }\n    } else {\n      return cb();\n    }\n  }\n  flowParseTypeParameterInstantiationInExpression() {\n    if (this.reScan_lt() !== 47) return;\n    return this.flowParseTypeParameterInstantiation();\n  }\n  flowParseTypeParameterInstantiation() {\n    const node = this.startNode();\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    node.params = [];\n    this.flowInTopLevelContext(() => {\n      this.expect(47);\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n      this.state.noAnonFunctionType = false;\n      while (!this.match(48)) {\n        node.params.push(this.flowParseType());\n        if (!this.match(48)) {\n          this.expect(12);\n        }\n      }\n      this.state.noAnonFunctionType = oldNoAnonFunctionType;\n    });\n    this.state.inType = oldInType;\n    if (!this.state.inType && this.curContext() === types.brace) {\n      this.reScan_lt_gt();\n    }\n    this.expect(48);\n    return this.finishNode(node, \"TypeParameterInstantiation\");\n  }\n  flowParseTypeParameterInstantiationCallOrNew() {\n    if (this.reScan_lt() !== 47) return;\n    const node = this.startNode();\n    const oldInType = this.state.inType;\n    node.params = [];\n    this.state.inType = true;\n    this.expect(47);\n    while (!this.match(48)) {\n      node.params.push(this.flowParseTypeOrImplicitInstantiation());\n      if (!this.match(48)) {\n        this.expect(12);\n      }\n    }\n    this.expect(48);\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterInstantiation\");\n  }\n  flowParseInterfaceType() {\n    const node = this.startNode();\n    this.expectContextual(129);\n    node.extends = [];\n    if (this.eat(81)) {\n      do {\n        node.extends.push(this.flowParseInterfaceExtends());\n      } while (this.eat(12));\n    }\n    node.body = this.flowParseObjectType({\n      allowStatic: false,\n      allowExact: false,\n      allowSpread: false,\n      allowProto: false,\n      allowInexact: false\n    });\n    return this.finishNode(node, \"InterfaceTypeAnnotation\");\n  }\n  flowParseObjectPropertyKey() {\n    return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(true);\n  }\n  flowParseObjectTypeIndexer(node, isStatic, variance) {\n    node.static = isStatic;\n    if (this.lookahead().type === 14) {\n      node.id = this.flowParseObjectPropertyKey();\n      node.key = this.flowParseTypeInitialiser();\n    } else {\n      node.id = null;\n      node.key = this.flowParseType();\n    }\n    this.expect(3);\n    node.value = this.flowParseTypeInitialiser();\n    node.variance = variance;\n    return this.finishNode(node, \"ObjectTypeIndexer\");\n  }\n  flowParseObjectTypeInternalSlot(node, isStatic) {\n    node.static = isStatic;\n    node.id = this.flowParseObjectPropertyKey();\n    this.expect(3);\n    this.expect(3);\n    if (this.match(47) || this.match(10)) {\n      node.method = true;\n      node.optional = false;\n      node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));\n    } else {\n      node.method = false;\n      if (this.eat(17)) {\n        node.optional = true;\n      }\n      node.value = this.flowParseTypeInitialiser();\n    }\n    return this.finishNode(node, \"ObjectTypeInternalSlot\");\n  }\n  flowParseObjectTypeMethodish(node) {\n    node.params = [];\n    node.rest = null;\n    node.typeParameters = null;\n    node.this = null;\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    this.expect(10);\n    if (this.match(78)) {\n      node.this = this.flowParseFunctionTypeParam(true);\n      node.this.name = null;\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    while (!this.match(11) && !this.match(21)) {\n      node.params.push(this.flowParseFunctionTypeParam(false));\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    if (this.eat(21)) {\n      node.rest = this.flowParseFunctionTypeParam(false);\n    }\n    this.expect(11);\n    node.returnType = this.flowParseTypeInitialiser();\n    return this.finishNode(node, \"FunctionTypeAnnotation\");\n  }\n  flowParseObjectTypeCallProperty(node, isStatic) {\n    const valueNode = this.startNode();\n    node.static = isStatic;\n    node.value = this.flowParseObjectTypeMethodish(valueNode);\n    return this.finishNode(node, \"ObjectTypeCallProperty\");\n  }\n  flowParseObjectType({\n    allowStatic,\n    allowExact,\n    allowSpread,\n    allowProto,\n    allowInexact\n  }) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    const nodeStart = this.startNode();\n    nodeStart.callProperties = [];\n    nodeStart.properties = [];\n    nodeStart.indexers = [];\n    nodeStart.internalSlots = [];\n    let endDelim;\n    let exact;\n    let inexact = false;\n    if (allowExact && this.match(6)) {\n      this.expect(6);\n      endDelim = 9;\n      exact = true;\n    } else {\n      this.expect(5);\n      endDelim = 8;\n      exact = false;\n    }\n    nodeStart.exact = exact;\n    while (!this.match(endDelim)) {\n      let isStatic = false;\n      let protoStartLoc = null;\n      let inexactStartLoc = null;\n      const node = this.startNode();\n      if (allowProto && this.isContextual(118)) {\n        const lookahead = this.lookahead();\n        if (lookahead.type !== 14 && lookahead.type !== 17) {\n          this.next();\n          protoStartLoc = this.state.startLoc;\n          allowStatic = false;\n        }\n      }\n      if (allowStatic && this.isContextual(106)) {\n        const lookahead = this.lookahead();\n        if (lookahead.type !== 14 && lookahead.type !== 17) {\n          this.next();\n          isStatic = true;\n        }\n      }\n      const variance = this.flowParseVariance();\n      if (this.eat(0)) {\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n        if (this.eat(0)) {\n          if (variance) {\n            this.unexpected(variance.loc.start);\n          }\n          nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));\n        } else {\n          nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));\n        }\n      } else if (this.match(10) || this.match(47)) {\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n        if (variance) {\n          this.unexpected(variance.loc.start);\n        }\n        nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));\n      } else {\n        let kind = \"init\";\n        if (this.isContextual(99) || this.isContextual(104)) {\n          const lookahead = this.lookahead();\n          if (tokenIsLiteralPropertyName(lookahead.type)) {\n            kind = this.state.value;\n            this.next();\n          }\n        }\n        const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);\n        if (propOrInexact === null) {\n          inexact = true;\n          inexactStartLoc = this.state.lastTokStartLoc;\n        } else {\n          nodeStart.properties.push(propOrInexact);\n        }\n      }\n      this.flowObjectTypeSemicolon();\n      if (inexactStartLoc && !this.match(8) && !this.match(9)) {\n        this.raise(FlowErrors.UnexpectedExplicitInexactInObject, inexactStartLoc);\n      }\n    }\n    this.expect(endDelim);\n    if (allowSpread) {\n      nodeStart.inexact = inexact;\n    }\n    const out = this.finishNode(nodeStart, \"ObjectTypeAnnotation\");\n    this.state.inType = oldInType;\n    return out;\n  }\n  flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {\n    if (this.eat(21)) {\n      const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);\n      if (isInexactToken) {\n        if (!allowSpread) {\n          this.raise(FlowErrors.InexactInsideNonObject, this.state.lastTokStartLoc);\n        } else if (!allowInexact) {\n          this.raise(FlowErrors.InexactInsideExact, this.state.lastTokStartLoc);\n        }\n        if (variance) {\n          this.raise(FlowErrors.InexactVariance, variance);\n        }\n        return null;\n      }\n      if (!allowSpread) {\n        this.raise(FlowErrors.UnexpectedSpreadType, this.state.lastTokStartLoc);\n      }\n      if (protoStartLoc != null) {\n        this.unexpected(protoStartLoc);\n      }\n      if (variance) {\n        this.raise(FlowErrors.SpreadVariance, variance);\n      }\n      node.argument = this.flowParseType();\n      return this.finishNode(node, \"ObjectTypeSpreadProperty\");\n    } else {\n      node.key = this.flowParseObjectPropertyKey();\n      node.static = isStatic;\n      node.proto = protoStartLoc != null;\n      node.kind = kind;\n      let optional = false;\n      if (this.match(47) || this.match(10)) {\n        node.method = true;\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n        if (variance) {\n          this.unexpected(variance.loc.start);\n        }\n        node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));\n        if (kind === \"get\" || kind === \"set\") {\n          this.flowCheckGetterSetterParams(node);\n        }\n        if (!allowSpread && node.key.name === \"constructor\" && node.value.this) {\n          this.raise(FlowErrors.ThisParamBannedInConstructor, node.value.this);\n        }\n      } else {\n        if (kind !== \"init\") this.unexpected();\n        node.method = false;\n        if (this.eat(17)) {\n          optional = true;\n        }\n        node.value = this.flowParseTypeInitialiser();\n        node.variance = variance;\n      }\n      node.optional = optional;\n      return this.finishNode(node, \"ObjectTypeProperty\");\n    }\n  }\n  flowCheckGetterSetterParams(property) {\n    const paramCount = property.kind === \"get\" ? 0 : 1;\n    const length = property.value.params.length + (property.value.rest ? 1 : 0);\n    if (property.value.this) {\n      this.raise(property.kind === \"get\" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, property.value.this);\n    }\n    if (length !== paramCount) {\n      this.raise(property.kind === \"get\" ? Errors.BadGetterArity : Errors.BadSetterArity, property);\n    }\n    if (property.kind === \"set\" && property.value.rest) {\n      this.raise(Errors.BadSetterRestParameter, property);\n    }\n  }\n  flowObjectTypeSemicolon() {\n    if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {\n      this.unexpected();\n    }\n  }\n  flowParseQualifiedTypeIdentifier(startLoc, id) {\n    startLoc != null ? startLoc : startLoc = this.state.startLoc;\n    let node = id || this.flowParseRestrictedIdentifier(true);\n    while (this.eat(16)) {\n      const node2 = this.startNodeAt(startLoc);\n      node2.qualification = node;\n      node2.id = this.flowParseRestrictedIdentifier(true);\n      node = this.finishNode(node2, \"QualifiedTypeIdentifier\");\n    }\n    return node;\n  }\n  flowParseGenericType(startLoc, id) {\n    const node = this.startNodeAt(startLoc);\n    node.typeParameters = null;\n    node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterInstantiation();\n    }\n    return this.finishNode(node, \"GenericTypeAnnotation\");\n  }\n  flowParseTypeofType() {\n    const node = this.startNode();\n    this.expect(87);\n    node.argument = this.flowParsePrimaryType();\n    return this.finishNode(node, \"TypeofTypeAnnotation\");\n  }\n  flowParseTupleType() {\n    const node = this.startNode();\n    node.types = [];\n    this.expect(0);\n    while (this.state.pos < this.length && !this.match(3)) {\n      node.types.push(this.flowParseType());\n      if (this.match(3)) break;\n      this.expect(12);\n    }\n    this.expect(3);\n    return this.finishNode(node, \"TupleTypeAnnotation\");\n  }\n  flowParseFunctionTypeParam(first) {\n    let name = null;\n    let optional = false;\n    let typeAnnotation = null;\n    const node = this.startNode();\n    const lh = this.lookahead();\n    const isThis = this.state.type === 78;\n    if (lh.type === 14 || lh.type === 17) {\n      if (isThis && !first) {\n        this.raise(FlowErrors.ThisParamMustBeFirst, node);\n      }\n      name = this.parseIdentifier(isThis);\n      if (this.eat(17)) {\n        optional = true;\n        if (isThis) {\n          this.raise(FlowErrors.ThisParamMayNotBeOptional, node);\n        }\n      }\n      typeAnnotation = this.flowParseTypeInitialiser();\n    } else {\n      typeAnnotation = this.flowParseType();\n    }\n    node.name = name;\n    node.optional = optional;\n    node.typeAnnotation = typeAnnotation;\n    return this.finishNode(node, \"FunctionTypeParam\");\n  }\n  reinterpretTypeAsFunctionTypeParam(type) {\n    const node = this.startNodeAt(type.loc.start);\n    node.name = null;\n    node.optional = false;\n    node.typeAnnotation = type;\n    return this.finishNode(node, \"FunctionTypeParam\");\n  }\n  flowParseFunctionTypeParams(params = []) {\n    let rest = null;\n    let _this = null;\n    if (this.match(78)) {\n      _this = this.flowParseFunctionTypeParam(true);\n      _this.name = null;\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    while (!this.match(11) && !this.match(21)) {\n      params.push(this.flowParseFunctionTypeParam(false));\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    if (this.eat(21)) {\n      rest = this.flowParseFunctionTypeParam(false);\n    }\n    return {\n      params,\n      rest,\n      _this\n    };\n  }\n  flowIdentToTypeAnnotation(startLoc, node, id) {\n    switch (id.name) {\n      case \"any\":\n        return this.finishNode(node, \"AnyTypeAnnotation\");\n      case \"bool\":\n      case \"boolean\":\n        return this.finishNode(node, \"BooleanTypeAnnotation\");\n      case \"mixed\":\n        return this.finishNode(node, \"MixedTypeAnnotation\");\n      case \"empty\":\n        return this.finishNode(node, \"EmptyTypeAnnotation\");\n      case \"number\":\n        return this.finishNode(node, \"NumberTypeAnnotation\");\n      case \"string\":\n        return this.finishNode(node, \"StringTypeAnnotation\");\n      case \"symbol\":\n        return this.finishNode(node, \"SymbolTypeAnnotation\");\n      default:\n        this.checkNotUnderscore(id.name);\n        return this.flowParseGenericType(startLoc, id);\n    }\n  }\n  flowParsePrimaryType() {\n    const startLoc = this.state.startLoc;\n    const node = this.startNode();\n    let tmp;\n    let type;\n    let isGroupedType = false;\n    const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n    switch (this.state.type) {\n      case 5:\n        return this.flowParseObjectType({\n          allowStatic: false,\n          allowExact: false,\n          allowSpread: true,\n          allowProto: false,\n          allowInexact: true\n        });\n      case 6:\n        return this.flowParseObjectType({\n          allowStatic: false,\n          allowExact: true,\n          allowSpread: true,\n          allowProto: false,\n          allowInexact: false\n        });\n      case 0:\n        this.state.noAnonFunctionType = false;\n        type = this.flowParseTupleType();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n        return type;\n      case 47:\n        {\n          const node = this.startNode();\n          node.typeParameters = this.flowParseTypeParameterDeclaration();\n          this.expect(10);\n          tmp = this.flowParseFunctionTypeParams();\n          node.params = tmp.params;\n          node.rest = tmp.rest;\n          node.this = tmp._this;\n          this.expect(11);\n          this.expect(19);\n          node.returnType = this.flowParseType();\n          return this.finishNode(node, \"FunctionTypeAnnotation\");\n        }\n      case 10:\n        {\n          const node = this.startNode();\n          this.next();\n          if (!this.match(11) && !this.match(21)) {\n            if (tokenIsIdentifier(this.state.type) || this.match(78)) {\n              const token = this.lookahead().type;\n              isGroupedType = token !== 17 && token !== 14;\n            } else {\n              isGroupedType = true;\n            }\n          }\n          if (isGroupedType) {\n            this.state.noAnonFunctionType = false;\n            type = this.flowParseType();\n            this.state.noAnonFunctionType = oldNoAnonFunctionType;\n            if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {\n              this.expect(11);\n              return type;\n            } else {\n              this.eat(12);\n            }\n          }\n          if (type) {\n            tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);\n          } else {\n            tmp = this.flowParseFunctionTypeParams();\n          }\n          node.params = tmp.params;\n          node.rest = tmp.rest;\n          node.this = tmp._this;\n          this.expect(11);\n          this.expect(19);\n          node.returnType = this.flowParseType();\n          node.typeParameters = null;\n          return this.finishNode(node, \"FunctionTypeAnnotation\");\n        }\n      case 134:\n        return this.parseLiteral(this.state.value, \"StringLiteralTypeAnnotation\");\n      case 85:\n      case 86:\n        node.value = this.match(85);\n        this.next();\n        return this.finishNode(node, \"BooleanLiteralTypeAnnotation\");\n      case 53:\n        if (this.state.value === \"-\") {\n          this.next();\n          if (this.match(135)) {\n            return this.parseLiteralAtNode(-this.state.value, \"NumberLiteralTypeAnnotation\", node);\n          }\n          if (this.match(136)) {\n            return this.parseLiteralAtNode(-this.state.value, \"BigIntLiteralTypeAnnotation\", node);\n          }\n          throw this.raise(FlowErrors.UnexpectedSubtractionOperand, this.state.startLoc);\n        }\n        this.unexpected();\n        return;\n      case 135:\n        return this.parseLiteral(this.state.value, \"NumberLiteralTypeAnnotation\");\n      case 136:\n        return this.parseLiteral(this.state.value, \"BigIntLiteralTypeAnnotation\");\n      case 88:\n        this.next();\n        return this.finishNode(node, \"VoidTypeAnnotation\");\n      case 84:\n        this.next();\n        return this.finishNode(node, \"NullLiteralTypeAnnotation\");\n      case 78:\n        this.next();\n        return this.finishNode(node, \"ThisTypeAnnotation\");\n      case 55:\n        this.next();\n        return this.finishNode(node, \"ExistsTypeAnnotation\");\n      case 87:\n        return this.flowParseTypeofType();\n      default:\n        if (tokenIsKeyword(this.state.type)) {\n          const label = tokenLabelName(this.state.type);\n          this.next();\n          return super.createIdentifier(node, label);\n        } else if (tokenIsIdentifier(this.state.type)) {\n          if (this.isContextual(129)) {\n            return this.flowParseInterfaceType();\n          }\n          return this.flowIdentToTypeAnnotation(startLoc, node, this.parseIdentifier());\n        }\n    }\n    this.unexpected();\n  }\n  flowParsePostfixType() {\n    const startLoc = this.state.startLoc;\n    let type = this.flowParsePrimaryType();\n    let seenOptionalIndexedAccess = false;\n    while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt(startLoc);\n      const optional = this.eat(18);\n      seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;\n      this.expect(0);\n      if (!optional && this.match(3)) {\n        node.elementType = type;\n        this.next();\n        type = this.finishNode(node, \"ArrayTypeAnnotation\");\n      } else {\n        node.objectType = type;\n        node.indexType = this.flowParseType();\n        this.expect(3);\n        if (seenOptionalIndexedAccess) {\n          node.optional = optional;\n          type = this.finishNode(node, \"OptionalIndexedAccessType\");\n        } else {\n          type = this.finishNode(node, \"IndexedAccessType\");\n        }\n      }\n    }\n    return type;\n  }\n  flowParsePrefixType() {\n    const node = this.startNode();\n    if (this.eat(17)) {\n      node.typeAnnotation = this.flowParsePrefixType();\n      return this.finishNode(node, \"NullableTypeAnnotation\");\n    } else {\n      return this.flowParsePostfixType();\n    }\n  }\n  flowParseAnonFunctionWithoutParens() {\n    const param = this.flowParsePrefixType();\n    if (!this.state.noAnonFunctionType && this.eat(19)) {\n      const node = this.startNodeAt(param.loc.start);\n      node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];\n      node.rest = null;\n      node.this = null;\n      node.returnType = this.flowParseType();\n      node.typeParameters = null;\n      return this.finishNode(node, \"FunctionTypeAnnotation\");\n    }\n    return param;\n  }\n  flowParseIntersectionType() {\n    const node = this.startNode();\n    this.eat(45);\n    const type = this.flowParseAnonFunctionWithoutParens();\n    node.types = [type];\n    while (this.eat(45)) {\n      node.types.push(this.flowParseAnonFunctionWithoutParens());\n    }\n    return node.types.length === 1 ? type : this.finishNode(node, \"IntersectionTypeAnnotation\");\n  }\n  flowParseUnionType() {\n    const node = this.startNode();\n    this.eat(43);\n    const type = this.flowParseIntersectionType();\n    node.types = [type];\n    while (this.eat(43)) {\n      node.types.push(this.flowParseIntersectionType());\n    }\n    return node.types.length === 1 ? type : this.finishNode(node, \"UnionTypeAnnotation\");\n  }\n  flowParseType() {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    const type = this.flowParseUnionType();\n    this.state.inType = oldInType;\n    return type;\n  }\n  flowParseTypeOrImplicitInstantiation() {\n    if (this.state.type === 132 && this.state.value === \"_\") {\n      const startLoc = this.state.startLoc;\n      const node = this.parseIdentifier();\n      return this.flowParseGenericType(startLoc, node);\n    } else {\n      return this.flowParseType();\n    }\n  }\n  flowParseTypeAnnotation() {\n    const node = this.startNode();\n    node.typeAnnotation = this.flowParseTypeInitialiser();\n    return this.finishNode(node, \"TypeAnnotation\");\n  }\n  flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {\n    const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();\n    if (this.match(14)) {\n      ident.typeAnnotation = this.flowParseTypeAnnotation();\n      this.resetEndLocation(ident);\n    }\n    return ident;\n  }\n  typeCastToParameter(node) {\n    node.expression.typeAnnotation = node.typeAnnotation;\n    this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);\n    return node.expression;\n  }\n  flowParseVariance() {\n    let variance = null;\n    if (this.match(53)) {\n      variance = this.startNode();\n      if (this.state.value === \"+\") {\n        variance.kind = \"plus\";\n      } else {\n        variance.kind = \"minus\";\n      }\n      this.next();\n      return this.finishNode(variance, \"Variance\");\n    }\n    return variance;\n  }\n  parseFunctionBody(node, allowExpressionBody, isMethod = false) {\n    if (allowExpressionBody) {\n      this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));\n      return;\n    }\n    super.parseFunctionBody(node, false, isMethod);\n  }\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    if (this.match(14)) {\n      const typeNode = this.startNode();\n      [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n      node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, \"TypeAnnotation\") : null;\n    }\n    return super.parseFunctionBodyAndFinish(node, type, isMethod);\n  }\n  parseStatementLike(flags) {\n    if (this.state.strict && this.isContextual(129)) {\n      const lookahead = this.lookahead();\n      if (tokenIsKeywordOrIdentifier(lookahead.type)) {\n        const node = this.startNode();\n        this.next();\n        return this.flowParseInterface(node);\n      }\n    } else if (this.isContextual(126)) {\n      const node = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(node);\n    }\n    const stmt = super.parseStatementLike(flags);\n    if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {\n      this.flowPragma = null;\n    }\n    return stmt;\n  }\n  parseExpressionStatement(node, expr, decorators) {\n    if (expr.type === \"Identifier\") {\n      if (expr.name === \"declare\") {\n        if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {\n          return this.flowParseDeclare(node);\n        }\n      } else if (tokenIsIdentifier(this.state.type)) {\n        if (expr.name === \"interface\") {\n          return this.flowParseInterface(node);\n        } else if (expr.name === \"type\") {\n          return this.flowParseTypeAlias(node);\n        } else if (expr.name === \"opaque\") {\n          return this.flowParseOpaqueType(node, false);\n        }\n      }\n    }\n    return super.parseExpressionStatement(node, expr, decorators);\n  }\n  shouldParseExportDeclaration() {\n    const {\n      type\n    } = this.state;\n    if (type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type)) {\n      return !this.state.containsEsc;\n    }\n    return super.shouldParseExportDeclaration();\n  }\n  isExportDefaultSpecifier() {\n    const {\n      type\n    } = this.state;\n    if (type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type)) {\n      return this.state.containsEsc;\n    }\n    return super.isExportDefaultSpecifier();\n  }\n  parseExportDefaultExpression() {\n    if (this.isContextual(126)) {\n      const node = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(node);\n    }\n    return super.parseExportDefaultExpression();\n  }\n  parseConditional(expr, startLoc, refExpressionErrors) {\n    if (!this.match(17)) return expr;\n    if (this.state.maybeInArrowParameters) {\n      const nextCh = this.lookaheadCharCode();\n      if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {\n        this.setOptionalParametersError(refExpressionErrors);\n        return expr;\n      }\n    }\n    this.expect(17);\n    const state = this.state.clone();\n    const originalNoArrowAt = this.state.noArrowAt;\n    const node = this.startNodeAt(startLoc);\n    let {\n      consequent,\n      failed\n    } = this.tryParseConditionalConsequent();\n    let [valid, invalid] = this.getArrowLikeExpressions(consequent);\n    if (failed || invalid.length > 0) {\n      const noArrowAt = [...originalNoArrowAt];\n      if (invalid.length > 0) {\n        this.state = state;\n        this.state.noArrowAt = noArrowAt;\n        for (let i = 0; i < invalid.length; i++) {\n          noArrowAt.push(invalid[i].start);\n        }\n        ({\n          consequent,\n          failed\n        } = this.tryParseConditionalConsequent());\n        [valid, invalid] = this.getArrowLikeExpressions(consequent);\n      }\n      if (failed && valid.length > 1) {\n        this.raise(FlowErrors.AmbiguousConditionalArrow, state.startLoc);\n      }\n      if (failed && valid.length === 1) {\n        this.state = state;\n        noArrowAt.push(valid[0].start);\n        this.state.noArrowAt = noArrowAt;\n        ({\n          consequent,\n          failed\n        } = this.tryParseConditionalConsequent());\n      }\n    }\n    this.getArrowLikeExpressions(consequent, true);\n    this.state.noArrowAt = originalNoArrowAt;\n    this.expect(14);\n    node.test = expr;\n    node.consequent = consequent;\n    node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(undefined, undefined));\n    return this.finishNode(node, \"ConditionalExpression\");\n  }\n  tryParseConditionalConsequent() {\n    this.state.noArrowParamsConversionAt.push(this.state.start);\n    const consequent = this.parseMaybeAssignAllowIn();\n    const failed = !this.match(14);\n    this.state.noArrowParamsConversionAt.pop();\n    return {\n      consequent,\n      failed\n    };\n  }\n  getArrowLikeExpressions(node, disallowInvalid) {\n    const stack = [node];\n    const arrows = [];\n    while (stack.length !== 0) {\n      const node = stack.pop();\n      if (node.type === \"ArrowFunctionExpression\" && node.body.type !== \"BlockStatement\") {\n        if (node.typeParameters || !node.returnType) {\n          this.finishArrowValidation(node);\n        } else {\n          arrows.push(node);\n        }\n        stack.push(node.body);\n      } else if (node.type === \"ConditionalExpression\") {\n        stack.push(node.consequent);\n        stack.push(node.alternate);\n      }\n    }\n    if (disallowInvalid) {\n      arrows.forEach(node => this.finishArrowValidation(node));\n      return [arrows, []];\n    }\n    return partition(arrows, node => node.params.every(param => this.isAssignable(param, true)));\n  }\n  finishArrowValidation(node) {\n    var _node$extra;\n    this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);\n    this.scope.enter(514 | 4);\n    super.checkParams(node, false, true);\n    this.scope.exit();\n  }\n  forwardNoArrowParamsConversionAt(node, parse) {\n    let result;\n    if (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {\n      this.state.noArrowParamsConversionAt.push(this.state.start);\n      result = parse();\n      this.state.noArrowParamsConversionAt.pop();\n    } else {\n      result = parse();\n    }\n    return result;\n  }\n  parseParenItem(node, startLoc) {\n    const newNode = super.parseParenItem(node, startLoc);\n    if (this.eat(17)) {\n      newNode.optional = true;\n      this.resetEndLocation(node);\n    }\n    if (this.match(14)) {\n      const typeCastNode = this.startNodeAt(startLoc);\n      typeCastNode.expression = newNode;\n      typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();\n      return this.finishNode(typeCastNode, \"TypeCastExpression\");\n    }\n    return newNode;\n  }\n  assertModuleNodeAllowed(node) {\n    if (node.type === \"ImportDeclaration\" && (node.importKind === \"type\" || node.importKind === \"typeof\") || node.type === \"ExportNamedDeclaration\" && node.exportKind === \"type\" || node.type === \"ExportAllDeclaration\" && node.exportKind === \"type\") {\n      return;\n    }\n    super.assertModuleNodeAllowed(node);\n  }\n  parseExportDeclaration(node) {\n    if (this.isContextual(130)) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      if (this.match(5)) {\n        node.specifiers = this.parseExportSpecifiers(true);\n        super.parseExportFrom(node);\n        return null;\n      } else {\n        return this.flowParseTypeAlias(declarationNode);\n      }\n    } else if (this.isContextual(131)) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseOpaqueType(declarationNode, false);\n    } else if (this.isContextual(129)) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseInterface(declarationNode);\n    } else if (this.isContextual(126)) {\n      node.exportKind = \"value\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(declarationNode);\n    } else {\n      return super.parseExportDeclaration(node);\n    }\n  }\n  eatExportStar(node) {\n    if (super.eatExportStar(node)) return true;\n    if (this.isContextual(130) && this.lookahead().type === 55) {\n      node.exportKind = \"type\";\n      this.next();\n      this.next();\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportNamespaceSpecifier(node) {\n    const {\n      startLoc\n    } = this.state;\n    const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);\n    if (hasNamespace && node.exportKind === \"type\") {\n      this.unexpected(startLoc);\n    }\n    return hasNamespace;\n  }\n  parseClassId(node, isStatement, optionalId) {\n    super.parseClassId(node, isStatement, optionalId);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n  }\n  parseClassMember(classBody, member, state) {\n    const {\n      startLoc\n    } = this.state;\n    if (this.isContextual(125)) {\n      if (super.parseClassMemberFromModifier(classBody, member)) {\n        return;\n      }\n      member.declare = true;\n    }\n    super.parseClassMember(classBody, member, state);\n    if (member.declare) {\n      if (member.type !== \"ClassProperty\" && member.type !== \"ClassPrivateProperty\" && member.type !== \"PropertyDefinition\") {\n        this.raise(FlowErrors.DeclareClassElement, startLoc);\n      } else if (member.value) {\n        this.raise(FlowErrors.DeclareClassFieldInitializer, member.value);\n      }\n    }\n  }\n  isIterator(word) {\n    return word === \"iterator\" || word === \"asyncIterator\";\n  }\n  readIterator() {\n    const word = super.readWord1();\n    const fullWord = \"@@\" + word;\n    if (!this.isIterator(word) || !this.state.inType) {\n      this.raise(Errors.InvalidIdentifier, this.state.curPosition(), {\n        identifierName: fullWord\n      });\n    }\n    this.finishToken(132, fullWord);\n  }\n  getTokenFromCode(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (code === 123 && next === 124) {\n      this.finishOp(6, 2);\n    } else if (this.state.inType && (code === 62 || code === 60)) {\n      this.finishOp(code === 62 ? 48 : 47, 1);\n    } else if (this.state.inType && code === 63) {\n      if (next === 46) {\n        this.finishOp(18, 2);\n      } else {\n        this.finishOp(17, 1);\n      }\n    } else if (isIteratorStart(code, next, this.input.charCodeAt(this.state.pos + 2))) {\n      this.state.pos += 2;\n      this.readIterator();\n    } else {\n      super.getTokenFromCode(code);\n    }\n  }\n  isAssignable(node, isBinding) {\n    if (node.type === \"TypeCastExpression\") {\n      return this.isAssignable(node.expression, isBinding);\n    } else {\n      return super.isAssignable(node, isBinding);\n    }\n  }\n  toAssignable(node, isLHS = false) {\n    if (!isLHS && node.type === \"AssignmentExpression\" && node.left.type === \"TypeCastExpression\") {\n      node.left = this.typeCastToParameter(node.left);\n    }\n    super.toAssignable(node, isLHS);\n  }\n  toAssignableList(exprList, trailingCommaLoc, isLHS) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n      if ((expr == null ? void 0 : expr.type) === \"TypeCastExpression\") {\n        exprList[i] = this.typeCastToParameter(expr);\n      }\n    }\n    super.toAssignableList(exprList, trailingCommaLoc, isLHS);\n  }\n  toReferencedList(exprList, isParenthesizedExpr) {\n    for (let i = 0; i < exprList.length; i++) {\n      var _expr$extra;\n      const expr = exprList[i];\n      if (expr && expr.type === \"TypeCastExpression\" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {\n        this.raise(FlowErrors.TypeCastInPattern, expr.typeAnnotation);\n      }\n    }\n    return exprList;\n  }\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n    const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);\n    if (canBePattern && !this.state.maybeInArrowParameters) {\n      this.toReferencedList(node.elements);\n    }\n    return node;\n  }\n  isValidLVal(type, isParenthesized, binding) {\n    return type === \"TypeCastExpression\" || super.isValidLVal(type, isParenthesized, binding);\n  }\n  parseClassProperty(node) {\n    if (this.match(14)) {\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n    }\n    return super.parseClassProperty(node);\n  }\n  parseClassPrivateProperty(node) {\n    if (this.match(14)) {\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n    }\n    return super.parseClassPrivateProperty(node);\n  }\n  isClassMethod() {\n    return this.match(47) || super.isClassMethod();\n  }\n  isClassProperty() {\n    return this.match(14) || super.isClassProperty();\n  }\n  isNonstaticConstructor(method) {\n    return !this.match(14) && super.isNonstaticConstructor(method);\n  }\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    if (method.variance) {\n      this.unexpected(method.variance.loc.start);\n    }\n    delete method.variance;\n    if (this.match(47)) {\n      method.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n    if (method.params && isConstructor) {\n      const params = method.params;\n      if (params.length > 0 && this.isThisParam(params[0])) {\n        this.raise(FlowErrors.ThisParamBannedInConstructor, method);\n      }\n    } else if (method.type === \"MethodDefinition\" && isConstructor && method.value.params) {\n      const params = method.value.params;\n      if (params.length > 0 && this.isThisParam(params[0])) {\n        this.raise(FlowErrors.ThisParamBannedInConstructor, method);\n      }\n    }\n  }\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    if (method.variance) {\n      this.unexpected(method.variance.loc.start);\n    }\n    delete method.variance;\n    if (this.match(47)) {\n      method.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n  }\n  parseClassSuper(node) {\n    super.parseClassSuper(node);\n    if (node.superClass && (this.match(47) || this.match(51))) {\n      {\n        node.superTypeParameters = this.flowParseTypeParameterInstantiationInExpression();\n      }\n    }\n    if (this.isContextual(113)) {\n      this.next();\n      const implemented = node.implements = [];\n      do {\n        const node = this.startNode();\n        node.id = this.flowParseRestrictedIdentifier(true);\n        if (this.match(47)) {\n          node.typeParameters = this.flowParseTypeParameterInstantiation();\n        } else {\n          node.typeParameters = null;\n        }\n        implemented.push(this.finishNode(node, \"ClassImplements\"));\n      } while (this.eat(12));\n    }\n  }\n  checkGetterSetterParams(method) {\n    super.checkGetterSetterParams(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    if (params.length > 0) {\n      const param = params[0];\n      if (this.isThisParam(param) && method.kind === \"get\") {\n        this.raise(FlowErrors.GetterMayNotHaveThisParam, param);\n      } else if (this.isThisParam(param)) {\n        this.raise(FlowErrors.SetterMayNotHaveThisParam, param);\n      }\n    }\n  }\n  parsePropertyNamePrefixOperator(node) {\n    node.variance = this.flowParseVariance();\n  }\n  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    if (prop.variance) {\n      this.unexpected(prop.variance.loc.start);\n    }\n    delete prop.variance;\n    let typeParameters;\n    if (this.match(47) && !isAccessor) {\n      typeParameters = this.flowParseTypeParameterDeclaration();\n      if (!this.match(10)) this.unexpected();\n    }\n    const result = super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);\n    if (typeParameters) {\n      (result.value || result).typeParameters = typeParameters;\n    }\n    return result;\n  }\n  parseFunctionParamType(param) {\n    if (this.eat(17)) {\n      if (param.type !== \"Identifier\") {\n        this.raise(FlowErrors.PatternIsOptional, param);\n      }\n      if (this.isThisParam(param)) {\n        this.raise(FlowErrors.ThisParamMayNotBeOptional, param);\n      }\n      param.optional = true;\n    }\n    if (this.match(14)) {\n      param.typeAnnotation = this.flowParseTypeAnnotation();\n    } else if (this.isThisParam(param)) {\n      this.raise(FlowErrors.ThisParamAnnotationRequired, param);\n    }\n    if (this.match(29) && this.isThisParam(param)) {\n      this.raise(FlowErrors.ThisParamNoDefault, param);\n    }\n    this.resetEndLocation(param);\n    return param;\n  }\n  parseMaybeDefault(startLoc, left) {\n    const node = super.parseMaybeDefault(startLoc, left);\n    if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n      this.raise(FlowErrors.TypeBeforeInitializer, node.typeAnnotation);\n    }\n    return node;\n  }\n  checkImportReflection(node) {\n    super.checkImportReflection(node);\n    if (node.module && node.importKind !== \"value\") {\n      this.raise(FlowErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);\n    }\n  }\n  parseImportSpecifierLocal(node, specifier, type) {\n    specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();\n    node.specifiers.push(this.finishImportSpecifier(specifier, type));\n  }\n  isPotentialImportPhase(isExport) {\n    if (super.isPotentialImportPhase(isExport)) return true;\n    if (this.isContextual(130)) {\n      if (!isExport) return true;\n      const ch = this.lookaheadCharCode();\n      return ch === 123 || ch === 42;\n    }\n    return !isExport && this.isContextual(87);\n  }\n  applyImportPhase(node, isExport, phase, loc) {\n    super.applyImportPhase(node, isExport, phase, loc);\n    if (isExport) {\n      if (!phase && this.match(65)) {\n        return;\n      }\n      node.exportKind = phase === \"type\" ? phase : \"value\";\n    } else {\n      if (phase === \"type\" && this.match(55)) this.unexpected();\n      node.importKind = phase === \"type\" || phase === \"typeof\" ? phase : \"value\";\n    }\n  }\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {\n    const firstIdent = specifier.imported;\n    let specifierTypeKind = null;\n    if (firstIdent.type === \"Identifier\") {\n      if (firstIdent.name === \"type\") {\n        specifierTypeKind = \"type\";\n      } else if (firstIdent.name === \"typeof\") {\n        specifierTypeKind = \"typeof\";\n      }\n    }\n    let isBinding = false;\n    if (this.isContextual(93) && !this.isLookaheadContextual(\"as\")) {\n      const as_ident = this.parseIdentifier(true);\n      if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {\n        specifier.imported = as_ident;\n        specifier.importKind = specifierTypeKind;\n        specifier.local = this.cloneIdentifier(as_ident);\n      } else {\n        specifier.imported = firstIdent;\n        specifier.importKind = null;\n        specifier.local = this.parseIdentifier();\n      }\n    } else {\n      if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {\n        specifier.imported = this.parseIdentifier(true);\n        specifier.importKind = specifierTypeKind;\n      } else {\n        if (importedIsString) {\n          throw this.raise(Errors.ImportBindingIsString, specifier, {\n            importName: firstIdent.value\n          });\n        }\n        specifier.imported = firstIdent;\n        specifier.importKind = null;\n      }\n      if (this.eatContextual(93)) {\n        specifier.local = this.parseIdentifier();\n      } else {\n        isBinding = true;\n        specifier.local = this.cloneIdentifier(specifier.imported);\n      }\n    }\n    const specifierIsTypeImport = hasTypeImportKind(specifier);\n    if (isInTypeOnlyImport && specifierIsTypeImport) {\n      this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, specifier);\n    }\n    if (isInTypeOnlyImport || specifierIsTypeImport) {\n      this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);\n    }\n    if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {\n      this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);\n    }\n    return this.finishImportSpecifier(specifier, \"ImportSpecifier\");\n  }\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case 78:\n        return this.parseIdentifier(true);\n      default:\n        return super.parseBindingAtom();\n    }\n  }\n  parseFunctionParams(node, isConstructor) {\n    const kind = node.kind;\n    if (kind !== \"get\" && kind !== \"set\" && this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    super.parseFunctionParams(node, isConstructor);\n  }\n  parseVarId(decl, kind) {\n    super.parseVarId(decl, kind);\n    if (this.match(14)) {\n      decl.id.typeAnnotation = this.flowParseTypeAnnotation();\n      this.resetEndLocation(decl.id);\n    }\n  }\n  parseAsyncArrowFromCallExpression(node, call) {\n    if (this.match(14)) {\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n      this.state.noAnonFunctionType = true;\n      node.returnType = this.flowParseTypeAnnotation();\n      this.state.noAnonFunctionType = oldNoAnonFunctionType;\n    }\n    return super.parseAsyncArrowFromCallExpression(node, call);\n  }\n  shouldParseAsyncArrow() {\n    return this.match(14) || super.shouldParseAsyncArrow();\n  }\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    var _jsx;\n    let state = null;\n    let jsx;\n    if (this.hasPlugin(\"jsx\") && (this.match(143) || this.match(47))) {\n      state = this.state.clone();\n      jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\n      if (!jsx.error) return jsx.node;\n      const {\n        context\n      } = this.state;\n      const currentContext = context[context.length - 1];\n      if (currentContext === types.j_oTag || currentContext === types.j_expr) {\n        context.pop();\n      }\n    }\n    if ((_jsx = jsx) != null && _jsx.error || this.match(47)) {\n      var _jsx2, _jsx3;\n      state = state || this.state.clone();\n      let typeParameters;\n      const arrow = this.tryParse(abort => {\n        var _arrowExpression$extr;\n        typeParameters = this.flowParseTypeParameterDeclaration();\n        const arrowExpression = this.forwardNoArrowParamsConversionAt(typeParameters, () => {\n          const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n          this.resetStartLocationFromNode(result, typeParameters);\n          return result;\n        });\n        if ((_arrowExpression$extr = arrowExpression.extra) != null && _arrowExpression$extr.parenthesized) abort();\n        const expr = this.maybeUnwrapTypeCastExpression(arrowExpression);\n        if (expr.type !== \"ArrowFunctionExpression\") abort();\n        expr.typeParameters = typeParameters;\n        this.resetStartLocationFromNode(expr, typeParameters);\n        return arrowExpression;\n      }, state);\n      let arrowExpression = null;\n      if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === \"ArrowFunctionExpression\") {\n        if (!arrow.error && !arrow.aborted) {\n          if (arrow.node.async) {\n            this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, typeParameters);\n          }\n          return arrow.node;\n        }\n        arrowExpression = arrow.node;\n      }\n      if ((_jsx2 = jsx) != null && _jsx2.node) {\n        this.state = jsx.failState;\n        return jsx.node;\n      }\n      if (arrowExpression) {\n        this.state = arrow.failState;\n        return arrowExpression;\n      }\n      if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error;\n      if (arrow.thrown) throw arrow.error;\n      throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, typeParameters);\n    }\n    return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n  }\n  parseArrow(node) {\n    if (this.match(14)) {\n      const result = this.tryParse(() => {\n        const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n        this.state.noAnonFunctionType = true;\n        const typeNode = this.startNode();\n        [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n        if (this.canInsertSemicolon()) this.unexpected();\n        if (!this.match(19)) this.unexpected();\n        return typeNode;\n      });\n      if (result.thrown) return null;\n      if (result.error) this.state = result.failState;\n      node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, \"TypeAnnotation\") : null;\n    }\n    return super.parseArrow(node);\n  }\n  shouldParseArrow(params) {\n    return this.match(14) || super.shouldParseArrow(params);\n  }\n  setArrowFunctionParameters(node, params) {\n    if (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {\n      node.params = params;\n    } else {\n      super.setArrowFunctionParameters(node, params);\n    }\n  }\n  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {\n    if (isArrowFunction && this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {\n      return;\n    }\n    for (let i = 0; i < node.params.length; i++) {\n      if (this.isThisParam(node.params[i]) && i > 0) {\n        this.raise(FlowErrors.ThisParamMustBeFirst, node.params[i]);\n      }\n    }\n    super.checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged);\n  }\n  parseParenAndDistinguishExpression(canBeArrow) {\n    return super.parseParenAndDistinguishExpression(canBeArrow && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));\n  }\n  parseSubscripts(base, startLoc, noCalls) {\n    if (base.type === \"Identifier\" && base.name === \"async\" && this.state.noArrowAt.includes(startLoc.index)) {\n      this.next();\n      const node = this.startNodeAt(startLoc);\n      node.callee = base;\n      node.arguments = super.parseCallExpressionArguments();\n      base = this.finishNode(node, \"CallExpression\");\n    } else if (base.type === \"Identifier\" && base.name === \"async\" && this.match(47)) {\n      const state = this.state.clone();\n      const arrow = this.tryParse(abort => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(), state);\n      if (!arrow.error && !arrow.aborted) return arrow.node;\n      const result = this.tryParse(() => super.parseSubscripts(base, startLoc, noCalls), state);\n      if (result.node && !result.error) return result.node;\n      if (arrow.node) {\n        this.state = arrow.failState;\n        return arrow.node;\n      }\n      if (result.node) {\n        this.state = result.failState;\n        return result.node;\n      }\n      throw arrow.error || result.error;\n    }\n    return super.parseSubscripts(base, startLoc, noCalls);\n  }\n  parseSubscript(base, startLoc, noCalls, subscriptState) {\n    if (this.match(18) && this.isLookaheadToken_lt()) {\n      subscriptState.optionalChainMember = true;\n      if (noCalls) {\n        subscriptState.stop = true;\n        return base;\n      }\n      this.next();\n      const node = this.startNodeAt(startLoc);\n      node.callee = base;\n      node.typeArguments = this.flowParseTypeParameterInstantiationInExpression();\n      this.expect(10);\n      node.arguments = this.parseCallExpressionArguments();\n      node.optional = true;\n      return this.finishCallExpression(node, true);\n    } else if (!noCalls && this.shouldParseTypes() && (this.match(47) || this.match(51))) {\n      const node = this.startNodeAt(startLoc);\n      node.callee = base;\n      const result = this.tryParse(() => {\n        node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();\n        this.expect(10);\n        node.arguments = super.parseCallExpressionArguments();\n        if (subscriptState.optionalChainMember) {\n          node.optional = false;\n        }\n        return this.finishCallExpression(node, subscriptState.optionalChainMember);\n      });\n      if (result.node) {\n        if (result.error) this.state = result.failState;\n        return result.node;\n      }\n    }\n    return super.parseSubscript(base, startLoc, noCalls, subscriptState);\n  }\n  parseNewCallee(node) {\n    super.parseNewCallee(node);\n    let targs = null;\n    if (this.shouldParseTypes() && this.match(47)) {\n      targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;\n    }\n    node.typeArguments = targs;\n  }\n  parseAsyncArrowWithTypeParameters(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    this.parseFunctionParams(node, false);\n    if (!this.parseArrow(node)) return;\n    return super.parseArrowExpression(node, undefined, true);\n  }\n  readToken_mult_modulo(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (code === 42 && next === 47 && this.state.hasFlowComment) {\n      this.state.hasFlowComment = false;\n      this.state.pos += 2;\n      this.nextToken();\n      return;\n    }\n    super.readToken_mult_modulo(code);\n  }\n  readToken_pipe_amp(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (code === 124 && next === 125) {\n      this.finishOp(9, 2);\n      return;\n    }\n    super.readToken_pipe_amp(code);\n  }\n  parseTopLevel(file, program) {\n    const fileNode = super.parseTopLevel(file, program);\n    if (this.state.hasFlowComment) {\n      this.raise(FlowErrors.UnterminatedFlowComment, this.state.curPosition());\n    }\n    return fileNode;\n  }\n  skipBlockComment() {\n    if (this.hasPlugin(\"flowComments\") && this.skipFlowComment()) {\n      if (this.state.hasFlowComment) {\n        throw this.raise(FlowErrors.NestedFlowComment, this.state.startLoc);\n      }\n      this.hasFlowCommentCompletion();\n      const commentSkip = this.skipFlowComment();\n      if (commentSkip) {\n        this.state.pos += commentSkip;\n        this.state.hasFlowComment = true;\n      }\n      return;\n    }\n    return super.skipBlockComment(this.state.hasFlowComment ? \"*-/\" : \"*/\");\n  }\n  skipFlowComment() {\n    const {\n      pos\n    } = this.state;\n    let shiftToFirstNonWhiteSpace = 2;\n    while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {\n      shiftToFirstNonWhiteSpace++;\n    }\n    const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);\n    const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);\n    if (ch2 === 58 && ch3 === 58) {\n      return shiftToFirstNonWhiteSpace + 2;\n    }\n    if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === \"flow-include\") {\n      return shiftToFirstNonWhiteSpace + 12;\n    }\n    if (ch2 === 58 && ch3 !== 58) {\n      return shiftToFirstNonWhiteSpace;\n    }\n    return false;\n  }\n  hasFlowCommentCompletion() {\n    const end = this.input.indexOf(\"*/\", this.state.pos);\n    if (end === -1) {\n      throw this.raise(Errors.UnterminatedComment, this.state.curPosition());\n    }\n  }\n  flowEnumErrorBooleanMemberNotInitialized(loc, {\n    enumName,\n    memberName\n  }) {\n    this.raise(FlowErrors.EnumBooleanMemberNotInitialized, loc, {\n      memberName,\n      enumName\n    });\n  }\n  flowEnumErrorInvalidMemberInitializer(loc, enumContext) {\n    return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === \"symbol\" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, loc, enumContext);\n  }\n  flowEnumErrorNumberMemberNotInitialized(loc, details) {\n    this.raise(FlowErrors.EnumNumberMemberNotInitialized, loc, details);\n  }\n  flowEnumErrorStringMemberInconsistentlyInitialized(node, details) {\n    this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized, node, details);\n  }\n  flowEnumMemberInit() {\n    const startLoc = this.state.startLoc;\n    const endOfInit = () => this.match(12) || this.match(8);\n    switch (this.state.type) {\n      case 135:\n        {\n          const literal = this.parseNumericLiteral(this.state.value);\n          if (endOfInit()) {\n            return {\n              type: \"number\",\n              loc: literal.loc.start,\n              value: literal\n            };\n          }\n          return {\n            type: \"invalid\",\n            loc: startLoc\n          };\n        }\n      case 134:\n        {\n          const literal = this.parseStringLiteral(this.state.value);\n          if (endOfInit()) {\n            return {\n              type: \"string\",\n              loc: literal.loc.start,\n              value: literal\n            };\n          }\n          return {\n            type: \"invalid\",\n            loc: startLoc\n          };\n        }\n      case 85:\n      case 86:\n        {\n          const literal = this.parseBooleanLiteral(this.match(85));\n          if (endOfInit()) {\n            return {\n              type: \"boolean\",\n              loc: literal.loc.start,\n              value: literal\n            };\n          }\n          return {\n            type: \"invalid\",\n            loc: startLoc\n          };\n        }\n      default:\n        return {\n          type: \"invalid\",\n          loc: startLoc\n        };\n    }\n  }\n  flowEnumMemberRaw() {\n    const loc = this.state.startLoc;\n    const id = this.parseIdentifier(true);\n    const init = this.eat(29) ? this.flowEnumMemberInit() : {\n      type: \"none\",\n      loc\n    };\n    return {\n      id,\n      init\n    };\n  }\n  flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {\n    const {\n      explicitType\n    } = context;\n    if (explicitType === null) {\n      return;\n    }\n    if (explicitType !== expectedType) {\n      this.flowEnumErrorInvalidMemberInitializer(loc, context);\n    }\n  }\n  flowEnumMembers({\n    enumName,\n    explicitType\n  }) {\n    const seenNames = new Set();\n    const members = {\n      booleanMembers: [],\n      numberMembers: [],\n      stringMembers: [],\n      defaultedMembers: []\n    };\n    let hasUnknownMembers = false;\n    while (!this.match(8)) {\n      if (this.eat(21)) {\n        hasUnknownMembers = true;\n        break;\n      }\n      const memberNode = this.startNode();\n      const {\n        id,\n        init\n      } = this.flowEnumMemberRaw();\n      const memberName = id.name;\n      if (memberName === \"\") {\n        continue;\n      }\n      if (/^[a-z]/.test(memberName)) {\n        this.raise(FlowErrors.EnumInvalidMemberName, id, {\n          memberName,\n          suggestion: memberName[0].toUpperCase() + memberName.slice(1),\n          enumName\n        });\n      }\n      if (seenNames.has(memberName)) {\n        this.raise(FlowErrors.EnumDuplicateMemberName, id, {\n          memberName,\n          enumName\n        });\n      }\n      seenNames.add(memberName);\n      const context = {\n        enumName,\n        explicitType,\n        memberName\n      };\n      memberNode.id = id;\n      switch (init.type) {\n        case \"boolean\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"boolean\");\n            memberNode.init = init.value;\n            members.booleanMembers.push(this.finishNode(memberNode, \"EnumBooleanMember\"));\n            break;\n          }\n        case \"number\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"number\");\n            memberNode.init = init.value;\n            members.numberMembers.push(this.finishNode(memberNode, \"EnumNumberMember\"));\n            break;\n          }\n        case \"string\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"string\");\n            memberNode.init = init.value;\n            members.stringMembers.push(this.finishNode(memberNode, \"EnumStringMember\"));\n            break;\n          }\n        case \"invalid\":\n          {\n            throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);\n          }\n        case \"none\":\n          {\n            switch (explicitType) {\n              case \"boolean\":\n                this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);\n                break;\n              case \"number\":\n                this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);\n                break;\n              default:\n                members.defaultedMembers.push(this.finishNode(memberNode, \"EnumDefaultedMember\"));\n            }\n          }\n      }\n      if (!this.match(8)) {\n        this.expect(12);\n      }\n    }\n    return {\n      members,\n      hasUnknownMembers\n    };\n  }\n  flowEnumStringMembers(initializedMembers, defaultedMembers, {\n    enumName\n  }) {\n    if (initializedMembers.length === 0) {\n      return defaultedMembers;\n    } else if (defaultedMembers.length === 0) {\n      return initializedMembers;\n    } else if (defaultedMembers.length > initializedMembers.length) {\n      for (const member of initializedMembers) {\n        this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {\n          enumName\n        });\n      }\n      return defaultedMembers;\n    } else {\n      for (const member of defaultedMembers) {\n        this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {\n          enumName\n        });\n      }\n      return initializedMembers;\n    }\n  }\n  flowEnumParseExplicitType({\n    enumName\n  }) {\n    if (!this.eatContextual(102)) return null;\n    if (!tokenIsIdentifier(this.state.type)) {\n      throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {\n        enumName\n      });\n    }\n    const {\n      value\n    } = this.state;\n    this.next();\n    if (value !== \"boolean\" && value !== \"number\" && value !== \"string\" && value !== \"symbol\") {\n      this.raise(FlowErrors.EnumInvalidExplicitType, this.state.startLoc, {\n        enumName,\n        invalidEnumType: value\n      });\n    }\n    return value;\n  }\n  flowEnumBody(node, id) {\n    const enumName = id.name;\n    const nameLoc = id.loc.start;\n    const explicitType = this.flowEnumParseExplicitType({\n      enumName\n    });\n    this.expect(5);\n    const {\n      members,\n      hasUnknownMembers\n    } = this.flowEnumMembers({\n      enumName,\n      explicitType\n    });\n    node.hasUnknownMembers = hasUnknownMembers;\n    switch (explicitType) {\n      case \"boolean\":\n        node.explicitType = true;\n        node.members = members.booleanMembers;\n        this.expect(8);\n        return this.finishNode(node, \"EnumBooleanBody\");\n      case \"number\":\n        node.explicitType = true;\n        node.members = members.numberMembers;\n        this.expect(8);\n        return this.finishNode(node, \"EnumNumberBody\");\n      case \"string\":\n        node.explicitType = true;\n        node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n          enumName\n        });\n        this.expect(8);\n        return this.finishNode(node, \"EnumStringBody\");\n      case \"symbol\":\n        node.members = members.defaultedMembers;\n        this.expect(8);\n        return this.finishNode(node, \"EnumSymbolBody\");\n      default:\n        {\n          const empty = () => {\n            node.members = [];\n            this.expect(8);\n            return this.finishNode(node, \"EnumStringBody\");\n          };\n          node.explicitType = false;\n          const boolsLen = members.booleanMembers.length;\n          const numsLen = members.numberMembers.length;\n          const strsLen = members.stringMembers.length;\n          const defaultedLen = members.defaultedMembers.length;\n          if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {\n            return empty();\n          } else if (!boolsLen && !numsLen) {\n            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n              enumName\n            });\n            this.expect(8);\n            return this.finishNode(node, \"EnumStringBody\");\n          } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {\n            for (const member of members.defaultedMembers) {\n              this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {\n                enumName,\n                memberName: member.id.name\n              });\n            }\n            node.members = members.booleanMembers;\n            this.expect(8);\n            return this.finishNode(node, \"EnumBooleanBody\");\n          } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {\n            for (const member of members.defaultedMembers) {\n              this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {\n                enumName,\n                memberName: member.id.name\n              });\n            }\n            node.members = members.numberMembers;\n            this.expect(8);\n            return this.finishNode(node, \"EnumNumberBody\");\n          } else {\n            this.raise(FlowErrors.EnumInconsistentMemberValues, nameLoc, {\n              enumName\n            });\n            return empty();\n          }\n        }\n    }\n  }\n  flowParseEnumDeclaration(node) {\n    const id = this.parseIdentifier();\n    node.id = id;\n    node.body = this.flowEnumBody(this.startNode(), id);\n    return this.finishNode(node, \"EnumDeclaration\");\n  }\n  jsxParseOpeningElementAfterName(node) {\n    if (this.shouldParseTypes()) {\n      if (this.match(47) || this.match(51)) {\n        node.typeArguments = this.flowParseTypeParameterInstantiationInExpression();\n      }\n    }\n    return super.jsxParseOpeningElementAfterName(node);\n  }\n  isLookaheadToken_lt() {\n    const next = this.nextTokenStart();\n    if (this.input.charCodeAt(next) === 60) {\n      const afterNext = this.input.charCodeAt(next + 1);\n      return afterNext !== 60 && afterNext !== 61;\n    }\n    return false;\n  }\n  reScan_lt_gt() {\n    const {\n      type\n    } = this.state;\n    if (type === 47) {\n      this.state.pos -= 1;\n      this.readToken_lt();\n    } else if (type === 48) {\n      this.state.pos -= 1;\n      this.readToken_gt();\n    }\n  }\n  reScan_lt() {\n    const {\n      type\n    } = this.state;\n    if (type === 51) {\n      this.state.pos -= 2;\n      this.finishOp(47, 1);\n      return 47;\n    }\n    return type;\n  }\n  maybeUnwrapTypeCastExpression(node) {\n    return node.type === \"TypeCastExpression\" ? node.expression : node;\n  }\n};\nconst entities = {\n  __proto__: null,\n  quot: \"\\u0022\",\n  amp: \"&\",\n  apos: \"\\u0027\",\n  lt: \"<\",\n  gt: \">\",\n  nbsp: \"\\u00A0\",\n  iexcl: \"\\u00A1\",\n  cent: \"\\u00A2\",\n  pound: \"\\u00A3\",\n  curren: \"\\u00A4\",\n  yen: \"\\u00A5\",\n  brvbar: \"\\u00A6\",\n  sect: \"\\u00A7\",\n  uml: \"\\u00A8\",\n  copy: \"\\u00A9\",\n  ordf: \"\\u00AA\",\n  laquo: \"\\u00AB\",\n  not: \"\\u00AC\",\n  shy: \"\\u00AD\",\n  reg: \"\\u00AE\",\n  macr: \"\\u00AF\",\n  deg: \"\\u00B0\",\n  plusmn: \"\\u00B1\",\n  sup2: \"\\u00B2\",\n  sup3: \"\\u00B3\",\n  acute: \"\\u00B4\",\n  micro: \"\\u00B5\",\n  para: \"\\u00B6\",\n  middot: \"\\u00B7\",\n  cedil: \"\\u00B8\",\n  sup1: \"\\u00B9\",\n  ordm: \"\\u00BA\",\n  raquo: \"\\u00BB\",\n  frac14: \"\\u00BC\",\n  frac12: \"\\u00BD\",\n  frac34: \"\\u00BE\",\n  iquest: \"\\u00BF\",\n  Agrave: \"\\u00C0\",\n  Aacute: \"\\u00C1\",\n  Acirc: \"\\u00C2\",\n  Atilde: \"\\u00C3\",\n  Auml: \"\\u00C4\",\n  Aring: \"\\u00C5\",\n  AElig: \"\\u00C6\",\n  Ccedil: \"\\u00C7\",\n  Egrave: \"\\u00C8\",\n  Eacute: \"\\u00C9\",\n  Ecirc: \"\\u00CA\",\n  Euml: \"\\u00CB\",\n  Igrave: \"\\u00CC\",\n  Iacute: \"\\u00CD\",\n  Icirc: \"\\u00CE\",\n  Iuml: \"\\u00CF\",\n  ETH: \"\\u00D0\",\n  Ntilde: \"\\u00D1\",\n  Ograve: \"\\u00D2\",\n  Oacute: \"\\u00D3\",\n  Ocirc: \"\\u00D4\",\n  Otilde: \"\\u00D5\",\n  Ouml: \"\\u00D6\",\n  times: \"\\u00D7\",\n  Oslash: \"\\u00D8\",\n  Ugrave: \"\\u00D9\",\n  Uacute: \"\\u00DA\",\n  Ucirc: \"\\u00DB\",\n  Uuml: \"\\u00DC\",\n  Yacute: \"\\u00DD\",\n  THORN: \"\\u00DE\",\n  szlig: \"\\u00DF\",\n  agrave: \"\\u00E0\",\n  aacute: \"\\u00E1\",\n  acirc: \"\\u00E2\",\n  atilde: \"\\u00E3\",\n  auml: \"\\u00E4\",\n  aring: \"\\u00E5\",\n  aelig: \"\\u00E6\",\n  ccedil: \"\\u00E7\",\n  egrave: \"\\u00E8\",\n  eacute: \"\\u00E9\",\n  ecirc: \"\\u00EA\",\n  euml: \"\\u00EB\",\n  igrave: \"\\u00EC\",\n  iacute: \"\\u00ED\",\n  icirc: \"\\u00EE\",\n  iuml: \"\\u00EF\",\n  eth: \"\\u00F0\",\n  ntilde: \"\\u00F1\",\n  ograve: \"\\u00F2\",\n  oacute: \"\\u00F3\",\n  ocirc: \"\\u00F4\",\n  otilde: \"\\u00F5\",\n  ouml: \"\\u00F6\",\n  divide: \"\\u00F7\",\n  oslash: \"\\u00F8\",\n  ugrave: \"\\u00F9\",\n  uacute: \"\\u00FA\",\n  ucirc: \"\\u00FB\",\n  uuml: \"\\u00FC\",\n  yacute: \"\\u00FD\",\n  thorn: \"\\u00FE\",\n  yuml: \"\\u00FF\",\n  OElig: \"\\u0152\",\n  oelig: \"\\u0153\",\n  Scaron: \"\\u0160\",\n  scaron: \"\\u0161\",\n  Yuml: \"\\u0178\",\n  fnof: \"\\u0192\",\n  circ: \"\\u02C6\",\n  tilde: \"\\u02DC\",\n  Alpha: \"\\u0391\",\n  Beta: \"\\u0392\",\n  Gamma: \"\\u0393\",\n  Delta: \"\\u0394\",\n  Epsilon: \"\\u0395\",\n  Zeta: \"\\u0396\",\n  Eta: \"\\u0397\",\n  Theta: \"\\u0398\",\n  Iota: \"\\u0399\",\n  Kappa: \"\\u039A\",\n  Lambda: \"\\u039B\",\n  Mu: \"\\u039C\",\n  Nu: \"\\u039D\",\n  Xi: \"\\u039E\",\n  Omicron: \"\\u039F\",\n  Pi: \"\\u03A0\",\n  Rho: \"\\u03A1\",\n  Sigma: \"\\u03A3\",\n  Tau: \"\\u03A4\",\n  Upsilon: \"\\u03A5\",\n  Phi: \"\\u03A6\",\n  Chi: \"\\u03A7\",\n  Psi: \"\\u03A8\",\n  Omega: \"\\u03A9\",\n  alpha: \"\\u03B1\",\n  beta: \"\\u03B2\",\n  gamma: \"\\u03B3\",\n  delta: \"\\u03B4\",\n  epsilon: \"\\u03B5\",\n  zeta: \"\\u03B6\",\n  eta: \"\\u03B7\",\n  theta: \"\\u03B8\",\n  iota: \"\\u03B9\",\n  kappa: \"\\u03BA\",\n  lambda: \"\\u03BB\",\n  mu: \"\\u03BC\",\n  nu: \"\\u03BD\",\n  xi: \"\\u03BE\",\n  omicron: \"\\u03BF\",\n  pi: \"\\u03C0\",\n  rho: \"\\u03C1\",\n  sigmaf: \"\\u03C2\",\n  sigma: \"\\u03C3\",\n  tau: \"\\u03C4\",\n  upsilon: \"\\u03C5\",\n  phi: \"\\u03C6\",\n  chi: \"\\u03C7\",\n  psi: \"\\u03C8\",\n  omega: \"\\u03C9\",\n  thetasym: \"\\u03D1\",\n  upsih: \"\\u03D2\",\n  piv: \"\\u03D6\",\n  ensp: \"\\u2002\",\n  emsp: \"\\u2003\",\n  thinsp: \"\\u2009\",\n  zwnj: \"\\u200C\",\n  zwj: \"\\u200D\",\n  lrm: \"\\u200E\",\n  rlm: \"\\u200F\",\n  ndash: \"\\u2013\",\n  mdash: \"\\u2014\",\n  lsquo: \"\\u2018\",\n  rsquo: \"\\u2019\",\n  sbquo: \"\\u201A\",\n  ldquo: \"\\u201C\",\n  rdquo: \"\\u201D\",\n  bdquo: \"\\u201E\",\n  dagger: \"\\u2020\",\n  Dagger: \"\\u2021\",\n  bull: \"\\u2022\",\n  hellip: \"\\u2026\",\n  permil: \"\\u2030\",\n  prime: \"\\u2032\",\n  Prime: \"\\u2033\",\n  lsaquo: \"\\u2039\",\n  rsaquo: \"\\u203A\",\n  oline: \"\\u203E\",\n  frasl: \"\\u2044\",\n  euro: \"\\u20AC\",\n  image: \"\\u2111\",\n  weierp: \"\\u2118\",\n  real: \"\\u211C\",\n  trade: \"\\u2122\",\n  alefsym: \"\\u2135\",\n  larr: \"\\u2190\",\n  uarr: \"\\u2191\",\n  rarr: \"\\u2192\",\n  darr: \"\\u2193\",\n  harr: \"\\u2194\",\n  crarr: \"\\u21B5\",\n  lArr: \"\\u21D0\",\n  uArr: \"\\u21D1\",\n  rArr: \"\\u21D2\",\n  dArr: \"\\u21D3\",\n  hArr: \"\\u21D4\",\n  forall: \"\\u2200\",\n  part: \"\\u2202\",\n  exist: \"\\u2203\",\n  empty: \"\\u2205\",\n  nabla: \"\\u2207\",\n  isin: \"\\u2208\",\n  notin: \"\\u2209\",\n  ni: \"\\u220B\",\n  prod: \"\\u220F\",\n  sum: \"\\u2211\",\n  minus: \"\\u2212\",\n  lowast: \"\\u2217\",\n  radic: \"\\u221A\",\n  prop: \"\\u221D\",\n  infin: \"\\u221E\",\n  ang: \"\\u2220\",\n  and: \"\\u2227\",\n  or: \"\\u2228\",\n  cap: \"\\u2229\",\n  cup: \"\\u222A\",\n  int: \"\\u222B\",\n  there4: \"\\u2234\",\n  sim: \"\\u223C\",\n  cong: \"\\u2245\",\n  asymp: \"\\u2248\",\n  ne: \"\\u2260\",\n  equiv: \"\\u2261\",\n  le: \"\\u2264\",\n  ge: \"\\u2265\",\n  sub: \"\\u2282\",\n  sup: \"\\u2283\",\n  nsub: \"\\u2284\",\n  sube: \"\\u2286\",\n  supe: \"\\u2287\",\n  oplus: \"\\u2295\",\n  otimes: \"\\u2297\",\n  perp: \"\\u22A5\",\n  sdot: \"\\u22C5\",\n  lceil: \"\\u2308\",\n  rceil: \"\\u2309\",\n  lfloor: \"\\u230A\",\n  rfloor: \"\\u230B\",\n  lang: \"\\u2329\",\n  rang: \"\\u232A\",\n  loz: \"\\u25CA\",\n  spades: \"\\u2660\",\n  clubs: \"\\u2663\",\n  hearts: \"\\u2665\",\n  diams: \"\\u2666\"\n};\nconst lineBreak = /\\r\\n|[\\r\\n\\u2028\\u2029]/;\nconst lineBreakG = new RegExp(lineBreak.source, \"g\");\nfunction isNewLine(code) {\n  switch (code) {\n    case 10:\n    case 13:\n    case 8232:\n    case 8233:\n      return true;\n    default:\n      return false;\n  }\n}\nfunction hasNewLine(input, start, end) {\n  for (let i = start; i < end; i++) {\n    if (isNewLine(input.charCodeAt(i))) {\n      return true;\n    }\n  }\n  return false;\n}\nconst skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\nconst skipWhiteSpaceInLine = /(?:[^\\S\\n\\r\\u2028\\u2029]|\\/\\/.*|\\/\\*.*?\\*\\/)*/g;\nfunction isWhitespace(code) {\n  switch (code) {\n    case 0x0009:\n    case 0x000b:\n    case 0x000c:\n    case 32:\n    case 160:\n    case 5760:\n    case 0x2000:\n    case 0x2001:\n    case 0x2002:\n    case 0x2003:\n    case 0x2004:\n    case 0x2005:\n    case 0x2006:\n    case 0x2007:\n    case 0x2008:\n    case 0x2009:\n    case 0x200a:\n    case 0x202f:\n    case 0x205f:\n    case 0x3000:\n    case 0xfeff:\n      return true;\n    default:\n      return false;\n  }\n}\nconst JsxErrors = ParseErrorEnum`jsx`({\n  AttributeIsEmpty: \"JSX attributes must only be assigned a non-empty expression.\",\n  MissingClosingTagElement: ({\n    openingTagName\n  }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,\n  MissingClosingTagFragment: \"Expected corresponding JSX closing tag for <>.\",\n  UnexpectedSequenceExpression: \"Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?\",\n  UnexpectedToken: ({\n    unexpected,\n    HTMLEntity\n  }) => `Unexpected token \\`${unexpected}\\`. Did you mean \\`${HTMLEntity}\\` or \\`{'${unexpected}'}\\`?`,\n  UnsupportedJsxValue: \"JSX value should be either an expression or a quoted JSX text.\",\n  UnterminatedJsxContent: \"Unterminated JSX contents.\",\n  UnwrappedAdjacentJSXElements: \"Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?\"\n});\nfunction isFragment(object) {\n  return object ? object.type === \"JSXOpeningFragment\" || object.type === \"JSXClosingFragment\" : false;\n}\nfunction getQualifiedJSXName(object) {\n  if (object.type === \"JSXIdentifier\") {\n    return object.name;\n  }\n  if (object.type === \"JSXNamespacedName\") {\n    return object.namespace.name + \":\" + object.name.name;\n  }\n  if (object.type === \"JSXMemberExpression\") {\n    return getQualifiedJSXName(object.object) + \".\" + getQualifiedJSXName(object.property);\n  }\n  throw new Error(\"Node had unexpected type: \" + object.type);\n}\nvar jsx = superClass => class JSXParserMixin extends superClass {\n  jsxReadToken() {\n    let out = \"\";\n    let chunkStart = this.state.pos;\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(JsxErrors.UnterminatedJsxContent, this.state.startLoc);\n      }\n      const ch = this.input.charCodeAt(this.state.pos);\n      switch (ch) {\n        case 60:\n        case 123:\n          if (this.state.pos === this.state.start) {\n            if (ch === 60 && this.state.canStartJSXElement) {\n              ++this.state.pos;\n              this.finishToken(143);\n            } else {\n              super.getTokenFromCode(ch);\n            }\n            return;\n          }\n          out += this.input.slice(chunkStart, this.state.pos);\n          this.finishToken(142, out);\n          return;\n        case 38:\n          out += this.input.slice(chunkStart, this.state.pos);\n          out += this.jsxReadEntity();\n          chunkStart = this.state.pos;\n          break;\n        case 62:\n        case 125:\n        default:\n          if (isNewLine(ch)) {\n            out += this.input.slice(chunkStart, this.state.pos);\n            out += this.jsxReadNewLine(true);\n            chunkStart = this.state.pos;\n          } else {\n            ++this.state.pos;\n          }\n      }\n    }\n  }\n  jsxReadNewLine(normalizeCRLF) {\n    const ch = this.input.charCodeAt(this.state.pos);\n    let out;\n    ++this.state.pos;\n    if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {\n      ++this.state.pos;\n      out = normalizeCRLF ? \"\\n\" : \"\\r\\n\";\n    } else {\n      out = String.fromCharCode(ch);\n    }\n    ++this.state.curLine;\n    this.state.lineStart = this.state.pos;\n    return out;\n  }\n  jsxReadString(quote) {\n    let out = \"\";\n    let chunkStart = ++this.state.pos;\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(Errors.UnterminatedString, this.state.startLoc);\n      }\n      const ch = this.input.charCodeAt(this.state.pos);\n      if (ch === quote) break;\n      if (ch === 38) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadEntity();\n        chunkStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadNewLine(false);\n        chunkStart = this.state.pos;\n      } else {\n        ++this.state.pos;\n      }\n    }\n    out += this.input.slice(chunkStart, this.state.pos++);\n    this.finishToken(134, out);\n  }\n  jsxReadEntity() {\n    const startPos = ++this.state.pos;\n    if (this.codePointAtPos(this.state.pos) === 35) {\n      ++this.state.pos;\n      let radix = 10;\n      if (this.codePointAtPos(this.state.pos) === 120) {\n        radix = 16;\n        ++this.state.pos;\n      }\n      const codePoint = this.readInt(radix, undefined, false, \"bail\");\n      if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {\n        ++this.state.pos;\n        return String.fromCodePoint(codePoint);\n      }\n    } else {\n      let count = 0;\n      let semi = false;\n      while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) === 59)) {\n        ++this.state.pos;\n      }\n      if (semi) {\n        const desc = this.input.slice(startPos, this.state.pos);\n        const entity = entities[desc];\n        ++this.state.pos;\n        if (entity) {\n          return entity;\n        }\n      }\n    }\n    this.state.pos = startPos;\n    return \"&\";\n  }\n  jsxReadWord() {\n    let ch;\n    const start = this.state.pos;\n    do {\n      ch = this.input.charCodeAt(++this.state.pos);\n    } while (isIdentifierChar(ch) || ch === 45);\n    this.finishToken(141, this.input.slice(start, this.state.pos));\n  }\n  jsxParseIdentifier() {\n    const node = this.startNode();\n    if (this.match(141)) {\n      node.name = this.state.value;\n    } else if (tokenIsKeyword(this.state.type)) {\n      node.name = tokenLabelName(this.state.type);\n    } else {\n      this.unexpected();\n    }\n    this.next();\n    return this.finishNode(node, \"JSXIdentifier\");\n  }\n  jsxParseNamespacedName() {\n    const startLoc = this.state.startLoc;\n    const name = this.jsxParseIdentifier();\n    if (!this.eat(14)) return name;\n    const node = this.startNodeAt(startLoc);\n    node.namespace = name;\n    node.name = this.jsxParseIdentifier();\n    return this.finishNode(node, \"JSXNamespacedName\");\n  }\n  jsxParseElementName() {\n    const startLoc = this.state.startLoc;\n    let node = this.jsxParseNamespacedName();\n    if (node.type === \"JSXNamespacedName\") {\n      return node;\n    }\n    while (this.eat(16)) {\n      const newNode = this.startNodeAt(startLoc);\n      newNode.object = node;\n      newNode.property = this.jsxParseIdentifier();\n      node = this.finishNode(newNode, \"JSXMemberExpression\");\n    }\n    return node;\n  }\n  jsxParseAttributeValue() {\n    let node;\n    switch (this.state.type) {\n      case 5:\n        node = this.startNode();\n        this.setContext(types.brace);\n        this.next();\n        node = this.jsxParseExpressionContainer(node, types.j_oTag);\n        if (node.expression.type === \"JSXEmptyExpression\") {\n          this.raise(JsxErrors.AttributeIsEmpty, node);\n        }\n        return node;\n      case 143:\n      case 134:\n        return this.parseExprAtom();\n      default:\n        throw this.raise(JsxErrors.UnsupportedJsxValue, this.state.startLoc);\n    }\n  }\n  jsxParseEmptyExpression() {\n    const node = this.startNodeAt(this.state.lastTokEndLoc);\n    return this.finishNodeAt(node, \"JSXEmptyExpression\", this.state.startLoc);\n  }\n  jsxParseSpreadChild(node) {\n    this.next();\n    node.expression = this.parseExpression();\n    this.setContext(types.j_expr);\n    this.state.canStartJSXElement = true;\n    this.expect(8);\n    return this.finishNode(node, \"JSXSpreadChild\");\n  }\n  jsxParseExpressionContainer(node, previousContext) {\n    if (this.match(8)) {\n      node.expression = this.jsxParseEmptyExpression();\n    } else {\n      const expression = this.parseExpression();\n      node.expression = expression;\n    }\n    this.setContext(previousContext);\n    this.state.canStartJSXElement = true;\n    this.expect(8);\n    return this.finishNode(node, \"JSXExpressionContainer\");\n  }\n  jsxParseAttribute() {\n    const node = this.startNode();\n    if (this.match(5)) {\n      this.setContext(types.brace);\n      this.next();\n      this.expect(21);\n      node.argument = this.parseMaybeAssignAllowIn();\n      this.setContext(types.j_oTag);\n      this.state.canStartJSXElement = true;\n      this.expect(8);\n      return this.finishNode(node, \"JSXSpreadAttribute\");\n    }\n    node.name = this.jsxParseNamespacedName();\n    node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;\n    return this.finishNode(node, \"JSXAttribute\");\n  }\n  jsxParseOpeningElementAt(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    if (this.eat(144)) {\n      return this.finishNode(node, \"JSXOpeningFragment\");\n    }\n    node.name = this.jsxParseElementName();\n    return this.jsxParseOpeningElementAfterName(node);\n  }\n  jsxParseOpeningElementAfterName(node) {\n    const attributes = [];\n    while (!this.match(56) && !this.match(144)) {\n      attributes.push(this.jsxParseAttribute());\n    }\n    node.attributes = attributes;\n    node.selfClosing = this.eat(56);\n    this.expect(144);\n    return this.finishNode(node, \"JSXOpeningElement\");\n  }\n  jsxParseClosingElementAt(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    if (this.eat(144)) {\n      return this.finishNode(node, \"JSXClosingFragment\");\n    }\n    node.name = this.jsxParseElementName();\n    this.expect(144);\n    return this.finishNode(node, \"JSXClosingElement\");\n  }\n  jsxParseElementAt(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    const children = [];\n    const openingElement = this.jsxParseOpeningElementAt(startLoc);\n    let closingElement = null;\n    if (!openingElement.selfClosing) {\n      contents: for (;;) {\n        switch (this.state.type) {\n          case 143:\n            startLoc = this.state.startLoc;\n            this.next();\n            if (this.eat(56)) {\n              closingElement = this.jsxParseClosingElementAt(startLoc);\n              break contents;\n            }\n            children.push(this.jsxParseElementAt(startLoc));\n            break;\n          case 142:\n            children.push(this.parseLiteral(this.state.value, \"JSXText\"));\n            break;\n          case 5:\n            {\n              const node = this.startNode();\n              this.setContext(types.brace);\n              this.next();\n              if (this.match(21)) {\n                children.push(this.jsxParseSpreadChild(node));\n              } else {\n                children.push(this.jsxParseExpressionContainer(node, types.j_expr));\n              }\n              break;\n            }\n          default:\n            this.unexpected();\n        }\n      }\n      if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {\n        this.raise(JsxErrors.MissingClosingTagFragment, closingElement);\n      } else if (!isFragment(openingElement) && isFragment(closingElement)) {\n        this.raise(JsxErrors.MissingClosingTagElement, closingElement, {\n          openingTagName: getQualifiedJSXName(openingElement.name)\n        });\n      } else if (!isFragment(openingElement) && !isFragment(closingElement)) {\n        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n          this.raise(JsxErrors.MissingClosingTagElement, closingElement, {\n            openingTagName: getQualifiedJSXName(openingElement.name)\n          });\n        }\n      }\n    }\n    if (isFragment(openingElement)) {\n      node.openingFragment = openingElement;\n      node.closingFragment = closingElement;\n    } else {\n      node.openingElement = openingElement;\n      node.closingElement = closingElement;\n    }\n    node.children = children;\n    if (this.match(47)) {\n      throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, this.state.startLoc);\n    }\n    return isFragment(openingElement) ? this.finishNode(node, \"JSXFragment\") : this.finishNode(node, \"JSXElement\");\n  }\n  jsxParseElement() {\n    const startLoc = this.state.startLoc;\n    this.next();\n    return this.jsxParseElementAt(startLoc);\n  }\n  setContext(newContext) {\n    const {\n      context\n    } = this.state;\n    context[context.length - 1] = newContext;\n  }\n  parseExprAtom(refExpressionErrors) {\n    if (this.match(143)) {\n      return this.jsxParseElement();\n    } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {\n      this.replaceToken(143);\n      return this.jsxParseElement();\n    } else {\n      return super.parseExprAtom(refExpressionErrors);\n    }\n  }\n  skipSpace() {\n    const curContext = this.curContext();\n    if (!curContext.preserveSpace) super.skipSpace();\n  }\n  getTokenFromCode(code) {\n    const context = this.curContext();\n    if (context === types.j_expr) {\n      this.jsxReadToken();\n      return;\n    }\n    if (context === types.j_oTag || context === types.j_cTag) {\n      if (isIdentifierStart(code)) {\n        this.jsxReadWord();\n        return;\n      }\n      if (code === 62) {\n        ++this.state.pos;\n        this.finishToken(144);\n        return;\n      }\n      if ((code === 34 || code === 39) && context === types.j_oTag) {\n        this.jsxReadString(code);\n        return;\n      }\n    }\n    if (code === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {\n      ++this.state.pos;\n      this.finishToken(143);\n      return;\n    }\n    super.getTokenFromCode(code);\n  }\n  updateContext(prevType) {\n    const {\n      context,\n      type\n    } = this.state;\n    if (type === 56 && prevType === 143) {\n      context.splice(-2, 2, types.j_cTag);\n      this.state.canStartJSXElement = false;\n    } else if (type === 143) {\n      context.push(types.j_oTag);\n    } else if (type === 144) {\n      const out = context[context.length - 1];\n      if (out === types.j_oTag && prevType === 56 || out === types.j_cTag) {\n        context.pop();\n        this.state.canStartJSXElement = context[context.length - 1] === types.j_expr;\n      } else {\n        this.setContext(types.j_expr);\n        this.state.canStartJSXElement = true;\n      }\n    } else {\n      this.state.canStartJSXElement = tokenComesBeforeExpression(type);\n    }\n  }\n};\nclass TypeScriptScope extends Scope {\n  constructor(...args) {\n    super(...args);\n    this.tsNames = new Map();\n  }\n}\nclass TypeScriptScopeHandler extends ScopeHandler {\n  constructor(...args) {\n    super(...args);\n    this.importsStack = [];\n  }\n  createScope(flags) {\n    this.importsStack.push(new Set());\n    return new TypeScriptScope(flags);\n  }\n  enter(flags) {\n    if (flags === 1024) {\n      this.importsStack.push(new Set());\n    }\n    super.enter(flags);\n  }\n  exit() {\n    const flags = super.exit();\n    if (flags === 1024) {\n      this.importsStack.pop();\n    }\n    return flags;\n  }\n  hasImport(name, allowShadow) {\n    const len = this.importsStack.length;\n    if (this.importsStack[len - 1].has(name)) {\n      return true;\n    }\n    if (!allowShadow && len > 1) {\n      for (let i = 0; i < len - 1; i++) {\n        if (this.importsStack[i].has(name)) return true;\n      }\n    }\n    return false;\n  }\n  declareName(name, bindingType, loc) {\n    if (bindingType & 4096) {\n      if (this.hasImport(name, true)) {\n        this.parser.raise(Errors.VarRedeclaration, loc, {\n          identifierName: name\n        });\n      }\n      this.importsStack[this.importsStack.length - 1].add(name);\n      return;\n    }\n    const scope = this.currentScope();\n    let type = scope.tsNames.get(name) || 0;\n    if (bindingType & 1024) {\n      this.maybeExportDefined(scope, name);\n      scope.tsNames.set(name, type | 16);\n      return;\n    }\n    super.declareName(name, bindingType, loc);\n    if (bindingType & 2) {\n      if (!(bindingType & 1)) {\n        this.checkRedeclarationInScope(scope, name, bindingType, loc);\n        this.maybeExportDefined(scope, name);\n      }\n      type = type | 1;\n    }\n    if (bindingType & 256) {\n      type = type | 2;\n    }\n    if (bindingType & 512) {\n      type = type | 4;\n    }\n    if (bindingType & 128) {\n      type = type | 8;\n    }\n    if (type) scope.tsNames.set(name, type);\n  }\n  isRedeclaredInScope(scope, name, bindingType) {\n    const type = scope.tsNames.get(name);\n    if ((type & 2) > 0) {\n      if (bindingType & 256) {\n        const isConst = !!(bindingType & 512);\n        const wasConst = (type & 4) > 0;\n        return isConst !== wasConst;\n      }\n      return true;\n    }\n    if (bindingType & 128 && (type & 8) > 0) {\n      if (scope.names.get(name) & 2) {\n        return !!(bindingType & 1);\n      } else {\n        return false;\n      }\n    }\n    if (bindingType & 2 && (type & 1) > 0) {\n      return true;\n    }\n    return super.isRedeclaredInScope(scope, name, bindingType);\n  }\n  checkLocalExport(id) {\n    const {\n      name\n    } = id;\n    if (this.hasImport(name)) return;\n    const len = this.scopeStack.length;\n    for (let i = len - 1; i >= 0; i--) {\n      const scope = this.scopeStack[i];\n      const type = scope.tsNames.get(name);\n      if ((type & 1) > 0 || (type & 16) > 0) {\n        return;\n      }\n    }\n    super.checkLocalExport(id);\n  }\n}\nclass ProductionParameterHandler {\n  constructor() {\n    this.stacks = [];\n  }\n  enter(flags) {\n    this.stacks.push(flags);\n  }\n  exit() {\n    this.stacks.pop();\n  }\n  currentFlags() {\n    return this.stacks[this.stacks.length - 1];\n  }\n  get hasAwait() {\n    return (this.currentFlags() & 2) > 0;\n  }\n  get hasYield() {\n    return (this.currentFlags() & 1) > 0;\n  }\n  get hasReturn() {\n    return (this.currentFlags() & 4) > 0;\n  }\n  get hasIn() {\n    return (this.currentFlags() & 8) > 0;\n  }\n}\nfunction functionFlags(isAsync, isGenerator) {\n  return (isAsync ? 2 : 0) | (isGenerator ? 1 : 0);\n}\nclass BaseParser {\n  constructor() {\n    this.sawUnambiguousESM = false;\n    this.ambiguousScriptDifferentAst = false;\n  }\n  sourceToOffsetPos(sourcePos) {\n    return sourcePos + this.startIndex;\n  }\n  offsetToSourcePos(offsetPos) {\n    return offsetPos - this.startIndex;\n  }\n  hasPlugin(pluginConfig) {\n    if (typeof pluginConfig === \"string\") {\n      return this.plugins.has(pluginConfig);\n    } else {\n      const [pluginName, pluginOptions] = pluginConfig;\n      if (!this.hasPlugin(pluginName)) {\n        return false;\n      }\n      const actualOptions = this.plugins.get(pluginName);\n      for (const key of Object.keys(pluginOptions)) {\n        if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n  getPluginOption(plugin, name) {\n    var _this$plugins$get;\n    return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];\n  }\n}\nfunction setTrailingComments(node, comments) {\n  if (node.trailingComments === undefined) {\n    node.trailingComments = comments;\n  } else {\n    node.trailingComments.unshift(...comments);\n  }\n}\nfunction setLeadingComments(node, comments) {\n  if (node.leadingComments === undefined) {\n    node.leadingComments = comments;\n  } else {\n    node.leadingComments.unshift(...comments);\n  }\n}\nfunction setInnerComments(node, comments) {\n  if (node.innerComments === undefined) {\n    node.innerComments = comments;\n  } else {\n    node.innerComments.unshift(...comments);\n  }\n}\nfunction adjustInnerComments(node, elements, commentWS) {\n  let lastElement = null;\n  let i = elements.length;\n  while (lastElement === null && i > 0) {\n    lastElement = elements[--i];\n  }\n  if (lastElement === null || lastElement.start > commentWS.start) {\n    setInnerComments(node, commentWS.comments);\n  } else {\n    setTrailingComments(lastElement, commentWS.comments);\n  }\n}\nclass CommentsParser extends BaseParser {\n  addComment(comment) {\n    if (this.filename) comment.loc.filename = this.filename;\n    const {\n      commentsLen\n    } = this.state;\n    if (this.comments.length !== commentsLen) {\n      this.comments.length = commentsLen;\n    }\n    this.comments.push(comment);\n    this.state.commentsLen++;\n  }\n  processComment(node) {\n    const {\n      commentStack\n    } = this.state;\n    const commentStackLength = commentStack.length;\n    if (commentStackLength === 0) return;\n    let i = commentStackLength - 1;\n    const lastCommentWS = commentStack[i];\n    if (lastCommentWS.start === node.end) {\n      lastCommentWS.leadingNode = node;\n      i--;\n    }\n    const {\n      start: nodeStart\n    } = node;\n    for (; i >= 0; i--) {\n      const commentWS = commentStack[i];\n      const commentEnd = commentWS.end;\n      if (commentEnd > nodeStart) {\n        commentWS.containingNode = node;\n        this.finalizeComment(commentWS);\n        commentStack.splice(i, 1);\n      } else {\n        if (commentEnd === nodeStart) {\n          commentWS.trailingNode = node;\n        }\n        break;\n      }\n    }\n  }\n  finalizeComment(commentWS) {\n    var _node$options;\n    const {\n      comments\n    } = commentWS;\n    if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {\n      if (commentWS.leadingNode !== null) {\n        setTrailingComments(commentWS.leadingNode, comments);\n      }\n      if (commentWS.trailingNode !== null) {\n        setLeadingComments(commentWS.trailingNode, comments);\n      }\n    } else {\n      const {\n        containingNode: node,\n        start: commentStart\n      } = commentWS;\n      if (this.input.charCodeAt(this.offsetToSourcePos(commentStart) - 1) === 44) {\n        switch (node.type) {\n          case \"ObjectExpression\":\n          case \"ObjectPattern\":\n          case \"RecordExpression\":\n            adjustInnerComments(node, node.properties, commentWS);\n            break;\n          case \"CallExpression\":\n          case \"OptionalCallExpression\":\n            adjustInnerComments(node, node.arguments, commentWS);\n            break;\n          case \"ImportExpression\":\n            adjustInnerComments(node, [node.source, (_node$options = node.options) != null ? _node$options : null], commentWS);\n            break;\n          case \"FunctionDeclaration\":\n          case \"FunctionExpression\":\n          case \"ArrowFunctionExpression\":\n          case \"ObjectMethod\":\n          case \"ClassMethod\":\n          case \"ClassPrivateMethod\":\n            adjustInnerComments(node, node.params, commentWS);\n            break;\n          case \"ArrayExpression\":\n          case \"ArrayPattern\":\n          case \"TupleExpression\":\n            adjustInnerComments(node, node.elements, commentWS);\n            break;\n          case \"ExportNamedDeclaration\":\n          case \"ImportDeclaration\":\n            adjustInnerComments(node, node.specifiers, commentWS);\n            break;\n          case \"TSEnumDeclaration\":\n            {\n              adjustInnerComments(node, node.members, commentWS);\n            }\n            break;\n          case \"TSEnumBody\":\n            adjustInnerComments(node, node.members, commentWS);\n            break;\n          default:\n            {\n              setInnerComments(node, comments);\n            }\n        }\n      } else {\n        setInnerComments(node, comments);\n      }\n    }\n  }\n  finalizeRemainingComments() {\n    const {\n      commentStack\n    } = this.state;\n    for (let i = commentStack.length - 1; i >= 0; i--) {\n      this.finalizeComment(commentStack[i]);\n    }\n    this.state.commentStack = [];\n  }\n  resetPreviousNodeTrailingComments(node) {\n    const {\n      commentStack\n    } = this.state;\n    const {\n      length\n    } = commentStack;\n    if (length === 0) return;\n    const commentWS = commentStack[length - 1];\n    if (commentWS.leadingNode === node) {\n      commentWS.leadingNode = null;\n    }\n  }\n  takeSurroundingComments(node, start, end) {\n    const {\n      commentStack\n    } = this.state;\n    const commentStackLength = commentStack.length;\n    if (commentStackLength === 0) return;\n    let i = commentStackLength - 1;\n    for (; i >= 0; i--) {\n      const commentWS = commentStack[i];\n      const commentEnd = commentWS.end;\n      const commentStart = commentWS.start;\n      if (commentStart === end) {\n        commentWS.leadingNode = node;\n      } else if (commentEnd === start) {\n        commentWS.trailingNode = node;\n      } else if (commentEnd < start) {\n        break;\n      }\n    }\n  }\n}\nclass State {\n  constructor() {\n    this.flags = 1024;\n    this.startIndex = void 0;\n    this.curLine = void 0;\n    this.lineStart = void 0;\n    this.startLoc = void 0;\n    this.endLoc = void 0;\n    this.errors = [];\n    this.potentialArrowAt = -1;\n    this.noArrowAt = [];\n    this.noArrowParamsConversionAt = [];\n    this.topicContext = {\n      maxNumOfResolvableTopics: 0,\n      maxTopicIndex: null\n    };\n    this.labels = [];\n    this.commentsLen = 0;\n    this.commentStack = [];\n    this.pos = 0;\n    this.type = 140;\n    this.value = null;\n    this.start = 0;\n    this.end = 0;\n    this.lastTokEndLoc = null;\n    this.lastTokStartLoc = null;\n    this.context = [types.brace];\n    this.firstInvalidTemplateEscapePos = null;\n    this.strictErrors = new Map();\n    this.tokensLength = 0;\n  }\n  get strict() {\n    return (this.flags & 1) > 0;\n  }\n  set strict(v) {\n    if (v) this.flags |= 1;else this.flags &= -2;\n  }\n  init({\n    strictMode,\n    sourceType,\n    startIndex,\n    startLine,\n    startColumn\n  }) {\n    this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === \"module\";\n    this.startIndex = startIndex;\n    this.curLine = startLine;\n    this.lineStart = -startColumn;\n    this.startLoc = this.endLoc = new Position(startLine, startColumn, startIndex);\n  }\n  get maybeInArrowParameters() {\n    return (this.flags & 2) > 0;\n  }\n  set maybeInArrowParameters(v) {\n    if (v) this.flags |= 2;else this.flags &= -3;\n  }\n  get inType() {\n    return (this.flags & 4) > 0;\n  }\n  set inType(v) {\n    if (v) this.flags |= 4;else this.flags &= -5;\n  }\n  get noAnonFunctionType() {\n    return (this.flags & 8) > 0;\n  }\n  set noAnonFunctionType(v) {\n    if (v) this.flags |= 8;else this.flags &= -9;\n  }\n  get hasFlowComment() {\n    return (this.flags & 16) > 0;\n  }\n  set hasFlowComment(v) {\n    if (v) this.flags |= 16;else this.flags &= -17;\n  }\n  get isAmbientContext() {\n    return (this.flags & 32) > 0;\n  }\n  set isAmbientContext(v) {\n    if (v) this.flags |= 32;else this.flags &= -33;\n  }\n  get inAbstractClass() {\n    return (this.flags & 64) > 0;\n  }\n  set inAbstractClass(v) {\n    if (v) this.flags |= 64;else this.flags &= -65;\n  }\n  get inDisallowConditionalTypesContext() {\n    return (this.flags & 128) > 0;\n  }\n  set inDisallowConditionalTypesContext(v) {\n    if (v) this.flags |= 128;else this.flags &= -129;\n  }\n  get soloAwait() {\n    return (this.flags & 256) > 0;\n  }\n  set soloAwait(v) {\n    if (v) this.flags |= 256;else this.flags &= -257;\n  }\n  get inFSharpPipelineDirectBody() {\n    return (this.flags & 512) > 0;\n  }\n  set inFSharpPipelineDirectBody(v) {\n    if (v) this.flags |= 512;else this.flags &= -513;\n  }\n  get canStartJSXElement() {\n    return (this.flags & 1024) > 0;\n  }\n  set canStartJSXElement(v) {\n    if (v) this.flags |= 1024;else this.flags &= -1025;\n  }\n  get containsEsc() {\n    return (this.flags & 2048) > 0;\n  }\n  set containsEsc(v) {\n    if (v) this.flags |= 2048;else this.flags &= -2049;\n  }\n  get hasTopLevelAwait() {\n    return (this.flags & 4096) > 0;\n  }\n  set hasTopLevelAwait(v) {\n    if (v) this.flags |= 4096;else this.flags &= -4097;\n  }\n  curPosition() {\n    return new Position(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);\n  }\n  clone() {\n    const state = new State();\n    state.flags = this.flags;\n    state.startIndex = this.startIndex;\n    state.curLine = this.curLine;\n    state.lineStart = this.lineStart;\n    state.startLoc = this.startLoc;\n    state.endLoc = this.endLoc;\n    state.errors = this.errors.slice();\n    state.potentialArrowAt = this.potentialArrowAt;\n    state.noArrowAt = this.noArrowAt.slice();\n    state.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice();\n    state.topicContext = this.topicContext;\n    state.labels = this.labels.slice();\n    state.commentsLen = this.commentsLen;\n    state.commentStack = this.commentStack.slice();\n    state.pos = this.pos;\n    state.type = this.type;\n    state.value = this.value;\n    state.start = this.start;\n    state.end = this.end;\n    state.lastTokEndLoc = this.lastTokEndLoc;\n    state.lastTokStartLoc = this.lastTokStartLoc;\n    state.context = this.context.slice();\n    state.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos;\n    state.strictErrors = this.strictErrors;\n    state.tokensLength = this.tokensLength;\n    return state;\n  }\n}\nvar _isDigit = function isDigit(code) {\n  return code >= 48 && code <= 57;\n};\nconst forbiddenNumericSeparatorSiblings = {\n  decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),\n  hex: new Set([46, 88, 95, 120])\n};\nconst isAllowedNumericSeparatorSibling = {\n  bin: ch => ch === 48 || ch === 49,\n  oct: ch => ch >= 48 && ch <= 55,\n  dec: ch => ch >= 48 && ch <= 57,\n  hex: ch => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102\n};\nfunction readStringContents(type, input, pos, lineStart, curLine, errors) {\n  const initialPos = pos;\n  const initialLineStart = lineStart;\n  const initialCurLine = curLine;\n  let out = \"\";\n  let firstInvalidLoc = null;\n  let chunkStart = pos;\n  const {\n    length\n  } = input;\n  for (;;) {\n    if (pos >= length) {\n      errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n    const ch = input.charCodeAt(pos);\n    if (isStringEnd(type, ch, input, pos)) {\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n    if (ch === 92) {\n      out += input.slice(chunkStart, pos);\n      const res = readEscapedChar(input, pos, lineStart, curLine, type === \"template\", errors);\n      if (res.ch === null && !firstInvalidLoc) {\n        firstInvalidLoc = {\n          pos,\n          lineStart,\n          curLine\n        };\n      } else {\n        out += res.ch;\n      }\n      ({\n        pos,\n        lineStart,\n        curLine\n      } = res);\n      chunkStart = pos;\n    } else if (ch === 8232 || ch === 8233) {\n      ++pos;\n      ++curLine;\n      lineStart = pos;\n    } else if (ch === 10 || ch === 13) {\n      if (type === \"template\") {\n        out += input.slice(chunkStart, pos) + \"\\n\";\n        ++pos;\n        if (ch === 13 && input.charCodeAt(pos) === 10) {\n          ++pos;\n        }\n        ++curLine;\n        chunkStart = lineStart = pos;\n      } else {\n        errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      }\n    } else {\n      ++pos;\n    }\n  }\n  return {\n    pos,\n    str: out,\n    firstInvalidLoc,\n    lineStart,\n    curLine,\n    containsInvalid: !!firstInvalidLoc\n  };\n}\nfunction isStringEnd(type, ch, input, pos) {\n  if (type === \"template\") {\n    return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;\n  }\n  return ch === (type === \"double\" ? 34 : 39);\n}\nfunction readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {\n  const throwOnInvalid = !inTemplate;\n  pos++;\n  const res = ch => ({\n    pos,\n    ch,\n    lineStart,\n    curLine\n  });\n  const ch = input.charCodeAt(pos++);\n  switch (ch) {\n    case 110:\n      return res(\"\\n\");\n    case 114:\n      return res(\"\\r\");\n    case 120:\n      {\n        let code;\n        ({\n          code,\n          pos\n        } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));\n        return res(code === null ? null : String.fromCharCode(code));\n      }\n    case 117:\n      {\n        let code;\n        ({\n          code,\n          pos\n        } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));\n        return res(code === null ? null : String.fromCodePoint(code));\n      }\n    case 116:\n      return res(\"\\t\");\n    case 98:\n      return res(\"\\b\");\n    case 118:\n      return res(\"\\u000b\");\n    case 102:\n      return res(\"\\f\");\n    case 13:\n      if (input.charCodeAt(pos) === 10) {\n        ++pos;\n      }\n    case 10:\n      lineStart = pos;\n      ++curLine;\n    case 8232:\n    case 8233:\n      return res(\"\");\n    case 56:\n    case 57:\n      if (inTemplate) {\n        return res(null);\n      } else {\n        errors.strictNumericEscape(pos - 1, lineStart, curLine);\n      }\n    default:\n      if (ch >= 48 && ch <= 55) {\n        const startPos = pos - 1;\n        const match = /^[0-7]+/.exec(input.slice(startPos, pos + 2));\n        let octalStr = match[0];\n        let octal = parseInt(octalStr, 8);\n        if (octal > 255) {\n          octalStr = octalStr.slice(0, -1);\n          octal = parseInt(octalStr, 8);\n        }\n        pos += octalStr.length - 1;\n        const next = input.charCodeAt(pos);\n        if (octalStr !== \"0\" || next === 56 || next === 57) {\n          if (inTemplate) {\n            return res(null);\n          } else {\n            errors.strictNumericEscape(startPos, lineStart, curLine);\n          }\n        }\n        return res(String.fromCharCode(octal));\n      }\n      return res(String.fromCharCode(ch));\n  }\n}\nfunction readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {\n  const initialPos = pos;\n  let n;\n  ({\n    n,\n    pos\n  } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));\n  if (n === null) {\n    if (throwOnInvalid) {\n      errors.invalidEscapeSequence(initialPos, lineStart, curLine);\n    } else {\n      pos = initialPos - 1;\n    }\n  }\n  return {\n    code: n,\n    pos\n  };\n}\nfunction readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {\n  const start = pos;\n  const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;\n  const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;\n  let invalid = false;\n  let total = 0;\n  for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    const code = input.charCodeAt(pos);\n    let val;\n    if (code === 95 && allowNumSeparator !== \"bail\") {\n      const prev = input.charCodeAt(pos - 1);\n      const next = input.charCodeAt(pos + 1);\n      if (!allowNumSeparator) {\n        if (bailOnError) return {\n          n: null,\n          pos\n        };\n        errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);\n      } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {\n        if (bailOnError) return {\n          n: null,\n          pos\n        };\n        errors.unexpectedNumericSeparator(pos, lineStart, curLine);\n      }\n      ++pos;\n      continue;\n    }\n    if (code >= 97) {\n      val = code - 97 + 10;\n    } else if (code >= 65) {\n      val = code - 65 + 10;\n    } else if (_isDigit(code)) {\n      val = code - 48;\n    } else {\n      val = Infinity;\n    }\n    if (val >= radix) {\n      if (val <= 9 && bailOnError) {\n        return {\n          n: null,\n          pos\n        };\n      } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {\n        val = 0;\n      } else if (forceLen) {\n        val = 0;\n        invalid = true;\n      } else {\n        break;\n      }\n    }\n    ++pos;\n    total = total * radix + val;\n  }\n  if (pos === start || len != null && pos - start !== len || invalid) {\n    return {\n      n: null,\n      pos\n    };\n  }\n  return {\n    n: total,\n    pos\n  };\n}\nfunction readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {\n  const ch = input.charCodeAt(pos);\n  let code;\n  if (ch === 123) {\n    ++pos;\n    ({\n      code,\n      pos\n    } = readHexChar(input, pos, lineStart, curLine, input.indexOf(\"}\", pos) - pos, true, throwOnInvalid, errors));\n    ++pos;\n    if (code !== null && code > 0x10ffff) {\n      if (throwOnInvalid) {\n        errors.invalidCodePoint(pos, lineStart, curLine);\n      } else {\n        return {\n          code: null,\n          pos\n        };\n      }\n    }\n  } else {\n    ({\n      code,\n      pos\n    } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));\n  }\n  return {\n    code,\n    pos\n  };\n}\nfunction buildPosition(pos, lineStart, curLine) {\n  return new Position(curLine, pos - lineStart, pos);\n}\nconst VALID_REGEX_FLAGS = new Set([103, 109, 115, 105, 121, 117, 100, 118]);\nclass Token {\n  constructor(state) {\n    const startIndex = state.startIndex || 0;\n    this.type = state.type;\n    this.value = state.value;\n    this.start = startIndex + state.start;\n    this.end = startIndex + state.end;\n    this.loc = new SourceLocation(state.startLoc, state.endLoc);\n  }\n}\nclass Tokenizer extends CommentsParser {\n  constructor(options, input) {\n    super();\n    this.isLookahead = void 0;\n    this.tokens = [];\n    this.errorHandlers_readInt = {\n      invalidDigit: (pos, lineStart, curLine, radix) => {\n        if (!(this.optionFlags & 2048)) return false;\n        this.raise(Errors.InvalidDigit, buildPosition(pos, lineStart, curLine), {\n          radix\n        });\n        return true;\n      },\n      numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),\n      unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)\n    };\n    this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {\n      invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),\n      invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)\n    });\n    this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {\n      strictNumericEscape: (pos, lineStart, curLine) => {\n        this.recordStrictModeErrors(Errors.StrictNumericEscape, buildPosition(pos, lineStart, curLine));\n      },\n      unterminated: (pos, lineStart, curLine) => {\n        throw this.raise(Errors.UnterminatedString, buildPosition(pos - 1, lineStart, curLine));\n      }\n    });\n    this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {\n      strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),\n      unterminated: (pos, lineStart, curLine) => {\n        throw this.raise(Errors.UnterminatedTemplate, buildPosition(pos, lineStart, curLine));\n      }\n    });\n    this.state = new State();\n    this.state.init(options);\n    this.input = input;\n    this.length = input.length;\n    this.comments = [];\n    this.isLookahead = false;\n  }\n  pushToken(token) {\n    this.tokens.length = this.state.tokensLength;\n    this.tokens.push(token);\n    ++this.state.tokensLength;\n  }\n  next() {\n    this.checkKeywordEscapes();\n    if (this.optionFlags & 256) {\n      this.pushToken(new Token(this.state));\n    }\n    this.state.lastTokEndLoc = this.state.endLoc;\n    this.state.lastTokStartLoc = this.state.startLoc;\n    this.nextToken();\n  }\n  eat(type) {\n    if (this.match(type)) {\n      this.next();\n      return true;\n    } else {\n      return false;\n    }\n  }\n  match(type) {\n    return this.state.type === type;\n  }\n  createLookaheadState(state) {\n    return {\n      pos: state.pos,\n      value: null,\n      type: state.type,\n      start: state.start,\n      end: state.end,\n      context: [this.curContext()],\n      inType: state.inType,\n      startLoc: state.startLoc,\n      lastTokEndLoc: state.lastTokEndLoc,\n      curLine: state.curLine,\n      lineStart: state.lineStart,\n      curPosition: state.curPosition\n    };\n  }\n  lookahead() {\n    const old = this.state;\n    this.state = this.createLookaheadState(old);\n    this.isLookahead = true;\n    this.nextToken();\n    this.isLookahead = false;\n    const curr = this.state;\n    this.state = old;\n    return curr;\n  }\n  nextTokenStart() {\n    return this.nextTokenStartSince(this.state.pos);\n  }\n  nextTokenStartSince(pos) {\n    skipWhiteSpace.lastIndex = pos;\n    return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;\n  }\n  lookaheadCharCode() {\n    return this.lookaheadCharCodeSince(this.state.pos);\n  }\n  lookaheadCharCodeSince(pos) {\n    return this.input.charCodeAt(this.nextTokenStartSince(pos));\n  }\n  nextTokenInLineStart() {\n    return this.nextTokenInLineStartSince(this.state.pos);\n  }\n  nextTokenInLineStartSince(pos) {\n    skipWhiteSpaceInLine.lastIndex = pos;\n    return skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos;\n  }\n  lookaheadInLineCharCode() {\n    return this.input.charCodeAt(this.nextTokenInLineStart());\n  }\n  codePointAtPos(pos) {\n    let cp = this.input.charCodeAt(pos);\n    if ((cp & 0xfc00) === 0xd800 && ++pos < this.input.length) {\n      const trail = this.input.charCodeAt(pos);\n      if ((trail & 0xfc00) === 0xdc00) {\n        cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);\n      }\n    }\n    return cp;\n  }\n  setStrict(strict) {\n    this.state.strict = strict;\n    if (strict) {\n      this.state.strictErrors.forEach(([toParseError, at]) => this.raise(toParseError, at));\n      this.state.strictErrors.clear();\n    }\n  }\n  curContext() {\n    return this.state.context[this.state.context.length - 1];\n  }\n  nextToken() {\n    this.skipSpace();\n    this.state.start = this.state.pos;\n    if (!this.isLookahead) this.state.startLoc = this.state.curPosition();\n    if (this.state.pos >= this.length) {\n      this.finishToken(140);\n      return;\n    }\n    this.getTokenFromCode(this.codePointAtPos(this.state.pos));\n  }\n  skipBlockComment(commentEnd) {\n    let startLoc;\n    if (!this.isLookahead) startLoc = this.state.curPosition();\n    const start = this.state.pos;\n    const end = this.input.indexOf(commentEnd, start + 2);\n    if (end === -1) {\n      throw this.raise(Errors.UnterminatedComment, this.state.curPosition());\n    }\n    this.state.pos = end + commentEnd.length;\n    lineBreakG.lastIndex = start + 2;\n    while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {\n      ++this.state.curLine;\n      this.state.lineStart = lineBreakG.lastIndex;\n    }\n    if (this.isLookahead) return;\n    const comment = {\n      type: \"CommentBlock\",\n      value: this.input.slice(start + 2, end),\n      start: this.sourceToOffsetPos(start),\n      end: this.sourceToOffsetPos(end + commentEnd.length),\n      loc: new SourceLocation(startLoc, this.state.curPosition())\n    };\n    if (this.optionFlags & 256) this.pushToken(comment);\n    return comment;\n  }\n  skipLineComment(startSkip) {\n    const start = this.state.pos;\n    let startLoc;\n    if (!this.isLookahead) startLoc = this.state.curPosition();\n    let ch = this.input.charCodeAt(this.state.pos += startSkip);\n    if (this.state.pos < this.length) {\n      while (!isNewLine(ch) && ++this.state.pos < this.length) {\n        ch = this.input.charCodeAt(this.state.pos);\n      }\n    }\n    if (this.isLookahead) return;\n    const end = this.state.pos;\n    const value = this.input.slice(start + startSkip, end);\n    const comment = {\n      type: \"CommentLine\",\n      value,\n      start: this.sourceToOffsetPos(start),\n      end: this.sourceToOffsetPos(end),\n      loc: new SourceLocation(startLoc, this.state.curPosition())\n    };\n    if (this.optionFlags & 256) this.pushToken(comment);\n    return comment;\n  }\n  skipSpace() {\n    const spaceStart = this.state.pos;\n    const comments = this.optionFlags & 4096 ? [] : null;\n    loop: while (this.state.pos < this.length) {\n      const ch = this.input.charCodeAt(this.state.pos);\n      switch (ch) {\n        case 32:\n        case 160:\n        case 9:\n          ++this.state.pos;\n          break;\n        case 13:\n          if (this.input.charCodeAt(this.state.pos + 1) === 10) {\n            ++this.state.pos;\n          }\n        case 10:\n        case 8232:\n        case 8233:\n          ++this.state.pos;\n          ++this.state.curLine;\n          this.state.lineStart = this.state.pos;\n          break;\n        case 47:\n          switch (this.input.charCodeAt(this.state.pos + 1)) {\n            case 42:\n              {\n                const comment = this.skipBlockComment(\"*/\");\n                if (comment !== undefined) {\n                  this.addComment(comment);\n                  comments == null || comments.push(comment);\n                }\n                break;\n              }\n            case 47:\n              {\n                const comment = this.skipLineComment(2);\n                if (comment !== undefined) {\n                  this.addComment(comment);\n                  comments == null || comments.push(comment);\n                }\n                break;\n              }\n            default:\n              break loop;\n          }\n          break;\n        default:\n          if (isWhitespace(ch)) {\n            ++this.state.pos;\n          } else if (ch === 45 && !this.inModule && this.optionFlags & 8192) {\n            const pos = this.state.pos;\n            if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {\n              const comment = this.skipLineComment(3);\n              if (comment !== undefined) {\n                this.addComment(comment);\n                comments == null || comments.push(comment);\n              }\n            } else {\n              break loop;\n            }\n          } else if (ch === 60 && !this.inModule && this.optionFlags & 8192) {\n            const pos = this.state.pos;\n            if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {\n              const comment = this.skipLineComment(4);\n              if (comment !== undefined) {\n                this.addComment(comment);\n                comments == null || comments.push(comment);\n              }\n            } else {\n              break loop;\n            }\n          } else {\n            break loop;\n          }\n      }\n    }\n    if ((comments == null ? void 0 : comments.length) > 0) {\n      const end = this.state.pos;\n      const commentWhitespace = {\n        start: this.sourceToOffsetPos(spaceStart),\n        end: this.sourceToOffsetPos(end),\n        comments,\n        leadingNode: null,\n        trailingNode: null,\n        containingNode: null\n      };\n      this.state.commentStack.push(commentWhitespace);\n    }\n  }\n  finishToken(type, val) {\n    this.state.end = this.state.pos;\n    this.state.endLoc = this.state.curPosition();\n    const prevType = this.state.type;\n    this.state.type = type;\n    this.state.value = val;\n    if (!this.isLookahead) {\n      this.updateContext(prevType);\n    }\n  }\n  replaceToken(type) {\n    this.state.type = type;\n    this.updateContext();\n  }\n  readToken_numberSign() {\n    if (this.state.pos === 0 && this.readToken_interpreter()) {\n      return;\n    }\n    const nextPos = this.state.pos + 1;\n    const next = this.codePointAtPos(nextPos);\n    if (next >= 48 && next <= 57) {\n      throw this.raise(Errors.UnexpectedDigitAfterHash, this.state.curPosition());\n    }\n    if (next === 123 || next === 91 && this.hasPlugin(\"recordAndTuple\")) {\n      this.expectPlugin(\"recordAndTuple\");\n      if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") === \"bar\") {\n        throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());\n      }\n      this.state.pos += 2;\n      if (next === 123) {\n        this.finishToken(7);\n      } else {\n        this.finishToken(1);\n      }\n    } else if (isIdentifierStart(next)) {\n      ++this.state.pos;\n      this.finishToken(139, this.readWord1(next));\n    } else if (next === 92) {\n      ++this.state.pos;\n      this.finishToken(139, this.readWord1());\n    } else {\n      this.finishOp(27, 1);\n    }\n  }\n  readToken_dot() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next >= 48 && next <= 57) {\n      this.readNumber(true);\n      return;\n    }\n    if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {\n      this.state.pos += 3;\n      this.finishToken(21);\n    } else {\n      ++this.state.pos;\n      this.finishToken(16);\n    }\n  }\n  readToken_slash() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 61) {\n      this.finishOp(31, 2);\n    } else {\n      this.finishOp(56, 1);\n    }\n  }\n  readToken_interpreter() {\n    if (this.state.pos !== 0 || this.length < 2) return false;\n    let ch = this.input.charCodeAt(this.state.pos + 1);\n    if (ch !== 33) return false;\n    const start = this.state.pos;\n    this.state.pos += 1;\n    while (!isNewLine(ch) && ++this.state.pos < this.length) {\n      ch = this.input.charCodeAt(this.state.pos);\n    }\n    const value = this.input.slice(start + 2, this.state.pos);\n    this.finishToken(28, value);\n    return true;\n  }\n  readToken_mult_modulo(code) {\n    let type = code === 42 ? 55 : 54;\n    let width = 1;\n    let next = this.input.charCodeAt(this.state.pos + 1);\n    if (code === 42 && next === 42) {\n      width++;\n      next = this.input.charCodeAt(this.state.pos + 2);\n      type = 57;\n    }\n    if (next === 61 && !this.state.inType) {\n      width++;\n      type = code === 37 ? 33 : 30;\n    }\n    this.finishOp(type, width);\n  }\n  readToken_pipe_amp(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === code) {\n      if (this.input.charCodeAt(this.state.pos + 2) === 61) {\n        this.finishOp(30, 3);\n      } else {\n        this.finishOp(code === 124 ? 41 : 42, 2);\n      }\n      return;\n    }\n    if (code === 124) {\n      if (next === 62) {\n        this.finishOp(39, 2);\n        return;\n      }\n      if (this.hasPlugin(\"recordAndTuple\") && next === 125) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());\n        }\n        this.state.pos += 2;\n        this.finishToken(9);\n        return;\n      }\n      if (this.hasPlugin(\"recordAndTuple\") && next === 93) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());\n        }\n        this.state.pos += 2;\n        this.finishToken(4);\n        return;\n      }\n    }\n    if (next === 61) {\n      this.finishOp(30, 2);\n      return;\n    }\n    this.finishOp(code === 124 ? 43 : 45, 1);\n  }\n  readToken_caret() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 61 && !this.state.inType) {\n      this.finishOp(32, 2);\n    } else if (next === 94 && this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"hack\",\n      topicToken: \"^^\"\n    }])) {\n      this.finishOp(37, 2);\n      const lookaheadCh = this.input.codePointAt(this.state.pos);\n      if (lookaheadCh === 94) {\n        this.unexpected();\n      }\n    } else {\n      this.finishOp(44, 1);\n    }\n  }\n  readToken_atSign() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 64 && this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"hack\",\n      topicToken: \"@@\"\n    }])) {\n      this.finishOp(38, 2);\n    } else {\n      this.finishOp(26, 1);\n    }\n  }\n  readToken_plus_min(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === code) {\n      this.finishOp(34, 2);\n      return;\n    }\n    if (next === 61) {\n      this.finishOp(30, 2);\n    } else {\n      this.finishOp(53, 1);\n    }\n  }\n  readToken_lt() {\n    const {\n      pos\n    } = this.state;\n    const next = this.input.charCodeAt(pos + 1);\n    if (next === 60) {\n      if (this.input.charCodeAt(pos + 2) === 61) {\n        this.finishOp(30, 3);\n        return;\n      }\n      this.finishOp(51, 2);\n      return;\n    }\n    if (next === 61) {\n      this.finishOp(49, 2);\n      return;\n    }\n    this.finishOp(47, 1);\n  }\n  readToken_gt() {\n    const {\n      pos\n    } = this.state;\n    const next = this.input.charCodeAt(pos + 1);\n    if (next === 62) {\n      const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;\n      if (this.input.charCodeAt(pos + size) === 61) {\n        this.finishOp(30, size + 1);\n        return;\n      }\n      this.finishOp(52, size);\n      return;\n    }\n    if (next === 61) {\n      this.finishOp(49, 2);\n      return;\n    }\n    this.finishOp(48, 1);\n  }\n  readToken_eq_excl(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 61) {\n      this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);\n      return;\n    }\n    if (code === 61 && next === 62) {\n      this.state.pos += 2;\n      this.finishToken(19);\n      return;\n    }\n    this.finishOp(code === 61 ? 29 : 35, 1);\n  }\n  readToken_question() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    const next2 = this.input.charCodeAt(this.state.pos + 2);\n    if (next === 63) {\n      if (next2 === 61) {\n        this.finishOp(30, 3);\n      } else {\n        this.finishOp(40, 2);\n      }\n    } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {\n      this.state.pos += 2;\n      this.finishToken(18);\n    } else {\n      ++this.state.pos;\n      this.finishToken(17);\n    }\n  }\n  getTokenFromCode(code) {\n    switch (code) {\n      case 46:\n        this.readToken_dot();\n        return;\n      case 40:\n        ++this.state.pos;\n        this.finishToken(10);\n        return;\n      case 41:\n        ++this.state.pos;\n        this.finishToken(11);\n        return;\n      case 59:\n        ++this.state.pos;\n        this.finishToken(13);\n        return;\n      case 44:\n        ++this.state.pos;\n        this.finishToken(12);\n        return;\n      case 91:\n        if (this.hasPlugin(\"recordAndTuple\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());\n          }\n          this.state.pos += 2;\n          this.finishToken(2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(0);\n        }\n        return;\n      case 93:\n        ++this.state.pos;\n        this.finishToken(3);\n        return;\n      case 123:\n        if (this.hasPlugin(\"recordAndTuple\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());\n          }\n          this.state.pos += 2;\n          this.finishToken(6);\n        } else {\n          ++this.state.pos;\n          this.finishToken(5);\n        }\n        return;\n      case 125:\n        ++this.state.pos;\n        this.finishToken(8);\n        return;\n      case 58:\n        if (this.hasPlugin(\"functionBind\") && this.input.charCodeAt(this.state.pos + 1) === 58) {\n          this.finishOp(15, 2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(14);\n        }\n        return;\n      case 63:\n        this.readToken_question();\n        return;\n      case 96:\n        this.readTemplateToken();\n        return;\n      case 48:\n        {\n          const next = this.input.charCodeAt(this.state.pos + 1);\n          if (next === 120 || next === 88) {\n            this.readRadixNumber(16);\n            return;\n          }\n          if (next === 111 || next === 79) {\n            this.readRadixNumber(8);\n            return;\n          }\n          if (next === 98 || next === 66) {\n            this.readRadixNumber(2);\n            return;\n          }\n        }\n      case 49:\n      case 50:\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n        this.readNumber(false);\n        return;\n      case 34:\n      case 39:\n        this.readString(code);\n        return;\n      case 47:\n        this.readToken_slash();\n        return;\n      case 37:\n      case 42:\n        this.readToken_mult_modulo(code);\n        return;\n      case 124:\n      case 38:\n        this.readToken_pipe_amp(code);\n        return;\n      case 94:\n        this.readToken_caret();\n        return;\n      case 43:\n      case 45:\n        this.readToken_plus_min(code);\n        return;\n      case 60:\n        this.readToken_lt();\n        return;\n      case 62:\n        this.readToken_gt();\n        return;\n      case 61:\n      case 33:\n        this.readToken_eq_excl(code);\n        return;\n      case 126:\n        this.finishOp(36, 1);\n        return;\n      case 64:\n        this.readToken_atSign();\n        return;\n      case 35:\n        this.readToken_numberSign();\n        return;\n      case 92:\n        this.readWord();\n        return;\n      default:\n        if (isIdentifierStart(code)) {\n          this.readWord(code);\n          return;\n        }\n    }\n    throw this.raise(Errors.InvalidOrUnexpectedToken, this.state.curPosition(), {\n      unexpected: String.fromCodePoint(code)\n    });\n  }\n  finishOp(type, size) {\n    const str = this.input.slice(this.state.pos, this.state.pos + size);\n    this.state.pos += size;\n    this.finishToken(type, str);\n  }\n  readRegexp() {\n    const startLoc = this.state.startLoc;\n    const start = this.state.start + 1;\n    let escaped, inClass;\n    let {\n      pos\n    } = this.state;\n    for (;; ++pos) {\n      if (pos >= this.length) {\n        throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));\n      }\n      const ch = this.input.charCodeAt(pos);\n      if (isNewLine(ch)) {\n        throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));\n      }\n      if (escaped) {\n        escaped = false;\n      } else {\n        if (ch === 91) {\n          inClass = true;\n        } else if (ch === 93 && inClass) {\n          inClass = false;\n        } else if (ch === 47 && !inClass) {\n          break;\n        }\n        escaped = ch === 92;\n      }\n    }\n    const content = this.input.slice(start, pos);\n    ++pos;\n    let mods = \"\";\n    const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);\n    while (pos < this.length) {\n      const cp = this.codePointAtPos(pos);\n      const char = String.fromCharCode(cp);\n      if (VALID_REGEX_FLAGS.has(cp)) {\n        if (cp === 118) {\n          if (mods.includes(\"u\")) {\n            this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());\n          }\n        } else if (cp === 117) {\n          if (mods.includes(\"v\")) {\n            this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());\n          }\n        }\n        if (mods.includes(char)) {\n          this.raise(Errors.DuplicateRegExpFlags, nextPos());\n        }\n      } else if (isIdentifierChar(cp) || cp === 92) {\n        this.raise(Errors.MalformedRegExpFlags, nextPos());\n      } else {\n        break;\n      }\n      ++pos;\n      mods += char;\n    }\n    this.state.pos = pos;\n    this.finishToken(138, {\n      pattern: content,\n      flags: mods\n    });\n  }\n  readInt(radix, len, forceLen = false, allowNumSeparator = true) {\n    const {\n      n,\n      pos\n    } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false);\n    this.state.pos = pos;\n    return n;\n  }\n  readRadixNumber(radix) {\n    const start = this.state.pos;\n    const startLoc = this.state.curPosition();\n    let isBigInt = false;\n    this.state.pos += 2;\n    const val = this.readInt(radix);\n    if (val == null) {\n      this.raise(Errors.InvalidDigit, createPositionWithColumnOffset(startLoc, 2), {\n        radix\n      });\n    }\n    const next = this.input.charCodeAt(this.state.pos);\n    if (next === 110) {\n      ++this.state.pos;\n      isBigInt = true;\n    } else if (next === 109) {\n      throw this.raise(Errors.InvalidDecimal, startLoc);\n    }\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\n      throw this.raise(Errors.NumberIdentifier, this.state.curPosition());\n    }\n    if (isBigInt) {\n      const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, \"\");\n      this.finishToken(136, str);\n      return;\n    }\n    this.finishToken(135, val);\n  }\n  readNumber(startsWithDot) {\n    const start = this.state.pos;\n    const startLoc = this.state.curPosition();\n    let isFloat = false;\n    let isBigInt = false;\n    let hasExponent = false;\n    let isOctal = false;\n    if (!startsWithDot && this.readInt(10) === null) {\n      this.raise(Errors.InvalidNumber, this.state.curPosition());\n    }\n    const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n    if (hasLeadingZero) {\n      const integer = this.input.slice(start, this.state.pos);\n      this.recordStrictModeErrors(Errors.StrictOctalLiteral, startLoc);\n      if (!this.state.strict) {\n        const underscorePos = integer.indexOf(\"_\");\n        if (underscorePos > 0) {\n          this.raise(Errors.ZeroDigitNumericSeparator, createPositionWithColumnOffset(startLoc, underscorePos));\n        }\n      }\n      isOctal = hasLeadingZero && !/[89]/.test(integer);\n    }\n    let next = this.input.charCodeAt(this.state.pos);\n    if (next === 46 && !isOctal) {\n      ++this.state.pos;\n      this.readInt(10);\n      isFloat = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n    if ((next === 69 || next === 101) && !isOctal) {\n      next = this.input.charCodeAt(++this.state.pos);\n      if (next === 43 || next === 45) {\n        ++this.state.pos;\n      }\n      if (this.readInt(10) === null) {\n        this.raise(Errors.InvalidOrMissingExponent, startLoc);\n      }\n      isFloat = true;\n      hasExponent = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n    if (next === 110) {\n      if (isFloat || hasLeadingZero) {\n        this.raise(Errors.InvalidBigIntLiteral, startLoc);\n      }\n      ++this.state.pos;\n      isBigInt = true;\n    }\n    if (next === 109) {\n      this.expectPlugin(\"decimal\", this.state.curPosition());\n      if (hasExponent || hasLeadingZero) {\n        this.raise(Errors.InvalidDecimal, startLoc);\n      }\n      ++this.state.pos;\n      var isDecimal = true;\n    }\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\n      throw this.raise(Errors.NumberIdentifier, this.state.curPosition());\n    }\n    const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, \"\");\n    if (isBigInt) {\n      this.finishToken(136, str);\n      return;\n    }\n    if (isDecimal) {\n      this.finishToken(137, str);\n      return;\n    }\n    const val = isOctal ? parseInt(str, 8) : parseFloat(str);\n    this.finishToken(135, val);\n  }\n  readCodePoint(throwOnInvalid) {\n    const {\n      code,\n      pos\n    } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);\n    this.state.pos = pos;\n    return code;\n  }\n  readString(quote) {\n    const {\n      str,\n      pos,\n      curLine,\n      lineStart\n    } = readStringContents(quote === 34 ? \"double\" : \"single\", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);\n    this.state.pos = pos + 1;\n    this.state.lineStart = lineStart;\n    this.state.curLine = curLine;\n    this.finishToken(134, str);\n  }\n  readTemplateContinuation() {\n    if (!this.match(8)) {\n      this.unexpected(null, 8);\n    }\n    this.state.pos--;\n    this.readTemplateToken();\n  }\n  readTemplateToken() {\n    const opening = this.input[this.state.pos];\n    const {\n      str,\n      firstInvalidLoc,\n      pos,\n      curLine,\n      lineStart\n    } = readStringContents(\"template\", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);\n    this.state.pos = pos + 1;\n    this.state.lineStart = lineStart;\n    this.state.curLine = curLine;\n    if (firstInvalidLoc) {\n      this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, this.sourceToOffsetPos(firstInvalidLoc.pos));\n    }\n    if (this.input.codePointAt(pos) === 96) {\n      this.finishToken(24, firstInvalidLoc ? null : opening + str + \"`\");\n    } else {\n      this.state.pos++;\n      this.finishToken(25, firstInvalidLoc ? null : opening + str + \"${\");\n    }\n  }\n  recordStrictModeErrors(toParseError, at) {\n    const index = at.index;\n    if (this.state.strict && !this.state.strictErrors.has(index)) {\n      this.raise(toParseError, at);\n    } else {\n      this.state.strictErrors.set(index, [toParseError, at]);\n    }\n  }\n  readWord1(firstCode) {\n    this.state.containsEsc = false;\n    let word = \"\";\n    const start = this.state.pos;\n    let chunkStart = this.state.pos;\n    if (firstCode !== undefined) {\n      this.state.pos += firstCode <= 0xffff ? 1 : 2;\n    }\n    while (this.state.pos < this.length) {\n      const ch = this.codePointAtPos(this.state.pos);\n      if (isIdentifierChar(ch)) {\n        this.state.pos += ch <= 0xffff ? 1 : 2;\n      } else if (ch === 92) {\n        this.state.containsEsc = true;\n        word += this.input.slice(chunkStart, this.state.pos);\n        const escStart = this.state.curPosition();\n        const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;\n        if (this.input.charCodeAt(++this.state.pos) !== 117) {\n          this.raise(Errors.MissingUnicodeEscape, this.state.curPosition());\n          chunkStart = this.state.pos - 1;\n          continue;\n        }\n        ++this.state.pos;\n        const esc = this.readCodePoint(true);\n        if (esc !== null) {\n          if (!identifierCheck(esc)) {\n            this.raise(Errors.EscapedCharNotAnIdentifier, escStart);\n          }\n          word += String.fromCodePoint(esc);\n        }\n        chunkStart = this.state.pos;\n      } else {\n        break;\n      }\n    }\n    return word + this.input.slice(chunkStart, this.state.pos);\n  }\n  readWord(firstCode) {\n    const word = this.readWord1(firstCode);\n    const type = keywords$1.get(word);\n    if (type !== undefined) {\n      this.finishToken(type, tokenLabelName(type));\n    } else {\n      this.finishToken(132, word);\n    }\n  }\n  checkKeywordEscapes() {\n    const {\n      type\n    } = this.state;\n    if (tokenIsKeyword(type) && this.state.containsEsc) {\n      this.raise(Errors.InvalidEscapedReservedWord, this.state.startLoc, {\n        reservedWord: tokenLabelName(type)\n      });\n    }\n  }\n  raise(toParseError, at, details = {}) {\n    const loc = at instanceof Position ? at : at.loc.start;\n    const error = toParseError(loc, details);\n    if (!(this.optionFlags & 2048)) throw error;\n    if (!this.isLookahead) this.state.errors.push(error);\n    return error;\n  }\n  raiseOverwrite(toParseError, at, details = {}) {\n    const loc = at instanceof Position ? at : at.loc.start;\n    const pos = loc.index;\n    const errors = this.state.errors;\n    for (let i = errors.length - 1; i >= 0; i--) {\n      const error = errors[i];\n      if (error.loc.index === pos) {\n        return errors[i] = toParseError(loc, details);\n      }\n      if (error.loc.index < pos) break;\n    }\n    return this.raise(toParseError, at, details);\n  }\n  updateContext(prevType) {}\n  unexpected(loc, type) {\n    throw this.raise(Errors.UnexpectedToken, loc != null ? loc : this.state.startLoc, {\n      expected: type ? tokenLabelName(type) : null\n    });\n  }\n  expectPlugin(pluginName, loc) {\n    if (this.hasPlugin(pluginName)) {\n      return true;\n    }\n    throw this.raise(Errors.MissingPlugin, loc != null ? loc : this.state.startLoc, {\n      missingPlugin: [pluginName]\n    });\n  }\n  expectOnePlugin(pluginNames) {\n    if (!pluginNames.some(name => this.hasPlugin(name))) {\n      throw this.raise(Errors.MissingOneOfPlugins, this.state.startLoc, {\n        missingPlugin: pluginNames\n      });\n    }\n  }\n  errorBuilder(error) {\n    return (pos, lineStart, curLine) => {\n      this.raise(error, buildPosition(pos, lineStart, curLine));\n    };\n  }\n}\nclass ClassScope {\n  constructor() {\n    this.privateNames = new Set();\n    this.loneAccessors = new Map();\n    this.undefinedPrivateNames = new Map();\n  }\n}\nclass ClassScopeHandler {\n  constructor(parser) {\n    this.parser = void 0;\n    this.stack = [];\n    this.undefinedPrivateNames = new Map();\n    this.parser = parser;\n  }\n  current() {\n    return this.stack[this.stack.length - 1];\n  }\n  enter() {\n    this.stack.push(new ClassScope());\n  }\n  exit() {\n    const oldClassScope = this.stack.pop();\n    const current = this.current();\n    for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {\n      if (current) {\n        if (!current.undefinedPrivateNames.has(name)) {\n          current.undefinedPrivateNames.set(name, loc);\n        }\n      } else {\n        this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {\n          identifierName: name\n        });\n      }\n    }\n  }\n  declarePrivateName(name, elementType, loc) {\n    const {\n      privateNames,\n      loneAccessors,\n      undefinedPrivateNames\n    } = this.current();\n    let redefined = privateNames.has(name);\n    if (elementType & 3) {\n      const accessor = redefined && loneAccessors.get(name);\n      if (accessor) {\n        const oldStatic = accessor & 4;\n        const newStatic = elementType & 4;\n        const oldKind = accessor & 3;\n        const newKind = elementType & 3;\n        redefined = oldKind === newKind || oldStatic !== newStatic;\n        if (!redefined) loneAccessors.delete(name);\n      } else if (!redefined) {\n        loneAccessors.set(name, elementType);\n      }\n    }\n    if (redefined) {\n      this.parser.raise(Errors.PrivateNameRedeclaration, loc, {\n        identifierName: name\n      });\n    }\n    privateNames.add(name);\n    undefinedPrivateNames.delete(name);\n  }\n  usePrivateName(name, loc) {\n    let classScope;\n    for (classScope of this.stack) {\n      if (classScope.privateNames.has(name)) return;\n    }\n    if (classScope) {\n      classScope.undefinedPrivateNames.set(name, loc);\n    } else {\n      this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {\n        identifierName: name\n      });\n    }\n  }\n}\nclass ExpressionScope {\n  constructor(type = 0) {\n    this.type = type;\n  }\n  canBeArrowParameterDeclaration() {\n    return this.type === 2 || this.type === 1;\n  }\n  isCertainlyParameterDeclaration() {\n    return this.type === 3;\n  }\n}\nclass ArrowHeadParsingScope extends ExpressionScope {\n  constructor(type) {\n    super(type);\n    this.declarationErrors = new Map();\n  }\n  recordDeclarationError(ParsingErrorClass, at) {\n    const index = at.index;\n    this.declarationErrors.set(index, [ParsingErrorClass, at]);\n  }\n  clearDeclarationError(index) {\n    this.declarationErrors.delete(index);\n  }\n  iterateErrors(iterator) {\n    this.declarationErrors.forEach(iterator);\n  }\n}\nclass ExpressionScopeHandler {\n  constructor(parser) {\n    this.parser = void 0;\n    this.stack = [new ExpressionScope()];\n    this.parser = parser;\n  }\n  enter(scope) {\n    this.stack.push(scope);\n  }\n  exit() {\n    this.stack.pop();\n  }\n  recordParameterInitializerError(toParseError, node) {\n    const origin = node.loc.start;\n    const {\n      stack\n    } = this;\n    let i = stack.length - 1;\n    let scope = stack[i];\n    while (!scope.isCertainlyParameterDeclaration()) {\n      if (scope.canBeArrowParameterDeclaration()) {\n        scope.recordDeclarationError(toParseError, origin);\n      } else {\n        return;\n      }\n      scope = stack[--i];\n    }\n    this.parser.raise(toParseError, origin);\n  }\n  recordArrowParameterBindingError(error, node) {\n    const {\n      stack\n    } = this;\n    const scope = stack[stack.length - 1];\n    const origin = node.loc.start;\n    if (scope.isCertainlyParameterDeclaration()) {\n      this.parser.raise(error, origin);\n    } else if (scope.canBeArrowParameterDeclaration()) {\n      scope.recordDeclarationError(error, origin);\n    } else {\n      return;\n    }\n  }\n  recordAsyncArrowParametersError(at) {\n    const {\n      stack\n    } = this;\n    let i = stack.length - 1;\n    let scope = stack[i];\n    while (scope.canBeArrowParameterDeclaration()) {\n      if (scope.type === 2) {\n        scope.recordDeclarationError(Errors.AwaitBindingIdentifier, at);\n      }\n      scope = stack[--i];\n    }\n  }\n  validateAsPattern() {\n    const {\n      stack\n    } = this;\n    const currentScope = stack[stack.length - 1];\n    if (!currentScope.canBeArrowParameterDeclaration()) return;\n    currentScope.iterateErrors(([toParseError, loc]) => {\n      this.parser.raise(toParseError, loc);\n      let i = stack.length - 2;\n      let scope = stack[i];\n      while (scope.canBeArrowParameterDeclaration()) {\n        scope.clearDeclarationError(loc.index);\n        scope = stack[--i];\n      }\n    });\n  }\n}\nfunction newParameterDeclarationScope() {\n  return new ExpressionScope(3);\n}\nfunction newArrowHeadScope() {\n  return new ArrowHeadParsingScope(1);\n}\nfunction newAsyncArrowScope() {\n  return new ArrowHeadParsingScope(2);\n}\nfunction newExpressionScope() {\n  return new ExpressionScope();\n}\nclass UtilParser extends Tokenizer {\n  addExtra(node, key, value, enumerable = true) {\n    if (!node) return;\n    let {\n      extra\n    } = node;\n    if (extra == null) {\n      extra = {};\n      node.extra = extra;\n    }\n    if (enumerable) {\n      extra[key] = value;\n    } else {\n      Object.defineProperty(extra, key, {\n        enumerable,\n        value\n      });\n    }\n  }\n  isContextual(token) {\n    return this.state.type === token && !this.state.containsEsc;\n  }\n  isUnparsedContextual(nameStart, name) {\n    if (this.input.startsWith(name, nameStart)) {\n      const nextCh = this.input.charCodeAt(nameStart + name.length);\n      return !(isIdentifierChar(nextCh) || (nextCh & 0xfc00) === 0xd800);\n    }\n    return false;\n  }\n  isLookaheadContextual(name) {\n    const next = this.nextTokenStart();\n    return this.isUnparsedContextual(next, name);\n  }\n  eatContextual(token) {\n    if (this.isContextual(token)) {\n      this.next();\n      return true;\n    }\n    return false;\n  }\n  expectContextual(token, toParseError) {\n    if (!this.eatContextual(token)) {\n      if (toParseError != null) {\n        throw this.raise(toParseError, this.state.startLoc);\n      }\n      this.unexpected(null, token);\n    }\n  }\n  canInsertSemicolon() {\n    return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();\n  }\n  hasPrecedingLineBreak() {\n    return hasNewLine(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);\n  }\n  hasFollowingLineBreak() {\n    return hasNewLine(this.input, this.state.end, this.nextTokenStart());\n  }\n  isLineTerminator() {\n    return this.eat(13) || this.canInsertSemicolon();\n  }\n  semicolon(allowAsi = true) {\n    if (allowAsi ? this.isLineTerminator() : this.eat(13)) return;\n    this.raise(Errors.MissingSemicolon, this.state.lastTokEndLoc);\n  }\n  expect(type, loc) {\n    if (!this.eat(type)) {\n      this.unexpected(loc, type);\n    }\n  }\n  tryParse(fn, oldState = this.state.clone()) {\n    const abortSignal = {\n      node: null\n    };\n    try {\n      const node = fn((node = null) => {\n        abortSignal.node = node;\n        throw abortSignal;\n      });\n      if (this.state.errors.length > oldState.errors.length) {\n        const failState = this.state;\n        this.state = oldState;\n        this.state.tokensLength = failState.tokensLength;\n        return {\n          node,\n          error: failState.errors[oldState.errors.length],\n          thrown: false,\n          aborted: false,\n          failState\n        };\n      }\n      return {\n        node,\n        error: null,\n        thrown: false,\n        aborted: false,\n        failState: null\n      };\n    } catch (error) {\n      const failState = this.state;\n      this.state = oldState;\n      if (error instanceof SyntaxError) {\n        return {\n          node: null,\n          error,\n          thrown: true,\n          aborted: false,\n          failState\n        };\n      }\n      if (error === abortSignal) {\n        return {\n          node: abortSignal.node,\n          error: null,\n          thrown: false,\n          aborted: true,\n          failState\n        };\n      }\n      throw error;\n    }\n  }\n  checkExpressionErrors(refExpressionErrors, andThrow) {\n    if (!refExpressionErrors) return false;\n    const {\n      shorthandAssignLoc,\n      doubleProtoLoc,\n      privateKeyLoc,\n      optionalParametersLoc,\n      voidPatternLoc\n    } = refExpressionErrors;\n    const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc || !!voidPatternLoc;\n    if (!andThrow) {\n      return hasErrors;\n    }\n    if (shorthandAssignLoc != null) {\n      this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);\n    }\n    if (doubleProtoLoc != null) {\n      this.raise(Errors.DuplicateProto, doubleProtoLoc);\n    }\n    if (privateKeyLoc != null) {\n      this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);\n    }\n    if (optionalParametersLoc != null) {\n      this.unexpected(optionalParametersLoc);\n    }\n    if (voidPatternLoc != null) {\n      this.raise(Errors.InvalidCoverDiscardElement, voidPatternLoc);\n    }\n  }\n  isLiteralPropertyName() {\n    return tokenIsLiteralPropertyName(this.state.type);\n  }\n  isPrivateName(node) {\n    return node.type === \"PrivateName\";\n  }\n  getPrivateNameSV(node) {\n    return node.id.name;\n  }\n  hasPropertyAsPrivateName(node) {\n    return (node.type === \"MemberExpression\" || node.type === \"OptionalMemberExpression\") && this.isPrivateName(node.property);\n  }\n  isObjectProperty(node) {\n    return node.type === \"ObjectProperty\";\n  }\n  isObjectMethod(node) {\n    return node.type === \"ObjectMethod\";\n  }\n  initializeScopes(inModule = this.options.sourceType === \"module\") {\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    const oldExportedIdentifiers = this.exportedIdentifiers;\n    this.exportedIdentifiers = new Set();\n    const oldInModule = this.inModule;\n    this.inModule = inModule;\n    const oldScope = this.scope;\n    const ScopeHandler = this.getScopeHandler();\n    this.scope = new ScopeHandler(this, inModule);\n    const oldProdParam = this.prodParam;\n    this.prodParam = new ProductionParameterHandler();\n    const oldClassScope = this.classScope;\n    this.classScope = new ClassScopeHandler(this);\n    const oldExpressionScope = this.expressionScope;\n    this.expressionScope = new ExpressionScopeHandler(this);\n    return () => {\n      this.state.labels = oldLabels;\n      this.exportedIdentifiers = oldExportedIdentifiers;\n      this.inModule = oldInModule;\n      this.scope = oldScope;\n      this.prodParam = oldProdParam;\n      this.classScope = oldClassScope;\n      this.expressionScope = oldExpressionScope;\n    };\n  }\n  enterInitialScopes() {\n    let paramFlags = 0;\n    if (this.inModule || this.optionFlags & 1) {\n      paramFlags |= 2;\n    }\n    if (this.optionFlags & 32) {\n      paramFlags |= 1;\n    }\n    const isCommonJS = !this.inModule && this.options.sourceType === \"commonjs\";\n    if (isCommonJS || this.optionFlags & 2) {\n      paramFlags |= 4;\n    }\n    this.prodParam.enter(paramFlags);\n    let scopeFlags = isCommonJS ? 514 : 1;\n    if (this.optionFlags & 4) {\n      scopeFlags |= 512;\n    }\n    this.scope.enter(scopeFlags);\n  }\n  checkDestructuringPrivate(refExpressionErrors) {\n    const {\n      privateKeyLoc\n    } = refExpressionErrors;\n    if (privateKeyLoc !== null) {\n      this.expectPlugin(\"destructuringPrivate\", privateKeyLoc);\n    }\n  }\n}\nclass ExpressionErrors {\n  constructor() {\n    this.shorthandAssignLoc = null;\n    this.doubleProtoLoc = null;\n    this.privateKeyLoc = null;\n    this.optionalParametersLoc = null;\n    this.voidPatternLoc = null;\n  }\n}\nclass Node {\n  constructor(parser, pos, loc) {\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n    this.loc = new SourceLocation(loc);\n    if ((parser == null ? void 0 : parser.optionFlags) & 128) this.range = [pos, 0];\n    if (parser != null && parser.filename) this.loc.filename = parser.filename;\n  }\n}\nconst NodePrototype = Node.prototype;\n{\n  NodePrototype.__clone = function () {\n    const newNode = new Node(undefined, this.start, this.loc.start);\n    const keys = Object.keys(this);\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      if (key !== \"leadingComments\" && key !== \"trailingComments\" && key !== \"innerComments\") {\n        newNode[key] = this[key];\n      }\n    }\n    return newNode;\n  };\n}\nclass NodeUtils extends UtilParser {\n  startNode() {\n    const loc = this.state.startLoc;\n    return new Node(this, loc.index, loc);\n  }\n  startNodeAt(loc) {\n    return new Node(this, loc.index, loc);\n  }\n  startNodeAtNode(type) {\n    return this.startNodeAt(type.loc.start);\n  }\n  finishNode(node, type) {\n    return this.finishNodeAt(node, type, this.state.lastTokEndLoc);\n  }\n  finishNodeAt(node, type, endLoc) {\n    node.type = type;\n    node.end = endLoc.index;\n    node.loc.end = endLoc;\n    if (this.optionFlags & 128) node.range[1] = endLoc.index;\n    if (this.optionFlags & 4096) {\n      this.processComment(node);\n    }\n    return node;\n  }\n  resetStartLocation(node, startLoc) {\n    node.start = startLoc.index;\n    node.loc.start = startLoc;\n    if (this.optionFlags & 128) node.range[0] = startLoc.index;\n  }\n  resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {\n    node.end = endLoc.index;\n    node.loc.end = endLoc;\n    if (this.optionFlags & 128) node.range[1] = endLoc.index;\n  }\n  resetStartLocationFromNode(node, locationNode) {\n    this.resetStartLocation(node, locationNode.loc.start);\n  }\n  castNodeTo(node, type) {\n    node.type = type;\n    return node;\n  }\n  cloneIdentifier(node) {\n    const {\n      type,\n      start,\n      end,\n      loc,\n      range,\n      name\n    } = node;\n    const cloned = Object.create(NodePrototype);\n    cloned.type = type;\n    cloned.start = start;\n    cloned.end = end;\n    cloned.loc = loc;\n    cloned.range = range;\n    cloned.name = name;\n    if (node.extra) cloned.extra = node.extra;\n    return cloned;\n  }\n  cloneStringLiteral(node) {\n    const {\n      type,\n      start,\n      end,\n      loc,\n      range,\n      extra\n    } = node;\n    const cloned = Object.create(NodePrototype);\n    cloned.type = type;\n    cloned.start = start;\n    cloned.end = end;\n    cloned.loc = loc;\n    cloned.range = range;\n    cloned.extra = extra;\n    cloned.value = node.value;\n    return cloned;\n  }\n}\nconst unwrapParenthesizedExpression = node => {\n  return node.type === \"ParenthesizedExpression\" ? unwrapParenthesizedExpression(node.expression) : node;\n};\nclass LValParser extends NodeUtils {\n  toAssignable(node, isLHS = false) {\n    var _node$extra, _node$extra3;\n    let parenthesized = undefined;\n    if (node.type === \"ParenthesizedExpression\" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {\n      parenthesized = unwrapParenthesizedExpression(node);\n      if (isLHS) {\n        if (parenthesized.type === \"Identifier\") {\n          this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, node);\n        } else if (parenthesized.type !== \"MemberExpression\" && !this.isOptionalMemberExpression(parenthesized)) {\n          this.raise(Errors.InvalidParenthesizedAssignment, node);\n        }\n      } else {\n        this.raise(Errors.InvalidParenthesizedAssignment, node);\n      }\n    }\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"RestElement\":\n      case \"VoidPattern\":\n        break;\n      case \"ObjectExpression\":\n        this.castNodeTo(node, \"ObjectPattern\");\n        for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {\n          var _node$extra2;\n          const prop = node.properties[i];\n          const isLast = i === last;\n          this.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n          if (isLast && prop.type === \"RestElement\" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {\n            this.raise(Errors.RestTrailingComma, node.extra.trailingCommaLoc);\n          }\n        }\n        break;\n      case \"ObjectProperty\":\n        {\n          const {\n            key,\n            value\n          } = node;\n          if (this.isPrivateName(key)) {\n            this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);\n          }\n          this.toAssignable(value, isLHS);\n          break;\n        }\n      case \"SpreadElement\":\n        {\n          throw new Error(\"Internal @babel/parser error (this is a bug, please report it).\" + \" SpreadElement should be converted by .toAssignable's caller.\");\n        }\n      case \"ArrayExpression\":\n        this.castNodeTo(node, \"ArrayPattern\");\n        this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);\n        break;\n      case \"AssignmentExpression\":\n        if (node.operator !== \"=\") {\n          this.raise(Errors.MissingEqInAssignment, node.left.loc.end);\n        }\n        this.castNodeTo(node, \"AssignmentPattern\");\n        delete node.operator;\n        if (node.left.type === \"VoidPattern\") {\n          this.raise(Errors.VoidPatternInitializer, node.left);\n        }\n        this.toAssignable(node.left, isLHS);\n        break;\n      case \"ParenthesizedExpression\":\n        this.toAssignable(parenthesized, isLHS);\n        break;\n    }\n  }\n  toAssignableObjectExpressionProp(prop, isLast, isLHS) {\n    if (prop.type === \"ObjectMethod\") {\n      this.raise(prop.kind === \"get\" || prop.kind === \"set\" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, prop.key);\n    } else if (prop.type === \"SpreadElement\") {\n      this.castNodeTo(prop, \"RestElement\");\n      const arg = prop.argument;\n      this.checkToRestConversion(arg, false);\n      this.toAssignable(arg, isLHS);\n      if (!isLast) {\n        this.raise(Errors.RestTrailingComma, prop);\n      }\n    } else {\n      this.toAssignable(prop, isLHS);\n    }\n  }\n  toAssignableList(exprList, trailingCommaLoc, isLHS) {\n    const end = exprList.length - 1;\n    for (let i = 0; i <= end; i++) {\n      const elt = exprList[i];\n      if (!elt) continue;\n      this.toAssignableListItem(exprList, i, isLHS);\n      if (elt.type === \"RestElement\") {\n        if (i < end) {\n          this.raise(Errors.RestTrailingComma, elt);\n        } else if (trailingCommaLoc) {\n          this.raise(Errors.RestTrailingComma, trailingCommaLoc);\n        }\n      }\n    }\n  }\n  toAssignableListItem(exprList, index, isLHS) {\n    const node = exprList[index];\n    if (node.type === \"SpreadElement\") {\n      this.castNodeTo(node, \"RestElement\");\n      const arg = node.argument;\n      this.checkToRestConversion(arg, true);\n      this.toAssignable(arg, isLHS);\n    } else {\n      this.toAssignable(node, isLHS);\n    }\n  }\n  isAssignable(node, isBinding) {\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"RestElement\":\n      case \"VoidPattern\":\n        return true;\n      case \"ObjectExpression\":\n        {\n          const last = node.properties.length - 1;\n          return node.properties.every((prop, i) => {\n            return prop.type !== \"ObjectMethod\" && (i === last || prop.type !== \"SpreadElement\") && this.isAssignable(prop);\n          });\n        }\n      case \"ObjectProperty\":\n        return this.isAssignable(node.value);\n      case \"SpreadElement\":\n        return this.isAssignable(node.argument);\n      case \"ArrayExpression\":\n        return node.elements.every(element => element === null || this.isAssignable(element));\n      case \"AssignmentExpression\":\n        return node.operator === \"=\";\n      case \"ParenthesizedExpression\":\n        return this.isAssignable(node.expression);\n      case \"MemberExpression\":\n      case \"OptionalMemberExpression\":\n        return !isBinding;\n      default:\n        return false;\n    }\n  }\n  toReferencedList(exprList, isParenthesizedExpr) {\n    return exprList;\n  }\n  toReferencedListDeep(exprList, isParenthesizedExpr) {\n    this.toReferencedList(exprList, isParenthesizedExpr);\n    for (const expr of exprList) {\n      if ((expr == null ? void 0 : expr.type) === \"ArrayExpression\") {\n        this.toReferencedListDeep(expr.elements);\n      }\n    }\n  }\n  parseSpread(refExpressionErrors) {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, undefined);\n    return this.finishNode(node, \"SpreadElement\");\n  }\n  parseRestBinding() {\n    const node = this.startNode();\n    this.next();\n    const argument = this.parseBindingAtom();\n    if (argument.type === \"VoidPattern\") {\n      this.raise(Errors.UnexpectedVoidPattern, argument);\n    }\n    node.argument = argument;\n    return this.finishNode(node, \"RestElement\");\n  }\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case 0:\n        {\n          const node = this.startNode();\n          this.next();\n          node.elements = this.parseBindingList(3, 93, 1);\n          return this.finishNode(node, \"ArrayPattern\");\n        }\n      case 5:\n        return this.parseObjectLike(8, true);\n      case 88:\n        return this.parseVoidPattern(null);\n    }\n    return this.parseIdentifier();\n  }\n  parseBindingList(close, closeCharCode, flags) {\n    const allowEmpty = flags & 1;\n    const elts = [];\n    let first = true;\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n      }\n      if (allowEmpty && this.match(12)) {\n        elts.push(null);\n      } else if (this.eat(close)) {\n        break;\n      } else if (this.match(21)) {\n        let rest = this.parseRestBinding();\n        if (this.hasPlugin(\"flow\") || flags & 2) {\n          rest = this.parseFunctionParamType(rest);\n        }\n        elts.push(rest);\n        if (!this.checkCommaAfterRest(closeCharCode)) {\n          this.expect(close);\n          break;\n        }\n      } else {\n        const decorators = [];\n        if (flags & 2) {\n          if (this.match(26) && this.hasPlugin(\"decorators\")) {\n            this.raise(Errors.UnsupportedParameterDecorator, this.state.startLoc);\n          }\n          while (this.match(26)) {\n            decorators.push(this.parseDecorator());\n          }\n        }\n        elts.push(this.parseBindingElement(flags, decorators));\n      }\n    }\n    return elts;\n  }\n  parseBindingRestProperty(prop) {\n    this.next();\n    if (this.hasPlugin(\"discardBinding\") && this.match(88)) {\n      prop.argument = this.parseVoidPattern(null);\n      this.raise(Errors.UnexpectedVoidPattern, prop.argument);\n    } else {\n      prop.argument = this.parseIdentifier();\n    }\n    this.checkCommaAfterRest(125);\n    return this.finishNode(prop, \"RestElement\");\n  }\n  parseBindingProperty() {\n    const {\n      type,\n      startLoc\n    } = this.state;\n    if (type === 21) {\n      return this.parseBindingRestProperty(this.startNode());\n    }\n    const prop = this.startNode();\n    if (type === 139) {\n      this.expectPlugin(\"destructuringPrivate\", startLoc);\n      this.classScope.usePrivateName(this.state.value, startLoc);\n      prop.key = this.parsePrivateName();\n    } else {\n      this.parsePropertyName(prop);\n    }\n    prop.method = false;\n    return this.parseObjPropValue(prop, startLoc, false, false, true, false);\n  }\n  parseBindingElement(flags, decorators) {\n    const left = this.parseMaybeDefault();\n    if (this.hasPlugin(\"flow\") || flags & 2) {\n      this.parseFunctionParamType(left);\n    }\n    if (decorators.length) {\n      left.decorators = decorators;\n      this.resetStartLocationFromNode(left, decorators[0]);\n    }\n    const elt = this.parseMaybeDefault(left.loc.start, left);\n    return elt;\n  }\n  parseFunctionParamType(param) {\n    return param;\n  }\n  parseMaybeDefault(startLoc, left) {\n    startLoc != null ? startLoc : startLoc = this.state.startLoc;\n    left = left != null ? left : this.parseBindingAtom();\n    if (!this.eat(29)) return left;\n    const node = this.startNodeAt(startLoc);\n    if (left.type === \"VoidPattern\") {\n      this.raise(Errors.VoidPatternInitializer, left);\n    }\n    node.left = left;\n    node.right = this.parseMaybeAssignAllowIn();\n    return this.finishNode(node, \"AssignmentPattern\");\n  }\n  isValidLVal(type, isUnparenthesizedInAssign, binding) {\n    switch (type) {\n      case \"AssignmentPattern\":\n        return \"left\";\n      case \"RestElement\":\n        return \"argument\";\n      case \"ObjectProperty\":\n        return \"value\";\n      case \"ParenthesizedExpression\":\n        return \"expression\";\n      case \"ArrayPattern\":\n        return \"elements\";\n      case \"ObjectPattern\":\n        return \"properties\";\n      case \"VoidPattern\":\n        return true;\n    }\n    return false;\n  }\n  isOptionalMemberExpression(expression) {\n    return expression.type === \"OptionalMemberExpression\";\n  }\n  checkLVal(expression, ancestor, binding = 64, checkClashes = false, strictModeChanged = false, hasParenthesizedAncestor = false) {\n    var _expression$extra;\n    const type = expression.type;\n    if (this.isObjectMethod(expression)) return;\n    const isOptionalMemberExpression = this.isOptionalMemberExpression(expression);\n    if (isOptionalMemberExpression || type === \"MemberExpression\") {\n      if (isOptionalMemberExpression) {\n        this.expectPlugin(\"optionalChainingAssign\", expression.loc.start);\n        if (ancestor.type !== \"AssignmentExpression\") {\n          this.raise(Errors.InvalidLhsOptionalChaining, expression, {\n            ancestor\n          });\n        }\n      }\n      if (binding !== 64) {\n        this.raise(Errors.InvalidPropertyBindingPattern, expression);\n      }\n      return;\n    }\n    if (type === \"Identifier\") {\n      this.checkIdentifier(expression, binding, strictModeChanged);\n      const {\n        name\n      } = expression;\n      if (checkClashes) {\n        if (checkClashes.has(name)) {\n          this.raise(Errors.ParamDupe, expression);\n        } else {\n          checkClashes.add(name);\n        }\n      }\n      return;\n    } else if (type === \"VoidPattern\" && ancestor.type === \"CatchClause\") {\n      this.raise(Errors.VoidPatternCatchClauseParam, expression);\n    }\n    const validity = this.isValidLVal(type, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === \"AssignmentExpression\", binding);\n    if (validity === true) return;\n    if (validity === false) {\n      const ParseErrorClass = binding === 64 ? Errors.InvalidLhs : Errors.InvalidLhsBinding;\n      this.raise(ParseErrorClass, expression, {\n        ancestor\n      });\n      return;\n    }\n    let key, isParenthesizedExpression;\n    if (typeof validity === \"string\") {\n      key = validity;\n      isParenthesizedExpression = type === \"ParenthesizedExpression\";\n    } else {\n      [key, isParenthesizedExpression] = validity;\n    }\n    const nextAncestor = type === \"ArrayPattern\" || type === \"ObjectPattern\" ? {\n      type\n    } : ancestor;\n    const val = expression[key];\n    if (Array.isArray(val)) {\n      for (const child of val) {\n        if (child) {\n          this.checkLVal(child, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression);\n        }\n      }\n    } else if (val) {\n      this.checkLVal(val, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression);\n    }\n  }\n  checkIdentifier(at, bindingType, strictModeChanged = false) {\n    if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {\n      if (bindingType === 64) {\n        this.raise(Errors.StrictEvalArguments, at, {\n          referenceName: at.name\n        });\n      } else {\n        this.raise(Errors.StrictEvalArgumentsBinding, at, {\n          bindingName: at.name\n        });\n      }\n    }\n    if (bindingType & 8192 && at.name === \"let\") {\n      this.raise(Errors.LetInLexicalBinding, at);\n    }\n    if (!(bindingType & 64)) {\n      this.declareNameFromIdentifier(at, bindingType);\n    }\n  }\n  declareNameFromIdentifier(identifier, binding) {\n    this.scope.declareName(identifier.name, binding, identifier.loc.start);\n  }\n  checkToRestConversion(node, allowPattern) {\n    switch (node.type) {\n      case \"ParenthesizedExpression\":\n        this.checkToRestConversion(node.expression, allowPattern);\n        break;\n      case \"Identifier\":\n      case \"MemberExpression\":\n        break;\n      case \"ArrayExpression\":\n      case \"ObjectExpression\":\n        if (allowPattern) break;\n      default:\n        this.raise(Errors.InvalidRestAssignmentPattern, node);\n    }\n  }\n  checkCommaAfterRest(close) {\n    if (!this.match(12)) {\n      return false;\n    }\n    this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, this.state.startLoc);\n    return true;\n  }\n}\nfunction nonNull(x) {\n  if (x == null) {\n    throw new Error(`Unexpected ${x} value.`);\n  }\n  return x;\n}\nfunction assert(x) {\n  if (!x) {\n    throw new Error(\"Assert fail\");\n  }\n}\nconst TSErrors = ParseErrorEnum`typescript`({\n  AbstractMethodHasImplementation: ({\n    methodName\n  }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,\n  AbstractPropertyHasInitializer: ({\n    propertyName\n  }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,\n  AccessorCannotBeOptional: \"An 'accessor' property cannot be declared optional.\",\n  AccessorCannotDeclareThisParameter: \"'get' and 'set' accessors cannot declare 'this' parameters.\",\n  AccessorCannotHaveTypeParameters: \"An accessor cannot have type parameters.\",\n  ClassMethodHasDeclare: \"Class methods cannot have the 'declare' modifier.\",\n  ClassMethodHasReadonly: \"Class methods cannot have the 'readonly' modifier.\",\n  ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: \"A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.\",\n  ConstructorHasTypeParameters: \"Type parameters cannot appear on a constructor declaration.\",\n  DeclareAccessor: ({\n    kind\n  }) => `'declare' is not allowed in ${kind}ters.`,\n  DeclareClassFieldHasInitializer: \"Initializers are not allowed in ambient contexts.\",\n  DeclareFunctionHasImplementation: \"An implementation cannot be declared in ambient contexts.\",\n  DuplicateAccessibilityModifier: ({\n    modifier\n  }) => `Accessibility modifier already seen: '${modifier}'.`,\n  DuplicateModifier: ({\n    modifier\n  }) => `Duplicate modifier: '${modifier}'.`,\n  EmptyHeritageClauseType: ({\n    token\n  }) => `'${token}' list cannot be empty.`,\n  EmptyTypeArguments: \"Type argument list cannot be empty.\",\n  EmptyTypeParameters: \"Type parameter list cannot be empty.\",\n  ExpectedAmbientAfterExportDeclare: \"'export declare' must be followed by an ambient declaration.\",\n  ImportAliasHasImportType: \"An import alias can not use 'import type'.\",\n  ImportReflectionHasImportType: \"An `import module` declaration can not use `type` modifier\",\n  IncompatibleModifiers: ({\n    modifiers\n  }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,\n  IndexSignatureHasAbstract: \"Index signatures cannot have the 'abstract' modifier.\",\n  IndexSignatureHasAccessibility: ({\n    modifier\n  }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,\n  IndexSignatureHasDeclare: \"Index signatures cannot have the 'declare' modifier.\",\n  IndexSignatureHasOverride: \"'override' modifier cannot appear on an index signature.\",\n  IndexSignatureHasStatic: \"Index signatures cannot have the 'static' modifier.\",\n  InitializerNotAllowedInAmbientContext: \"Initializers are not allowed in ambient contexts.\",\n  InvalidHeritageClauseType: ({\n    token\n  }) => `'${token}' list can only include identifiers or qualified-names with optional type arguments.`,\n  InvalidModifierOnAwaitUsingDeclaration: modifier => `'${modifier}' modifier cannot appear on an await using declaration.`,\n  InvalidModifierOnTypeMember: ({\n    modifier\n  }) => `'${modifier}' modifier cannot appear on a type member.`,\n  InvalidModifierOnTypeParameter: ({\n    modifier\n  }) => `'${modifier}' modifier cannot appear on a type parameter.`,\n  InvalidModifierOnTypeParameterPositions: ({\n    modifier\n  }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,\n  InvalidModifierOnUsingDeclaration: modifier => `'${modifier}' modifier cannot appear on a using declaration.`,\n  InvalidModifiersOrder: ({\n    orderedModifiers\n  }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,\n  InvalidPropertyAccessAfterInstantiationExpression: \"Invalid property access after an instantiation expression. \" + \"You can either wrap the instantiation expression in parentheses, or delete the type arguments.\",\n  InvalidTupleMemberLabel: \"Tuple members must be labeled with a simple identifier.\",\n  MissingInterfaceName: \"'interface' declarations must be followed by an identifier.\",\n  NonAbstractClassHasAbstractMethod: \"Abstract methods can only appear within an abstract class.\",\n  NonClassMethodPropertyHasAbstractModifier: \"'abstract' modifier can only appear on a class, method, or property declaration.\",\n  OptionalTypeBeforeRequired: \"A required element cannot follow an optional element.\",\n  OverrideNotInSubClass: \"This member cannot have an 'override' modifier because its containing class does not extend another class.\",\n  PatternIsOptional: \"A binding pattern parameter cannot be optional in an implementation signature.\",\n  PrivateElementHasAbstract: \"Private elements cannot have the 'abstract' modifier.\",\n  PrivateElementHasAccessibility: ({\n    modifier\n  }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,\n  ReadonlyForMethodSignature: \"'readonly' modifier can only appear on a property declaration or index signature.\",\n  ReservedArrowTypeParam: \"This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.\",\n  ReservedTypeAssertion: \"This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.\",\n  SetAccessorCannotHaveOptionalParameter: \"A 'set' accessor cannot have an optional parameter.\",\n  SetAccessorCannotHaveRestParameter: \"A 'set' accessor cannot have rest parameter.\",\n  SetAccessorCannotHaveReturnType: \"A 'set' accessor cannot have a return type annotation.\",\n  SingleTypeParameterWithoutTrailingComma: ({\n    typeParameterName\n  }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,\n  StaticBlockCannotHaveModifier: \"Static class blocks cannot have any modifier.\",\n  TupleOptionalAfterType: \"A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).\",\n  TypeAnnotationAfterAssign: \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\",\n  TypeImportCannotSpecifyDefaultAndNamed: \"A type-only import can specify a default import or named bindings, but not both.\",\n  TypeModifierIsUsedInTypeExports: \"The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.\",\n  TypeModifierIsUsedInTypeImports: \"The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.\",\n  UnexpectedParameterModifier: \"A parameter property is only allowed in a constructor implementation.\",\n  UnexpectedReadonly: \"'readonly' type modifier is only permitted on array and tuple literal types.\",\n  UnexpectedTypeAnnotation: \"Did not expect a type annotation here.\",\n  UnexpectedTypeCastInParameter: \"Unexpected type cast in parameter position.\",\n  UnsupportedImportTypeArgument: \"Argument in a type import must be a string literal.\",\n  UnsupportedParameterPropertyKind: \"A parameter property may not be declared using a binding pattern.\",\n  UnsupportedSignatureParameterKind: ({\n    type\n  }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`,\n  UsingDeclarationInAmbientContext: kind => `'${kind}' declarations are not allowed in ambient contexts.`\n});\nfunction keywordTypeFromName(value) {\n  switch (value) {\n    case \"any\":\n      return \"TSAnyKeyword\";\n    case \"boolean\":\n      return \"TSBooleanKeyword\";\n    case \"bigint\":\n      return \"TSBigIntKeyword\";\n    case \"never\":\n      return \"TSNeverKeyword\";\n    case \"number\":\n      return \"TSNumberKeyword\";\n    case \"object\":\n      return \"TSObjectKeyword\";\n    case \"string\":\n      return \"TSStringKeyword\";\n    case \"symbol\":\n      return \"TSSymbolKeyword\";\n    case \"undefined\":\n      return \"TSUndefinedKeyword\";\n    case \"unknown\":\n      return \"TSUnknownKeyword\";\n    default:\n      return undefined;\n  }\n}\nfunction tsIsAccessModifier(modifier) {\n  return modifier === \"private\" || modifier === \"public\" || modifier === \"protected\";\n}\nfunction tsIsVarianceAnnotations(modifier) {\n  return modifier === \"in\" || modifier === \"out\";\n}\nvar typescript = superClass => class TypeScriptParserMixin extends superClass {\n  constructor(...args) {\n    super(...args);\n    this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {\n      allowedModifiers: [\"in\", \"out\"],\n      disallowedModifiers: [\"const\", \"public\", \"private\", \"protected\", \"readonly\", \"declare\", \"abstract\", \"override\"],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameter\n    });\n    this.tsParseConstModifier = this.tsParseModifiers.bind(this, {\n      allowedModifiers: [\"const\"],\n      disallowedModifiers: [\"in\", \"out\"],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions\n    });\n    this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {\n      allowedModifiers: [\"in\", \"out\", \"const\"],\n      disallowedModifiers: [\"public\", \"private\", \"protected\", \"readonly\", \"declare\", \"abstract\", \"override\"],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameter\n    });\n  }\n  getScopeHandler() {\n    return TypeScriptScopeHandler;\n  }\n  tsIsIdentifier() {\n    return tokenIsIdentifier(this.state.type);\n  }\n  tsTokenCanFollowModifier() {\n    return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();\n  }\n  tsNextTokenOnSameLineAndCanFollowModifier() {\n    this.next();\n    if (this.hasPrecedingLineBreak()) {\n      return false;\n    }\n    return this.tsTokenCanFollowModifier();\n  }\n  tsNextTokenCanFollowModifier() {\n    if (this.match(106)) {\n      this.next();\n      return this.tsTokenCanFollowModifier();\n    }\n    return this.tsNextTokenOnSameLineAndCanFollowModifier();\n  }\n  tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock, hasSeenStaticModifier) {\n    if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75) {\n      return undefined;\n    }\n    const modifier = this.state.value;\n    if (allowedModifiers.includes(modifier)) {\n      if (hasSeenStaticModifier && this.match(106)) {\n        return undefined;\n      }\n      if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {\n        return undefined;\n      }\n      if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {\n        return modifier;\n      }\n    }\n    return undefined;\n  }\n  tsParseModifiers({\n    allowedModifiers,\n    disallowedModifiers,\n    stopOnStartOfClassStaticBlock,\n    errorTemplate = TSErrors.InvalidModifierOnTypeMember\n  }, modified) {\n    const enforceOrder = (loc, modifier, before, after) => {\n      if (modifier === before && modified[after]) {\n        this.raise(TSErrors.InvalidModifiersOrder, loc, {\n          orderedModifiers: [before, after]\n        });\n      }\n    };\n    const incompatible = (loc, modifier, mod1, mod2) => {\n      if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {\n        this.raise(TSErrors.IncompatibleModifiers, loc, {\n          modifiers: [mod1, mod2]\n        });\n      }\n    };\n    for (;;) {\n      const {\n        startLoc\n      } = this.state;\n      const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock, modified.static);\n      if (!modifier) break;\n      if (tsIsAccessModifier(modifier)) {\n        if (modified.accessibility) {\n          this.raise(TSErrors.DuplicateAccessibilityModifier, startLoc, {\n            modifier\n          });\n        } else {\n          enforceOrder(startLoc, modifier, modifier, \"override\");\n          enforceOrder(startLoc, modifier, modifier, \"static\");\n          enforceOrder(startLoc, modifier, modifier, \"readonly\");\n          modified.accessibility = modifier;\n        }\n      } else if (tsIsVarianceAnnotations(modifier)) {\n        if (modified[modifier]) {\n          this.raise(TSErrors.DuplicateModifier, startLoc, {\n            modifier\n          });\n        }\n        modified[modifier] = true;\n        enforceOrder(startLoc, modifier, \"in\", \"out\");\n      } else {\n        if (hasOwnProperty.call(modified, modifier)) {\n          this.raise(TSErrors.DuplicateModifier, startLoc, {\n            modifier\n          });\n        } else {\n          enforceOrder(startLoc, modifier, \"static\", \"readonly\");\n          enforceOrder(startLoc, modifier, \"static\", \"override\");\n          enforceOrder(startLoc, modifier, \"override\", \"readonly\");\n          enforceOrder(startLoc, modifier, \"abstract\", \"override\");\n          incompatible(startLoc, modifier, \"declare\", \"override\");\n          incompatible(startLoc, modifier, \"static\", \"abstract\");\n        }\n        modified[modifier] = true;\n      }\n      if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {\n        this.raise(errorTemplate, startLoc, {\n          modifier\n        });\n      }\n    }\n  }\n  tsIsListTerminator(kind) {\n    switch (kind) {\n      case \"EnumMembers\":\n      case \"TypeMembers\":\n        return this.match(8);\n      case \"HeritageClauseElement\":\n        return this.match(5);\n      case \"TupleElementTypes\":\n        return this.match(3);\n      case \"TypeParametersOrArguments\":\n        return this.match(48);\n    }\n  }\n  tsParseList(kind, parseElement) {\n    const result = [];\n    while (!this.tsIsListTerminator(kind)) {\n      result.push(parseElement());\n    }\n    return result;\n  }\n  tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {\n    return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));\n  }\n  tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {\n    const result = [];\n    let trailingCommaPos = -1;\n    for (;;) {\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n      trailingCommaPos = -1;\n      const element = parseElement();\n      if (element == null) {\n        return undefined;\n      }\n      result.push(element);\n      if (this.eat(12)) {\n        trailingCommaPos = this.state.lastTokStartLoc.index;\n        continue;\n      }\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n      if (expectSuccess) {\n        this.expect(12);\n      }\n      return undefined;\n    }\n    if (refTrailingCommaPos) {\n      refTrailingCommaPos.value = trailingCommaPos;\n    }\n    return result;\n  }\n  tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {\n    if (!skipFirstToken) {\n      if (bracket) {\n        this.expect(0);\n      } else {\n        this.expect(47);\n      }\n    }\n    const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);\n    if (bracket) {\n      this.expect(3);\n    } else {\n      this.expect(48);\n    }\n    return result;\n  }\n  tsParseImportType() {\n    const node = this.startNode();\n    this.expect(83);\n    this.expect(10);\n    if (!this.match(134)) {\n      this.raise(TSErrors.UnsupportedImportTypeArgument, this.state.startLoc);\n      {\n        node.argument = super.parseExprAtom();\n      }\n    } else {\n      {\n        node.argument = this.parseStringLiteral(this.state.value);\n      }\n    }\n    if (this.eat(12)) {\n      node.options = this.tsParseImportTypeOptions();\n    } else {\n      node.options = null;\n    }\n    this.expect(11);\n    if (this.eat(16)) {\n      node.qualifier = this.tsParseEntityName(1 | 2);\n    }\n    if (this.match(47)) {\n      {\n        node.typeParameters = this.tsParseTypeArguments();\n      }\n    }\n    return this.finishNode(node, \"TSImportType\");\n  }\n  tsParseImportTypeOptions() {\n    const node = this.startNode();\n    this.expect(5);\n    const withProperty = this.startNode();\n    if (this.isContextual(76)) {\n      withProperty.method = false;\n      withProperty.key = this.parseIdentifier(true);\n      withProperty.computed = false;\n      withProperty.shorthand = false;\n    } else {\n      this.unexpected(null, 76);\n    }\n    this.expect(14);\n    withProperty.value = this.tsParseImportTypeWithPropertyValue();\n    node.properties = [this.finishObjectProperty(withProperty)];\n    this.expect(8);\n    return this.finishNode(node, \"ObjectExpression\");\n  }\n  tsParseImportTypeWithPropertyValue() {\n    const node = this.startNode();\n    const properties = [];\n    this.expect(5);\n    while (!this.match(8)) {\n      const type = this.state.type;\n      if (tokenIsIdentifier(type) || type === 134) {\n        properties.push(super.parsePropertyDefinition(null));\n      } else {\n        this.unexpected();\n      }\n      this.eat(12);\n    }\n    node.properties = properties;\n    this.next();\n    return this.finishNode(node, \"ObjectExpression\");\n  }\n  tsParseEntityName(flags) {\n    let entity;\n    if (flags & 1 && this.match(78)) {\n      if (flags & 2) {\n        entity = this.parseIdentifier(true);\n      } else {\n        const node = this.startNode();\n        this.next();\n        entity = this.finishNode(node, \"ThisExpression\");\n      }\n    } else {\n      entity = this.parseIdentifier(!!(flags & 1));\n    }\n    while (this.eat(16)) {\n      const node = this.startNodeAtNode(entity);\n      node.left = entity;\n      node.right = this.parseIdentifier(!!(flags & 1));\n      entity = this.finishNode(node, \"TSQualifiedName\");\n    }\n    return entity;\n  }\n  tsParseTypeReference() {\n    const node = this.startNode();\n    node.typeName = this.tsParseEntityName(1);\n    if (!this.hasPrecedingLineBreak() && this.match(47)) {\n      {\n        node.typeParameters = this.tsParseTypeArguments();\n      }\n    }\n    return this.finishNode(node, \"TSTypeReference\");\n  }\n  tsParseThisTypePredicate(lhs) {\n    this.next();\n    const node = this.startNodeAtNode(lhs);\n    node.parameterName = lhs;\n    node.typeAnnotation = this.tsParseTypeAnnotation(false);\n    node.asserts = false;\n    return this.finishNode(node, \"TSTypePredicate\");\n  }\n  tsParseThisTypeNode() {\n    const node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"TSThisType\");\n  }\n  tsParseTypeQuery() {\n    const node = this.startNode();\n    this.expect(87);\n    if (this.match(83)) {\n      node.exprName = this.tsParseImportType();\n    } else {\n      {\n        node.exprName = this.tsParseEntityName(1 | 2);\n      }\n    }\n    if (!this.hasPrecedingLineBreak() && this.match(47)) {\n      {\n        node.typeParameters = this.tsParseTypeArguments();\n      }\n    }\n    return this.finishNode(node, \"TSTypeQuery\");\n  }\n  tsParseTypeParameter(parseModifiers) {\n    const node = this.startNode();\n    parseModifiers(node);\n    node.name = this.tsParseTypeParameterName();\n    node.constraint = this.tsEatThenParseType(81);\n    node.default = this.tsEatThenParseType(29);\n    return this.finishNode(node, \"TSTypeParameter\");\n  }\n  tsTryParseTypeParameters(parseModifiers) {\n    if (this.match(47)) {\n      return this.tsParseTypeParameters(parseModifiers);\n    }\n  }\n  tsParseTypeParameters(parseModifiers) {\n    const node = this.startNode();\n    if (this.match(47) || this.match(143)) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n    const refTrailingCommaPos = {\n      value: -1\n    };\n    node.params = this.tsParseBracketedList(\"TypeParametersOrArguments\", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);\n    if (node.params.length === 0) {\n      this.raise(TSErrors.EmptyTypeParameters, node);\n    }\n    if (refTrailingCommaPos.value !== -1) {\n      this.addExtra(node, \"trailingComma\", refTrailingCommaPos.value);\n    }\n    return this.finishNode(node, \"TSTypeParameterDeclaration\");\n  }\n  tsFillSignature(returnToken, signature) {\n    const returnTokenRequired = returnToken === 19;\n    const paramsKey = \"parameters\";\n    const returnTypeKey = \"typeAnnotation\";\n    signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    this.expect(10);\n    signature[paramsKey] = this.tsParseBindingListForSignature();\n    if (returnTokenRequired) {\n      signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    } else if (this.match(returnToken)) {\n      signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    }\n  }\n  tsParseBindingListForSignature() {\n    const list = super.parseBindingList(11, 41, 2);\n    for (const pattern of list) {\n      const {\n        type\n      } = pattern;\n      if (type === \"AssignmentPattern\" || type === \"TSParameterProperty\") {\n        this.raise(TSErrors.UnsupportedSignatureParameterKind, pattern, {\n          type\n        });\n      }\n    }\n    return list;\n  }\n  tsParseTypeMemberSemicolon() {\n    if (!this.eat(12) && !this.isLineTerminator()) {\n      this.expect(13);\n    }\n  }\n  tsParseSignatureMember(kind, node) {\n    this.tsFillSignature(14, node);\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, kind);\n  }\n  tsIsUnambiguouslyIndexSignature() {\n    this.next();\n    if (tokenIsIdentifier(this.state.type)) {\n      this.next();\n      return this.match(14);\n    }\n    return false;\n  }\n  tsTryParseIndexSignature(node) {\n    if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {\n      return;\n    }\n    this.expect(0);\n    const id = this.parseIdentifier();\n    id.typeAnnotation = this.tsParseTypeAnnotation();\n    this.resetEndLocation(id);\n    this.expect(3);\n    node.parameters = [id];\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) node.typeAnnotation = type;\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, \"TSIndexSignature\");\n  }\n  tsParsePropertyOrMethodSignature(node, readonly) {\n    if (this.eat(17)) node.optional = true;\n    if (this.match(10) || this.match(47)) {\n      if (readonly) {\n        this.raise(TSErrors.ReadonlyForMethodSignature, node);\n      }\n      const method = node;\n      if (method.kind && this.match(47)) {\n        this.raise(TSErrors.AccessorCannotHaveTypeParameters, this.state.curPosition());\n      }\n      this.tsFillSignature(14, method);\n      this.tsParseTypeMemberSemicolon();\n      const paramsKey = \"parameters\";\n      const returnTypeKey = \"typeAnnotation\";\n      if (method.kind === \"get\") {\n        if (method[paramsKey].length > 0) {\n          this.raise(Errors.BadGetterArity, this.state.curPosition());\n          if (this.isThisParam(method[paramsKey][0])) {\n            this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());\n          }\n        }\n      } else if (method.kind === \"set\") {\n        if (method[paramsKey].length !== 1) {\n          this.raise(Errors.BadSetterArity, this.state.curPosition());\n        } else {\n          const firstParameter = method[paramsKey][0];\n          if (this.isThisParam(firstParameter)) {\n            this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());\n          }\n          if (firstParameter.type === \"Identifier\" && firstParameter.optional) {\n            this.raise(TSErrors.SetAccessorCannotHaveOptionalParameter, this.state.curPosition());\n          }\n          if (firstParameter.type === \"RestElement\") {\n            this.raise(TSErrors.SetAccessorCannotHaveRestParameter, this.state.curPosition());\n          }\n        }\n        if (method[returnTypeKey]) {\n          this.raise(TSErrors.SetAccessorCannotHaveReturnType, method[returnTypeKey]);\n        }\n      } else {\n        method.kind = \"method\";\n      }\n      return this.finishNode(method, \"TSMethodSignature\");\n    } else {\n      const property = node;\n      if (readonly) property.readonly = true;\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) property.typeAnnotation = type;\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(property, \"TSPropertySignature\");\n    }\n  }\n  tsParseTypeMember() {\n    const node = this.startNode();\n    if (this.match(10) || this.match(47)) {\n      return this.tsParseSignatureMember(\"TSCallSignatureDeclaration\", node);\n    }\n    if (this.match(77)) {\n      const id = this.startNode();\n      this.next();\n      if (this.match(10) || this.match(47)) {\n        return this.tsParseSignatureMember(\"TSConstructSignatureDeclaration\", node);\n      } else {\n        node.key = this.createIdentifier(id, \"new\");\n        return this.tsParsePropertyOrMethodSignature(node, false);\n      }\n    }\n    this.tsParseModifiers({\n      allowedModifiers: [\"readonly\"],\n      disallowedModifiers: [\"declare\", \"abstract\", \"private\", \"protected\", \"public\", \"static\", \"override\"]\n    }, node);\n    const idx = this.tsTryParseIndexSignature(node);\n    if (idx) {\n      return idx;\n    }\n    super.parsePropertyName(node);\n    if (!node.computed && node.key.type === \"Identifier\" && (node.key.name === \"get\" || node.key.name === \"set\") && this.tsTokenCanFollowModifier()) {\n      node.kind = node.key.name;\n      super.parsePropertyName(node);\n      if (!this.match(10) && !this.match(47)) {\n        this.unexpected(null, 10);\n      }\n    }\n    return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);\n  }\n  tsParseTypeLiteral() {\n    const node = this.startNode();\n    node.members = this.tsParseObjectTypeMembers();\n    return this.finishNode(node, \"TSTypeLiteral\");\n  }\n  tsParseObjectTypeMembers() {\n    this.expect(5);\n    const members = this.tsParseList(\"TypeMembers\", this.tsParseTypeMember.bind(this));\n    this.expect(8);\n    return members;\n  }\n  tsIsStartOfMappedType() {\n    this.next();\n    if (this.eat(53)) {\n      return this.isContextual(122);\n    }\n    if (this.isContextual(122)) {\n      this.next();\n    }\n    if (!this.match(0)) {\n      return false;\n    }\n    this.next();\n    if (!this.tsIsIdentifier()) {\n      return false;\n    }\n    this.next();\n    return this.match(58);\n  }\n  tsParseMappedType() {\n    const node = this.startNode();\n    this.expect(5);\n    if (this.match(53)) {\n      node.readonly = this.state.value;\n      this.next();\n      this.expectContextual(122);\n    } else if (this.eatContextual(122)) {\n      node.readonly = true;\n    }\n    this.expect(0);\n    {\n      const typeParameter = this.startNode();\n      typeParameter.name = this.tsParseTypeParameterName();\n      typeParameter.constraint = this.tsExpectThenParseType(58);\n      node.typeParameter = this.finishNode(typeParameter, \"TSTypeParameter\");\n    }\n    node.nameType = this.eatContextual(93) ? this.tsParseType() : null;\n    this.expect(3);\n    if (this.match(53)) {\n      node.optional = this.state.value;\n      this.next();\n      this.expect(17);\n    } else if (this.eat(17)) {\n      node.optional = true;\n    }\n    node.typeAnnotation = this.tsTryParseType();\n    this.semicolon();\n    this.expect(8);\n    return this.finishNode(node, \"TSMappedType\");\n  }\n  tsParseTupleType() {\n    const node = this.startNode();\n    node.elementTypes = this.tsParseBracketedList(\"TupleElementTypes\", this.tsParseTupleElementType.bind(this), true, false);\n    let seenOptionalElement = false;\n    node.elementTypes.forEach(elementNode => {\n      const {\n        type\n      } = elementNode;\n      if (seenOptionalElement && type !== \"TSRestType\" && type !== \"TSOptionalType\" && !(type === \"TSNamedTupleMember\" && elementNode.optional)) {\n        this.raise(TSErrors.OptionalTypeBeforeRequired, elementNode);\n      }\n      seenOptionalElement || (seenOptionalElement = type === \"TSNamedTupleMember\" && elementNode.optional || type === \"TSOptionalType\");\n    });\n    return this.finishNode(node, \"TSTupleType\");\n  }\n  tsParseTupleElementType() {\n    const restStartLoc = this.state.startLoc;\n    const rest = this.eat(21);\n    const {\n      startLoc\n    } = this.state;\n    let labeled;\n    let label;\n    let optional;\n    let type;\n    const isWord = tokenIsKeywordOrIdentifier(this.state.type);\n    const chAfterWord = isWord ? this.lookaheadCharCode() : null;\n    if (chAfterWord === 58) {\n      labeled = true;\n      optional = false;\n      label = this.parseIdentifier(true);\n      this.expect(14);\n      type = this.tsParseType();\n    } else if (chAfterWord === 63) {\n      optional = true;\n      const wordName = this.state.value;\n      const typeOrLabel = this.tsParseNonArrayType();\n      if (this.lookaheadCharCode() === 58) {\n        labeled = true;\n        label = this.createIdentifier(this.startNodeAt(startLoc), wordName);\n        this.expect(17);\n        this.expect(14);\n        type = this.tsParseType();\n      } else {\n        labeled = false;\n        type = typeOrLabel;\n        this.expect(17);\n      }\n    } else {\n      type = this.tsParseType();\n      optional = this.eat(17);\n      labeled = this.eat(14);\n    }\n    if (labeled) {\n      let labeledNode;\n      if (label) {\n        labeledNode = this.startNodeAt(startLoc);\n        labeledNode.optional = optional;\n        labeledNode.label = label;\n        labeledNode.elementType = type;\n        if (this.eat(17)) {\n          labeledNode.optional = true;\n          this.raise(TSErrors.TupleOptionalAfterType, this.state.lastTokStartLoc);\n        }\n      } else {\n        labeledNode = this.startNodeAt(startLoc);\n        labeledNode.optional = optional;\n        this.raise(TSErrors.InvalidTupleMemberLabel, type);\n        labeledNode.label = type;\n        labeledNode.elementType = this.tsParseType();\n      }\n      type = this.finishNode(labeledNode, \"TSNamedTupleMember\");\n    } else if (optional) {\n      const optionalTypeNode = this.startNodeAt(startLoc);\n      optionalTypeNode.typeAnnotation = type;\n      type = this.finishNode(optionalTypeNode, \"TSOptionalType\");\n    }\n    if (rest) {\n      const restNode = this.startNodeAt(restStartLoc);\n      restNode.typeAnnotation = type;\n      type = this.finishNode(restNode, \"TSRestType\");\n    }\n    return type;\n  }\n  tsParseParenthesizedType() {\n    const node = this.startNode();\n    this.expect(10);\n    node.typeAnnotation = this.tsParseType();\n    this.expect(11);\n    return this.finishNode(node, \"TSParenthesizedType\");\n  }\n  tsParseFunctionOrConstructorType(type, abstract) {\n    const node = this.startNode();\n    if (type === \"TSConstructorType\") {\n      node.abstract = !!abstract;\n      if (abstract) this.next();\n      this.next();\n    }\n    this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node));\n    return this.finishNode(node, type);\n  }\n  tsParseLiteralTypeNode() {\n    const node = this.startNode();\n    switch (this.state.type) {\n      case 135:\n      case 136:\n      case 134:\n      case 85:\n      case 86:\n        node.literal = super.parseExprAtom();\n        break;\n      default:\n        this.unexpected();\n    }\n    return this.finishNode(node, \"TSLiteralType\");\n  }\n  tsParseTemplateLiteralType() {\n    {\n      const node = this.startNode();\n      node.literal = super.parseTemplate(false);\n      return this.finishNode(node, \"TSLiteralType\");\n    }\n  }\n  parseTemplateSubstitution() {\n    if (this.state.inType) return this.tsParseType();\n    return super.parseTemplateSubstitution();\n  }\n  tsParseThisTypeOrThisTypePredicate() {\n    const thisKeyword = this.tsParseThisTypeNode();\n    if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {\n      return this.tsParseThisTypePredicate(thisKeyword);\n    } else {\n      return thisKeyword;\n    }\n  }\n  tsParseNonArrayType() {\n    switch (this.state.type) {\n      case 134:\n      case 135:\n      case 136:\n      case 85:\n      case 86:\n        return this.tsParseLiteralTypeNode();\n      case 53:\n        if (this.state.value === \"-\") {\n          const node = this.startNode();\n          const nextToken = this.lookahead();\n          if (nextToken.type !== 135 && nextToken.type !== 136) {\n            this.unexpected();\n          }\n          node.literal = this.parseMaybeUnary();\n          return this.finishNode(node, \"TSLiteralType\");\n        }\n        break;\n      case 78:\n        return this.tsParseThisTypeOrThisTypePredicate();\n      case 87:\n        return this.tsParseTypeQuery();\n      case 83:\n        return this.tsParseImportType();\n      case 5:\n        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();\n      case 0:\n        return this.tsParseTupleType();\n      case 10:\n        return this.tsParseParenthesizedType();\n      case 25:\n      case 24:\n        return this.tsParseTemplateLiteralType();\n      default:\n        {\n          const {\n            type\n          } = this.state;\n          if (tokenIsIdentifier(type) || type === 88 || type === 84) {\n            const nodeType = type === 88 ? \"TSVoidKeyword\" : type === 84 ? \"TSNullKeyword\" : keywordTypeFromName(this.state.value);\n            if (nodeType !== undefined && this.lookaheadCharCode() !== 46) {\n              const node = this.startNode();\n              this.next();\n              return this.finishNode(node, nodeType);\n            }\n            return this.tsParseTypeReference();\n          }\n        }\n    }\n    this.unexpected();\n  }\n  tsParseArrayTypeOrHigher() {\n    const {\n      startLoc\n    } = this.state;\n    let type = this.tsParseNonArrayType();\n    while (!this.hasPrecedingLineBreak() && this.eat(0)) {\n      if (this.match(3)) {\n        const node = this.startNodeAt(startLoc);\n        node.elementType = type;\n        this.expect(3);\n        type = this.finishNode(node, \"TSArrayType\");\n      } else {\n        const node = this.startNodeAt(startLoc);\n        node.objectType = type;\n        node.indexType = this.tsParseType();\n        this.expect(3);\n        type = this.finishNode(node, \"TSIndexedAccessType\");\n      }\n    }\n    return type;\n  }\n  tsParseTypeOperator() {\n    const node = this.startNode();\n    const operator = this.state.value;\n    this.next();\n    node.operator = operator;\n    node.typeAnnotation = this.tsParseTypeOperatorOrHigher();\n    if (operator === \"readonly\") {\n      this.tsCheckTypeAnnotationForReadOnly(node);\n    }\n    return this.finishNode(node, \"TSTypeOperator\");\n  }\n  tsCheckTypeAnnotationForReadOnly(node) {\n    switch (node.typeAnnotation.type) {\n      case \"TSTupleType\":\n      case \"TSArrayType\":\n        return;\n      default:\n        this.raise(TSErrors.UnexpectedReadonly, node);\n    }\n  }\n  tsParseInferType() {\n    const node = this.startNode();\n    this.expectContextual(115);\n    const typeParameter = this.startNode();\n    typeParameter.name = this.tsParseTypeParameterName();\n    typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());\n    node.typeParameter = this.finishNode(typeParameter, \"TSTypeParameter\");\n    return this.finishNode(node, \"TSInferType\");\n  }\n  tsParseConstraintForInferType() {\n    if (this.eat(81)) {\n      const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());\n      if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {\n        return constraint;\n      }\n    }\n  }\n  tsParseTypeOperatorOrHigher() {\n    const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;\n    return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());\n  }\n  tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {\n    const node = this.startNode();\n    const hasLeadingOperator = this.eat(operator);\n    const types = [];\n    do {\n      types.push(parseConstituentType());\n    } while (this.eat(operator));\n    if (types.length === 1 && !hasLeadingOperator) {\n      return types[0];\n    }\n    node.types = types;\n    return this.finishNode(node, kind);\n  }\n  tsParseIntersectionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType(\"TSIntersectionType\", this.tsParseTypeOperatorOrHigher.bind(this), 45);\n  }\n  tsParseUnionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType(\"TSUnionType\", this.tsParseIntersectionTypeOrHigher.bind(this), 43);\n  }\n  tsIsStartOfFunctionType() {\n    if (this.match(47)) {\n      return true;\n    }\n    return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));\n  }\n  tsSkipParameterStart() {\n    if (tokenIsIdentifier(this.state.type) || this.match(78)) {\n      this.next();\n      return true;\n    }\n    if (this.match(5)) {\n      const {\n        errors\n      } = this.state;\n      const previousErrorCount = errors.length;\n      try {\n        this.parseObjectLike(8, true);\n        return errors.length === previousErrorCount;\n      } catch (_unused) {\n        return false;\n      }\n    }\n    if (this.match(0)) {\n      this.next();\n      const {\n        errors\n      } = this.state;\n      const previousErrorCount = errors.length;\n      try {\n        super.parseBindingList(3, 93, 1);\n        return errors.length === previousErrorCount;\n      } catch (_unused2) {\n        return false;\n      }\n    }\n    return false;\n  }\n  tsIsUnambiguouslyStartOfFunctionType() {\n    this.next();\n    if (this.match(11) || this.match(21)) {\n      return true;\n    }\n    if (this.tsSkipParameterStart()) {\n      if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {\n        return true;\n      }\n      if (this.match(11)) {\n        this.next();\n        if (this.match(19)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  tsParseTypeOrTypePredicateAnnotation(returnToken) {\n    return this.tsInType(() => {\n      const t = this.startNode();\n      this.expect(returnToken);\n      const node = this.startNode();\n      const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));\n      if (asserts && this.match(78)) {\n        let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();\n        if (thisTypePredicate.type === \"TSThisType\") {\n          node.parameterName = thisTypePredicate;\n          node.asserts = true;\n          node.typeAnnotation = null;\n          thisTypePredicate = this.finishNode(node, \"TSTypePredicate\");\n        } else {\n          this.resetStartLocationFromNode(thisTypePredicate, node);\n          thisTypePredicate.asserts = true;\n        }\n        t.typeAnnotation = thisTypePredicate;\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n      const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));\n      if (!typePredicateVariable) {\n        if (!asserts) {\n          return this.tsParseTypeAnnotation(false, t);\n        }\n        node.parameterName = this.parseIdentifier();\n        node.asserts = asserts;\n        node.typeAnnotation = null;\n        t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n      const type = this.tsParseTypeAnnotation(false);\n      node.parameterName = typePredicateVariable;\n      node.typeAnnotation = type;\n      node.asserts = asserts;\n      t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n      return this.finishNode(t, \"TSTypeAnnotation\");\n    });\n  }\n  tsTryParseTypeOrTypePredicateAnnotation() {\n    if (this.match(14)) {\n      return this.tsParseTypeOrTypePredicateAnnotation(14);\n    }\n  }\n  tsTryParseTypeAnnotation() {\n    if (this.match(14)) {\n      return this.tsParseTypeAnnotation();\n    }\n  }\n  tsTryParseType() {\n    return this.tsEatThenParseType(14);\n  }\n  tsParseTypePredicatePrefix() {\n    const id = this.parseIdentifier();\n    if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {\n      this.next();\n      return id;\n    }\n  }\n  tsParseTypePredicateAsserts() {\n    if (this.state.type !== 109) {\n      return false;\n    }\n    const containsEsc = this.state.containsEsc;\n    this.next();\n    if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {\n      return false;\n    }\n    if (containsEsc) {\n      this.raise(Errors.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {\n        reservedWord: \"asserts\"\n      });\n    }\n    return true;\n  }\n  tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {\n    this.tsInType(() => {\n      if (eatColon) this.expect(14);\n      t.typeAnnotation = this.tsParseType();\n    });\n    return this.finishNode(t, \"TSTypeAnnotation\");\n  }\n  tsParseType() {\n    assert(this.state.inType);\n    const type = this.tsParseNonConditionalType();\n    if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {\n      return type;\n    }\n    const node = this.startNodeAtNode(type);\n    node.checkType = type;\n    node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());\n    this.expect(17);\n    node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());\n    this.expect(14);\n    node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());\n    return this.finishNode(node, \"TSConditionalType\");\n  }\n  isAbstractConstructorSignature() {\n    return this.isContextual(124) && this.isLookaheadContextual(\"new\");\n  }\n  tsParseNonConditionalType() {\n    if (this.tsIsStartOfFunctionType()) {\n      return this.tsParseFunctionOrConstructorType(\"TSFunctionType\");\n    }\n    if (this.match(77)) {\n      return this.tsParseFunctionOrConstructorType(\"TSConstructorType\");\n    } else if (this.isAbstractConstructorSignature()) {\n      return this.tsParseFunctionOrConstructorType(\"TSConstructorType\", true);\n    }\n    return this.tsParseUnionTypeOrHigher();\n  }\n  tsParseTypeAssertion() {\n    if (this.getPluginOption(\"typescript\", \"disallowAmbiguousJSXLike\")) {\n      this.raise(TSErrors.ReservedTypeAssertion, this.state.startLoc);\n    }\n    const node = this.startNode();\n    node.typeAnnotation = this.tsInType(() => {\n      this.next();\n      return this.match(75) ? this.tsParseTypeReference() : this.tsParseType();\n    });\n    this.expect(48);\n    node.expression = this.parseMaybeUnary();\n    return this.finishNode(node, \"TSTypeAssertion\");\n  }\n  tsParseHeritageClause(token) {\n    const originalStartLoc = this.state.startLoc;\n    const delimitedList = this.tsParseDelimitedList(\"HeritageClauseElement\", () => {\n      {\n        const node = this.startNode();\n        node.expression = this.tsParseEntityName(1 | 2);\n        if (this.match(47)) {\n          node.typeParameters = this.tsParseTypeArguments();\n        }\n        return this.finishNode(node, \"TSExpressionWithTypeArguments\");\n      }\n    });\n    if (!delimitedList.length) {\n      this.raise(TSErrors.EmptyHeritageClauseType, originalStartLoc, {\n        token\n      });\n    }\n    return delimitedList;\n  }\n  tsParseInterfaceDeclaration(node, properties = {}) {\n    if (this.hasFollowingLineBreak()) return null;\n    this.expectContextual(129);\n    if (properties.declare) node.declare = true;\n    if (tokenIsIdentifier(this.state.type)) {\n      node.id = this.parseIdentifier();\n      this.checkIdentifier(node.id, 130);\n    } else {\n      node.id = null;\n      this.raise(TSErrors.MissingInterfaceName, this.state.startLoc);\n    }\n    node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);\n    if (this.eat(81)) {\n      node.extends = this.tsParseHeritageClause(\"extends\");\n    }\n    const body = this.startNode();\n    body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));\n    node.body = this.finishNode(body, \"TSInterfaceBody\");\n    return this.finishNode(node, \"TSInterfaceDeclaration\");\n  }\n  tsParseTypeAliasDeclaration(node) {\n    node.id = this.parseIdentifier();\n    this.checkIdentifier(node.id, 2);\n    node.typeAnnotation = this.tsInType(() => {\n      node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers);\n      this.expect(29);\n      if (this.isContextual(114) && this.lookaheadCharCode() !== 46) {\n        const node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"TSIntrinsicKeyword\");\n      }\n      return this.tsParseType();\n    });\n    this.semicolon();\n    return this.finishNode(node, \"TSTypeAliasDeclaration\");\n  }\n  tsInTopLevelContext(cb) {\n    if (this.curContext() !== types.brace) {\n      const oldContext = this.state.context;\n      this.state.context = [oldContext[0]];\n      try {\n        return cb();\n      } finally {\n        this.state.context = oldContext;\n      }\n    } else {\n      return cb();\n    }\n  }\n  tsInType(cb) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    try {\n      return cb();\n    } finally {\n      this.state.inType = oldInType;\n    }\n  }\n  tsInDisallowConditionalTypesContext(cb) {\n    const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;\n    this.state.inDisallowConditionalTypesContext = true;\n    try {\n      return cb();\n    } finally {\n      this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n    }\n  }\n  tsInAllowConditionalTypesContext(cb) {\n    const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;\n    this.state.inDisallowConditionalTypesContext = false;\n    try {\n      return cb();\n    } finally {\n      this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n    }\n  }\n  tsEatThenParseType(token) {\n    if (this.match(token)) {\n      return this.tsNextThenParseType();\n    }\n  }\n  tsExpectThenParseType(token) {\n    return this.tsInType(() => {\n      this.expect(token);\n      return this.tsParseType();\n    });\n  }\n  tsNextThenParseType() {\n    return this.tsInType(() => {\n      this.next();\n      return this.tsParseType();\n    });\n  }\n  tsParseEnumMember() {\n    const node = this.startNode();\n    node.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);\n    if (this.eat(29)) {\n      node.initializer = super.parseMaybeAssignAllowIn();\n    }\n    return this.finishNode(node, \"TSEnumMember\");\n  }\n  tsParseEnumDeclaration(node, properties = {}) {\n    if (properties.const) node.const = true;\n    if (properties.declare) node.declare = true;\n    this.expectContextual(126);\n    node.id = this.parseIdentifier();\n    this.checkIdentifier(node.id, node.const ? 8971 : 8459);\n    {\n      this.expect(5);\n      node.members = this.tsParseDelimitedList(\"EnumMembers\", this.tsParseEnumMember.bind(this));\n      this.expect(8);\n    }\n    return this.finishNode(node, \"TSEnumDeclaration\");\n  }\n  tsParseEnumBody() {\n    const node = this.startNode();\n    this.expect(5);\n    node.members = this.tsParseDelimitedList(\"EnumMembers\", this.tsParseEnumMember.bind(this));\n    this.expect(8);\n    return this.finishNode(node, \"TSEnumBody\");\n  }\n  tsParseModuleBlock() {\n    const node = this.startNode();\n    this.scope.enter(0);\n    this.expect(5);\n    super.parseBlockOrModuleBlockBody(node.body = [], undefined, true, 8);\n    this.scope.exit();\n    return this.finishNode(node, \"TSModuleBlock\");\n  }\n  tsParseModuleOrNamespaceDeclaration(node, nested = false) {\n    node.id = this.parseIdentifier();\n    if (!nested) {\n      this.checkIdentifier(node.id, 1024);\n    }\n    if (this.eat(16)) {\n      const inner = this.startNode();\n      this.tsParseModuleOrNamespaceDeclaration(inner, true);\n      node.body = inner;\n    } else {\n      this.scope.enter(1024);\n      this.prodParam.enter(0);\n      node.body = this.tsParseModuleBlock();\n      this.prodParam.exit();\n      this.scope.exit();\n    }\n    return this.finishNode(node, \"TSModuleDeclaration\");\n  }\n  tsParseAmbientExternalModuleDeclaration(node) {\n    if (this.isContextual(112)) {\n      node.kind = \"global\";\n      {\n        node.global = true;\n      }\n      node.id = this.parseIdentifier();\n    } else if (this.match(134)) {\n      node.kind = \"module\";\n      node.id = super.parseStringLiteral(this.state.value);\n    } else {\n      this.unexpected();\n    }\n    if (this.match(5)) {\n      this.scope.enter(1024);\n      this.prodParam.enter(0);\n      node.body = this.tsParseModuleBlock();\n      this.prodParam.exit();\n      this.scope.exit();\n    } else {\n      this.semicolon();\n    }\n    return this.finishNode(node, \"TSModuleDeclaration\");\n  }\n  tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, isExport) {\n    {\n      node.isExport = isExport || false;\n    }\n    node.id = maybeDefaultIdentifier || this.parseIdentifier();\n    this.checkIdentifier(node.id, 4096);\n    this.expect(29);\n    const moduleReference = this.tsParseModuleReference();\n    if (node.importKind === \"type\" && moduleReference.type !== \"TSExternalModuleReference\") {\n      this.raise(TSErrors.ImportAliasHasImportType, moduleReference);\n    }\n    node.moduleReference = moduleReference;\n    this.semicolon();\n    return this.finishNode(node, \"TSImportEqualsDeclaration\");\n  }\n  tsIsExternalModuleReference() {\n    return this.isContextual(119) && this.lookaheadCharCode() === 40;\n  }\n  tsParseModuleReference() {\n    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(0);\n  }\n  tsParseExternalModuleReference() {\n    const node = this.startNode();\n    this.expectContextual(119);\n    this.expect(10);\n    if (!this.match(134)) {\n      this.unexpected();\n    }\n    node.expression = super.parseExprAtom();\n    this.expect(11);\n    this.sawUnambiguousESM = true;\n    return this.finishNode(node, \"TSExternalModuleReference\");\n  }\n  tsLookAhead(f) {\n    const state = this.state.clone();\n    const res = f();\n    this.state = state;\n    return res;\n  }\n  tsTryParseAndCatch(f) {\n    const result = this.tryParse(abort => f() || abort());\n    if (result.aborted || !result.node) return;\n    if (result.error) this.state = result.failState;\n    return result.node;\n  }\n  tsTryParse(f) {\n    const state = this.state.clone();\n    const result = f();\n    if (result !== undefined && result !== false) {\n      return result;\n    }\n    this.state = state;\n  }\n  tsTryParseDeclare(node) {\n    if (this.isLineTerminator()) {\n      return;\n    }\n    const startType = this.state.type;\n    return this.tsInAmbientContext(() => {\n      switch (startType) {\n        case 68:\n          node.declare = true;\n          return super.parseFunctionStatement(node, false, false);\n        case 80:\n          node.declare = true;\n          return this.parseClass(node, true, false);\n        case 126:\n          return this.tsParseEnumDeclaration(node, {\n            declare: true\n          });\n        case 112:\n          return this.tsParseAmbientExternalModuleDeclaration(node);\n        case 100:\n          if (this.state.containsEsc) {\n            return;\n          }\n        case 75:\n        case 74:\n          if (!this.match(75) || !this.isLookaheadContextual(\"enum\")) {\n            node.declare = true;\n            return this.parseVarStatement(node, this.state.value, true);\n          }\n          this.expect(75);\n          return this.tsParseEnumDeclaration(node, {\n            const: true,\n            declare: true\n          });\n        case 107:\n          if (this.isUsing()) {\n            this.raise(TSErrors.InvalidModifierOnUsingDeclaration, this.state.startLoc, \"declare\");\n            node.declare = true;\n            return this.parseVarStatement(node, \"using\", true);\n          }\n          break;\n        case 96:\n          if (this.isAwaitUsing()) {\n            this.raise(TSErrors.InvalidModifierOnAwaitUsingDeclaration, this.state.startLoc, \"declare\");\n            node.declare = true;\n            this.next();\n            return this.parseVarStatement(node, \"await using\", true);\n          }\n          break;\n        case 129:\n          {\n            const result = this.tsParseInterfaceDeclaration(node, {\n              declare: true\n            });\n            if (result) return result;\n          }\n        default:\n          if (tokenIsIdentifier(startType)) {\n            return this.tsParseDeclaration(node, this.state.value, true, null);\n          }\n      }\n    });\n  }\n  tsTryParseExportDeclaration() {\n    return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);\n  }\n  tsParseExpressionStatement(node, expr, decorators) {\n    switch (expr.name) {\n      case \"declare\":\n        {\n          const declaration = this.tsTryParseDeclare(node);\n          if (declaration) {\n            declaration.declare = true;\n          }\n          return declaration;\n        }\n      case \"global\":\n        if (this.match(5)) {\n          this.scope.enter(1024);\n          this.prodParam.enter(0);\n          const mod = node;\n          mod.kind = \"global\";\n          {\n            node.global = true;\n          }\n          mod.id = expr;\n          mod.body = this.tsParseModuleBlock();\n          this.scope.exit();\n          this.prodParam.exit();\n          return this.finishNode(mod, \"TSModuleDeclaration\");\n        }\n        break;\n      default:\n        return this.tsParseDeclaration(node, expr.name, false, decorators);\n    }\n  }\n  tsParseDeclaration(node, value, next, decorators) {\n    switch (value) {\n      case \"abstract\":\n        if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {\n          return this.tsParseAbstractDeclaration(node, decorators);\n        }\n        break;\n      case \"module\":\n        if (this.tsCheckLineTerminator(next)) {\n          if (this.match(134)) {\n            return this.tsParseAmbientExternalModuleDeclaration(node);\n          } else if (tokenIsIdentifier(this.state.type)) {\n            node.kind = \"module\";\n            return this.tsParseModuleOrNamespaceDeclaration(node);\n          }\n        }\n        break;\n      case \"namespace\":\n        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {\n          node.kind = \"namespace\";\n          return this.tsParseModuleOrNamespaceDeclaration(node);\n        }\n        break;\n      case \"type\":\n        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {\n          return this.tsParseTypeAliasDeclaration(node);\n        }\n        break;\n    }\n  }\n  tsCheckLineTerminator(next) {\n    if (next) {\n      if (this.hasFollowingLineBreak()) return false;\n      this.next();\n      return true;\n    }\n    return !this.isLineTerminator();\n  }\n  tsTryParseGenericAsyncArrowFunction(startLoc) {\n    if (!this.match(47)) return;\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = true;\n    const res = this.tsTryParseAndCatch(() => {\n      const node = this.startNodeAt(startLoc);\n      node.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);\n      super.parseFunctionParams(node);\n      node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();\n      this.expect(19);\n      return node;\n    });\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    if (!res) return;\n    return super.parseArrowExpression(res, null, true);\n  }\n  tsParseTypeArgumentsInExpression() {\n    if (this.reScan_lt() !== 47) return;\n    return this.tsParseTypeArguments();\n  }\n  tsParseTypeArguments() {\n    const node = this.startNode();\n    node.params = this.tsInType(() => this.tsInTopLevelContext(() => {\n      this.expect(47);\n      return this.tsParseDelimitedList(\"TypeParametersOrArguments\", this.tsParseType.bind(this));\n    }));\n    if (node.params.length === 0) {\n      this.raise(TSErrors.EmptyTypeArguments, node);\n    } else if (!this.state.inType && this.curContext() === types.brace) {\n      this.reScan_lt_gt();\n    }\n    this.expect(48);\n    return this.finishNode(node, \"TSTypeParameterInstantiation\");\n  }\n  tsIsDeclarationStart() {\n    return tokenIsTSDeclarationStart(this.state.type);\n  }\n  isExportDefaultSpecifier() {\n    if (this.tsIsDeclarationStart()) return false;\n    return super.isExportDefaultSpecifier();\n  }\n  parseBindingElement(flags, decorators) {\n    const startLoc = decorators.length ? decorators[0].loc.start : this.state.startLoc;\n    const modified = {};\n    this.tsParseModifiers({\n      allowedModifiers: [\"public\", \"private\", \"protected\", \"override\", \"readonly\"]\n    }, modified);\n    const accessibility = modified.accessibility;\n    const override = modified.override;\n    const readonly = modified.readonly;\n    if (!(flags & 4) && (accessibility || readonly || override)) {\n      this.raise(TSErrors.UnexpectedParameterModifier, startLoc);\n    }\n    const left = this.parseMaybeDefault();\n    if (flags & 2) {\n      this.parseFunctionParamType(left);\n    }\n    const elt = this.parseMaybeDefault(left.loc.start, left);\n    if (accessibility || readonly || override) {\n      const pp = this.startNodeAt(startLoc);\n      if (decorators.length) {\n        pp.decorators = decorators;\n      }\n      if (accessibility) pp.accessibility = accessibility;\n      if (readonly) pp.readonly = readonly;\n      if (override) pp.override = override;\n      if (elt.type !== \"Identifier\" && elt.type !== \"AssignmentPattern\") {\n        this.raise(TSErrors.UnsupportedParameterPropertyKind, pp);\n      }\n      pp.parameter = elt;\n      return this.finishNode(pp, \"TSParameterProperty\");\n    }\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n    return elt;\n  }\n  isSimpleParameter(node) {\n    return node.type === \"TSParameterProperty\" && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);\n  }\n  tsDisallowOptionalPattern(node) {\n    for (const param of node.params) {\n      if (param.type !== \"Identifier\" && param.optional && !this.state.isAmbientContext) {\n        this.raise(TSErrors.PatternIsOptional, param);\n      }\n    }\n  }\n  setArrowFunctionParameters(node, params, trailingCommaLoc) {\n    super.setArrowFunctionParameters(node, params, trailingCommaLoc);\n    this.tsDisallowOptionalPattern(node);\n  }\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    if (this.match(14)) {\n      node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);\n    }\n    const bodilessType = type === \"FunctionDeclaration\" ? \"TSDeclareFunction\" : type === \"ClassMethod\" || type === \"ClassPrivateMethod\" ? \"TSDeclareMethod\" : undefined;\n    if (bodilessType && !this.match(5) && this.isLineTerminator()) {\n      return this.finishNode(node, bodilessType);\n    }\n    if (bodilessType === \"TSDeclareFunction\" && this.state.isAmbientContext) {\n      this.raise(TSErrors.DeclareFunctionHasImplementation, node);\n      if (node.declare) {\n        return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);\n      }\n    }\n    this.tsDisallowOptionalPattern(node);\n    return super.parseFunctionBodyAndFinish(node, type, isMethod);\n  }\n  registerFunctionStatementId(node) {\n    if (!node.body && node.id) {\n      this.checkIdentifier(node.id, 1024);\n    } else {\n      super.registerFunctionStatementId(node);\n    }\n  }\n  tsCheckForInvalidTypeCasts(items) {\n    items.forEach(node => {\n      if ((node == null ? void 0 : node.type) === \"TSTypeCastExpression\") {\n        this.raise(TSErrors.UnexpectedTypeAnnotation, node.typeAnnotation);\n      }\n    });\n  }\n  toReferencedList(exprList, isInParens) {\n    this.tsCheckForInvalidTypeCasts(exprList);\n    return exprList;\n  }\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n    const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);\n    if (node.type === \"ArrayExpression\") {\n      this.tsCheckForInvalidTypeCasts(node.elements);\n    }\n    return node;\n  }\n  parseSubscript(base, startLoc, noCalls, state) {\n    if (!this.hasPrecedingLineBreak() && this.match(35)) {\n      this.state.canStartJSXElement = false;\n      this.next();\n      const nonNullExpression = this.startNodeAt(startLoc);\n      nonNullExpression.expression = base;\n      return this.finishNode(nonNullExpression, \"TSNonNullExpression\");\n    }\n    let isOptionalCall = false;\n    if (this.match(18) && this.lookaheadCharCode() === 60) {\n      if (noCalls) {\n        state.stop = true;\n        return base;\n      }\n      state.optionalChainMember = isOptionalCall = true;\n      this.next();\n    }\n    if (this.match(47) || this.match(51)) {\n      let missingParenErrorLoc;\n      const result = this.tsTryParseAndCatch(() => {\n        if (!noCalls && this.atPossibleAsyncArrow(base)) {\n          const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);\n          if (asyncArrowFn) {\n            return asyncArrowFn;\n          }\n        }\n        const typeArguments = this.tsParseTypeArgumentsInExpression();\n        if (!typeArguments) return;\n        if (isOptionalCall && !this.match(10)) {\n          missingParenErrorLoc = this.state.curPosition();\n          return;\n        }\n        if (tokenIsTemplate(this.state.type)) {\n          const result = super.parseTaggedTemplateExpression(base, startLoc, state);\n          {\n            result.typeParameters = typeArguments;\n          }\n          return result;\n        }\n        if (!noCalls && this.eat(10)) {\n          const node = this.startNodeAt(startLoc);\n          node.callee = base;\n          node.arguments = this.parseCallExpressionArguments();\n          this.tsCheckForInvalidTypeCasts(node.arguments);\n          {\n            node.typeParameters = typeArguments;\n          }\n          if (state.optionalChainMember) {\n            node.optional = isOptionalCall;\n          }\n          return this.finishCallExpression(node, state.optionalChainMember);\n        }\n        const tokenType = this.state.type;\n        if (tokenType === 48 || tokenType === 52 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()) {\n          return;\n        }\n        const node = this.startNodeAt(startLoc);\n        node.expression = base;\n        {\n          node.typeParameters = typeArguments;\n        }\n        return this.finishNode(node, \"TSInstantiationExpression\");\n      });\n      if (missingParenErrorLoc) {\n        this.unexpected(missingParenErrorLoc, 10);\n      }\n      if (result) {\n        if (result.type === \"TSInstantiationExpression\") {\n          if (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) {\n            this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc);\n          }\n          if (!this.match(16) && !this.match(18)) {\n            result.expression = super.stopParseSubscript(base, state);\n          }\n        }\n        return result;\n      }\n    }\n    return super.parseSubscript(base, startLoc, noCalls, state);\n  }\n  parseNewCallee(node) {\n    var _callee$extra;\n    super.parseNewCallee(node);\n    const {\n      callee\n    } = node;\n    if (callee.type === \"TSInstantiationExpression\" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {\n      {\n        node.typeParameters = callee.typeParameters;\n      }\n      node.callee = callee.expression;\n    }\n  }\n  parseExprOp(left, leftStartLoc, minPrec) {\n    let isSatisfies;\n    if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(120)))) {\n      const node = this.startNodeAt(leftStartLoc);\n      node.expression = left;\n      node.typeAnnotation = this.tsInType(() => {\n        this.next();\n        if (this.match(75)) {\n          if (isSatisfies) {\n            this.raise(Errors.UnexpectedKeyword, this.state.startLoc, {\n              keyword: \"const\"\n            });\n          }\n          return this.tsParseTypeReference();\n        }\n        return this.tsParseType();\n      });\n      this.finishNode(node, isSatisfies ? \"TSSatisfiesExpression\" : \"TSAsExpression\");\n      this.reScan_lt_gt();\n      return this.parseExprOp(node, leftStartLoc, minPrec);\n    }\n    return super.parseExprOp(left, leftStartLoc, minPrec);\n  }\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (!this.state.isAmbientContext) {\n      super.checkReservedWord(word, startLoc, checkKeywords, isBinding);\n    }\n  }\n  checkImportReflection(node) {\n    super.checkImportReflection(node);\n    if (node.module && node.importKind !== \"value\") {\n      this.raise(TSErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);\n    }\n  }\n  checkDuplicateExports() {}\n  isPotentialImportPhase(isExport) {\n    if (super.isPotentialImportPhase(isExport)) return true;\n    if (this.isContextual(130)) {\n      const ch = this.lookaheadCharCode();\n      return isExport ? ch === 123 || ch === 42 : ch !== 61;\n    }\n    return !isExport && this.isContextual(87);\n  }\n  applyImportPhase(node, isExport, phase, loc) {\n    super.applyImportPhase(node, isExport, phase, loc);\n    if (isExport) {\n      node.exportKind = phase === \"type\" ? \"type\" : \"value\";\n    } else {\n      node.importKind = phase === \"type\" || phase === \"typeof\" ? phase : \"value\";\n    }\n  }\n  parseImport(node) {\n    if (this.match(134)) {\n      node.importKind = \"value\";\n      return super.parseImport(node);\n    }\n    let importNode;\n    if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61) {\n      node.importKind = \"value\";\n      return this.tsParseImportEqualsDeclaration(node);\n    } else if (this.isContextual(130)) {\n      const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);\n      if (this.lookaheadCharCode() === 61) {\n        return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier);\n      } else {\n        importNode = super.parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier);\n      }\n    } else {\n      importNode = super.parseImport(node);\n    }\n    if (importNode.importKind === \"type\" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === \"ImportDefaultSpecifier\") {\n      this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, importNode);\n    }\n    return importNode;\n  }\n  parseExport(node, decorators) {\n    if (this.match(83)) {\n      const nodeImportEquals = node;\n      this.next();\n      let maybeDefaultIdentifier = null;\n      if (this.isContextual(130) && this.isPotentialImportPhase(false)) {\n        maybeDefaultIdentifier = this.parseMaybeImportPhase(nodeImportEquals, false);\n      } else {\n        nodeImportEquals.importKind = \"value\";\n      }\n      const declaration = this.tsParseImportEqualsDeclaration(nodeImportEquals, maybeDefaultIdentifier, true);\n      {\n        return declaration;\n      }\n    } else if (this.eat(29)) {\n      const assign = node;\n      assign.expression = super.parseExpression();\n      this.semicolon();\n      this.sawUnambiguousESM = true;\n      return this.finishNode(assign, \"TSExportAssignment\");\n    } else if (this.eatContextual(93)) {\n      const decl = node;\n      this.expectContextual(128);\n      decl.id = this.parseIdentifier();\n      this.semicolon();\n      return this.finishNode(decl, \"TSNamespaceExportDeclaration\");\n    } else {\n      return super.parseExport(node, decorators);\n    }\n  }\n  isAbstractClass() {\n    return this.isContextual(124) && this.isLookaheadContextual(\"class\");\n  }\n  parseExportDefaultExpression() {\n    if (this.isAbstractClass()) {\n      const cls = this.startNode();\n      this.next();\n      cls.abstract = true;\n      return this.parseClass(cls, true, true);\n    }\n    if (this.match(129)) {\n      const result = this.tsParseInterfaceDeclaration(this.startNode());\n      if (result) return result;\n    }\n    return super.parseExportDefaultExpression();\n  }\n  parseVarStatement(node, kind, allowMissingInitializer = false) {\n    const {\n      isAmbientContext\n    } = this.state;\n    const declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);\n    if (!isAmbientContext) return declaration;\n    if (!node.declare && (kind === \"using\" || kind === \"await using\")) {\n      this.raiseOverwrite(TSErrors.UsingDeclarationInAmbientContext, node, kind);\n      return declaration;\n    }\n    for (const {\n      id,\n      init\n    } of declaration.declarations) {\n      if (!init) continue;\n      if (kind === \"var\" || kind === \"let\" || !!id.typeAnnotation) {\n        this.raise(TSErrors.InitializerNotAllowedInAmbientContext, init);\n      } else if (!isValidAmbientConstInitializer(init, this.hasPlugin(\"estree\"))) {\n        this.raise(TSErrors.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, init);\n      }\n    }\n    return declaration;\n  }\n  parseStatementContent(flags, decorators) {\n    if (this.match(75) && this.isLookaheadContextual(\"enum\")) {\n      const node = this.startNode();\n      this.expect(75);\n      return this.tsParseEnumDeclaration(node, {\n        const: true\n      });\n    }\n    if (this.isContextual(126)) {\n      return this.tsParseEnumDeclaration(this.startNode());\n    }\n    if (this.isContextual(129)) {\n      const result = this.tsParseInterfaceDeclaration(this.startNode());\n      if (result) return result;\n    }\n    return super.parseStatementContent(flags, decorators);\n  }\n  parseAccessModifier() {\n    return this.tsParseModifier([\"public\", \"protected\", \"private\"]);\n  }\n  tsHasSomeModifiers(member, modifiers) {\n    return modifiers.some(modifier => {\n      if (tsIsAccessModifier(modifier)) {\n        return member.accessibility === modifier;\n      }\n      return !!member[modifier];\n    });\n  }\n  tsIsStartOfStaticBlocks() {\n    return this.isContextual(106) && this.lookaheadCharCode() === 123;\n  }\n  parseClassMember(classBody, member, state) {\n    const modifiers = [\"declare\", \"private\", \"public\", \"protected\", \"override\", \"abstract\", \"readonly\", \"static\"];\n    this.tsParseModifiers({\n      allowedModifiers: modifiers,\n      disallowedModifiers: [\"in\", \"out\"],\n      stopOnStartOfClassStaticBlock: true,\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions\n    }, member);\n    const callParseClassMemberWithIsStatic = () => {\n      if (this.tsIsStartOfStaticBlocks()) {\n        this.next();\n        this.next();\n        if (this.tsHasSomeModifiers(member, modifiers)) {\n          this.raise(TSErrors.StaticBlockCannotHaveModifier, this.state.curPosition());\n        }\n        super.parseClassStaticBlock(classBody, member);\n      } else {\n        this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);\n      }\n    };\n    if (member.declare) {\n      this.tsInAmbientContext(callParseClassMemberWithIsStatic);\n    } else {\n      callParseClassMemberWithIsStatic();\n    }\n  }\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\n    const idx = this.tsTryParseIndexSignature(member);\n    if (idx) {\n      classBody.body.push(idx);\n      if (member.abstract) {\n        this.raise(TSErrors.IndexSignatureHasAbstract, member);\n      }\n      if (member.accessibility) {\n        this.raise(TSErrors.IndexSignatureHasAccessibility, member, {\n          modifier: member.accessibility\n        });\n      }\n      if (member.declare) {\n        this.raise(TSErrors.IndexSignatureHasDeclare, member);\n      }\n      if (member.override) {\n        this.raise(TSErrors.IndexSignatureHasOverride, member);\n      }\n      return;\n    }\n    if (!this.state.inAbstractClass && member.abstract) {\n      this.raise(TSErrors.NonAbstractClassHasAbstractMethod, member);\n    }\n    if (member.override) {\n      if (!state.hadSuperClass) {\n        this.raise(TSErrors.OverrideNotInSubClass, member);\n      }\n    }\n    super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n  parsePostMemberNameModifiers(methodOrProp) {\n    const optional = this.eat(17);\n    if (optional) methodOrProp.optional = true;\n    if (methodOrProp.readonly && this.match(10)) {\n      this.raise(TSErrors.ClassMethodHasReadonly, methodOrProp);\n    }\n    if (methodOrProp.declare && this.match(10)) {\n      this.raise(TSErrors.ClassMethodHasDeclare, methodOrProp);\n    }\n  }\n  parseExpressionStatement(node, expr, decorators) {\n    const decl = expr.type === \"Identifier\" ? this.tsParseExpressionStatement(node, expr, decorators) : undefined;\n    return decl || super.parseExpressionStatement(node, expr, decorators);\n  }\n  shouldParseExportDeclaration() {\n    if (this.tsIsDeclarationStart()) return true;\n    return super.shouldParseExportDeclaration();\n  }\n  parseConditional(expr, startLoc, refExpressionErrors) {\n    if (!this.match(17)) return expr;\n    if (this.state.maybeInArrowParameters) {\n      const nextCh = this.lookaheadCharCode();\n      if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {\n        this.setOptionalParametersError(refExpressionErrors);\n        return expr;\n      }\n    }\n    return super.parseConditional(expr, startLoc, refExpressionErrors);\n  }\n  parseParenItem(node, startLoc) {\n    const newNode = super.parseParenItem(node, startLoc);\n    if (this.eat(17)) {\n      newNode.optional = true;\n      this.resetEndLocation(node);\n    }\n    if (this.match(14)) {\n      const typeCastNode = this.startNodeAt(startLoc);\n      typeCastNode.expression = node;\n      typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();\n      return this.finishNode(typeCastNode, \"TSTypeCastExpression\");\n    }\n    return node;\n  }\n  parseExportDeclaration(node) {\n    if (!this.state.isAmbientContext && this.isContextual(125)) {\n      return this.tsInAmbientContext(() => this.parseExportDeclaration(node));\n    }\n    const startLoc = this.state.startLoc;\n    const isDeclare = this.eatContextual(125);\n    if (isDeclare && (this.isContextual(125) || !this.shouldParseExportDeclaration())) {\n      throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, this.state.startLoc);\n    }\n    const isIdentifier = tokenIsIdentifier(this.state.type);\n    const declaration = isIdentifier && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);\n    if (!declaration) return null;\n    if (declaration.type === \"TSInterfaceDeclaration\" || declaration.type === \"TSTypeAliasDeclaration\" || isDeclare) {\n      node.exportKind = \"type\";\n    }\n    if (isDeclare && declaration.type !== \"TSImportEqualsDeclaration\") {\n      this.resetStartLocation(declaration, startLoc);\n      declaration.declare = true;\n    }\n    return declaration;\n  }\n  parseClassId(node, isStatement, optionalId, bindingType) {\n    if ((!isStatement || optionalId) && this.isContextual(113)) {\n      return;\n    }\n    super.parseClassId(node, isStatement, optionalId, node.declare ? 1024 : 8331);\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);\n    if (typeParameters) node.typeParameters = typeParameters;\n  }\n  parseClassPropertyAnnotation(node) {\n    if (!node.optional) {\n      if (this.eat(35)) {\n        node.definite = true;\n      } else if (this.eat(17)) {\n        node.optional = true;\n      }\n    }\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) node.typeAnnotation = type;\n  }\n  parseClassProperty(node) {\n    this.parseClassPropertyAnnotation(node);\n    if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29)) {\n      this.raise(TSErrors.DeclareClassFieldHasInitializer, this.state.startLoc);\n    }\n    if (node.abstract && this.match(29)) {\n      const {\n        key\n      } = node;\n      this.raise(TSErrors.AbstractPropertyHasInitializer, this.state.startLoc, {\n        propertyName: key.type === \"Identifier\" && !node.computed ? key.name : `[${this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end))}]`\n      });\n    }\n    return super.parseClassProperty(node);\n  }\n  parseClassPrivateProperty(node) {\n    if (node.abstract) {\n      this.raise(TSErrors.PrivateElementHasAbstract, node);\n    }\n    if (node.accessibility) {\n      this.raise(TSErrors.PrivateElementHasAccessibility, node, {\n        modifier: node.accessibility\n      });\n    }\n    this.parseClassPropertyAnnotation(node);\n    return super.parseClassPrivateProperty(node);\n  }\n  parseClassAccessorProperty(node) {\n    this.parseClassPropertyAnnotation(node);\n    if (node.optional) {\n      this.raise(TSErrors.AccessorCannotBeOptional, node);\n    }\n    return super.parseClassAccessorProperty(node);\n  }\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    if (typeParameters && isConstructor) {\n      this.raise(TSErrors.ConstructorHasTypeParameters, typeParameters);\n    }\n    const {\n      declare = false,\n      kind\n    } = method;\n    if (declare && (kind === \"get\" || kind === \"set\")) {\n      this.raise(TSErrors.DeclareAccessor, method, {\n        kind\n      });\n    }\n    if (typeParameters) method.typeParameters = typeParameters;\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n  }\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    if (typeParameters) method.typeParameters = typeParameters;\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n  }\n  declareClassPrivateMethodInScope(node, kind) {\n    if (node.type === \"TSDeclareMethod\") return;\n    if (node.type === \"MethodDefinition\" && node.value.body == null) {\n      return;\n    }\n    super.declareClassPrivateMethodInScope(node, kind);\n  }\n  parseClassSuper(node) {\n    super.parseClassSuper(node);\n    if (node.superClass && (this.match(47) || this.match(51))) {\n      {\n        node.superTypeParameters = this.tsParseTypeArgumentsInExpression();\n      }\n    }\n    if (this.eatContextual(113)) {\n      node.implements = this.tsParseHeritageClause(\"implements\");\n    }\n  }\n  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    if (typeParameters) prop.typeParameters = typeParameters;\n    return super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);\n  }\n  parseFunctionParams(node, isConstructor) {\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    if (typeParameters) node.typeParameters = typeParameters;\n    super.parseFunctionParams(node, isConstructor);\n  }\n  parseVarId(decl, kind) {\n    super.parseVarId(decl, kind);\n    if (decl.id.type === \"Identifier\" && !this.hasPrecedingLineBreak() && this.eat(35)) {\n      decl.definite = true;\n    }\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) {\n      decl.id.typeAnnotation = type;\n      this.resetEndLocation(decl.id);\n    }\n  }\n  parseAsyncArrowFromCallExpression(node, call) {\n    if (this.match(14)) {\n      node.returnType = this.tsParseTypeAnnotation();\n    }\n    return super.parseAsyncArrowFromCallExpression(node, call);\n  }\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2;\n    let state;\n    let jsx;\n    let typeCast;\n    if (this.hasPlugin(\"jsx\") && (this.match(143) || this.match(47))) {\n      state = this.state.clone();\n      jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\n      if (!jsx.error) return jsx.node;\n      const {\n        context\n      } = this.state;\n      const currentContext = context[context.length - 1];\n      if (currentContext === types.j_oTag || currentContext === types.j_expr) {\n        context.pop();\n      }\n    }\n    if (!((_jsx = jsx) != null && _jsx.error) && !this.match(47)) {\n      return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n    }\n    if (!state || state === this.state) state = this.state.clone();\n    let typeParameters;\n    const arrow = this.tryParse(abort => {\n      var _expr$extra, _typeParameters;\n      typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);\n      const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n      if (expr.type !== \"ArrowFunctionExpression\" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {\n        abort();\n      }\n      if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {\n        this.resetStartLocationFromNode(expr, typeParameters);\n      }\n      expr.typeParameters = typeParameters;\n      return expr;\n    }, state);\n    if (!arrow.error && !arrow.aborted) {\n      if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);\n      return arrow.node;\n    }\n    if (!jsx) {\n      assert(!this.hasPlugin(\"jsx\"));\n      typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\n      if (!typeCast.error) return typeCast.node;\n    }\n    if ((_jsx2 = jsx) != null && _jsx2.node) {\n      this.state = jsx.failState;\n      return jsx.node;\n    }\n    if (arrow.node) {\n      this.state = arrow.failState;\n      if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);\n      return arrow.node;\n    }\n    if ((_typeCast = typeCast) != null && _typeCast.node) {\n      this.state = typeCast.failState;\n      return typeCast.node;\n    }\n    throw ((_jsx3 = jsx) == null ? void 0 : _jsx3.error) || arrow.error || ((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.error);\n  }\n  reportReservedArrowTypeParam(node) {\n    var _node$extra2;\n    if (node.params.length === 1 && !node.params[0].constraint && !((_node$extra2 = node.extra) != null && _node$extra2.trailingComma) && this.getPluginOption(\"typescript\", \"disallowAmbiguousJSXLike\")) {\n      this.raise(TSErrors.ReservedArrowTypeParam, node);\n    }\n  }\n  parseMaybeUnary(refExpressionErrors, sawUnary) {\n    if (!this.hasPlugin(\"jsx\") && this.match(47)) {\n      return this.tsParseTypeAssertion();\n    }\n    return super.parseMaybeUnary(refExpressionErrors, sawUnary);\n  }\n  parseArrow(node) {\n    if (this.match(14)) {\n      const result = this.tryParse(abort => {\n        const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);\n        if (this.canInsertSemicolon() || !this.match(19)) abort();\n        return returnType;\n      });\n      if (result.aborted) return;\n      if (!result.thrown) {\n        if (result.error) this.state = result.failState;\n        node.returnType = result.node;\n      }\n    }\n    return super.parseArrow(node);\n  }\n  parseFunctionParamType(param) {\n    if (this.eat(17)) {\n      param.optional = true;\n    }\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) param.typeAnnotation = type;\n    this.resetEndLocation(param);\n    return param;\n  }\n  isAssignable(node, isBinding) {\n    switch (node.type) {\n      case \"TSTypeCastExpression\":\n        return this.isAssignable(node.expression, isBinding);\n      case \"TSParameterProperty\":\n        return true;\n      default:\n        return super.isAssignable(node, isBinding);\n    }\n  }\n  toAssignable(node, isLHS = false) {\n    switch (node.type) {\n      case \"ParenthesizedExpression\":\n        this.toAssignableParenthesizedExpression(node, isLHS);\n        break;\n      case \"TSAsExpression\":\n      case \"TSSatisfiesExpression\":\n      case \"TSNonNullExpression\":\n      case \"TSTypeAssertion\":\n        if (isLHS) {\n          this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, node);\n        } else {\n          this.raise(TSErrors.UnexpectedTypeCastInParameter, node);\n        }\n        this.toAssignable(node.expression, isLHS);\n        break;\n      case \"AssignmentExpression\":\n        if (!isLHS && node.left.type === \"TSTypeCastExpression\") {\n          node.left = this.typeCastToParameter(node.left);\n        }\n      default:\n        super.toAssignable(node, isLHS);\n    }\n  }\n  toAssignableParenthesizedExpression(node, isLHS) {\n    switch (node.expression.type) {\n      case \"TSAsExpression\":\n      case \"TSSatisfiesExpression\":\n      case \"TSNonNullExpression\":\n      case \"TSTypeAssertion\":\n      case \"ParenthesizedExpression\":\n        this.toAssignable(node.expression, isLHS);\n        break;\n      default:\n        super.toAssignable(node, isLHS);\n    }\n  }\n  checkToRestConversion(node, allowPattern) {\n    switch (node.type) {\n      case \"TSAsExpression\":\n      case \"TSSatisfiesExpression\":\n      case \"TSTypeAssertion\":\n      case \"TSNonNullExpression\":\n        this.checkToRestConversion(node.expression, false);\n        break;\n      default:\n        super.checkToRestConversion(node, allowPattern);\n    }\n  }\n  isValidLVal(type, isUnparenthesizedInAssign, binding) {\n    switch (type) {\n      case \"TSTypeCastExpression\":\n        return true;\n      case \"TSParameterProperty\":\n        return \"parameter\";\n      case \"TSNonNullExpression\":\n        return \"expression\";\n      case \"TSAsExpression\":\n      case \"TSSatisfiesExpression\":\n      case \"TSTypeAssertion\":\n        return (binding !== 64 || !isUnparenthesizedInAssign) && [\"expression\", true];\n      default:\n        return super.isValidLVal(type, isUnparenthesizedInAssign, binding);\n    }\n  }\n  parseBindingAtom() {\n    if (this.state.type === 78) {\n      return this.parseIdentifier(true);\n    }\n    return super.parseBindingAtom();\n  }\n  parseMaybeDecoratorArguments(expr, startLoc) {\n    if (this.match(47) || this.match(51)) {\n      const typeArguments = this.tsParseTypeArgumentsInExpression();\n      if (this.match(10)) {\n        const call = super.parseMaybeDecoratorArguments(expr, startLoc);\n        {\n          call.typeParameters = typeArguments;\n        }\n        return call;\n      }\n      this.unexpected(null, 10);\n    }\n    return super.parseMaybeDecoratorArguments(expr, startLoc);\n  }\n  checkCommaAfterRest(close) {\n    if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {\n      this.next();\n      return false;\n    }\n    return super.checkCommaAfterRest(close);\n  }\n  isClassMethod() {\n    return this.match(47) || super.isClassMethod();\n  }\n  isClassProperty() {\n    return this.match(35) || this.match(14) || super.isClassProperty();\n  }\n  parseMaybeDefault(startLoc, left) {\n    const node = super.parseMaybeDefault(startLoc, left);\n    if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n      this.raise(TSErrors.TypeAnnotationAfterAssign, node.typeAnnotation);\n    }\n    return node;\n  }\n  getTokenFromCode(code) {\n    if (this.state.inType) {\n      if (code === 62) {\n        this.finishOp(48, 1);\n        return;\n      }\n      if (code === 60) {\n        this.finishOp(47, 1);\n        return;\n      }\n    }\n    super.getTokenFromCode(code);\n  }\n  reScan_lt_gt() {\n    const {\n      type\n    } = this.state;\n    if (type === 47) {\n      this.state.pos -= 1;\n      this.readToken_lt();\n    } else if (type === 48) {\n      this.state.pos -= 1;\n      this.readToken_gt();\n    }\n  }\n  reScan_lt() {\n    const {\n      type\n    } = this.state;\n    if (type === 51) {\n      this.state.pos -= 2;\n      this.finishOp(47, 1);\n      return 47;\n    }\n    return type;\n  }\n  toAssignableListItem(exprList, index, isLHS) {\n    const node = exprList[index];\n    if (node.type === \"TSTypeCastExpression\") {\n      exprList[index] = this.typeCastToParameter(node);\n    }\n    super.toAssignableListItem(exprList, index, isLHS);\n  }\n  typeCastToParameter(node) {\n    node.expression.typeAnnotation = node.typeAnnotation;\n    this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);\n    return node.expression;\n  }\n  shouldParseArrow(params) {\n    if (this.match(14)) {\n      return params.every(expr => this.isAssignable(expr, true));\n    }\n    return super.shouldParseArrow(params);\n  }\n  shouldParseAsyncArrow() {\n    return this.match(14) || super.shouldParseAsyncArrow();\n  }\n  canHaveLeadingDecorator() {\n    return super.canHaveLeadingDecorator() || this.isAbstractClass();\n  }\n  jsxParseOpeningElementAfterName(node) {\n    if (this.match(47) || this.match(51)) {\n      const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());\n      if (typeArguments) {\n        {\n          node.typeParameters = typeArguments;\n        }\n      }\n    }\n    return super.jsxParseOpeningElementAfterName(node);\n  }\n  getGetterSetterExpectedParamCount(method) {\n    const baseCount = super.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    const firstParam = params[0];\n    const hasContextParam = firstParam && this.isThisParam(firstParam);\n    return hasContextParam ? baseCount + 1 : baseCount;\n  }\n  parseCatchClauseParam() {\n    const param = super.parseCatchClauseParam();\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) {\n      param.typeAnnotation = type;\n      this.resetEndLocation(param);\n    }\n    return param;\n  }\n  tsInAmbientContext(cb) {\n    const {\n      isAmbientContext: oldIsAmbientContext,\n      strict: oldStrict\n    } = this.state;\n    this.state.isAmbientContext = true;\n    this.state.strict = false;\n    try {\n      return cb();\n    } finally {\n      this.state.isAmbientContext = oldIsAmbientContext;\n      this.state.strict = oldStrict;\n    }\n  }\n  parseClass(node, isStatement, optionalId) {\n    const oldInAbstractClass = this.state.inAbstractClass;\n    this.state.inAbstractClass = !!node.abstract;\n    try {\n      return super.parseClass(node, isStatement, optionalId);\n    } finally {\n      this.state.inAbstractClass = oldInAbstractClass;\n    }\n  }\n  tsParseAbstractDeclaration(node, decorators) {\n    if (this.match(80)) {\n      node.abstract = true;\n      return this.maybeTakeDecorators(decorators, this.parseClass(node, true, false));\n    } else if (this.isContextual(129)) {\n      if (!this.hasFollowingLineBreak()) {\n        node.abstract = true;\n        this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifier, node);\n        return this.tsParseInterfaceDeclaration(node);\n      }\n    } else {\n      this.unexpected(null, 80);\n    }\n  }\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {\n    const method = super.parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);\n    if (method.abstract || method.type === \"TSAbstractMethodDefinition\") {\n      const hasEstreePlugin = this.hasPlugin(\"estree\");\n      const methodFn = hasEstreePlugin ? method.value : method;\n      if (methodFn.body) {\n        const {\n          key\n        } = method;\n        this.raise(TSErrors.AbstractMethodHasImplementation, method, {\n          methodName: key.type === \"Identifier\" && !method.computed ? key.name : `[${this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end))}]`\n        });\n      }\n    }\n    return method;\n  }\n  tsParseTypeParameterName() {\n    const typeName = this.parseIdentifier();\n    return typeName.name;\n  }\n  shouldParseAsAmbientContext() {\n    return !!this.getPluginOption(\"typescript\", \"dts\");\n  }\n  parse() {\n    if (this.shouldParseAsAmbientContext()) {\n      this.state.isAmbientContext = true;\n    }\n    return super.parse();\n  }\n  getExpression() {\n    if (this.shouldParseAsAmbientContext()) {\n      this.state.isAmbientContext = true;\n    }\n    return super.getExpression();\n  }\n  parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {\n    if (!isString && isMaybeTypeOnly) {\n      this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);\n      return this.finishNode(node, \"ExportSpecifier\");\n    }\n    node.exportKind = \"value\";\n    return super.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly);\n  }\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {\n    if (!importedIsString && isMaybeTypeOnly) {\n      this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);\n      return this.finishNode(specifier, \"ImportSpecifier\");\n    }\n    specifier.importKind = \"value\";\n    return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? 4098 : 4096);\n  }\n  parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {\n    const leftOfAsKey = isImport ? \"imported\" : \"local\";\n    const rightOfAsKey = isImport ? \"local\" : \"exported\";\n    let leftOfAs = node[leftOfAsKey];\n    let rightOfAs;\n    let hasTypeSpecifier = false;\n    let canParseAsKeyword = true;\n    const loc = leftOfAs.loc.start;\n    if (this.isContextual(93)) {\n      const firstAs = this.parseIdentifier();\n      if (this.isContextual(93)) {\n        const secondAs = this.parseIdentifier();\n        if (tokenIsKeywordOrIdentifier(this.state.type)) {\n          hasTypeSpecifier = true;\n          leftOfAs = firstAs;\n          rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();\n          canParseAsKeyword = false;\n        } else {\n          rightOfAs = secondAs;\n          canParseAsKeyword = false;\n        }\n      } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n        canParseAsKeyword = false;\n        rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();\n      } else {\n        hasTypeSpecifier = true;\n        leftOfAs = firstAs;\n      }\n    } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n      hasTypeSpecifier = true;\n      if (isImport) {\n        leftOfAs = this.parseIdentifier(true);\n        if (!this.isContextual(93)) {\n          this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);\n        }\n      } else {\n        leftOfAs = this.parseModuleExportName();\n      }\n    }\n    if (hasTypeSpecifier && isInTypeOnlyImportExport) {\n      this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, loc);\n    }\n    node[leftOfAsKey] = leftOfAs;\n    node[rightOfAsKey] = rightOfAs;\n    const kindKey = isImport ? \"importKind\" : \"exportKind\";\n    node[kindKey] = hasTypeSpecifier ? \"type\" : \"value\";\n    if (canParseAsKeyword && this.eatContextual(93)) {\n      node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();\n    }\n    if (!node[rightOfAsKey]) {\n      node[rightOfAsKey] = this.cloneIdentifier(node[leftOfAsKey]);\n    }\n    if (isImport) {\n      this.checkIdentifier(node[rightOfAsKey], hasTypeSpecifier ? 4098 : 4096);\n    }\n  }\n  fillOptionalPropertiesForTSESLint(node) {\n    var _node$directive, _node$decorators, _node$optional, _node$typeAnnotation, _node$accessibility, _node$decorators2, _node$override, _node$readonly, _node$static, _node$declare, _node$returnType, _node$typeParameters, _node$optional2, _node$optional3, _node$accessibility2, _node$readonly2, _node$static2, _node$declare2, _node$definite, _node$readonly3, _node$typeAnnotation2, _node$accessibility3, _node$decorators3, _node$override2, _node$optional4, _node$id, _node$abstract, _node$declare3, _node$decorators4, _node$implements, _node$superTypeArgume, _node$typeParameters2, _node$declare4, _node$definite2, _node$const, _node$declare5, _node$computed, _node$qualifier, _node$options, _node$declare6, _node$extends, _node$declare7, _node$global, _node$const2, _node$in, _node$out;\n    switch (node.type) {\n      case \"ExpressionStatement\":\n        (_node$directive = node.directive) != null ? _node$directive : node.directive = undefined;\n        return;\n      case \"RestElement\":\n        node.value = undefined;\n      case \"Identifier\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"ObjectPattern\":\n        (_node$decorators = node.decorators) != null ? _node$decorators : node.decorators = [];\n        (_node$optional = node.optional) != null ? _node$optional : node.optional = false;\n        (_node$typeAnnotation = node.typeAnnotation) != null ? _node$typeAnnotation : node.typeAnnotation = undefined;\n        return;\n      case \"TSParameterProperty\":\n        (_node$accessibility = node.accessibility) != null ? _node$accessibility : node.accessibility = undefined;\n        (_node$decorators2 = node.decorators) != null ? _node$decorators2 : node.decorators = [];\n        (_node$override = node.override) != null ? _node$override : node.override = false;\n        (_node$readonly = node.readonly) != null ? _node$readonly : node.readonly = false;\n        (_node$static = node.static) != null ? _node$static : node.static = false;\n        return;\n      case \"TSEmptyBodyFunctionExpression\":\n        node.body = null;\n      case \"TSDeclareFunction\":\n      case \"FunctionDeclaration\":\n      case \"FunctionExpression\":\n      case \"ClassMethod\":\n      case \"ClassPrivateMethod\":\n        (_node$declare = node.declare) != null ? _node$declare : node.declare = false;\n        (_node$returnType = node.returnType) != null ? _node$returnType : node.returnType = undefined;\n        (_node$typeParameters = node.typeParameters) != null ? _node$typeParameters : node.typeParameters = undefined;\n        return;\n      case \"Property\":\n        (_node$optional2 = node.optional) != null ? _node$optional2 : node.optional = false;\n        return;\n      case \"TSMethodSignature\":\n      case \"TSPropertySignature\":\n        (_node$optional3 = node.optional) != null ? _node$optional3 : node.optional = false;\n      case \"TSIndexSignature\":\n        (_node$accessibility2 = node.accessibility) != null ? _node$accessibility2 : node.accessibility = undefined;\n        (_node$readonly2 = node.readonly) != null ? _node$readonly2 : node.readonly = false;\n        (_node$static2 = node.static) != null ? _node$static2 : node.static = false;\n        return;\n      case \"TSAbstractPropertyDefinition\":\n      case \"PropertyDefinition\":\n      case \"TSAbstractAccessorProperty\":\n      case \"AccessorProperty\":\n        (_node$declare2 = node.declare) != null ? _node$declare2 : node.declare = false;\n        (_node$definite = node.definite) != null ? _node$definite : node.definite = false;\n        (_node$readonly3 = node.readonly) != null ? _node$readonly3 : node.readonly = false;\n        (_node$typeAnnotation2 = node.typeAnnotation) != null ? _node$typeAnnotation2 : node.typeAnnotation = undefined;\n      case \"TSAbstractMethodDefinition\":\n      case \"MethodDefinition\":\n        (_node$accessibility3 = node.accessibility) != null ? _node$accessibility3 : node.accessibility = undefined;\n        (_node$decorators3 = node.decorators) != null ? _node$decorators3 : node.decorators = [];\n        (_node$override2 = node.override) != null ? _node$override2 : node.override = false;\n        (_node$optional4 = node.optional) != null ? _node$optional4 : node.optional = false;\n        return;\n      case \"ClassExpression\":\n        (_node$id = node.id) != null ? _node$id : node.id = null;\n      case \"ClassDeclaration\":\n        (_node$abstract = node.abstract) != null ? _node$abstract : node.abstract = false;\n        (_node$declare3 = node.declare) != null ? _node$declare3 : node.declare = false;\n        (_node$decorators4 = node.decorators) != null ? _node$decorators4 : node.decorators = [];\n        (_node$implements = node.implements) != null ? _node$implements : node.implements = [];\n        (_node$superTypeArgume = node.superTypeArguments) != null ? _node$superTypeArgume : node.superTypeArguments = undefined;\n        (_node$typeParameters2 = node.typeParameters) != null ? _node$typeParameters2 : node.typeParameters = undefined;\n        return;\n      case \"TSTypeAliasDeclaration\":\n      case \"VariableDeclaration\":\n        (_node$declare4 = node.declare) != null ? _node$declare4 : node.declare = false;\n        return;\n      case \"VariableDeclarator\":\n        (_node$definite2 = node.definite) != null ? _node$definite2 : node.definite = false;\n        return;\n      case \"TSEnumDeclaration\":\n        (_node$const = node.const) != null ? _node$const : node.const = false;\n        (_node$declare5 = node.declare) != null ? _node$declare5 : node.declare = false;\n        return;\n      case \"TSEnumMember\":\n        (_node$computed = node.computed) != null ? _node$computed : node.computed = false;\n        return;\n      case \"TSImportType\":\n        (_node$qualifier = node.qualifier) != null ? _node$qualifier : node.qualifier = null;\n        (_node$options = node.options) != null ? _node$options : node.options = null;\n        return;\n      case \"TSInterfaceDeclaration\":\n        (_node$declare6 = node.declare) != null ? _node$declare6 : node.declare = false;\n        (_node$extends = node.extends) != null ? _node$extends : node.extends = [];\n        return;\n      case \"TSModuleDeclaration\":\n        (_node$declare7 = node.declare) != null ? _node$declare7 : node.declare = false;\n        (_node$global = node.global) != null ? _node$global : node.global = node.kind === \"global\";\n        return;\n      case \"TSTypeParameter\":\n        (_node$const2 = node.const) != null ? _node$const2 : node.const = false;\n        (_node$in = node.in) != null ? _node$in : node.in = false;\n        (_node$out = node.out) != null ? _node$out : node.out = false;\n        return;\n    }\n  }\n};\nfunction isPossiblyLiteralEnum(expression) {\n  if (expression.type !== \"MemberExpression\") return false;\n  const {\n    computed,\n    property\n  } = expression;\n  if (computed && property.type !== \"StringLiteral\" && (property.type !== \"TemplateLiteral\" || property.expressions.length > 0)) {\n    return false;\n  }\n  return isUncomputedMemberExpressionChain(expression.object);\n}\nfunction isValidAmbientConstInitializer(expression, estree) {\n  var _expression$extra;\n  const {\n    type\n  } = expression;\n  if ((_expression$extra = expression.extra) != null && _expression$extra.parenthesized) {\n    return false;\n  }\n  if (estree) {\n    if (type === \"Literal\") {\n      const {\n        value\n      } = expression;\n      if (typeof value === \"string\" || typeof value === \"boolean\") {\n        return true;\n      }\n    }\n  } else {\n    if (type === \"StringLiteral\" || type === \"BooleanLiteral\") {\n      return true;\n    }\n  }\n  if (isNumber(expression, estree) || isNegativeNumber(expression, estree)) {\n    return true;\n  }\n  if (type === \"TemplateLiteral\" && expression.expressions.length === 0) {\n    return true;\n  }\n  if (isPossiblyLiteralEnum(expression)) {\n    return true;\n  }\n  return false;\n}\nfunction isNumber(expression, estree) {\n  if (estree) {\n    return expression.type === \"Literal\" && (typeof expression.value === \"number\" || \"bigint\" in expression);\n  }\n  return expression.type === \"NumericLiteral\" || expression.type === \"BigIntLiteral\";\n}\nfunction isNegativeNumber(expression, estree) {\n  if (expression.type === \"UnaryExpression\") {\n    const {\n      operator,\n      argument\n    } = expression;\n    if (operator === \"-\" && isNumber(argument, estree)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isUncomputedMemberExpressionChain(expression) {\n  if (expression.type === \"Identifier\") return true;\n  if (expression.type !== \"MemberExpression\" || expression.computed) {\n    return false;\n  }\n  return isUncomputedMemberExpressionChain(expression.object);\n}\nconst PlaceholderErrors = ParseErrorEnum`placeholders`({\n  ClassNameIsRequired: \"A class name is required.\",\n  UnexpectedSpace: \"Unexpected space in placeholder.\"\n});\nvar placeholders = superClass => class PlaceholdersParserMixin extends superClass {\n  parsePlaceholder(expectedNode) {\n    if (this.match(133)) {\n      const node = this.startNode();\n      this.next();\n      this.assertNoSpace();\n      node.name = super.parseIdentifier(true);\n      this.assertNoSpace();\n      this.expect(133);\n      return this.finishPlaceholder(node, expectedNode);\n    }\n  }\n  finishPlaceholder(node, expectedNode) {\n    let placeholder = node;\n    if (!placeholder.expectedNode || !placeholder.type) {\n      placeholder = this.finishNode(placeholder, \"Placeholder\");\n    }\n    placeholder.expectedNode = expectedNode;\n    return placeholder;\n  }\n  getTokenFromCode(code) {\n    if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {\n      this.finishOp(133, 2);\n    } else {\n      super.getTokenFromCode(code);\n    }\n  }\n  parseExprAtom(refExpressionErrors) {\n    return this.parsePlaceholder(\"Expression\") || super.parseExprAtom(refExpressionErrors);\n  }\n  parseIdentifier(liberal) {\n    return this.parsePlaceholder(\"Identifier\") || super.parseIdentifier(liberal);\n  }\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (word !== undefined) {\n      super.checkReservedWord(word, startLoc, checkKeywords, isBinding);\n    }\n  }\n  cloneIdentifier(node) {\n    const cloned = super.cloneIdentifier(node);\n    if (cloned.type === \"Placeholder\") {\n      cloned.expectedNode = node.expectedNode;\n    }\n    return cloned;\n  }\n  cloneStringLiteral(node) {\n    if (node.type === \"Placeholder\") {\n      return this.cloneIdentifier(node);\n    }\n    return super.cloneStringLiteral(node);\n  }\n  parseBindingAtom() {\n    return this.parsePlaceholder(\"Pattern\") || super.parseBindingAtom();\n  }\n  isValidLVal(type, isParenthesized, binding) {\n    return type === \"Placeholder\" || super.isValidLVal(type, isParenthesized, binding);\n  }\n  toAssignable(node, isLHS) {\n    if (node && node.type === \"Placeholder\" && node.expectedNode === \"Expression\") {\n      node.expectedNode = \"Pattern\";\n    } else {\n      super.toAssignable(node, isLHS);\n    }\n  }\n  chStartsBindingIdentifier(ch, pos) {\n    if (super.chStartsBindingIdentifier(ch, pos)) {\n      return true;\n    }\n    const next = this.nextTokenStart();\n    if (this.input.charCodeAt(next) === 37 && this.input.charCodeAt(next + 1) === 37) {\n      return true;\n    }\n    return false;\n  }\n  verifyBreakContinue(node, isBreak) {\n    if (node.label && node.label.type === \"Placeholder\") return;\n    super.verifyBreakContinue(node, isBreak);\n  }\n  parseExpressionStatement(node, expr) {\n    var _expr$extra;\n    if (expr.type !== \"Placeholder\" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {\n      return super.parseExpressionStatement(node, expr);\n    }\n    if (this.match(14)) {\n      const stmt = node;\n      stmt.label = this.finishPlaceholder(expr, \"Identifier\");\n      this.next();\n      stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();\n      return this.finishNode(stmt, \"LabeledStatement\");\n    }\n    this.semicolon();\n    const stmtPlaceholder = node;\n    stmtPlaceholder.name = expr.name;\n    return this.finishPlaceholder(stmtPlaceholder, \"Statement\");\n  }\n  parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {\n    return this.parsePlaceholder(\"BlockStatement\") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);\n  }\n  parseFunctionId(requireId) {\n    return this.parsePlaceholder(\"Identifier\") || super.parseFunctionId(requireId);\n  }\n  parseClass(node, isStatement, optionalId) {\n    const type = isStatement ? \"ClassDeclaration\" : \"ClassExpression\";\n    this.next();\n    const oldStrict = this.state.strict;\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (placeholder) {\n      if (this.match(81) || this.match(133) || this.match(5)) {\n        node.id = placeholder;\n      } else if (optionalId || !isStatement) {\n        node.id = null;\n        node.body = this.finishPlaceholder(placeholder, \"ClassBody\");\n        return this.finishNode(node, type);\n      } else {\n        throw this.raise(PlaceholderErrors.ClassNameIsRequired, this.state.startLoc);\n      }\n    } else {\n      this.parseClassId(node, isStatement, optionalId);\n    }\n    super.parseClassSuper(node);\n    node.body = this.parsePlaceholder(\"ClassBody\") || super.parseClassBody(!!node.superClass, oldStrict);\n    return this.finishNode(node, type);\n  }\n  parseExport(node, decorators) {\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (!placeholder) return super.parseExport(node, decorators);\n    const node2 = node;\n    if (!this.isContextual(98) && !this.match(12)) {\n      node2.specifiers = [];\n      node2.source = null;\n      node2.declaration = this.finishPlaceholder(placeholder, \"Declaration\");\n      return this.finishNode(node2, \"ExportNamedDeclaration\");\n    }\n    this.expectPlugin(\"exportDefaultFrom\");\n    const specifier = this.startNode();\n    specifier.exported = placeholder;\n    node2.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n    return super.parseExport(node2, decorators);\n  }\n  isExportDefaultSpecifier() {\n    if (this.match(65)) {\n      const next = this.nextTokenStart();\n      if (this.isUnparsedContextual(next, \"from\")) {\n        if (this.input.startsWith(tokenLabelName(133), this.nextTokenStartSince(next + 4))) {\n          return true;\n        }\n      }\n    }\n    return super.isExportDefaultSpecifier();\n  }\n  maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {\n    var _specifiers;\n    if ((_specifiers = node.specifiers) != null && _specifiers.length) {\n      return true;\n    }\n    return super.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);\n  }\n  checkExport(node) {\n    const {\n      specifiers\n    } = node;\n    if (specifiers != null && specifiers.length) {\n      node.specifiers = specifiers.filter(node => node.exported.type === \"Placeholder\");\n    }\n    super.checkExport(node);\n    node.specifiers = specifiers;\n  }\n  parseImport(node) {\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (!placeholder) return super.parseImport(node);\n    node.specifiers = [];\n    if (!this.isContextual(98) && !this.match(12)) {\n      node.source = this.finishPlaceholder(placeholder, \"StringLiteral\");\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n    const specifier = this.startNodeAtNode(placeholder);\n    specifier.local = placeholder;\n    node.specifiers.push(this.finishNode(specifier, \"ImportDefaultSpecifier\"));\n    if (this.eat(12)) {\n      const hasStarImport = this.maybeParseStarImportSpecifier(node);\n      if (!hasStarImport) this.parseNamedImportSpecifiers(node);\n    }\n    this.expectContextual(98);\n    node.source = this.parseImportSource();\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n  parseImportSource() {\n    return this.parsePlaceholder(\"StringLiteral\") || super.parseImportSource();\n  }\n  assertNoSpace() {\n    if (this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index)) {\n      this.raise(PlaceholderErrors.UnexpectedSpace, this.state.lastTokEndLoc);\n    }\n  }\n};\nvar v8intrinsic = superClass => class V8IntrinsicMixin extends superClass {\n  parseV8Intrinsic() {\n    if (this.match(54)) {\n      const v8IntrinsicStartLoc = this.state.startLoc;\n      const node = this.startNode();\n      this.next();\n      if (tokenIsIdentifier(this.state.type)) {\n        const name = this.parseIdentifierName();\n        const identifier = this.createIdentifier(node, name);\n        this.castNodeTo(identifier, \"V8IntrinsicIdentifier\");\n        if (this.match(10)) {\n          return identifier;\n        }\n      }\n      this.unexpected(v8IntrinsicStartLoc);\n    }\n  }\n  parseExprAtom(refExpressionErrors) {\n    return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);\n  }\n};\nconst PIPELINE_PROPOSALS = [\"minimal\", \"fsharp\", \"hack\", \"smart\"];\nconst TOPIC_TOKENS = [\"^^\", \"@@\", \"^\", \"%\", \"#\"];\nfunction validatePlugins(pluginsMap) {\n  if (pluginsMap.has(\"decorators\")) {\n    if (pluginsMap.has(\"decorators-legacy\")) {\n      throw new Error(\"Cannot use the decorators and decorators-legacy plugin together\");\n    }\n    const decoratorsBeforeExport = pluginsMap.get(\"decorators\").decoratorsBeforeExport;\n    if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== \"boolean\") {\n      throw new Error(\"'decoratorsBeforeExport' must be a boolean, if specified.\");\n    }\n    const allowCallParenthesized = pluginsMap.get(\"decorators\").allowCallParenthesized;\n    if (allowCallParenthesized != null && typeof allowCallParenthesized !== \"boolean\") {\n      throw new Error(\"'allowCallParenthesized' must be a boolean.\");\n    }\n  }\n  if (pluginsMap.has(\"flow\") && pluginsMap.has(\"typescript\")) {\n    throw new Error(\"Cannot combine flow and typescript plugins.\");\n  }\n  if (pluginsMap.has(\"placeholders\") && pluginsMap.has(\"v8intrinsic\")) {\n    throw new Error(\"Cannot combine placeholders and v8intrinsic plugins.\");\n  }\n  if (pluginsMap.has(\"pipelineOperator\")) {\n    var _pluginsMap$get2;\n    const proposal = pluginsMap.get(\"pipelineOperator\").proposal;\n    if (!PIPELINE_PROPOSALS.includes(proposal)) {\n      const proposalList = PIPELINE_PROPOSALS.map(p => `\"${p}\"`).join(\", \");\n      throw new Error(`\"pipelineOperator\" requires \"proposal\" option whose value must be one of: ${proposalList}.`);\n    }\n    if (proposal === \"hack\") {\n      if (pluginsMap.has(\"placeholders\")) {\n        throw new Error(\"Cannot combine placeholders plugin and Hack-style pipes.\");\n      }\n      if (pluginsMap.has(\"v8intrinsic\")) {\n        throw new Error(\"Cannot combine v8intrinsic plugin and Hack-style pipes.\");\n      }\n      const topicToken = pluginsMap.get(\"pipelineOperator\").topicToken;\n      if (!TOPIC_TOKENS.includes(topicToken)) {\n        const tokenList = TOPIC_TOKENS.map(t => `\"${t}\"`).join(\", \");\n        throw new Error(`\"pipelineOperator\" in \"proposal\": \"hack\" mode also requires a \"topicToken\" option whose value must be one of: ${tokenList}.`);\n      }\n      {\n        var _pluginsMap$get;\n        if (topicToken === \"#\" && ((_pluginsMap$get = pluginsMap.get(\"recordAndTuple\")) == null ? void 0 : _pluginsMap$get.syntaxType) === \"hash\") {\n          throw new Error(`Plugin conflict between \\`[\"pipelineOperator\", { proposal: \"hack\", topicToken: \"#\" }]\\` and \\`${JSON.stringify([\"recordAndTuple\", pluginsMap.get(\"recordAndTuple\")])}\\`.`);\n        }\n      }\n    } else if (proposal === \"smart\" && ((_pluginsMap$get2 = pluginsMap.get(\"recordAndTuple\")) == null ? void 0 : _pluginsMap$get2.syntaxType) === \"hash\") {\n      throw new Error(`Plugin conflict between \\`[\"pipelineOperator\", { proposal: \"smart\" }]\\` and \\`${JSON.stringify([\"recordAndTuple\", pluginsMap.get(\"recordAndTuple\")])}\\`.`);\n    }\n  }\n  if (pluginsMap.has(\"moduleAttributes\")) {\n    {\n      if (pluginsMap.has(\"deprecatedImportAssert\") || pluginsMap.has(\"importAssertions\")) {\n        throw new Error(\"Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.\");\n      }\n      const moduleAttributesVersionPluginOption = pluginsMap.get(\"moduleAttributes\").version;\n      if (moduleAttributesVersionPluginOption !== \"may-2020\") {\n        throw new Error(\"The 'moduleAttributes' plugin requires a 'version' option,\" + \" representing the last proposal update. Currently, the\" + \" only supported value is 'may-2020'.\");\n      }\n    }\n  }\n  if (pluginsMap.has(\"importAssertions\")) {\n    if (pluginsMap.has(\"deprecatedImportAssert\")) {\n      throw new Error(\"Cannot combine importAssertions and deprecatedImportAssert plugins.\");\n    }\n  }\n  if (!pluginsMap.has(\"deprecatedImportAssert\") && pluginsMap.has(\"importAttributes\") && pluginsMap.get(\"importAttributes\").deprecatedAssertSyntax) {\n    {\n      pluginsMap.set(\"deprecatedImportAssert\", {});\n    }\n  }\n  if (pluginsMap.has(\"recordAndTuple\")) {\n    {\n      const syntaxType = pluginsMap.get(\"recordAndTuple\").syntaxType;\n      if (syntaxType != null) {\n        const RECORD_AND_TUPLE_SYNTAX_TYPES = [\"hash\", \"bar\"];\n        if (!RECORD_AND_TUPLE_SYNTAX_TYPES.includes(syntaxType)) {\n          throw new Error(\"The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: \" + RECORD_AND_TUPLE_SYNTAX_TYPES.map(p => `'${p}'`).join(\", \"));\n        }\n      }\n    }\n  }\n  if (pluginsMap.has(\"asyncDoExpressions\") && !pluginsMap.has(\"doExpressions\")) {\n    const error = new Error(\"'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.\");\n    error.missingPlugins = \"doExpressions\";\n    throw error;\n  }\n  if (pluginsMap.has(\"optionalChainingAssign\") && pluginsMap.get(\"optionalChainingAssign\").version !== \"2023-07\") {\n    throw new Error(\"The 'optionalChainingAssign' plugin requires a 'version' option,\" + \" representing the last proposal update. Currently, the\" + \" only supported value is '2023-07'.\");\n  }\n  if (pluginsMap.has(\"discardBinding\") && pluginsMap.get(\"discardBinding\").syntaxType !== \"void\") {\n    throw new Error(\"The 'discardBinding' plugin requires a 'syntaxType' option. Currently the only supported value is 'void'.\");\n  }\n}\nconst mixinPlugins = {\n  estree,\n  jsx,\n  flow,\n  typescript,\n  v8intrinsic,\n  placeholders\n};\nconst mixinPluginNames = Object.keys(mixinPlugins);\nclass ExpressionParser extends LValParser {\n  checkProto(prop, isRecord, sawProto, refExpressionErrors) {\n    if (prop.type === \"SpreadElement\" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {\n      return sawProto;\n    }\n    const key = prop.key;\n    const name = key.type === \"Identifier\" ? key.name : key.value;\n    if (name === \"__proto__\") {\n      if (isRecord) {\n        this.raise(Errors.RecordNoProto, key);\n        return true;\n      }\n      if (sawProto) {\n        if (refExpressionErrors) {\n          if (refExpressionErrors.doubleProtoLoc === null) {\n            refExpressionErrors.doubleProtoLoc = key.loc.start;\n          }\n        } else {\n          this.raise(Errors.DuplicateProto, key);\n        }\n      }\n      return true;\n    }\n    return sawProto;\n  }\n  shouldExitDescending(expr, potentialArrowAt) {\n    return expr.type === \"ArrowFunctionExpression\" && this.offsetToSourcePos(expr.start) === potentialArrowAt;\n  }\n  getExpression() {\n    this.enterInitialScopes();\n    this.nextToken();\n    if (this.match(140)) {\n      throw this.raise(Errors.ParseExpressionEmptyInput, this.state.startLoc);\n    }\n    const expr = this.parseExpression();\n    if (!this.match(140)) {\n      throw this.raise(Errors.ParseExpressionExpectsEOF, this.state.startLoc, {\n        unexpected: this.input.codePointAt(this.state.start)\n      });\n    }\n    this.finalizeRemainingComments();\n    expr.comments = this.comments;\n    expr.errors = this.state.errors;\n    if (this.optionFlags & 256) {\n      expr.tokens = this.tokens;\n    }\n    return expr;\n  }\n  parseExpression(disallowIn, refExpressionErrors) {\n    if (disallowIn) {\n      return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n    }\n    return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n  }\n  parseExpressionBase(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const expr = this.parseMaybeAssign(refExpressionErrors);\n    if (this.match(12)) {\n      const node = this.startNodeAt(startLoc);\n      node.expressions = [expr];\n      while (this.eat(12)) {\n        node.expressions.push(this.parseMaybeAssign(refExpressionErrors));\n      }\n      this.toReferencedList(node.expressions);\n      return this.finishNode(node, \"SequenceExpression\");\n    }\n    return expr;\n  }\n  parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {\n    return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));\n  }\n  parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {\n    return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));\n  }\n  setOptionalParametersError(refExpressionErrors) {\n    refExpressionErrors.optionalParametersLoc = this.state.startLoc;\n  }\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    const startLoc = this.state.startLoc;\n    const isYield = this.isContextual(108);\n    if (isYield) {\n      if (this.prodParam.hasYield) {\n        this.next();\n        let left = this.parseYield(startLoc);\n        if (afterLeftParse) {\n          left = afterLeftParse.call(this, left, startLoc);\n        }\n        return left;\n      }\n    }\n    let ownExpressionErrors;\n    if (refExpressionErrors) {\n      ownExpressionErrors = false;\n    } else {\n      refExpressionErrors = new ExpressionErrors();\n      ownExpressionErrors = true;\n    }\n    const {\n      type\n    } = this.state;\n    if (type === 10 || tokenIsIdentifier(type)) {\n      this.state.potentialArrowAt = this.state.start;\n    }\n    let left = this.parseMaybeConditional(refExpressionErrors);\n    if (afterLeftParse) {\n      left = afterLeftParse.call(this, left, startLoc);\n    }\n    if (tokenIsAssignment(this.state.type)) {\n      const node = this.startNodeAt(startLoc);\n      const operator = this.state.value;\n      node.operator = operator;\n      if (this.match(29)) {\n        this.toAssignable(left, true);\n        node.left = left;\n        const startIndex = startLoc.index;\n        if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) {\n          refExpressionErrors.doubleProtoLoc = null;\n        }\n        if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) {\n          refExpressionErrors.shorthandAssignLoc = null;\n        }\n        if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {\n          this.checkDestructuringPrivate(refExpressionErrors);\n          refExpressionErrors.privateKeyLoc = null;\n        }\n        if (refExpressionErrors.voidPatternLoc != null && refExpressionErrors.voidPatternLoc.index >= startIndex) {\n          refExpressionErrors.voidPatternLoc = null;\n        }\n      } else {\n        node.left = left;\n      }\n      this.next();\n      node.right = this.parseMaybeAssign();\n      this.checkLVal(left, this.finishNode(node, \"AssignmentExpression\"));\n      return node;\n    } else if (ownExpressionErrors) {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n    if (isYield) {\n      const {\n        type\n      } = this.state;\n      const startsExpr = this.hasPlugin(\"v8intrinsic\") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);\n      if (startsExpr && !this.isAmbiguousPrefixOrIdentifier()) {\n        this.raiseOverwrite(Errors.YieldNotInGeneratorFunction, startLoc);\n        return this.parseYield(startLoc);\n      }\n    }\n    return left;\n  }\n  parseMaybeConditional(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprOps(refExpressionErrors);\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n    return this.parseConditional(expr, startLoc, refExpressionErrors);\n  }\n  parseConditional(expr, startLoc, refExpressionErrors) {\n    if (this.eat(17)) {\n      const node = this.startNodeAt(startLoc);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssignAllowIn();\n      this.expect(14);\n      node.alternate = this.parseMaybeAssign();\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n    return expr;\n  }\n  parseMaybeUnaryOrPrivate(refExpressionErrors) {\n    return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);\n  }\n  parseExprOps(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n    return this.parseExprOp(expr, startLoc, -1);\n  }\n  parseExprOp(left, leftStartLoc, minPrec) {\n    if (this.isPrivateName(left)) {\n      const value = this.getPrivateNameSV(left);\n      if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {\n        this.raise(Errors.PrivateInExpectedIn, left, {\n          identifierName: value\n        });\n      }\n      this.classScope.usePrivateName(value, left.loc.start);\n    }\n    const op = this.state.type;\n    if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {\n      let prec = tokenOperatorPrecedence(op);\n      if (prec > minPrec) {\n        if (op === 39) {\n          this.expectPlugin(\"pipelineOperator\");\n          if (this.state.inFSharpPipelineDirectBody) {\n            return left;\n          }\n          this.checkPipelineAtInfixOperator(left, leftStartLoc);\n        }\n        const node = this.startNodeAt(leftStartLoc);\n        node.left = left;\n        node.operator = this.state.value;\n        const logical = op === 41 || op === 42;\n        const coalesce = op === 40;\n        if (coalesce) {\n          prec = tokenOperatorPrecedence(42);\n        }\n        this.next();\n        if (op === 39 && this.hasPlugin([\"pipelineOperator\", {\n          proposal: \"minimal\"\n        }])) {\n          if (this.state.type === 96 && this.prodParam.hasAwait) {\n            throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);\n          }\n        }\n        node.right = this.parseExprOpRightExpr(op, prec);\n        const finishedNode = this.finishNode(node, logical || coalesce ? \"LogicalExpression\" : \"BinaryExpression\");\n        const nextOp = this.state.type;\n        if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {\n          throw this.raise(Errors.MixingCoalesceWithLogical, this.state.startLoc);\n        }\n        return this.parseExprOp(finishedNode, leftStartLoc, minPrec);\n      }\n    }\n    return left;\n  }\n  parseExprOpRightExpr(op, prec) {\n    const startLoc = this.state.startLoc;\n    switch (op) {\n      case 39:\n        switch (this.getPluginOption(\"pipelineOperator\", \"proposal\")) {\n          case \"hack\":\n            return this.withTopicBindingContext(() => {\n              return this.parseHackPipeBody();\n            });\n          case \"fsharp\":\n            return this.withSoloAwaitPermittingContext(() => {\n              return this.parseFSharpPipelineBody(prec);\n            });\n        }\n        if (this.getPluginOption(\"pipelineOperator\", \"proposal\") === \"smart\") {\n          return this.withTopicBindingContext(() => {\n            if (this.prodParam.hasYield && this.isContextual(108)) {\n              throw this.raise(Errors.PipeBodyIsTighter, this.state.startLoc);\n            }\n            return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startLoc);\n          });\n        }\n      default:\n        return this.parseExprOpBaseRightExpr(op, prec);\n    }\n  }\n  parseExprOpBaseRightExpr(op, prec) {\n    const startLoc = this.state.startLoc;\n    return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);\n  }\n  parseHackPipeBody() {\n    var _body$extra;\n    const {\n      startLoc\n    } = this.state;\n    const body = this.parseMaybeAssign();\n    const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);\n    if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {\n      this.raise(Errors.PipeUnparenthesizedBody, startLoc, {\n        type: body.type\n      });\n    }\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      this.raise(Errors.PipeTopicUnused, startLoc);\n    }\n    return body;\n  }\n  checkExponentialAfterUnary(node) {\n    if (this.match(57)) {\n      this.raise(Errors.UnexpectedTokenUnaryExponentiation, node.argument);\n    }\n  }\n  parseMaybeUnary(refExpressionErrors, sawUnary) {\n    const startLoc = this.state.startLoc;\n    const isAwait = this.isContextual(96);\n    if (isAwait && this.recordAwaitIfAllowed()) {\n      this.next();\n      const expr = this.parseAwait(startLoc);\n      if (!sawUnary) this.checkExponentialAfterUnary(expr);\n      return expr;\n    }\n    const update = this.match(34);\n    const node = this.startNode();\n    if (tokenIsPrefix(this.state.type)) {\n      node.operator = this.state.value;\n      node.prefix = true;\n      if (this.match(72)) {\n        this.expectPlugin(\"throwExpressions\");\n      }\n      const isDelete = this.match(89);\n      this.next();\n      node.argument = this.parseMaybeUnary(null, true);\n      this.checkExpressionErrors(refExpressionErrors, true);\n      if (this.state.strict && isDelete) {\n        const arg = node.argument;\n        if (arg.type === \"Identifier\") {\n          this.raise(Errors.StrictDelete, node);\n        } else if (this.hasPropertyAsPrivateName(arg)) {\n          this.raise(Errors.DeletePrivateField, node);\n        }\n      }\n      if (!update) {\n        if (!sawUnary) {\n          this.checkExponentialAfterUnary(node);\n        }\n        return this.finishNode(node, \"UnaryExpression\");\n      }\n    }\n    const expr = this.parseUpdate(node, update, refExpressionErrors);\n    if (isAwait) {\n      const {\n        type\n      } = this.state;\n      const startsExpr = this.hasPlugin(\"v8intrinsic\") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);\n      if (startsExpr && !this.isAmbiguousPrefixOrIdentifier()) {\n        this.raiseOverwrite(Errors.AwaitNotInAsyncContext, startLoc);\n        return this.parseAwait(startLoc);\n      }\n    }\n    return expr;\n  }\n  parseUpdate(node, update, refExpressionErrors) {\n    if (update) {\n      const updateExpressionNode = node;\n      this.checkLVal(updateExpressionNode.argument, this.finishNode(updateExpressionNode, \"UpdateExpression\"));\n      return node;\n    }\n    const startLoc = this.state.startLoc;\n    let expr = this.parseExprSubscripts(refExpressionErrors);\n    if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;\n    while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt(startLoc);\n      node.operator = this.state.value;\n      node.prefix = false;\n      node.argument = expr;\n      this.next();\n      this.checkLVal(expr, expr = this.finishNode(node, \"UpdateExpression\"));\n    }\n    return expr;\n  }\n  parseExprSubscripts(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprAtom(refExpressionErrors);\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n    return this.parseSubscripts(expr, startLoc);\n  }\n  parseSubscripts(base, startLoc, noCalls) {\n    const state = {\n      optionalChainMember: false,\n      maybeAsyncArrow: this.atPossibleAsyncArrow(base),\n      stop: false\n    };\n    do {\n      base = this.parseSubscript(base, startLoc, noCalls, state);\n      state.maybeAsyncArrow = false;\n    } while (!state.stop);\n    return base;\n  }\n  parseSubscript(base, startLoc, noCalls, state) {\n    const {\n      type\n    } = this.state;\n    if (!noCalls && type === 15) {\n      return this.parseBind(base, startLoc, noCalls, state);\n    } else if (tokenIsTemplate(type)) {\n      return this.parseTaggedTemplateExpression(base, startLoc, state);\n    }\n    let optional = false;\n    if (type === 18) {\n      if (noCalls) {\n        this.raise(Errors.OptionalChainingNoNew, this.state.startLoc);\n        if (this.lookaheadCharCode() === 40) {\n          return this.stopParseSubscript(base, state);\n        }\n      }\n      state.optionalChainMember = optional = true;\n      this.next();\n    }\n    if (!noCalls && this.match(10)) {\n      return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);\n    } else {\n      const computed = this.eat(0);\n      if (computed || optional || this.eat(16)) {\n        return this.parseMember(base, startLoc, state, computed, optional);\n      } else {\n        return this.stopParseSubscript(base, state);\n      }\n    }\n  }\n  stopParseSubscript(base, state) {\n    state.stop = true;\n    return base;\n  }\n  parseMember(base, startLoc, state, computed, optional) {\n    const node = this.startNodeAt(startLoc);\n    node.object = base;\n    node.computed = computed;\n    if (computed) {\n      node.property = this.parseExpression();\n      this.expect(3);\n    } else if (this.match(139)) {\n      if (base.type === \"Super\") {\n        this.raise(Errors.SuperPrivateField, startLoc);\n      }\n      this.classScope.usePrivateName(this.state.value, this.state.startLoc);\n      node.property = this.parsePrivateName();\n    } else {\n      node.property = this.parseIdentifier(true);\n    }\n    if (state.optionalChainMember) {\n      node.optional = optional;\n      return this.finishNode(node, \"OptionalMemberExpression\");\n    } else {\n      return this.finishNode(node, \"MemberExpression\");\n    }\n  }\n  parseBind(base, startLoc, noCalls, state) {\n    const node = this.startNodeAt(startLoc);\n    node.object = base;\n    this.next();\n    node.callee = this.parseNoCallExpr();\n    state.stop = true;\n    return this.parseSubscripts(this.finishNode(node, \"BindExpression\"), startLoc, noCalls);\n  }\n  parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    let refExpressionErrors = null;\n    this.state.maybeInArrowParameters = true;\n    this.next();\n    const node = this.startNodeAt(startLoc);\n    node.callee = base;\n    const {\n      maybeAsyncArrow,\n      optionalChainMember\n    } = state;\n    if (maybeAsyncArrow) {\n      this.expressionScope.enter(newAsyncArrowScope());\n      refExpressionErrors = new ExpressionErrors();\n    }\n    if (optionalChainMember) {\n      node.optional = optional;\n    }\n    if (optional) {\n      node.arguments = this.parseCallExpressionArguments();\n    } else {\n      node.arguments = this.parseCallExpressionArguments(base.type !== \"Super\", node, refExpressionErrors);\n    }\n    let finishedNode = this.finishCallExpression(node, optionalChainMember);\n    if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {\n      state.stop = true;\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);\n    } else {\n      if (maybeAsyncArrow) {\n        this.checkExpressionErrors(refExpressionErrors, true);\n        this.expressionScope.exit();\n      }\n      this.toReferencedArguments(finishedNode);\n    }\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return finishedNode;\n  }\n  toReferencedArguments(node, isParenthesizedExpr) {\n    this.toReferencedListDeep(node.arguments, isParenthesizedExpr);\n  }\n  parseTaggedTemplateExpression(base, startLoc, state) {\n    const node = this.startNodeAt(startLoc);\n    node.tag = base;\n    node.quasi = this.parseTemplate(true);\n    if (state.optionalChainMember) {\n      this.raise(Errors.OptionalChainingNoTemplate, startLoc);\n    }\n    return this.finishNode(node, \"TaggedTemplateExpression\");\n  }\n  atPossibleAsyncArrow(base) {\n    return base.type === \"Identifier\" && base.name === \"async\" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.offsetToSourcePos(base.start) === this.state.potentialArrowAt;\n  }\n  finishCallExpression(node, optional) {\n    if (node.callee.type === \"Import\") {\n      if (node.arguments.length === 0 || node.arguments.length > 2) {\n        this.raise(Errors.ImportCallArity, node);\n      } else {\n        for (const arg of node.arguments) {\n          if (arg.type === \"SpreadElement\") {\n            this.raise(Errors.ImportCallSpreadArgument, arg);\n          }\n        }\n      }\n    }\n    return this.finishNode(node, optional ? \"OptionalCallExpression\" : \"CallExpression\");\n  }\n  parseCallExpressionArguments(allowPlaceholder, nodeForExtra, refExpressionErrors) {\n    const elts = [];\n    let first = true;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    while (!this.eat(11)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.match(11)) {\n          if (nodeForExtra) {\n            this.addTrailingCommaExtraToNode(nodeForExtra);\n          }\n          this.next();\n          break;\n        }\n      }\n      elts.push(this.parseExprListItem(11, false, refExpressionErrors, allowPlaceholder));\n    }\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return elts;\n  }\n  shouldParseAsyncArrow() {\n    return this.match(19) && !this.canInsertSemicolon();\n  }\n  parseAsyncArrowFromCallExpression(node, call) {\n    var _call$extra;\n    this.resetPreviousNodeTrailingComments(call);\n    this.expect(19);\n    this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);\n    if (call.innerComments) {\n      setInnerComments(node, call.innerComments);\n    }\n    if (call.callee.trailingComments) {\n      setInnerComments(node, call.callee.trailingComments);\n    }\n    return node;\n  }\n  parseNoCallExpr() {\n    const startLoc = this.state.startLoc;\n    return this.parseSubscripts(this.parseExprAtom(), startLoc, true);\n  }\n  parseExprAtom(refExpressionErrors) {\n    let node;\n    let decorators = null;\n    const {\n      type\n    } = this.state;\n    switch (type) {\n      case 79:\n        return this.parseSuper();\n      case 83:\n        node = this.startNode();\n        this.next();\n        if (this.match(16)) {\n          return this.parseImportMetaPropertyOrPhaseCall(node);\n        }\n        if (this.match(10)) {\n          if (this.optionFlags & 512) {\n            return this.parseImportCall(node);\n          } else {\n            return this.finishNode(node, \"Import\");\n          }\n        } else {\n          this.raise(Errors.UnsupportedImport, this.state.lastTokStartLoc);\n          return this.finishNode(node, \"Import\");\n        }\n      case 78:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"ThisExpression\");\n      case 90:\n        {\n          return this.parseDo(this.startNode(), false);\n        }\n      case 56:\n      case 31:\n        {\n          this.readRegexp();\n          return this.parseRegExpLiteral(this.state.value);\n        }\n      case 135:\n        return this.parseNumericLiteral(this.state.value);\n      case 136:\n        return this.parseBigIntLiteral(this.state.value);\n      case 134:\n        return this.parseStringLiteral(this.state.value);\n      case 84:\n        return this.parseNullLiteral();\n      case 85:\n        return this.parseBooleanLiteral(true);\n      case 86:\n        return this.parseBooleanLiteral(false);\n      case 10:\n        {\n          const canBeArrow = this.state.potentialArrowAt === this.state.start;\n          return this.parseParenAndDistinguishExpression(canBeArrow);\n        }\n      case 0:\n        {\n          return this.parseArrayLike(3, true, false, refExpressionErrors);\n        }\n      case 5:\n        {\n          return this.parseObjectLike(8, false, false, refExpressionErrors);\n        }\n      case 68:\n        return this.parseFunctionOrFunctionSent();\n      case 26:\n        decorators = this.parseDecorators();\n      case 80:\n        return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);\n      case 77:\n        return this.parseNewOrNewTarget();\n      case 25:\n      case 24:\n        return this.parseTemplate(false);\n      case 15:\n        {\n          node = this.startNode();\n          this.next();\n          node.object = null;\n          const callee = node.callee = this.parseNoCallExpr();\n          if (callee.type === \"MemberExpression\") {\n            return this.finishNode(node, \"BindExpression\");\n          } else {\n            throw this.raise(Errors.UnsupportedBind, callee);\n          }\n        }\n      case 139:\n        {\n          this.raise(Errors.PrivateInExpectedIn, this.state.startLoc, {\n            identifierName: this.state.value\n          });\n          return this.parsePrivateName();\n        }\n      case 33:\n        {\n          return this.parseTopicReferenceThenEqualsSign(54, \"%\");\n        }\n      case 32:\n        {\n          return this.parseTopicReferenceThenEqualsSign(44, \"^\");\n        }\n      case 37:\n      case 38:\n        {\n          return this.parseTopicReference(\"hack\");\n        }\n      case 44:\n      case 54:\n      case 27:\n        {\n          const pipeProposal = this.getPluginOption(\"pipelineOperator\", \"proposal\");\n          if (pipeProposal) {\n            return this.parseTopicReference(pipeProposal);\n          }\n          this.unexpected();\n          break;\n        }\n      case 47:\n        {\n          const lookaheadCh = this.input.codePointAt(this.nextTokenStart());\n          if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {\n            this.expectOnePlugin([\"jsx\", \"flow\", \"typescript\"]);\n          } else {\n            this.unexpected();\n          }\n          break;\n        }\n      default:\n        {\n          if (type === 137) {\n            return this.parseDecimalLiteral(this.state.value);\n          } else if (type === 2 || type === 1) {\n            return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);\n          } else if (type === 6 || type === 7) {\n            return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);\n          }\n        }\n        if (tokenIsIdentifier(type)) {\n          if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) {\n            return this.parseModuleExpression();\n          }\n          const canBeArrow = this.state.potentialArrowAt === this.state.start;\n          const containsEsc = this.state.containsEsc;\n          const id = this.parseIdentifier();\n          if (!containsEsc && id.name === \"async\" && !this.canInsertSemicolon()) {\n            const {\n              type\n            } = this.state;\n            if (type === 68) {\n              this.resetPreviousNodeTrailingComments(id);\n              this.next();\n              return this.parseAsyncFunctionExpression(this.startNodeAtNode(id));\n            } else if (tokenIsIdentifier(type)) {\n              if (this.lookaheadCharCode() === 61) {\n                return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));\n              } else {\n                return id;\n              }\n            } else if (type === 90) {\n              this.resetPreviousNodeTrailingComments(id);\n              return this.parseDo(this.startNodeAtNode(id), true);\n            }\n          }\n          if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {\n            this.next();\n            return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);\n          }\n          return id;\n        } else {\n          this.unexpected();\n        }\n    }\n  }\n  parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {\n    const pipeProposal = this.getPluginOption(\"pipelineOperator\", \"proposal\");\n    if (pipeProposal) {\n      this.state.type = topicTokenType;\n      this.state.value = topicTokenValue;\n      this.state.pos--;\n      this.state.end--;\n      this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);\n      return this.parseTopicReference(pipeProposal);\n    } else {\n      this.unexpected();\n    }\n  }\n  parseTopicReference(pipeProposal) {\n    const node = this.startNode();\n    const startLoc = this.state.startLoc;\n    const tokenType = this.state.type;\n    this.next();\n    return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);\n  }\n  finishTopicReference(node, startLoc, pipeProposal, tokenType) {\n    if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {\n      if (pipeProposal === \"hack\") {\n        if (!this.topicReferenceIsAllowedInCurrentContext()) {\n          this.raise(Errors.PipeTopicUnbound, startLoc);\n        }\n        this.registerTopicReference();\n        return this.finishNode(node, \"TopicReference\");\n      } else {\n        if (!this.topicReferenceIsAllowedInCurrentContext()) {\n          this.raise(Errors.PrimaryTopicNotAllowed, startLoc);\n        }\n        this.registerTopicReference();\n        return this.finishNode(node, \"PipelinePrimaryTopicReference\");\n      }\n    } else {\n      throw this.raise(Errors.PipeTopicUnconfiguredToken, startLoc, {\n        token: tokenLabelName(tokenType)\n      });\n    }\n  }\n  testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {\n    switch (pipeProposal) {\n      case \"hack\":\n        {\n          return this.hasPlugin([\"pipelineOperator\", {\n            topicToken: tokenLabelName(tokenType)\n          }]);\n        }\n      case \"smart\":\n        return tokenType === 27;\n      default:\n        throw this.raise(Errors.PipeTopicRequiresHackPipes, startLoc);\n    }\n  }\n  parseAsyncArrowUnaryFunction(node) {\n    this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));\n    const params = [this.parseIdentifier()];\n    this.prodParam.exit();\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(Errors.LineTerminatorBeforeArrow, this.state.curPosition());\n    }\n    this.expect(19);\n    return this.parseArrowExpression(node, params, true);\n  }\n  parseDo(node, isAsync) {\n    this.expectPlugin(\"doExpressions\");\n    if (isAsync) {\n      this.expectPlugin(\"asyncDoExpressions\");\n    }\n    node.async = isAsync;\n    this.next();\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    if (isAsync) {\n      this.prodParam.enter(2);\n      node.body = this.parseBlock();\n      this.prodParam.exit();\n    } else {\n      node.body = this.parseBlock();\n    }\n    this.state.labels = oldLabels;\n    return this.finishNode(node, \"DoExpression\");\n  }\n  parseSuper() {\n    const node = this.startNode();\n    this.next();\n    if (this.match(10) && !this.scope.allowDirectSuper && !(this.optionFlags & 16)) {\n      this.raise(Errors.SuperNotAllowed, node);\n    } else if (!this.scope.allowSuper && !(this.optionFlags & 16)) {\n      this.raise(Errors.UnexpectedSuper, node);\n    }\n    if (!this.match(10) && !this.match(0) && !this.match(16)) {\n      this.raise(Errors.UnsupportedSuper, node);\n    }\n    return this.finishNode(node, \"Super\");\n  }\n  parsePrivateName() {\n    const node = this.startNode();\n    const id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));\n    const name = this.state.value;\n    this.next();\n    node.id = this.createIdentifier(id, name);\n    return this.finishNode(node, \"PrivateName\");\n  }\n  parseFunctionOrFunctionSent() {\n    const node = this.startNode();\n    this.next();\n    if (this.prodParam.hasYield && this.match(16)) {\n      const meta = this.createIdentifier(this.startNodeAtNode(node), \"function\");\n      this.next();\n      if (this.match(103)) {\n        this.expectPlugin(\"functionSent\");\n      } else if (!this.hasPlugin(\"functionSent\")) {\n        this.unexpected();\n      }\n      return this.parseMetaProperty(node, meta, \"sent\");\n    }\n    return this.parseFunction(node);\n  }\n  parseMetaProperty(node, meta, propertyName) {\n    node.meta = meta;\n    const containsEsc = this.state.containsEsc;\n    node.property = this.parseIdentifier(true);\n    if (node.property.name !== propertyName || containsEsc) {\n      this.raise(Errors.UnsupportedMetaProperty, node.property, {\n        target: meta.name,\n        onlyValidPropertyName: propertyName\n      });\n    }\n    return this.finishNode(node, \"MetaProperty\");\n  }\n  parseImportMetaPropertyOrPhaseCall(node) {\n    this.next();\n    if (this.isContextual(105) || this.isContextual(97)) {\n      const isSource = this.isContextual(105);\n      this.expectPlugin(isSource ? \"sourcePhaseImports\" : \"deferredImportEvaluation\");\n      this.next();\n      node.phase = isSource ? \"source\" : \"defer\";\n      return this.parseImportCall(node);\n    } else {\n      const id = this.createIdentifierAt(this.startNodeAtNode(node), \"import\", this.state.lastTokStartLoc);\n      if (this.isContextual(101)) {\n        if (!this.inModule) {\n          this.raise(Errors.ImportMetaOutsideModule, id);\n        }\n        this.sawUnambiguousESM = true;\n      }\n      return this.parseMetaProperty(node, id, \"meta\");\n    }\n  }\n  parseLiteralAtNode(value, type, node) {\n    this.addExtra(node, \"rawValue\", value);\n    this.addExtra(node, \"raw\", this.input.slice(this.offsetToSourcePos(node.start), this.state.end));\n    node.value = value;\n    this.next();\n    return this.finishNode(node, type);\n  }\n  parseLiteral(value, type) {\n    const node = this.startNode();\n    return this.parseLiteralAtNode(value, type, node);\n  }\n  parseStringLiteral(value) {\n    return this.parseLiteral(value, \"StringLiteral\");\n  }\n  parseNumericLiteral(value) {\n    return this.parseLiteral(value, \"NumericLiteral\");\n  }\n  parseBigIntLiteral(value) {\n    {\n      return this.parseLiteral(value, \"BigIntLiteral\");\n    }\n  }\n  parseDecimalLiteral(value) {\n    return this.parseLiteral(value, \"DecimalLiteral\");\n  }\n  parseRegExpLiteral(value) {\n    const node = this.startNode();\n    this.addExtra(node, \"raw\", this.input.slice(this.offsetToSourcePos(node.start), this.state.end));\n    node.pattern = value.pattern;\n    node.flags = value.flags;\n    this.next();\n    return this.finishNode(node, \"RegExpLiteral\");\n  }\n  parseBooleanLiteral(value) {\n    const node = this.startNode();\n    node.value = value;\n    this.next();\n    return this.finishNode(node, \"BooleanLiteral\");\n  }\n  parseNullLiteral() {\n    const node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"NullLiteral\");\n  }\n  parseParenAndDistinguishExpression(canBeArrow) {\n    const startLoc = this.state.startLoc;\n    let val;\n    this.next();\n    this.expressionScope.enter(newArrowHeadScope());\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.maybeInArrowParameters = true;\n    this.state.inFSharpPipelineDirectBody = false;\n    const innerStartLoc = this.state.startLoc;\n    const exprList = [];\n    const refExpressionErrors = new ExpressionErrors();\n    let first = true;\n    let spreadStartLoc;\n    let optionalCommaStartLoc;\n    while (!this.match(11)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);\n        if (this.match(11)) {\n          optionalCommaStartLoc = this.state.startLoc;\n          break;\n        }\n      }\n      if (this.match(21)) {\n        const spreadNodeStartLoc = this.state.startLoc;\n        spreadStartLoc = this.state.startLoc;\n        exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc));\n        if (!this.checkCommaAfterRest(41)) {\n          break;\n        }\n      } else {\n        exprList.push(this.parseMaybeAssignAllowInOrVoidPattern(11, refExpressionErrors, this.parseParenItem));\n      }\n    }\n    const innerEndLoc = this.state.lastTokEndLoc;\n    this.expect(11);\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let arrowNode = this.startNodeAt(startLoc);\n    if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      this.parseArrowExpression(arrowNode, exprList, false);\n      return arrowNode;\n    }\n    this.expressionScope.exit();\n    if (!exprList.length) {\n      this.unexpected(this.state.lastTokStartLoc);\n    }\n    if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc);\n    if (spreadStartLoc) this.unexpected(spreadStartLoc);\n    this.checkExpressionErrors(refExpressionErrors, true);\n    this.toReferencedListDeep(exprList, true);\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartLoc);\n      val.expressions = exprList;\n      this.finishNode(val, \"SequenceExpression\");\n      this.resetEndLocation(val, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n    return this.wrapParenthesis(startLoc, val);\n  }\n  wrapParenthesis(startLoc, expression) {\n    if (!(this.optionFlags & 1024)) {\n      this.addExtra(expression, \"parenthesized\", true);\n      this.addExtra(expression, \"parenStart\", startLoc.index);\n      this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index);\n      return expression;\n    }\n    const parenExpression = this.startNodeAt(startLoc);\n    parenExpression.expression = expression;\n    return this.finishNode(parenExpression, \"ParenthesizedExpression\");\n  }\n  shouldParseArrow(params) {\n    return !this.canInsertSemicolon();\n  }\n  parseArrow(node) {\n    if (this.eat(19)) {\n      return node;\n    }\n  }\n  parseParenItem(node, startLoc) {\n    return node;\n  }\n  parseNewOrNewTarget() {\n    const node = this.startNode();\n    this.next();\n    if (this.match(16)) {\n      const meta = this.createIdentifier(this.startNodeAtNode(node), \"new\");\n      this.next();\n      const metaProp = this.parseMetaProperty(node, meta, \"target\");\n      if (!this.scope.allowNewTarget) {\n        this.raise(Errors.UnexpectedNewTarget, metaProp);\n      }\n      return metaProp;\n    }\n    return this.parseNew(node);\n  }\n  parseNew(node) {\n    this.parseNewCallee(node);\n    if (this.eat(10)) {\n      const args = this.parseExprList(11);\n      this.toReferencedList(args);\n      node.arguments = args;\n    } else {\n      node.arguments = [];\n    }\n    return this.finishNode(node, \"NewExpression\");\n  }\n  parseNewCallee(node) {\n    const isImport = this.match(83);\n    const callee = this.parseNoCallExpr();\n    node.callee = callee;\n    if (isImport && (callee.type === \"Import\" || callee.type === \"ImportExpression\")) {\n      this.raise(Errors.ImportCallNotNewExpression, callee);\n    }\n  }\n  parseTemplateElement(isTagged) {\n    const {\n      start,\n      startLoc,\n      end,\n      value\n    } = this.state;\n    const elemStart = start + 1;\n    const elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));\n    if (value === null) {\n      if (!isTagged) {\n        this.raise(Errors.InvalidEscapeSequenceTemplate, createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1));\n      }\n    }\n    const isTail = this.match(24);\n    const endOffset = isTail ? -1 : -2;\n    const elemEnd = end + endOffset;\n    elem.value = {\n      raw: this.input.slice(elemStart, elemEnd).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: value === null ? null : value.slice(1, endOffset)\n    };\n    elem.tail = isTail;\n    this.next();\n    const finishedNode = this.finishNode(elem, \"TemplateElement\");\n    this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));\n    return finishedNode;\n  }\n  parseTemplate(isTagged) {\n    const node = this.startNode();\n    let curElt = this.parseTemplateElement(isTagged);\n    const quasis = [curElt];\n    const substitutions = [];\n    while (!curElt.tail) {\n      substitutions.push(this.parseTemplateSubstitution());\n      this.readTemplateContinuation();\n      quasis.push(curElt = this.parseTemplateElement(isTagged));\n    }\n    node.expressions = substitutions;\n    node.quasis = quasis;\n    return this.finishNode(node, \"TemplateLiteral\");\n  }\n  parseTemplateSubstitution() {\n    return this.parseExpression();\n  }\n  parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {\n    if (isRecord) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    let sawProto = false;\n    let first = true;\n    const node = this.startNode();\n    node.properties = [];\n    this.next();\n    while (!this.match(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.match(close)) {\n          this.addTrailingCommaExtraToNode(node);\n          break;\n        }\n      }\n      let prop;\n      if (isPattern) {\n        prop = this.parseBindingProperty();\n      } else {\n        prop = this.parsePropertyDefinition(refExpressionErrors);\n        sawProto = this.checkProto(prop, isRecord, sawProto, refExpressionErrors);\n      }\n      if (isRecord && !this.isObjectProperty(prop) && prop.type !== \"SpreadElement\") {\n        this.raise(Errors.InvalidRecordProperty, prop);\n      }\n      {\n        if (prop.shorthand) {\n          this.addExtra(prop, \"shorthand\", true);\n        }\n      }\n      node.properties.push(prop);\n    }\n    this.next();\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let type = \"ObjectExpression\";\n    if (isPattern) {\n      type = \"ObjectPattern\";\n    } else if (isRecord) {\n      type = \"RecordExpression\";\n    }\n    return this.finishNode(node, type);\n  }\n  addTrailingCommaExtraToNode(node) {\n    this.addExtra(node, \"trailingComma\", this.state.lastTokStartLoc.index);\n    this.addExtra(node, \"trailingCommaLoc\", this.state.lastTokStartLoc, false);\n  }\n  maybeAsyncOrAccessorProp(prop) {\n    return !prop.computed && prop.key.type === \"Identifier\" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));\n  }\n  parsePropertyDefinition(refExpressionErrors) {\n    let decorators = [];\n    if (this.match(26)) {\n      if (this.hasPlugin(\"decorators\")) {\n        this.raise(Errors.UnsupportedPropertyDecorator, this.state.startLoc);\n      }\n      while (this.match(26)) {\n        decorators.push(this.parseDecorator());\n      }\n    }\n    const prop = this.startNode();\n    let isAsync = false;\n    let isAccessor = false;\n    let startLoc;\n    if (this.match(21)) {\n      if (decorators.length) this.unexpected();\n      return this.parseSpread();\n    }\n    if (decorators.length) {\n      prop.decorators = decorators;\n      decorators = [];\n    }\n    prop.method = false;\n    if (refExpressionErrors) {\n      startLoc = this.state.startLoc;\n    }\n    let isGenerator = this.eat(55);\n    this.parsePropertyNamePrefixOperator(prop);\n    const containsEsc = this.state.containsEsc;\n    this.parsePropertyName(prop, refExpressionErrors);\n    if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {\n      const {\n        key\n      } = prop;\n      const keyName = key.name;\n      if (keyName === \"async\" && !this.hasPrecedingLineBreak()) {\n        isAsync = true;\n        this.resetPreviousNodeTrailingComments(key);\n        isGenerator = this.eat(55);\n        this.parsePropertyName(prop);\n      }\n      if (keyName === \"get\" || keyName === \"set\") {\n        isAccessor = true;\n        this.resetPreviousNodeTrailingComments(key);\n        prop.kind = keyName;\n        if (this.match(55)) {\n          isGenerator = true;\n          this.raise(Errors.AccessorIsGenerator, this.state.curPosition(), {\n            kind: keyName\n          });\n          this.next();\n        }\n        this.parsePropertyName(prop);\n      }\n    }\n    return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);\n  }\n  getGetterSetterExpectedParamCount(method) {\n    return method.kind === \"get\" ? 0 : 1;\n  }\n  getObjectOrClassMethodParams(method) {\n    return method.params;\n  }\n  checkGetterSetterParams(method) {\n    var _params;\n    const paramCount = this.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    if (params.length !== paramCount) {\n      this.raise(method.kind === \"get\" ? Errors.BadGetterArity : Errors.BadSetterArity, method);\n    }\n    if (method.kind === \"set\" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === \"RestElement\") {\n      this.raise(Errors.BadSetterRestParameter, method);\n    }\n  }\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {\n    if (isAccessor) {\n      const finishedProp = this.parseMethod(prop, isGenerator, false, false, false, \"ObjectMethod\");\n      this.checkGetterSetterParams(finishedProp);\n      return finishedProp;\n    }\n    if (isAsync || isGenerator || this.match(10)) {\n      if (isPattern) this.unexpected();\n      prop.kind = \"method\";\n      prop.method = true;\n      return this.parseMethod(prop, isGenerator, isAsync, false, false, \"ObjectMethod\");\n    }\n  }\n  parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {\n    prop.shorthand = false;\n    if (this.eat(14)) {\n      prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowInOrVoidPattern(8, refExpressionErrors);\n      return this.finishObjectProperty(prop);\n    }\n    if (!prop.computed && prop.key.type === \"Identifier\") {\n      this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(startLoc, this.cloneIdentifier(prop.key));\n      } else if (this.match(29)) {\n        const shorthandAssignLoc = this.state.startLoc;\n        if (refExpressionErrors != null) {\n          if (refExpressionErrors.shorthandAssignLoc === null) {\n            refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;\n          }\n        } else {\n          this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);\n        }\n        prop.value = this.parseMaybeDefault(startLoc, this.cloneIdentifier(prop.key));\n      } else {\n        prop.value = this.cloneIdentifier(prop.key);\n      }\n      prop.shorthand = true;\n      return this.finishObjectProperty(prop);\n    }\n  }\n  finishObjectProperty(node) {\n    return this.finishNode(node, \"ObjectProperty\");\n  }\n  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);\n    if (!node) this.unexpected();\n    return node;\n  }\n  parsePropertyName(prop, refExpressionErrors) {\n    if (this.eat(0)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssignAllowIn();\n      this.expect(3);\n    } else {\n      const {\n        type,\n        value\n      } = this.state;\n      let key;\n      if (tokenIsKeywordOrIdentifier(type)) {\n        key = this.parseIdentifier(true);\n      } else {\n        switch (type) {\n          case 135:\n            key = this.parseNumericLiteral(value);\n            break;\n          case 134:\n            key = this.parseStringLiteral(value);\n            break;\n          case 136:\n            key = this.parseBigIntLiteral(value);\n            break;\n          case 139:\n            {\n              const privateKeyLoc = this.state.startLoc;\n              if (refExpressionErrors != null) {\n                if (refExpressionErrors.privateKeyLoc === null) {\n                  refExpressionErrors.privateKeyLoc = privateKeyLoc;\n                }\n              } else {\n                this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);\n              }\n              key = this.parsePrivateName();\n              break;\n            }\n          default:\n            if (type === 137) {\n              key = this.parseDecimalLiteral(value);\n              break;\n            }\n            this.unexpected();\n        }\n      }\n      prop.key = key;\n      if (type !== 139) {\n        prop.computed = false;\n      }\n    }\n  }\n  initFunction(node, isAsync) {\n    node.id = null;\n    node.generator = false;\n    node.async = isAsync;\n  }\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\n    this.initFunction(node, isAsync);\n    node.generator = isGenerator;\n    this.scope.enter(514 | 16 | (inClassScope ? 576 : 0) | (allowDirectSuper ? 32 : 0));\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n    this.parseFunctionParams(node, isConstructor);\n    const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);\n    this.prodParam.exit();\n    this.scope.exit();\n    return finishedNode;\n  }\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n    if (isTuple) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const node = this.startNode();\n    this.next();\n    node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return this.finishNode(node, isTuple ? \"TupleExpression\" : \"ArrayExpression\");\n  }\n  parseArrowExpression(node, params, isAsync, trailingCommaLoc) {\n    this.scope.enter(514 | 4);\n    let flags = functionFlags(isAsync, false);\n    if (!this.match(5) && this.prodParam.hasIn) {\n      flags |= 8;\n    }\n    this.prodParam.enter(flags);\n    this.initFunction(node, isAsync);\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    if (params) {\n      this.state.maybeInArrowParameters = true;\n      this.setArrowFunctionParameters(node, params, trailingCommaLoc);\n    }\n    this.state.maybeInArrowParameters = false;\n    this.parseFunctionBody(node, true);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return this.finishNode(node, \"ArrowFunctionExpression\");\n  }\n  setArrowFunctionParameters(node, params, trailingCommaLoc) {\n    this.toAssignableList(params, trailingCommaLoc, false);\n    node.params = params;\n  }\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    this.parseFunctionBody(node, false, isMethod);\n    return this.finishNode(node, type);\n  }\n  parseFunctionBody(node, allowExpression, isMethod = false) {\n    const isExpression = allowExpression && !this.match(5);\n    this.expressionScope.enter(newExpressionScope());\n    if (isExpression) {\n      node.body = this.parseMaybeAssign();\n      this.checkParams(node, false, allowExpression, false);\n    } else {\n      const oldStrict = this.state.strict;\n      const oldLabels = this.state.labels;\n      this.state.labels = [];\n      this.prodParam.enter(this.prodParam.currentFlags() | 4);\n      node.body = this.parseBlock(true, false, hasStrictModeDirective => {\n        const nonSimple = !this.isSimpleParamList(node.params);\n        if (hasStrictModeDirective && nonSimple) {\n          this.raise(Errors.IllegalLanguageModeDirective, (node.kind === \"method\" || node.kind === \"constructor\") && !!node.key ? node.key.loc.end : node);\n        }\n        const strictModeChanged = !oldStrict && this.state.strict;\n        this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);\n        if (this.state.strict && node.id) {\n          this.checkIdentifier(node.id, 65, strictModeChanged);\n        }\n      });\n      this.prodParam.exit();\n      this.state.labels = oldLabels;\n    }\n    this.expressionScope.exit();\n  }\n  isSimpleParameter(node) {\n    return node.type === \"Identifier\";\n  }\n  isSimpleParamList(params) {\n    for (let i = 0, len = params.length; i < len; i++) {\n      if (!this.isSimpleParameter(params[i])) return false;\n    }\n    return true;\n  }\n  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {\n    const checkClashes = !allowDuplicates && new Set();\n    const formalParameters = {\n      type: \"FormalParameters\"\n    };\n    for (const param of node.params) {\n      this.checkLVal(param, formalParameters, 5, checkClashes, strictModeChanged);\n    }\n  }\n  parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {\n    const elts = [];\n    let first = true;\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.match(close)) {\n          if (nodeForExtra) {\n            this.addTrailingCommaExtraToNode(nodeForExtra);\n          }\n          this.next();\n          break;\n        }\n      }\n      elts.push(this.parseExprListItem(close, allowEmpty, refExpressionErrors));\n    }\n    return elts;\n  }\n  parseExprListItem(close, allowEmpty, refExpressionErrors, allowPlaceholder) {\n    let elt;\n    if (this.match(12)) {\n      if (!allowEmpty) {\n        this.raise(Errors.UnexpectedToken, this.state.curPosition(), {\n          unexpected: \",\"\n        });\n      }\n      elt = null;\n    } else if (this.match(21)) {\n      const spreadNodeStartLoc = this.state.startLoc;\n      elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);\n    } else if (this.match(17)) {\n      this.expectPlugin(\"partialApplication\");\n      if (!allowPlaceholder) {\n        this.raise(Errors.UnexpectedArgumentPlaceholder, this.state.startLoc);\n      }\n      const node = this.startNode();\n      this.next();\n      elt = this.finishNode(node, \"ArgumentPlaceholder\");\n    } else {\n      elt = this.parseMaybeAssignAllowInOrVoidPattern(close, refExpressionErrors, this.parseParenItem);\n    }\n    return elt;\n  }\n  parseIdentifier(liberal) {\n    const node = this.startNode();\n    const name = this.parseIdentifierName(liberal);\n    return this.createIdentifier(node, name);\n  }\n  createIdentifier(node, name) {\n    node.name = name;\n    node.loc.identifierName = name;\n    return this.finishNode(node, \"Identifier\");\n  }\n  createIdentifierAt(node, name, endLoc) {\n    node.name = name;\n    node.loc.identifierName = name;\n    return this.finishNodeAt(node, \"Identifier\", endLoc);\n  }\n  parseIdentifierName(liberal) {\n    let name;\n    const {\n      startLoc,\n      type\n    } = this.state;\n    if (tokenIsKeywordOrIdentifier(type)) {\n      name = this.state.value;\n    } else {\n      this.unexpected();\n    }\n    const tokenIsKeyword = tokenKeywordOrIdentifierIsKeyword(type);\n    if (liberal) {\n      if (tokenIsKeyword) {\n        this.replaceToken(132);\n      }\n    } else {\n      this.checkReservedWord(name, startLoc, tokenIsKeyword, false);\n    }\n    this.next();\n    return name;\n  }\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (word.length > 10) {\n      return;\n    }\n    if (!canBeReservedWord(word)) {\n      return;\n    }\n    if (checkKeywords && isKeyword(word)) {\n      this.raise(Errors.UnexpectedKeyword, startLoc, {\n        keyword: word\n      });\n      return;\n    }\n    const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;\n    if (reservedTest(word, this.inModule)) {\n      this.raise(Errors.UnexpectedReservedWord, startLoc, {\n        reservedWord: word\n      });\n      return;\n    } else if (word === \"yield\") {\n      if (this.prodParam.hasYield) {\n        this.raise(Errors.YieldBindingIdentifier, startLoc);\n        return;\n      }\n    } else if (word === \"await\") {\n      if (this.prodParam.hasAwait) {\n        this.raise(Errors.AwaitBindingIdentifier, startLoc);\n        return;\n      }\n      if (this.scope.inStaticBlock) {\n        this.raise(Errors.AwaitBindingIdentifierInStaticBlock, startLoc);\n        return;\n      }\n      this.expressionScope.recordAsyncArrowParametersError(startLoc);\n    } else if (word === \"arguments\") {\n      if (this.scope.inClassAndNotInNonArrowFunction) {\n        this.raise(Errors.ArgumentsInClass, startLoc);\n        return;\n      }\n    }\n  }\n  recordAwaitIfAllowed() {\n    const isAwaitAllowed = this.prodParam.hasAwait;\n    if (isAwaitAllowed && !this.scope.inFunction) {\n      this.state.hasTopLevelAwait = true;\n    }\n    return isAwaitAllowed;\n  }\n  parseAwait(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, node);\n    if (this.eat(55)) {\n      this.raise(Errors.ObsoleteAwaitStar, node);\n    }\n    if (!this.scope.inFunction && !(this.optionFlags & 1)) {\n      if (this.isAmbiguousPrefixOrIdentifier()) {\n        this.ambiguousScriptDifferentAst = true;\n      } else {\n        this.sawUnambiguousESM = true;\n      }\n    }\n    if (!this.state.soloAwait) {\n      node.argument = this.parseMaybeUnary(null, true);\n    }\n    return this.finishNode(node, \"AwaitExpression\");\n  }\n  isAmbiguousPrefixOrIdentifier() {\n    if (this.hasPrecedingLineBreak()) return true;\n    const {\n      type\n    } = this.state;\n    return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 102 && !this.state.containsEsc || type === 138 || type === 56 || this.hasPlugin(\"v8intrinsic\") && type === 54;\n  }\n  parseYield(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, node);\n    let delegating = false;\n    let argument = null;\n    if (!this.hasPrecedingLineBreak()) {\n      delegating = this.eat(55);\n      switch (this.state.type) {\n        case 13:\n        case 140:\n        case 8:\n        case 11:\n        case 3:\n        case 9:\n        case 14:\n        case 12:\n          if (!delegating) break;\n        default:\n          argument = this.parseMaybeAssign();\n      }\n    }\n    node.delegate = delegating;\n    node.argument = argument;\n    return this.finishNode(node, \"YieldExpression\");\n  }\n  parseImportCall(node) {\n    this.next();\n    node.source = this.parseMaybeAssignAllowIn();\n    node.options = null;\n    if (this.eat(12)) {\n      if (!this.match(11)) {\n        node.options = this.parseMaybeAssignAllowIn();\n        if (this.eat(12)) {\n          this.addTrailingCommaExtraToNode(node.options);\n          if (!this.match(11)) {\n            do {\n              this.parseMaybeAssignAllowIn();\n            } while (this.eat(12) && !this.match(11));\n            this.raise(Errors.ImportCallArity, node);\n          }\n        }\n      } else {\n        this.addTrailingCommaExtraToNode(node.source);\n      }\n    }\n    this.expect(11);\n    return this.finishNode(node, \"ImportExpression\");\n  }\n  checkPipelineAtInfixOperator(left, leftStartLoc) {\n    if (this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"smart\"\n    }])) {\n      if (left.type === \"SequenceExpression\") {\n        this.raise(Errors.PipelineHeadSequenceExpression, leftStartLoc);\n      }\n    }\n  }\n  parseSmartPipelineBodyInStyle(childExpr, startLoc) {\n    if (this.isSimpleReference(childExpr)) {\n      const bodyNode = this.startNodeAt(startLoc);\n      bodyNode.callee = childExpr;\n      return this.finishNode(bodyNode, \"PipelineBareFunction\");\n    } else {\n      const bodyNode = this.startNodeAt(startLoc);\n      this.checkSmartPipeTopicBodyEarlyErrors(startLoc);\n      bodyNode.expression = childExpr;\n      return this.finishNode(bodyNode, \"PipelineTopicExpression\");\n    }\n  }\n  isSimpleReference(expression) {\n    switch (expression.type) {\n      case \"MemberExpression\":\n        return !expression.computed && this.isSimpleReference(expression.object);\n      case \"Identifier\":\n        return true;\n      default:\n        return false;\n    }\n  }\n  checkSmartPipeTopicBodyEarlyErrors(startLoc) {\n    if (this.match(19)) {\n      throw this.raise(Errors.PipelineBodyNoArrow, this.state.startLoc);\n    }\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      this.raise(Errors.PipelineTopicUnused, startLoc);\n    }\n  }\n  withTopicBindingContext(callback) {\n    const outerContextTopicState = this.state.topicContext;\n    this.state.topicContext = {\n      maxNumOfResolvableTopics: 1,\n      maxTopicIndex: null\n    };\n    try {\n      return callback();\n    } finally {\n      this.state.topicContext = outerContextTopicState;\n    }\n  }\n  withSmartMixTopicForbiddingContext(callback) {\n    if (this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"smart\"\n    }])) {\n      const outerContextTopicState = this.state.topicContext;\n      this.state.topicContext = {\n        maxNumOfResolvableTopics: 0,\n        maxTopicIndex: null\n      };\n      try {\n        return callback();\n      } finally {\n        this.state.topicContext = outerContextTopicState;\n      }\n    } else {\n      return callback();\n    }\n  }\n  withSoloAwaitPermittingContext(callback) {\n    const outerContextSoloAwaitState = this.state.soloAwait;\n    this.state.soloAwait = true;\n    try {\n      return callback();\n    } finally {\n      this.state.soloAwait = outerContextSoloAwaitState;\n    }\n  }\n  allowInAnd(callback) {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToSet = 8 & ~flags;\n    if (prodParamToSet) {\n      this.prodParam.enter(flags | 8);\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n    return callback();\n  }\n  disallowInAnd(callback) {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToClear = 8 & flags;\n    if (prodParamToClear) {\n      this.prodParam.enter(flags & ~8);\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n    return callback();\n  }\n  registerTopicReference() {\n    this.state.topicContext.maxTopicIndex = 0;\n  }\n  topicReferenceIsAllowedInCurrentContext() {\n    return this.state.topicContext.maxNumOfResolvableTopics >= 1;\n  }\n  topicReferenceWasUsedInCurrentContext() {\n    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;\n  }\n  parseFSharpPipelineBody(prec) {\n    const startLoc = this.state.startLoc;\n    this.state.potentialArrowAt = this.state.start;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = true;\n    const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return ret;\n  }\n  parseModuleExpression() {\n    this.expectPlugin(\"moduleBlocks\");\n    const node = this.startNode();\n    this.next();\n    if (!this.match(5)) {\n      this.unexpected(null, 5);\n    }\n    const program = this.startNodeAt(this.state.endLoc);\n    this.next();\n    const revertScopes = this.initializeScopes(true);\n    this.enterInitialScopes();\n    try {\n      node.body = this.parseProgram(program, 8, \"module\");\n    } finally {\n      revertScopes();\n    }\n    return this.finishNode(node, \"ModuleExpression\");\n  }\n  parseVoidPattern(refExpressionErrors) {\n    this.expectPlugin(\"discardBinding\");\n    const node = this.startNode();\n    if (refExpressionErrors != null) {\n      refExpressionErrors.voidPatternLoc = this.state.startLoc;\n    }\n    this.next();\n    return this.finishNode(node, \"VoidPattern\");\n  }\n  parseMaybeAssignAllowInOrVoidPattern(close, refExpressionErrors, afterLeftParse) {\n    if (refExpressionErrors != null && this.match(88)) {\n      const nextCode = this.lookaheadCharCode();\n      if (nextCode === 44 || nextCode === (close === 3 ? 93 : close === 8 ? 125 : 41) || nextCode === 61) {\n        return this.parseMaybeDefault(this.state.startLoc, this.parseVoidPattern(refExpressionErrors));\n      }\n    }\n    return this.parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse);\n  }\n  parsePropertyNamePrefixOperator(prop) {}\n}\nconst loopLabel = {\n    kind: 1\n  },\n  switchLabel = {\n    kind: 2\n  };\nconst loneSurrogate = /[\\uD800-\\uDFFF]/u;\nconst keywordRelationalOperator = /in(?:stanceof)?/y;\nfunction babel7CompatTokens(tokens, input, startIndex) {\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    const {\n      type\n    } = token;\n    if (typeof type === \"number\") {\n      {\n        if (type === 139) {\n          const {\n            loc,\n            start,\n            value,\n            end\n          } = token;\n          const hashEndPos = start + 1;\n          const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);\n          tokens.splice(i, 1, new Token({\n            type: getExportedToken(27),\n            value: \"#\",\n            start: start,\n            end: hashEndPos,\n            startLoc: loc.start,\n            endLoc: hashEndLoc\n          }), new Token({\n            type: getExportedToken(132),\n            value: value,\n            start: hashEndPos,\n            end: end,\n            startLoc: hashEndLoc,\n            endLoc: loc.end\n          }));\n          i++;\n          continue;\n        }\n        if (tokenIsTemplate(type)) {\n          const {\n            loc,\n            start,\n            value,\n            end\n          } = token;\n          const backquoteEnd = start + 1;\n          const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);\n          let startToken;\n          if (input.charCodeAt(start - startIndex) === 96) {\n            startToken = new Token({\n              type: getExportedToken(22),\n              value: \"`\",\n              start: start,\n              end: backquoteEnd,\n              startLoc: loc.start,\n              endLoc: backquoteEndLoc\n            });\n          } else {\n            startToken = new Token({\n              type: getExportedToken(8),\n              value: \"}\",\n              start: start,\n              end: backquoteEnd,\n              startLoc: loc.start,\n              endLoc: backquoteEndLoc\n            });\n          }\n          let templateValue, templateElementEnd, templateElementEndLoc, endToken;\n          if (type === 24) {\n            templateElementEnd = end - 1;\n            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);\n            templateValue = value === null ? null : value.slice(1, -1);\n            endToken = new Token({\n              type: getExportedToken(22),\n              value: \"`\",\n              start: templateElementEnd,\n              end: end,\n              startLoc: templateElementEndLoc,\n              endLoc: loc.end\n            });\n          } else {\n            templateElementEnd = end - 2;\n            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);\n            templateValue = value === null ? null : value.slice(1, -2);\n            endToken = new Token({\n              type: getExportedToken(23),\n              value: \"${\",\n              start: templateElementEnd,\n              end: end,\n              startLoc: templateElementEndLoc,\n              endLoc: loc.end\n            });\n          }\n          tokens.splice(i, 1, startToken, new Token({\n            type: getExportedToken(20),\n            value: templateValue,\n            start: backquoteEnd,\n            end: templateElementEnd,\n            startLoc: backquoteEndLoc,\n            endLoc: templateElementEndLoc\n          }), endToken);\n          i += 2;\n          continue;\n        }\n      }\n      token.type = getExportedToken(type);\n    }\n  }\n  return tokens;\n}\nclass StatementParser extends ExpressionParser {\n  parseTopLevel(file, program) {\n    file.program = this.parseProgram(program, 140, this.options.sourceType === \"module\" ? \"module\" : \"script\");\n    file.comments = this.comments;\n    if (this.optionFlags & 256) {\n      file.tokens = babel7CompatTokens(this.tokens, this.input, this.startIndex);\n    }\n    return this.finishNode(file, \"File\");\n  }\n  parseProgram(program, end, sourceType) {\n    program.sourceType = sourceType;\n    program.interpreter = this.parseInterpreterDirective();\n    this.parseBlockBody(program, true, true, end);\n    if (this.inModule) {\n      if (!(this.optionFlags & 64) && this.scope.undefinedExports.size > 0) {\n        for (const [localName, at] of Array.from(this.scope.undefinedExports)) {\n          this.raise(Errors.ModuleExportUndefined, at, {\n            localName\n          });\n        }\n      }\n      this.addExtra(program, \"topLevelAwait\", this.state.hasTopLevelAwait);\n    }\n    let finishedProgram;\n    if (end === 140) {\n      finishedProgram = this.finishNode(program, \"Program\");\n    } else {\n      finishedProgram = this.finishNodeAt(program, \"Program\", createPositionWithColumnOffset(this.state.startLoc, -1));\n    }\n    return finishedProgram;\n  }\n  stmtToDirective(stmt) {\n    const directive = this.castNodeTo(stmt, \"Directive\");\n    const directiveLiteral = this.castNodeTo(stmt.expression, \"DirectiveLiteral\");\n    const expressionValue = directiveLiteral.value;\n    const raw = this.input.slice(this.offsetToSourcePos(directiveLiteral.start), this.offsetToSourcePos(directiveLiteral.end));\n    const val = directiveLiteral.value = raw.slice(1, -1);\n    this.addExtra(directiveLiteral, \"raw\", raw);\n    this.addExtra(directiveLiteral, \"rawValue\", val);\n    this.addExtra(directiveLiteral, \"expressionValue\", expressionValue);\n    directive.value = directiveLiteral;\n    delete stmt.expression;\n    return directive;\n  }\n  parseInterpreterDirective() {\n    if (!this.match(28)) {\n      return null;\n    }\n    const node = this.startNode();\n    node.value = this.state.value;\n    this.next();\n    return this.finishNode(node, \"InterpreterDirective\");\n  }\n  isLet() {\n    if (!this.isContextual(100)) {\n      return false;\n    }\n    return this.hasFollowingBindingAtom();\n  }\n  isUsing() {\n    if (!this.isContextual(107)) {\n      return false;\n    }\n    const next = this.nextTokenInLineStart();\n    const nextCh = this.codePointAtPos(next);\n    return this.chStartsBindingIdentifier(nextCh, next);\n  }\n  isForUsing() {\n    if (!this.isContextual(107)) {\n      return false;\n    }\n    const next = this.nextTokenInLineStart();\n    const nextCh = this.codePointAtPos(next);\n    if (this.isUnparsedContextual(next, \"of\")) {\n      const nextCharAfterOf = this.lookaheadCharCodeSince(next + 2);\n      if (nextCharAfterOf !== 61 && nextCharAfterOf !== 58 && nextCharAfterOf !== 59) {\n        return false;\n      }\n    }\n    if (this.chStartsBindingIdentifier(nextCh, next) || this.isUnparsedContextual(next, \"void\")) {\n      return true;\n    }\n    return false;\n  }\n  isAwaitUsing() {\n    if (!this.isContextual(96)) {\n      return false;\n    }\n    let next = this.nextTokenInLineStart();\n    if (this.isUnparsedContextual(next, \"using\")) {\n      next = this.nextTokenInLineStartSince(next + 5);\n      const nextCh = this.codePointAtPos(next);\n      if (this.chStartsBindingIdentifier(nextCh, next)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  chStartsBindingIdentifier(ch, pos) {\n    if (isIdentifierStart(ch)) {\n      keywordRelationalOperator.lastIndex = pos;\n      if (keywordRelationalOperator.test(this.input)) {\n        const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);\n        if (!isIdentifierChar(endCh) && endCh !== 92) {\n          return false;\n        }\n      }\n      return true;\n    } else if (ch === 92) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  chStartsBindingPattern(ch) {\n    return ch === 91 || ch === 123;\n  }\n  hasFollowingBindingAtom() {\n    const next = this.nextTokenStart();\n    const nextCh = this.codePointAtPos(next);\n    return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);\n  }\n  hasInLineFollowingBindingIdentifierOrBrace() {\n    const next = this.nextTokenInLineStart();\n    const nextCh = this.codePointAtPos(next);\n    return nextCh === 123 || this.chStartsBindingIdentifier(nextCh, next);\n  }\n  allowsUsing() {\n    return (this.scope.inModule || !this.scope.inTopLevel) && !this.scope.inBareCaseStatement;\n  }\n  parseModuleItem() {\n    return this.parseStatementLike(1 | 2 | 4 | 8);\n  }\n  parseStatementListItem() {\n    return this.parseStatementLike(2 | 4 | (!this.options.annexB || this.state.strict ? 0 : 8));\n  }\n  parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction = false) {\n    let flags = 0;\n    if (this.options.annexB && !this.state.strict) {\n      flags |= 4;\n      if (allowLabeledFunction) {\n        flags |= 8;\n      }\n    }\n    return this.parseStatementLike(flags);\n  }\n  parseStatement() {\n    return this.parseStatementLike(0);\n  }\n  parseStatementLike(flags) {\n    let decorators = null;\n    if (this.match(26)) {\n      decorators = this.parseDecorators(true);\n    }\n    return this.parseStatementContent(flags, decorators);\n  }\n  parseStatementContent(flags, decorators) {\n    const startType = this.state.type;\n    const node = this.startNode();\n    const allowDeclaration = !!(flags & 2);\n    const allowFunctionDeclaration = !!(flags & 4);\n    const topLevel = flags & 1;\n    switch (startType) {\n      case 60:\n        return this.parseBreakContinueStatement(node, true);\n      case 63:\n        return this.parseBreakContinueStatement(node, false);\n      case 64:\n        return this.parseDebuggerStatement(node);\n      case 90:\n        return this.parseDoWhileStatement(node);\n      case 91:\n        return this.parseForStatement(node);\n      case 68:\n        if (this.lookaheadCharCode() === 46) break;\n        if (!allowFunctionDeclaration) {\n          this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, this.state.startLoc);\n        }\n        return this.parseFunctionStatement(node, false, !allowDeclaration && allowFunctionDeclaration);\n      case 80:\n        if (!allowDeclaration) this.unexpected();\n        return this.parseClass(this.maybeTakeDecorators(decorators, node), true);\n      case 69:\n        return this.parseIfStatement(node);\n      case 70:\n        return this.parseReturnStatement(node);\n      case 71:\n        return this.parseSwitchStatement(node);\n      case 72:\n        return this.parseThrowStatement(node);\n      case 73:\n        return this.parseTryStatement(node);\n      case 96:\n        if (this.isAwaitUsing()) {\n          if (!this.allowsUsing()) {\n            this.raise(Errors.UnexpectedUsingDeclaration, node);\n          } else if (!allowDeclaration) {\n            this.raise(Errors.UnexpectedLexicalDeclaration, node);\n          } else if (!this.recordAwaitIfAllowed()) {\n            this.raise(Errors.AwaitUsingNotInAsyncContext, node);\n          }\n          this.next();\n          return this.parseVarStatement(node, \"await using\");\n        }\n        break;\n      case 107:\n        if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace()) {\n          break;\n        }\n        if (!this.allowsUsing()) {\n          this.raise(Errors.UnexpectedUsingDeclaration, this.state.startLoc);\n        } else if (!allowDeclaration) {\n          this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);\n        }\n        return this.parseVarStatement(node, \"using\");\n      case 100:\n        {\n          if (this.state.containsEsc) {\n            break;\n          }\n          const next = this.nextTokenStart();\n          const nextCh = this.codePointAtPos(next);\n          if (nextCh !== 91) {\n            if (!allowDeclaration && this.hasFollowingLineBreak()) break;\n            if (!this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123) {\n              break;\n            }\n          }\n        }\n      case 75:\n        {\n          if (!allowDeclaration) {\n            this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);\n          }\n        }\n      case 74:\n        {\n          const kind = this.state.value;\n          return this.parseVarStatement(node, kind);\n        }\n      case 92:\n        return this.parseWhileStatement(node);\n      case 76:\n        return this.parseWithStatement(node);\n      case 5:\n        return this.parseBlock();\n      case 13:\n        return this.parseEmptyStatement(node);\n      case 83:\n        {\n          const nextTokenCharCode = this.lookaheadCharCode();\n          if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {\n            break;\n          }\n        }\n      case 82:\n        {\n          if (!(this.optionFlags & 8) && !topLevel) {\n            this.raise(Errors.UnexpectedImportExport, this.state.startLoc);\n          }\n          this.next();\n          let result;\n          if (startType === 83) {\n            result = this.parseImport(node);\n          } else {\n            result = this.parseExport(node, decorators);\n          }\n          this.assertModuleNodeAllowed(result);\n          return result;\n        }\n      default:\n        {\n          if (this.isAsyncFunction()) {\n            if (!allowDeclaration) {\n              this.raise(Errors.AsyncFunctionInSingleStatementContext, this.state.startLoc);\n            }\n            this.next();\n            return this.parseFunctionStatement(node, true, !allowDeclaration && allowFunctionDeclaration);\n          }\n        }\n    }\n    const maybeName = this.state.value;\n    const expr = this.parseExpression();\n    if (tokenIsIdentifier(startType) && expr.type === \"Identifier\" && this.eat(14)) {\n      return this.parseLabeledStatement(node, maybeName, expr, flags);\n    } else {\n      return this.parseExpressionStatement(node, expr, decorators);\n    }\n  }\n  assertModuleNodeAllowed(node) {\n    if (!(this.optionFlags & 8) && !this.inModule) {\n      this.raise(Errors.ImportOutsideModule, node);\n    }\n  }\n  decoratorsEnabledBeforeExport() {\n    if (this.hasPlugin(\"decorators-legacy\")) return true;\n    return this.hasPlugin(\"decorators\") && this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") !== false;\n  }\n  maybeTakeDecorators(maybeDecorators, classNode, exportNode) {\n    if (maybeDecorators) {\n      var _classNode$decorators;\n      if ((_classNode$decorators = classNode.decorators) != null && _classNode$decorators.length) {\n        if (typeof this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") !== \"boolean\") {\n          this.raise(Errors.DecoratorsBeforeAfterExport, classNode.decorators[0]);\n        }\n        classNode.decorators.unshift(...maybeDecorators);\n      } else {\n        classNode.decorators = maybeDecorators;\n      }\n      this.resetStartLocationFromNode(classNode, maybeDecorators[0]);\n      if (exportNode) this.resetStartLocationFromNode(exportNode, classNode);\n    }\n    return classNode;\n  }\n  canHaveLeadingDecorator() {\n    return this.match(80);\n  }\n  parseDecorators(allowExport) {\n    const decorators = [];\n    do {\n      decorators.push(this.parseDecorator());\n    } while (this.match(26));\n    if (this.match(82)) {\n      if (!allowExport) {\n        this.unexpected();\n      }\n      if (!this.decoratorsEnabledBeforeExport()) {\n        this.raise(Errors.DecoratorExportClass, this.state.startLoc);\n      }\n    } else if (!this.canHaveLeadingDecorator()) {\n      throw this.raise(Errors.UnexpectedLeadingDecorator, this.state.startLoc);\n    }\n    return decorators;\n  }\n  parseDecorator() {\n    this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n    const node = this.startNode();\n    this.next();\n    if (this.hasPlugin(\"decorators\")) {\n      const startLoc = this.state.startLoc;\n      let expr;\n      if (this.match(10)) {\n        const startLoc = this.state.startLoc;\n        this.next();\n        expr = this.parseExpression();\n        this.expect(11);\n        expr = this.wrapParenthesis(startLoc, expr);\n        const paramsStartLoc = this.state.startLoc;\n        node.expression = this.parseMaybeDecoratorArguments(expr, startLoc);\n        if (this.getPluginOption(\"decorators\", \"allowCallParenthesized\") === false && node.expression !== expr) {\n          this.raise(Errors.DecoratorArgumentsOutsideParentheses, paramsStartLoc);\n        }\n      } else {\n        expr = this.parseIdentifier(false);\n        while (this.eat(16)) {\n          const node = this.startNodeAt(startLoc);\n          node.object = expr;\n          if (this.match(139)) {\n            this.classScope.usePrivateName(this.state.value, this.state.startLoc);\n            node.property = this.parsePrivateName();\n          } else {\n            node.property = this.parseIdentifier(true);\n          }\n          node.computed = false;\n          expr = this.finishNode(node, \"MemberExpression\");\n        }\n        node.expression = this.parseMaybeDecoratorArguments(expr, startLoc);\n      }\n    } else {\n      node.expression = this.parseExprSubscripts();\n    }\n    return this.finishNode(node, \"Decorator\");\n  }\n  parseMaybeDecoratorArguments(expr, startLoc) {\n    if (this.eat(10)) {\n      const node = this.startNodeAt(startLoc);\n      node.callee = expr;\n      node.arguments = this.parseCallExpressionArguments();\n      this.toReferencedList(node.arguments);\n      return this.finishNode(node, \"CallExpression\");\n    }\n    return expr;\n  }\n  parseBreakContinueStatement(node, isBreak) {\n    this.next();\n    if (this.isLineTerminator()) {\n      node.label = null;\n    } else {\n      node.label = this.parseIdentifier();\n      this.semicolon();\n    }\n    this.verifyBreakContinue(node, isBreak);\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n  }\n  verifyBreakContinue(node, isBreak) {\n    let i;\n    for (i = 0; i < this.state.labels.length; ++i) {\n      const lab = this.state.labels[i];\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === 1)) {\n          break;\n        }\n        if (node.label && isBreak) break;\n      }\n    }\n    if (i === this.state.labels.length) {\n      const type = isBreak ? \"BreakStatement\" : \"ContinueStatement\";\n      this.raise(Errors.IllegalBreakContinue, node, {\n        type\n      });\n    }\n  }\n  parseDebuggerStatement(node) {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\");\n  }\n  parseHeaderExpression() {\n    this.expect(10);\n    const val = this.parseExpression();\n    this.expect(11);\n    return val;\n  }\n  parseDoWhileStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    this.state.labels.pop();\n    this.expect(92);\n    node.test = this.parseHeaderExpression();\n    this.eat(13);\n    return this.finishNode(node, \"DoWhileStatement\");\n  }\n  parseForStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    let awaitAt = null;\n    if (this.isContextual(96) && this.recordAwaitIfAllowed()) {\n      awaitAt = this.state.startLoc;\n      this.next();\n    }\n    this.scope.enter(0);\n    this.expect(10);\n    if (this.match(13)) {\n      if (awaitAt !== null) {\n        this.unexpected(awaitAt);\n      }\n      return this.parseFor(node, null);\n    }\n    const startsWithLet = this.isContextual(100);\n    {\n      const startsWithAwaitUsing = this.isAwaitUsing();\n      const starsWithUsingDeclaration = startsWithAwaitUsing || this.isForUsing();\n      const isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;\n      if (this.match(74) || this.match(75) || isLetOrUsing) {\n        const initNode = this.startNode();\n        let kind;\n        if (startsWithAwaitUsing) {\n          kind = \"await using\";\n          if (!this.recordAwaitIfAllowed()) {\n            this.raise(Errors.AwaitUsingNotInAsyncContext, this.state.startLoc);\n          }\n          this.next();\n        } else {\n          kind = this.state.value;\n        }\n        this.next();\n        this.parseVar(initNode, true, kind);\n        const init = this.finishNode(initNode, \"VariableDeclaration\");\n        const isForIn = this.match(58);\n        if (isForIn && starsWithUsingDeclaration) {\n          this.raise(Errors.ForInUsing, init);\n        }\n        if ((isForIn || this.isContextual(102)) && init.declarations.length === 1) {\n          return this.parseForIn(node, init, awaitAt);\n        }\n        if (awaitAt !== null) {\n          this.unexpected(awaitAt);\n        }\n        return this.parseFor(node, init);\n      }\n    }\n    const startsWithAsync = this.isContextual(95);\n    const refExpressionErrors = new ExpressionErrors();\n    const init = this.parseExpression(true, refExpressionErrors);\n    const isForOf = this.isContextual(102);\n    if (isForOf) {\n      if (startsWithLet) {\n        this.raise(Errors.ForOfLet, init);\n      }\n      if (awaitAt === null && startsWithAsync && init.type === \"Identifier\") {\n        this.raise(Errors.ForOfAsync, init);\n      }\n    }\n    if (isForOf || this.match(58)) {\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.toAssignable(init, true);\n      const type = isForOf ? \"ForOfStatement\" : \"ForInStatement\";\n      this.checkLVal(init, {\n        type\n      });\n      return this.parseForIn(node, init, awaitAt);\n    } else {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n    if (awaitAt !== null) {\n      this.unexpected(awaitAt);\n    }\n    return this.parseFor(node, init);\n  }\n  parseFunctionStatement(node, isAsync, isHangingDeclaration) {\n    this.next();\n    return this.parseFunction(node, 1 | (isHangingDeclaration ? 2 : 0) | (isAsync ? 8 : 0));\n  }\n  parseIfStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    node.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();\n    node.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null;\n    return this.finishNode(node, \"IfStatement\");\n  }\n  parseReturnStatement(node) {\n    if (!this.prodParam.hasReturn) {\n      this.raise(Errors.IllegalReturn, this.state.startLoc);\n    }\n    this.next();\n    if (this.isLineTerminator()) {\n      node.argument = null;\n    } else {\n      node.argument = this.parseExpression();\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ReturnStatement\");\n  }\n  parseSwitchStatement(node) {\n    this.next();\n    node.discriminant = this.parseHeaderExpression();\n    const cases = node.cases = [];\n    this.expect(5);\n    this.state.labels.push(switchLabel);\n    this.scope.enter(256);\n    let cur;\n    for (let sawDefault; !this.match(8);) {\n      if (this.match(61) || this.match(65)) {\n        const isCase = this.match(61);\n        if (cur) this.finishNode(cur, \"SwitchCase\");\n        cases.push(cur = this.startNode());\n        cur.consequent = [];\n        this.next();\n        if (isCase) {\n          cur.test = this.parseExpression();\n        } else {\n          if (sawDefault) {\n            this.raise(Errors.MultipleDefaultsInSwitch, this.state.lastTokStartLoc);\n          }\n          sawDefault = true;\n          cur.test = null;\n        }\n        this.expect(14);\n      } else {\n        if (cur) {\n          cur.consequent.push(this.parseStatementListItem());\n        } else {\n          this.unexpected();\n        }\n      }\n    }\n    this.scope.exit();\n    if (cur) this.finishNode(cur, \"SwitchCase\");\n    this.next();\n    this.state.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\");\n  }\n  parseThrowStatement(node) {\n    this.next();\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(Errors.NewlineAfterThrow, this.state.lastTokEndLoc);\n    }\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\");\n  }\n  parseCatchClauseParam() {\n    const param = this.parseBindingAtom();\n    this.scope.enter(this.options.annexB && param.type === \"Identifier\" ? 8 : 0);\n    this.checkLVal(param, {\n      type: \"CatchClause\"\n    }, 9);\n    return param;\n  }\n  parseTryStatement(node) {\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n    if (this.match(62)) {\n      const clause = this.startNode();\n      this.next();\n      if (this.match(10)) {\n        this.expect(10);\n        clause.param = this.parseCatchClauseParam();\n        this.expect(11);\n      } else {\n        clause.param = null;\n        this.scope.enter(0);\n      }\n      clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));\n      this.scope.exit();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n    node.finalizer = this.eat(67) ? this.parseBlock() : null;\n    if (!node.handler && !node.finalizer) {\n      this.raise(Errors.NoCatchOrFinally, node);\n    }\n    return this.finishNode(node, \"TryStatement\");\n  }\n  parseVarStatement(node, kind, allowMissingInitializer = false) {\n    this.next();\n    this.parseVar(node, false, kind, allowMissingInitializer);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\");\n  }\n  parseWhileStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    this.state.labels.push(loopLabel);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    this.state.labels.pop();\n    return this.finishNode(node, \"WhileStatement\");\n  }\n  parseWithStatement(node) {\n    if (this.state.strict) {\n      this.raise(Errors.StrictWith, this.state.startLoc);\n    }\n    this.next();\n    node.object = this.parseHeaderExpression();\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    return this.finishNode(node, \"WithStatement\");\n  }\n  parseEmptyStatement(node) {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\");\n  }\n  parseLabeledStatement(node, maybeName, expr, flags) {\n    for (const label of this.state.labels) {\n      if (label.name === maybeName) {\n        this.raise(Errors.LabelRedeclaration, expr, {\n          labelName: maybeName\n        });\n      }\n    }\n    const kind = tokenIsLoop(this.state.type) ? 1 : this.match(71) ? 2 : null;\n    for (let i = this.state.labels.length - 1; i >= 0; i--) {\n      const label = this.state.labels[i];\n      if (label.statementStart === node.start) {\n        label.statementStart = this.sourceToOffsetPos(this.state.start);\n        label.kind = kind;\n      } else {\n        break;\n      }\n    }\n    this.state.labels.push({\n      name: maybeName,\n      kind: kind,\n      statementStart: this.sourceToOffsetPos(this.state.start)\n    });\n    node.body = flags & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement();\n    this.state.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\");\n  }\n  parseExpressionStatement(node, expr, decorators) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\");\n  }\n  parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {\n    const node = this.startNode();\n    if (allowDirectives) {\n      this.state.strictErrors.clear();\n    }\n    this.expect(5);\n    if (createNewLexicalScope) {\n      this.scope.enter(0);\n    }\n    this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);\n    if (createNewLexicalScope) {\n      this.scope.exit();\n    }\n    return this.finishNode(node, \"BlockStatement\");\n  }\n  isValidDirective(stmt) {\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"StringLiteral\" && !stmt.expression.extra.parenthesized;\n  }\n  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {\n    const body = node.body = [];\n    const directives = node.directives = [];\n    this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end, afterBlockParse);\n  }\n  parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {\n    const oldStrict = this.state.strict;\n    let hasStrictModeDirective = false;\n    let parsedNonDirective = false;\n    while (!this.match(end)) {\n      const stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();\n      if (directives && !parsedNonDirective) {\n        if (this.isValidDirective(stmt)) {\n          const directive = this.stmtToDirective(stmt);\n          directives.push(directive);\n          if (!hasStrictModeDirective && directive.value.value === \"use strict\") {\n            hasStrictModeDirective = true;\n            this.setStrict(true);\n          }\n          continue;\n        }\n        parsedNonDirective = true;\n        this.state.strictErrors.clear();\n      }\n      body.push(stmt);\n    }\n    afterBlockParse == null || afterBlockParse.call(this, hasStrictModeDirective);\n    if (!oldStrict) {\n      this.setStrict(false);\n    }\n    this.next();\n  }\n  parseFor(node, init) {\n    node.init = init;\n    this.semicolon(false);\n    node.test = this.match(13) ? null : this.parseExpression();\n    this.semicolon(false);\n    node.update = this.match(11) ? null : this.parseExpression();\n    this.expect(11);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, \"ForStatement\");\n  }\n  parseForIn(node, init, awaitAt) {\n    const isForIn = this.match(58);\n    this.next();\n    if (isForIn) {\n      if (awaitAt !== null) this.unexpected(awaitAt);\n    } else {\n      node.await = awaitAt !== null;\n    }\n    if (init.type === \"VariableDeclaration\" && init.declarations[0].init != null && (!isForIn || !this.options.annexB || this.state.strict || init.kind !== \"var\" || init.declarations[0].id.type !== \"Identifier\")) {\n      this.raise(Errors.ForInOfLoopInitializer, init, {\n        type: isForIn ? \"ForInStatement\" : \"ForOfStatement\"\n      });\n    }\n    if (init.type === \"AssignmentPattern\") {\n      this.raise(Errors.InvalidLhs, init, {\n        ancestor: {\n          type: \"ForStatement\"\n        }\n      });\n    }\n    node.left = init;\n    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();\n    this.expect(11);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\");\n  }\n  parseVar(node, isFor, kind, allowMissingInitializer = false) {\n    const declarations = node.declarations = [];\n    node.kind = kind;\n    for (;;) {\n      const decl = this.startNode();\n      this.parseVarId(decl, kind);\n      decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();\n      if (decl.init === null && !allowMissingInitializer) {\n        if (decl.id.type !== \"Identifier\" && !(isFor && (this.match(58) || this.isContextual(102)))) {\n          this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {\n            kind: \"destructuring\"\n          });\n        } else if ((kind === \"const\" || kind === \"using\" || kind === \"await using\") && !(this.match(58) || this.isContextual(102))) {\n          this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {\n            kind\n          });\n        }\n      }\n      declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n      if (!this.eat(12)) break;\n    }\n    return node;\n  }\n  parseVarId(decl, kind) {\n    const id = this.parseBindingAtom();\n    if (kind === \"using\" || kind === \"await using\") {\n      if (id.type === \"ArrayPattern\" || id.type === \"ObjectPattern\") {\n        this.raise(Errors.UsingDeclarationHasBindingPattern, id.loc.start);\n      }\n    } else {\n      if (id.type === \"VoidPattern\") {\n        this.raise(Errors.UnexpectedVoidPattern, id.loc.start);\n      }\n    }\n    this.checkLVal(id, {\n      type: \"VariableDeclarator\"\n    }, kind === \"var\" ? 5 : 8201);\n    decl.id = id;\n  }\n  parseAsyncFunctionExpression(node) {\n    return this.parseFunction(node, 8);\n  }\n  parseFunction(node, flags = 0) {\n    const hangingDeclaration = flags & 2;\n    const isDeclaration = !!(flags & 1);\n    const requireId = isDeclaration && !(flags & 4);\n    const isAsync = !!(flags & 8);\n    this.initFunction(node, isAsync);\n    if (this.match(55)) {\n      if (hangingDeclaration) {\n        this.raise(Errors.GeneratorInSingleStatementContext, this.state.startLoc);\n      }\n      this.next();\n      node.generator = true;\n    }\n    if (isDeclaration) {\n      node.id = this.parseFunctionId(requireId);\n    }\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = false;\n    this.scope.enter(514);\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n    if (!isDeclaration) {\n      node.id = this.parseFunctionId();\n    }\n    this.parseFunctionParams(node, false);\n    this.withSmartMixTopicForbiddingContext(() => {\n      this.parseFunctionBodyAndFinish(node, isDeclaration ? \"FunctionDeclaration\" : \"FunctionExpression\");\n    });\n    this.prodParam.exit();\n    this.scope.exit();\n    if (isDeclaration && !hangingDeclaration) {\n      this.registerFunctionStatementId(node);\n    }\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return node;\n  }\n  parseFunctionId(requireId) {\n    return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;\n  }\n  parseFunctionParams(node, isConstructor) {\n    this.expect(10);\n    this.expressionScope.enter(newParameterDeclarationScope());\n    node.params = this.parseBindingList(11, 41, 2 | (isConstructor ? 4 : 0));\n    this.expressionScope.exit();\n  }\n  registerFunctionStatementId(node) {\n    if (!node.id) return;\n    this.scope.declareName(node.id.name, !this.options.annexB || this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, node.id.loc.start);\n  }\n  parseClass(node, isStatement, optionalId) {\n    this.next();\n    const oldStrict = this.state.strict;\n    this.state.strict = true;\n    this.parseClassId(node, isStatement, optionalId);\n    this.parseClassSuper(node);\n    node.body = this.parseClassBody(!!node.superClass, oldStrict);\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n  }\n  isClassProperty() {\n    return this.match(29) || this.match(13) || this.match(8);\n  }\n  isClassMethod() {\n    return this.match(10);\n  }\n  nameIsConstructor(key) {\n    return key.type === \"Identifier\" && key.name === \"constructor\" || key.type === \"StringLiteral\" && key.value === \"constructor\";\n  }\n  isNonstaticConstructor(method) {\n    return !method.computed && !method.static && this.nameIsConstructor(method.key);\n  }\n  parseClassBody(hadSuperClass, oldStrict) {\n    this.classScope.enter();\n    const state = {\n      hadConstructor: false,\n      hadSuperClass\n    };\n    let decorators = [];\n    const classBody = this.startNode();\n    classBody.body = [];\n    this.expect(5);\n    this.withSmartMixTopicForbiddingContext(() => {\n      while (!this.match(8)) {\n        if (this.eat(13)) {\n          if (decorators.length > 0) {\n            throw this.raise(Errors.DecoratorSemicolon, this.state.lastTokEndLoc);\n          }\n          continue;\n        }\n        if (this.match(26)) {\n          decorators.push(this.parseDecorator());\n          continue;\n        }\n        const member = this.startNode();\n        if (decorators.length) {\n          member.decorators = decorators;\n          this.resetStartLocationFromNode(member, decorators[0]);\n          decorators = [];\n        }\n        this.parseClassMember(classBody, member, state);\n        if (member.kind === \"constructor\" && member.decorators && member.decorators.length > 0) {\n          this.raise(Errors.DecoratorConstructor, member);\n        }\n      }\n    });\n    this.state.strict = oldStrict;\n    this.next();\n    if (decorators.length) {\n      throw this.raise(Errors.TrailingDecorator, this.state.startLoc);\n    }\n    this.classScope.exit();\n    return this.finishNode(classBody, \"ClassBody\");\n  }\n  parseClassMemberFromModifier(classBody, member) {\n    const key = this.parseIdentifier(true);\n    if (this.isClassMethod()) {\n      const method = member;\n      method.kind = \"method\";\n      method.computed = false;\n      method.key = key;\n      method.static = false;\n      this.pushClassMethod(classBody, method, false, false, false, false);\n      return true;\n    } else if (this.isClassProperty()) {\n      const prop = member;\n      prop.computed = false;\n      prop.key = key;\n      prop.static = false;\n      classBody.body.push(this.parseClassProperty(prop));\n      return true;\n    }\n    this.resetPreviousNodeTrailingComments(key);\n    return false;\n  }\n  parseClassMember(classBody, member, state) {\n    const isStatic = this.isContextual(106);\n    if (isStatic) {\n      if (this.parseClassMemberFromModifier(classBody, member)) {\n        return;\n      }\n      if (this.eat(5)) {\n        this.parseClassStaticBlock(classBody, member);\n        return;\n      }\n    }\n    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\n    const publicMethod = member;\n    const privateMethod = member;\n    const publicProp = member;\n    const privateProp = member;\n    const accessorProp = member;\n    const method = publicMethod;\n    const publicMember = publicMethod;\n    member.static = isStatic;\n    this.parsePropertyNamePrefixOperator(member);\n    if (this.eat(55)) {\n      method.kind = \"method\";\n      const isPrivateName = this.match(139);\n      this.parseClassElementName(method);\n      this.parsePostMemberNameModifiers(method);\n      if (isPrivateName) {\n        this.pushClassPrivateMethod(classBody, privateMethod, true, false);\n        return;\n      }\n      if (this.isNonstaticConstructor(publicMethod)) {\n        this.raise(Errors.ConstructorIsGenerator, publicMethod.key);\n      }\n      this.pushClassMethod(classBody, publicMethod, true, false, false, false);\n      return;\n    }\n    const isContextual = !this.state.containsEsc && tokenIsIdentifier(this.state.type);\n    const key = this.parseClassElementName(member);\n    const maybeContextualKw = isContextual ? key.name : null;\n    const isPrivate = this.isPrivateName(key);\n    const maybeQuestionTokenStartLoc = this.state.startLoc;\n    this.parsePostMemberNameModifiers(publicMember);\n    if (this.isClassMethod()) {\n      method.kind = \"method\";\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n        return;\n      }\n      const isConstructor = this.isNonstaticConstructor(publicMethod);\n      let allowsDirectSuper = false;\n      if (isConstructor) {\n        publicMethod.kind = \"constructor\";\n        if (state.hadConstructor && !this.hasPlugin(\"typescript\")) {\n          this.raise(Errors.DuplicateConstructor, key);\n        }\n        if (isConstructor && this.hasPlugin(\"typescript\") && member.override) {\n          this.raise(Errors.OverrideOnConstructor, key);\n        }\n        state.hadConstructor = true;\n        allowsDirectSuper = state.hadSuperClass;\n      }\n      this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);\n    } else if (this.isClassProperty()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else if (maybeContextualKw === \"async\" && !this.isLineTerminator()) {\n      this.resetPreviousNodeTrailingComments(key);\n      const isGenerator = this.eat(55);\n      if (publicMember.optional) {\n        this.unexpected(maybeQuestionTokenStartLoc);\n      }\n      method.kind = \"method\";\n      const isPrivate = this.match(139);\n      this.parseClassElementName(method);\n      this.parsePostMemberNameModifiers(publicMember);\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(Errors.ConstructorIsAsync, publicMethod.key);\n        }\n        this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);\n      }\n    } else if ((maybeContextualKw === \"get\" || maybeContextualKw === \"set\") && !(this.match(55) && this.isLineTerminator())) {\n      this.resetPreviousNodeTrailingComments(key);\n      method.kind = maybeContextualKw;\n      const isPrivate = this.match(139);\n      this.parseClassElementName(publicMethod);\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(Errors.ConstructorIsAccessor, publicMethod.key);\n        }\n        this.pushClassMethod(classBody, publicMethod, false, false, false, false);\n      }\n      this.checkGetterSetterParams(publicMethod);\n    } else if (maybeContextualKw === \"accessor\" && !this.isLineTerminator()) {\n      this.expectPlugin(\"decoratorAutoAccessors\");\n      this.resetPreviousNodeTrailingComments(key);\n      const isPrivate = this.match(139);\n      this.parseClassElementName(publicProp);\n      this.pushClassAccessorProperty(classBody, accessorProp, isPrivate);\n    } else if (this.isLineTerminator()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else {\n      this.unexpected();\n    }\n  }\n  parseClassElementName(member) {\n    const {\n      type,\n      value\n    } = this.state;\n    if ((type === 132 || type === 134) && member.static && value === \"prototype\") {\n      this.raise(Errors.StaticPrototype, this.state.startLoc);\n    }\n    if (type === 139) {\n      if (value === \"constructor\") {\n        this.raise(Errors.ConstructorClassPrivateField, this.state.startLoc);\n      }\n      const key = this.parsePrivateName();\n      member.key = key;\n      return key;\n    }\n    this.parsePropertyName(member);\n    return member.key;\n  }\n  parseClassStaticBlock(classBody, member) {\n    var _member$decorators;\n    this.scope.enter(576 | 128 | 16);\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    this.prodParam.enter(0);\n    const body = member.body = [];\n    this.parseBlockOrModuleBlockBody(body, undefined, false, 8);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.labels = oldLabels;\n    classBody.body.push(this.finishNode(member, \"StaticBlock\"));\n    if ((_member$decorators = member.decorators) != null && _member$decorators.length) {\n      this.raise(Errors.DecoratorStaticBlock, member);\n    }\n  }\n  pushClassProperty(classBody, prop) {\n    if (!prop.computed && this.nameIsConstructor(prop.key)) {\n      this.raise(Errors.ConstructorClassField, prop.key);\n    }\n    classBody.body.push(this.parseClassProperty(prop));\n  }\n  pushClassPrivateProperty(classBody, prop) {\n    const node = this.parseClassPrivateProperty(prop);\n    classBody.body.push(node);\n    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);\n  }\n  pushClassAccessorProperty(classBody, prop, isPrivate) {\n    if (!isPrivate && !prop.computed && this.nameIsConstructor(prop.key)) {\n      this.raise(Errors.ConstructorClassField, prop.key);\n    }\n    const node = this.parseClassAccessorProperty(prop);\n    classBody.body.push(node);\n    if (isPrivate) {\n      this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);\n    }\n  }\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, \"ClassMethod\", true));\n  }\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    const node = this.parseMethod(method, isGenerator, isAsync, false, false, \"ClassPrivateMethod\", true);\n    classBody.body.push(node);\n    const kind = node.kind === \"get\" ? node.static ? 6 : 2 : node.kind === \"set\" ? node.static ? 5 : 1 : 0;\n    this.declareClassPrivateMethodInScope(node, kind);\n  }\n  declareClassPrivateMethodInScope(node, kind) {\n    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);\n  }\n  parsePostMemberNameModifiers(methodOrProp) {}\n  parseClassPrivateProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassPrivateProperty\");\n  }\n  parseClassProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassProperty\");\n  }\n  parseClassAccessorProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassAccessorProperty\");\n  }\n  parseInitializer(node) {\n    this.scope.enter(576 | 16);\n    this.expressionScope.enter(newExpressionScope());\n    this.prodParam.enter(0);\n    node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;\n    this.expressionScope.exit();\n    this.prodParam.exit();\n    this.scope.exit();\n  }\n  parseClassId(node, isStatement, optionalId, bindingType = 8331) {\n    if (tokenIsIdentifier(this.state.type)) {\n      node.id = this.parseIdentifier();\n      if (isStatement) {\n        this.declareNameFromIdentifier(node.id, bindingType);\n      }\n    } else {\n      if (optionalId || !isStatement) {\n        node.id = null;\n      } else {\n        throw this.raise(Errors.MissingClassName, this.state.startLoc);\n      }\n    }\n  }\n  parseClassSuper(node) {\n    node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;\n  }\n  parseExport(node, decorators) {\n    const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, true);\n    const hasDefault = this.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);\n    const parseAfterDefault = !hasDefault || this.eat(12);\n    const hasStar = parseAfterDefault && this.eatExportStar(node);\n    const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);\n    const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));\n    const isFromRequired = hasDefault || hasStar;\n    if (hasStar && !hasNamespace) {\n      if (hasDefault) this.unexpected();\n      if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\n      }\n      this.parseExportFrom(node, true);\n      this.sawUnambiguousESM = true;\n      return this.finishNode(node, \"ExportAllDeclaration\");\n    }\n    const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);\n    if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) {\n      this.unexpected(null, 5);\n    }\n    if (hasNamespace && parseAfterNamespace) {\n      this.unexpected(null, 98);\n    }\n    let hasDeclaration;\n    if (isFromRequired || hasSpecifiers) {\n      hasDeclaration = false;\n      if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\n      }\n      this.parseExportFrom(node, isFromRequired);\n    } else {\n      hasDeclaration = this.maybeParseExportDeclaration(node);\n    }\n    if (isFromRequired || hasSpecifiers || hasDeclaration) {\n      var _node2$declaration;\n      const node2 = node;\n      this.checkExport(node2, true, false, !!node2.source);\n      if (((_node2$declaration = node2.declaration) == null ? void 0 : _node2$declaration.type) === \"ClassDeclaration\") {\n        this.maybeTakeDecorators(decorators, node2.declaration, node2);\n      } else if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\n      }\n      this.sawUnambiguousESM = true;\n      return this.finishNode(node2, \"ExportNamedDeclaration\");\n    }\n    if (this.eat(65)) {\n      const node2 = node;\n      const decl = this.parseExportDefaultExpression();\n      node2.declaration = decl;\n      if (decl.type === \"ClassDeclaration\") {\n        this.maybeTakeDecorators(decorators, decl, node2);\n      } else if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\n      }\n      this.checkExport(node2, true, true);\n      this.sawUnambiguousESM = true;\n      return this.finishNode(node2, \"ExportDefaultDeclaration\");\n    }\n    this.unexpected(null, 5);\n  }\n  eatExportStar(node) {\n    return this.eat(55);\n  }\n  maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {\n    if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {\n      this.expectPlugin(\"exportDefaultFrom\", maybeDefaultIdentifier == null ? void 0 : maybeDefaultIdentifier.loc.start);\n      const id = maybeDefaultIdentifier || this.parseIdentifier(true);\n      const specifier = this.startNodeAtNode(id);\n      specifier.exported = id;\n      node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportNamespaceSpecifier(node) {\n    if (this.isContextual(93)) {\n      var _ref, _ref$specifiers;\n      (_ref$specifiers = (_ref = node).specifiers) != null ? _ref$specifiers : _ref.specifiers = [];\n      const specifier = this.startNodeAt(this.state.lastTokStartLoc);\n      this.next();\n      specifier.exported = this.parseModuleExportName();\n      node.specifiers.push(this.finishNode(specifier, \"ExportNamespaceSpecifier\"));\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportNamedSpecifiers(node) {\n    if (this.match(5)) {\n      const node2 = node;\n      if (!node2.specifiers) node2.specifiers = [];\n      const isTypeExport = node2.exportKind === \"type\";\n      node2.specifiers.push(...this.parseExportSpecifiers(isTypeExport));\n      node2.source = null;\n      if (this.hasPlugin(\"importAssertions\")) {\n        node2.assertions = [];\n      } else {\n        node2.attributes = [];\n      }\n      node2.declaration = null;\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportDeclaration(node) {\n    if (this.shouldParseExportDeclaration()) {\n      node.specifiers = [];\n      node.source = null;\n      if (this.hasPlugin(\"importAssertions\")) {\n        node.assertions = [];\n      } else {\n        node.attributes = [];\n      }\n      node.declaration = this.parseExportDeclaration(node);\n      return true;\n    }\n    return false;\n  }\n  isAsyncFunction() {\n    if (!this.isContextual(95)) return false;\n    const next = this.nextTokenInLineStart();\n    return this.isUnparsedContextual(next, \"function\");\n  }\n  parseExportDefaultExpression() {\n    const expr = this.startNode();\n    if (this.match(68)) {\n      this.next();\n      return this.parseFunction(expr, 1 | 4);\n    } else if (this.isAsyncFunction()) {\n      this.next();\n      this.next();\n      return this.parseFunction(expr, 1 | 4 | 8);\n    }\n    if (this.match(80)) {\n      return this.parseClass(expr, true, true);\n    }\n    if (this.match(26)) {\n      if (this.hasPlugin(\"decorators\") && this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") === true) {\n        this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);\n      }\n      return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);\n    }\n    if (this.match(75) || this.match(74) || this.isLet() || this.isUsing() || this.isAwaitUsing()) {\n      throw this.raise(Errors.UnsupportedDefaultExport, this.state.startLoc);\n    }\n    const res = this.parseMaybeAssignAllowIn();\n    this.semicolon();\n    return res;\n  }\n  parseExportDeclaration(node) {\n    if (this.match(80)) {\n      const node = this.parseClass(this.startNode(), true, false);\n      return node;\n    }\n    return this.parseStatementListItem();\n  }\n  isExportDefaultSpecifier() {\n    const {\n      type\n    } = this.state;\n    if (tokenIsIdentifier(type)) {\n      if (type === 95 && !this.state.containsEsc || type === 100) {\n        return false;\n      }\n      if ((type === 130 || type === 129) && !this.state.containsEsc) {\n        const next = this.nextTokenStart();\n        const nextChar = this.input.charCodeAt(next);\n        if (nextChar === 123 || this.chStartsBindingIdentifier(nextChar, next) && !this.input.startsWith(\"from\", next)) {\n          this.expectOnePlugin([\"flow\", \"typescript\"]);\n          return false;\n        }\n      }\n    } else if (!this.match(65)) {\n      return false;\n    }\n    const next = this.nextTokenStart();\n    const hasFrom = this.isUnparsedContextual(next, \"from\");\n    if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {\n      return true;\n    }\n    if (this.match(65) && hasFrom) {\n      const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));\n      return nextAfterFrom === 34 || nextAfterFrom === 39;\n    }\n    return false;\n  }\n  parseExportFrom(node, expect) {\n    if (this.eatContextual(98)) {\n      node.source = this.parseImportSource();\n      this.checkExport(node);\n      this.maybeParseImportAttributes(node);\n      this.checkJSONModuleImport(node);\n    } else if (expect) {\n      this.unexpected();\n    }\n    this.semicolon();\n  }\n  shouldParseExportDeclaration() {\n    const {\n      type\n    } = this.state;\n    if (type === 26) {\n      this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n      if (this.hasPlugin(\"decorators\")) {\n        if (this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") === true) {\n          this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);\n        }\n        return true;\n      }\n    }\n    if (this.isUsing()) {\n      this.raise(Errors.UsingDeclarationExport, this.state.startLoc);\n      return true;\n    }\n    if (this.isAwaitUsing()) {\n      this.raise(Errors.UsingDeclarationExport, this.state.startLoc);\n      return true;\n    }\n    return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();\n  }\n  checkExport(node, checkNames, isDefault, isFrom) {\n    if (checkNames) {\n      var _node$specifiers;\n      if (isDefault) {\n        this.checkDuplicateExports(node, \"default\");\n        if (this.hasPlugin(\"exportDefaultFrom\")) {\n          var _declaration$extra;\n          const declaration = node.declaration;\n          if (declaration.type === \"Identifier\" && declaration.name === \"from\" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {\n            this.raise(Errors.ExportDefaultFromAsIdentifier, declaration);\n          }\n        }\n      } else if ((_node$specifiers = node.specifiers) != null && _node$specifiers.length) {\n        for (const specifier of node.specifiers) {\n          const {\n            exported\n          } = specifier;\n          const exportName = exported.type === \"Identifier\" ? exported.name : exported.value;\n          this.checkDuplicateExports(specifier, exportName);\n          if (!isFrom && specifier.local) {\n            const {\n              local\n            } = specifier;\n            if (local.type !== \"Identifier\") {\n              this.raise(Errors.ExportBindingIsString, specifier, {\n                localName: local.value,\n                exportName\n              });\n            } else {\n              this.checkReservedWord(local.name, local.loc.start, true, false);\n              this.scope.checkLocalExport(local);\n            }\n          }\n        }\n      } else if (node.declaration) {\n        const decl = node.declaration;\n        if (decl.type === \"FunctionDeclaration\" || decl.type === \"ClassDeclaration\") {\n          const {\n            id\n          } = decl;\n          if (!id) throw new Error(\"Assertion failure\");\n          this.checkDuplicateExports(node, id.name);\n        } else if (decl.type === \"VariableDeclaration\") {\n          for (const declaration of decl.declarations) {\n            this.checkDeclaration(declaration.id);\n          }\n        }\n      }\n    }\n  }\n  checkDeclaration(node) {\n    if (node.type === \"Identifier\") {\n      this.checkDuplicateExports(node, node.name);\n    } else if (node.type === \"ObjectPattern\") {\n      for (const prop of node.properties) {\n        this.checkDeclaration(prop);\n      }\n    } else if (node.type === \"ArrayPattern\") {\n      for (const elem of node.elements) {\n        if (elem) {\n          this.checkDeclaration(elem);\n        }\n      }\n    } else if (node.type === \"ObjectProperty\") {\n      this.checkDeclaration(node.value);\n    } else if (node.type === \"RestElement\") {\n      this.checkDeclaration(node.argument);\n    } else if (node.type === \"AssignmentPattern\") {\n      this.checkDeclaration(node.left);\n    }\n  }\n  checkDuplicateExports(node, exportName) {\n    if (this.exportedIdentifiers.has(exportName)) {\n      if (exportName === \"default\") {\n        this.raise(Errors.DuplicateDefaultExport, node);\n      } else {\n        this.raise(Errors.DuplicateExport, node, {\n          exportName\n        });\n      }\n    }\n    this.exportedIdentifiers.add(exportName);\n  }\n  parseExportSpecifiers(isInTypeExport) {\n    const nodes = [];\n    let first = true;\n    this.expect(5);\n    while (!this.eat(8)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.eat(8)) break;\n      }\n      const isMaybeTypeOnly = this.isContextual(130);\n      const isString = this.match(134);\n      const node = this.startNode();\n      node.local = this.parseModuleExportName();\n      nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));\n    }\n    return nodes;\n  }\n  parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {\n    if (this.eatContextual(93)) {\n      node.exported = this.parseModuleExportName();\n    } else if (isString) {\n      node.exported = this.cloneStringLiteral(node.local);\n    } else if (!node.exported) {\n      node.exported = this.cloneIdentifier(node.local);\n    }\n    return this.finishNode(node, \"ExportSpecifier\");\n  }\n  parseModuleExportName() {\n    if (this.match(134)) {\n      const result = this.parseStringLiteral(this.state.value);\n      const surrogate = loneSurrogate.exec(result.value);\n      if (surrogate) {\n        this.raise(Errors.ModuleExportNameHasLoneSurrogate, result, {\n          surrogateCharCode: surrogate[0].charCodeAt(0)\n        });\n      }\n      return result;\n    }\n    return this.parseIdentifier(true);\n  }\n  isJSONModuleImport(node) {\n    if (node.assertions != null) {\n      return node.assertions.some(({\n        key,\n        value\n      }) => {\n        return value.value === \"json\" && (key.type === \"Identifier\" ? key.name === \"type\" : key.value === \"type\");\n      });\n    }\n    return false;\n  }\n  checkImportReflection(node) {\n    const {\n      specifiers\n    } = node;\n    const singleBindingType = specifiers.length === 1 ? specifiers[0].type : null;\n    if (node.phase === \"source\") {\n      if (singleBindingType !== \"ImportDefaultSpecifier\") {\n        this.raise(Errors.SourcePhaseImportRequiresDefault, specifiers[0].loc.start);\n      }\n    } else if (node.phase === \"defer\") {\n      if (singleBindingType !== \"ImportNamespaceSpecifier\") {\n        this.raise(Errors.DeferImportRequiresNamespace, specifiers[0].loc.start);\n      }\n    } else if (node.module) {\n      var _node$assertions;\n      if (singleBindingType !== \"ImportDefaultSpecifier\") {\n        this.raise(Errors.ImportReflectionNotBinding, specifiers[0].loc.start);\n      }\n      if (((_node$assertions = node.assertions) == null ? void 0 : _node$assertions.length) > 0) {\n        this.raise(Errors.ImportReflectionHasAssertion, specifiers[0].loc.start);\n      }\n    }\n  }\n  checkJSONModuleImport(node) {\n    if (this.isJSONModuleImport(node) && node.type !== \"ExportAllDeclaration\") {\n      const {\n        specifiers\n      } = node;\n      if (specifiers != null) {\n        const nonDefaultNamedSpecifier = specifiers.find(specifier => {\n          let imported;\n          if (specifier.type === \"ExportSpecifier\") {\n            imported = specifier.local;\n          } else if (specifier.type === \"ImportSpecifier\") {\n            imported = specifier.imported;\n          }\n          if (imported !== undefined) {\n            return imported.type === \"Identifier\" ? imported.name !== \"default\" : imported.value !== \"default\";\n          }\n        });\n        if (nonDefaultNamedSpecifier !== undefined) {\n          this.raise(Errors.ImportJSONBindingNotDefault, nonDefaultNamedSpecifier.loc.start);\n        }\n      }\n    }\n  }\n  isPotentialImportPhase(isExport) {\n    if (isExport) return false;\n    return this.isContextual(105) || this.isContextual(97) || this.isContextual(127);\n  }\n  applyImportPhase(node, isExport, phase, loc) {\n    if (isExport) {\n      return;\n    }\n    if (phase === \"module\") {\n      this.expectPlugin(\"importReflection\", loc);\n      node.module = true;\n    } else if (this.hasPlugin(\"importReflection\")) {\n      node.module = false;\n    }\n    if (phase === \"source\") {\n      this.expectPlugin(\"sourcePhaseImports\", loc);\n      node.phase = \"source\";\n    } else if (phase === \"defer\") {\n      this.expectPlugin(\"deferredImportEvaluation\", loc);\n      node.phase = \"defer\";\n    } else if (this.hasPlugin(\"sourcePhaseImports\")) {\n      node.phase = null;\n    }\n  }\n  parseMaybeImportPhase(node, isExport) {\n    if (!this.isPotentialImportPhase(isExport)) {\n      this.applyImportPhase(node, isExport, null);\n      return null;\n    }\n    const phaseIdentifier = this.startNode();\n    const phaseIdentifierName = this.parseIdentifierName(true);\n    const {\n      type\n    } = this.state;\n    const isImportPhase = tokenIsKeywordOrIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;\n    if (isImportPhase) {\n      this.applyImportPhase(node, isExport, phaseIdentifierName, phaseIdentifier.loc.start);\n      return null;\n    } else {\n      this.applyImportPhase(node, isExport, null);\n      return this.createIdentifier(phaseIdentifier, phaseIdentifierName);\n    }\n  }\n  isPrecedingIdImportPhase(phase) {\n    const {\n      type\n    } = this.state;\n    return tokenIsIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;\n  }\n  parseImport(node) {\n    if (this.match(134)) {\n      return this.parseImportSourceAndAttributes(node);\n    }\n    return this.parseImportSpecifiersAndAfter(node, this.parseMaybeImportPhase(node, false));\n  }\n  parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier) {\n    node.specifiers = [];\n    const hasDefault = this.maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier);\n    const parseNext = !hasDefault || this.eat(12);\n    const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);\n    if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);\n    this.expectContextual(98);\n    return this.parseImportSourceAndAttributes(node);\n  }\n  parseImportSourceAndAttributes(node) {\n    var _node$specifiers2;\n    (_node$specifiers2 = node.specifiers) != null ? _node$specifiers2 : node.specifiers = [];\n    node.source = this.parseImportSource();\n    this.maybeParseImportAttributes(node);\n    this.checkImportReflection(node);\n    this.checkJSONModuleImport(node);\n    this.semicolon();\n    this.sawUnambiguousESM = true;\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n  parseImportSource() {\n    if (!this.match(134)) this.unexpected();\n    return this.parseExprAtom();\n  }\n  parseImportSpecifierLocal(node, specifier, type) {\n    specifier.local = this.parseIdentifier();\n    node.specifiers.push(this.finishImportSpecifier(specifier, type));\n  }\n  finishImportSpecifier(specifier, type, bindingType = 8201) {\n    this.checkLVal(specifier.local, {\n      type\n    }, bindingType);\n    return this.finishNode(specifier, type);\n  }\n  parseImportAttributes() {\n    this.expect(5);\n    const attrs = [];\n    const attrNames = new Set();\n    do {\n      if (this.match(8)) {\n        break;\n      }\n      const node = this.startNode();\n      const keyName = this.state.value;\n      if (attrNames.has(keyName)) {\n        this.raise(Errors.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {\n          key: keyName\n        });\n      }\n      attrNames.add(keyName);\n      if (this.match(134)) {\n        node.key = this.parseStringLiteral(keyName);\n      } else {\n        node.key = this.parseIdentifier(true);\n      }\n      this.expect(14);\n      if (!this.match(134)) {\n        throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);\n      }\n      node.value = this.parseStringLiteral(this.state.value);\n      attrs.push(this.finishNode(node, \"ImportAttribute\"));\n    } while (this.eat(12));\n    this.expect(8);\n    return attrs;\n  }\n  parseModuleAttributes() {\n    const attrs = [];\n    const attributes = new Set();\n    do {\n      const node = this.startNode();\n      node.key = this.parseIdentifier(true);\n      if (node.key.name !== \"type\") {\n        this.raise(Errors.ModuleAttributeDifferentFromType, node.key);\n      }\n      if (attributes.has(node.key.name)) {\n        this.raise(Errors.ModuleAttributesWithDuplicateKeys, node.key, {\n          key: node.key.name\n        });\n      }\n      attributes.add(node.key.name);\n      this.expect(14);\n      if (!this.match(134)) {\n        throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);\n      }\n      node.value = this.parseStringLiteral(this.state.value);\n      attrs.push(this.finishNode(node, \"ImportAttribute\"));\n    } while (this.eat(12));\n    return attrs;\n  }\n  maybeParseImportAttributes(node) {\n    let attributes;\n    {\n      var useWith = false;\n    }\n    if (this.match(76)) {\n      if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) {\n        return;\n      }\n      this.next();\n      if (this.hasPlugin(\"moduleAttributes\")) {\n        attributes = this.parseModuleAttributes();\n        this.addExtra(node, \"deprecatedWithLegacySyntax\", true);\n      } else {\n        attributes = this.parseImportAttributes();\n      }\n      {\n        useWith = true;\n      }\n    } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {\n      if (!this.hasPlugin(\"deprecatedImportAssert\") && !this.hasPlugin(\"importAssertions\")) {\n        this.raise(Errors.ImportAttributesUseAssert, this.state.startLoc);\n      }\n      if (!this.hasPlugin(\"importAssertions\")) {\n        this.addExtra(node, \"deprecatedAssertSyntax\", true);\n      }\n      this.next();\n      attributes = this.parseImportAttributes();\n    } else {\n      attributes = [];\n    }\n    if (!useWith && this.hasPlugin(\"importAssertions\")) {\n      node.assertions = attributes;\n    } else {\n      node.attributes = attributes;\n    }\n  }\n  maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier) {\n    if (maybeDefaultIdentifier) {\n      const specifier = this.startNodeAtNode(maybeDefaultIdentifier);\n      specifier.local = maybeDefaultIdentifier;\n      node.specifiers.push(this.finishImportSpecifier(specifier, \"ImportDefaultSpecifier\"));\n      return true;\n    } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n      this.parseImportSpecifierLocal(node, this.startNode(), \"ImportDefaultSpecifier\");\n      return true;\n    }\n    return false;\n  }\n  maybeParseStarImportSpecifier(node) {\n    if (this.match(55)) {\n      const specifier = this.startNode();\n      this.next();\n      this.expectContextual(93);\n      this.parseImportSpecifierLocal(node, specifier, \"ImportNamespaceSpecifier\");\n      return true;\n    }\n    return false;\n  }\n  parseNamedImportSpecifiers(node) {\n    let first = true;\n    this.expect(5);\n    while (!this.eat(8)) {\n      if (first) {\n        first = false;\n      } else {\n        if (this.eat(14)) {\n          throw this.raise(Errors.DestructureNamedImport, this.state.startLoc);\n        }\n        this.expect(12);\n        if (this.eat(8)) break;\n      }\n      const specifier = this.startNode();\n      const importedIsString = this.match(134);\n      const isMaybeTypeOnly = this.isContextual(130);\n      specifier.imported = this.parseModuleExportName();\n      const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === \"type\" || node.importKind === \"typeof\", isMaybeTypeOnly, undefined);\n      node.specifiers.push(importSpecifier);\n    }\n  }\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {\n    if (this.eatContextual(93)) {\n      specifier.local = this.parseIdentifier();\n    } else {\n      const {\n        imported\n      } = specifier;\n      if (importedIsString) {\n        throw this.raise(Errors.ImportBindingIsString, specifier, {\n          importName: imported.value\n        });\n      }\n      this.checkReservedWord(imported.name, specifier.loc.start, true, true);\n      if (!specifier.local) {\n        specifier.local = this.cloneIdentifier(imported);\n      }\n    }\n    return this.finishImportSpecifier(specifier, \"ImportSpecifier\", bindingType);\n  }\n  isThisParam(param) {\n    return param.type === \"Identifier\" && param.name === \"this\";\n  }\n}\nclass Parser extends StatementParser {\n  constructor(options, input, pluginsMap) {\n    options = getOptions(options);\n    super(options, input);\n    this.options = options;\n    this.initializeScopes();\n    this.plugins = pluginsMap;\n    this.filename = options.sourceFilename;\n    this.startIndex = options.startIndex;\n    let optionFlags = 0;\n    if (options.allowAwaitOutsideFunction) {\n      optionFlags |= 1;\n    }\n    if (options.allowReturnOutsideFunction) {\n      optionFlags |= 2;\n    }\n    if (options.allowImportExportEverywhere) {\n      optionFlags |= 8;\n    }\n    if (options.allowSuperOutsideMethod) {\n      optionFlags |= 16;\n    }\n    if (options.allowUndeclaredExports) {\n      optionFlags |= 64;\n    }\n    if (options.allowNewTargetOutsideFunction) {\n      optionFlags |= 4;\n    }\n    if (options.allowYieldOutsideFunction) {\n      optionFlags |= 32;\n    }\n    if (options.ranges) {\n      optionFlags |= 128;\n    }\n    if (options.tokens) {\n      optionFlags |= 256;\n    }\n    if (options.createImportExpressions) {\n      optionFlags |= 512;\n    }\n    if (options.createParenthesizedExpressions) {\n      optionFlags |= 1024;\n    }\n    if (options.errorRecovery) {\n      optionFlags |= 2048;\n    }\n    if (options.attachComment) {\n      optionFlags |= 4096;\n    }\n    if (options.annexB) {\n      optionFlags |= 8192;\n    }\n    this.optionFlags = optionFlags;\n  }\n  getScopeHandler() {\n    return ScopeHandler;\n  }\n  parse() {\n    this.enterInitialScopes();\n    const file = this.startNode();\n    const program = this.startNode();\n    this.nextToken();\n    file.errors = null;\n    this.parseTopLevel(file, program);\n    file.errors = this.state.errors;\n    file.comments.length = this.state.commentsLen;\n    return file;\n  }\n}\nfunction parse(input, options) {\n  var _options;\n  if (((_options = options) == null ? void 0 : _options.sourceType) === \"unambiguous\") {\n    options = Object.assign({}, options);\n    try {\n      options.sourceType = \"module\";\n      const parser = getParser(options, input);\n      const ast = parser.parse();\n      if (parser.sawUnambiguousESM) {\n        return ast;\n      }\n      if (parser.ambiguousScriptDifferentAst) {\n        try {\n          options.sourceType = \"script\";\n          return getParser(options, input).parse();\n        } catch (_unused) {}\n      } else {\n        ast.program.sourceType = \"script\";\n      }\n      return ast;\n    } catch (moduleError) {\n      try {\n        options.sourceType = \"script\";\n        return getParser(options, input).parse();\n      } catch (_unused2) {}\n      throw moduleError;\n    }\n  } else {\n    return getParser(options, input).parse();\n  }\n}\nfunction parseExpression(input, options) {\n  const parser = getParser(options, input);\n  if (parser.options.strictMode) {\n    parser.state.strict = true;\n  }\n  return parser.getExpression();\n}\nfunction generateExportedTokenTypes(internalTokenTypes) {\n  const tokenTypes = {};\n  for (const typeName of Object.keys(internalTokenTypes)) {\n    tokenTypes[typeName] = getExportedToken(internalTokenTypes[typeName]);\n  }\n  return tokenTypes;\n}\nconst tokTypes = generateExportedTokenTypes(tt);\nfunction getParser(options, input) {\n  let cls = Parser;\n  const pluginsMap = new Map();\n  if (options != null && options.plugins) {\n    for (const plugin of options.plugins) {\n      let name, opts;\n      if (typeof plugin === \"string\") {\n        name = plugin;\n      } else {\n        [name, opts] = plugin;\n      }\n      if (!pluginsMap.has(name)) {\n        pluginsMap.set(name, opts || {});\n      }\n    }\n    validatePlugins(pluginsMap);\n    cls = getParserClass(pluginsMap);\n  }\n  return new cls(options, input, pluginsMap);\n}\nconst parserClassCache = new Map();\nfunction getParserClass(pluginsMap) {\n  const pluginList = [];\n  for (const name of mixinPluginNames) {\n    if (pluginsMap.has(name)) {\n      pluginList.push(name);\n    }\n  }\n  const key = pluginList.join(\"|\");\n  let cls = parserClassCache.get(key);\n  if (!cls) {\n    cls = Parser;\n    for (const plugin of pluginList) {\n      cls = mixinPlugins[plugin](cls);\n    }\n    parserClassCache.set(key, cls);\n  }\n  return cls;\n}\nexports.parse = parse;\nexports.parseExpression = parseExpression;\nexports.tokTypes = tokTypes;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGJhYmVsK3BhcnNlckA3LjI4LjAvbm9kZV9tb2R1bGVzL0BiYWJlbC9wYXJzZXIvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSwwR0FBMEcsWUFBWTtBQUN0SDtBQUNBO0FBQ0E7QUFDQSxHQUFHLFVBQVUsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRywrQkFBK0IsTUFBTTtBQUN4QztBQUNBLDBLQUEwSztBQUMxSztBQUNBLGlHQUFpRyxLQUFLO0FBQ3RHLHlLQUF5SztBQUN6SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLFVBQVUsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsMEdBQTBHLEdBQUcsVUFBVSxRQUFRLFdBQVcsSUFBSTtBQUNqSjtBQUNBO0FBQ0E7QUFDQSxHQUFHLFNBQVMsZ0RBQWdEO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsb0JBQW9CLGlEQUFpRDtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyx5RkFBeUYsR0FBRyxXQUFXLFVBQVU7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsaUNBQWlDLE1BQU07QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLG1DQUFtQyxhQUFhO0FBQ25EO0FBQ0E7QUFDQSxHQUFHLDJCQUEyQixlQUFlO0FBQzdDO0FBQ0E7QUFDQSxHQUFHLGtDQUFrQyw0QkFBNEI7QUFDakU7QUFDQTtBQUNBLEdBQUcsMENBQTBDLDRCQUE0QjtBQUN6RTtBQUNBO0FBQ0EsR0FBRywyREFBMkQsNEJBQTRCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyw4QkFBOEIsV0FBVztBQUM1QztBQUNBO0FBQ0E7QUFDQSxHQUFHLHNCQUFzQixnQkFBZ0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsZUFBZSxVQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHNFQUFzRSwyREFBMkQ7QUFDcEk7QUFDQTtBQUNBLEdBQUcsMEZBQTBGLDJEQUEyRDtBQUN4SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHVCQUF1QixJQUFJO0FBQzlCO0FBQ0E7QUFDQSxHQUFHLGtFQUFrRSwrQkFBK0I7QUFDcEc7QUFDQTtBQUNBLEdBQUcsZ0JBQWdCLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsb0VBQW9FLGVBQWUsbUNBQW1DLGdCQUFnQjtBQUN6STtBQUNBO0FBQ0EsR0FBRyxnQ0FBZ0MsZUFBZTtBQUNsRCxnRkFBZ0Y7QUFDaEYsbUZBQW1GO0FBQ25GLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsNEJBQTRCLFFBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGtDQUFrQyxhQUFhO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyx3QkFBd0Isa0JBQWtCLFdBQVcsU0FBUyxFQUFFLDBCQUEwQixTQUFTLFFBQVE7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHlDQUF5QyxRQUFRLEtBQUssT0FBTyxHQUFHLHNCQUFzQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxvQkFBb0IsZUFBZTtBQUN0QyxpR0FBaUcsTUFBTSxRQUFRLEtBQUs7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHNCQUFzQixjQUFjO0FBQ3ZDO0FBQ0E7QUFDQSxHQUFHLGlCQUFpQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsZ0tBQWdLLGlDQUFpQztBQUNwTTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLEdBQUcsNEJBQTRCLE1BQU0sb0JBQW9CLE9BQU8sNEVBQTRFLHFDQUFxQyxNQUFNLEdBQUc7QUFDMUwsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQSxHQUFHLDBEQUEwRDtBQUM3RDtBQUNBLEdBQUcsSUFBSTtBQUNQLENBQUM7QUFDRCxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDRFQUE0RTtBQUM1RSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0JBQW9CLEdBQUcsU0FBUyxHQUFHLFdBQVc7QUFDekU7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxNQUFNLElBQUk7QUFDVjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSCwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLEdBQUc7QUFDSCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLEdBQUc7QUFDSCx3QkFBd0I7QUFDeEIsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsc0JBQXNCO0FBQ3RCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFlBQVk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHVDQUF1QyxhQUFhO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsa0VBQWtFLFlBQVksaUJBQWlCLFlBQVksdUJBQXVCLFNBQVM7QUFDOUk7QUFDQTtBQUNBO0FBQ0EsR0FBRyw0REFBNEQsV0FBVyw0Q0FBNEMsU0FBUztBQUMvSDtBQUNBO0FBQ0EsR0FBRyxlQUFlLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRyxvQkFBb0IsZ0JBQWdCLDJGQUEyRixTQUFTO0FBQzNJO0FBQ0E7QUFDQSxHQUFHLGlIQUFpSCxTQUFTO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxlQUFlLFNBQVMsZ0JBQWdCLGFBQWEsOEJBQThCLFdBQVcsbUJBQW1CLGNBQWM7QUFDbEk7QUFDQTtBQUNBO0FBQ0EsR0FBRyx5REFBeUQsV0FBVyxnQkFBZ0IsU0FBUztBQUNoRztBQUNBO0FBQ0E7QUFDQSxHQUFHLDBDQUEwQyxXQUFXLDJFQUEyRSxTQUFTO0FBQzVJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRywwRkFBMEYsV0FBVyx1QkFBdUIsV0FBVyxnQkFBZ0IsU0FBUztBQUNuSztBQUNBO0FBQ0E7QUFDQSxHQUFHLDJEQUEyRCxZQUFZLGtCQUFrQixTQUFTO0FBQ3JHO0FBQ0E7QUFDQSxHQUFHLGdIQUFnSCxTQUFTO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsaUNBQWlDLGFBQWE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBJQUEwSSx5QkFBeUI7QUFDbks7QUFDQTtBQUNBO0FBQ0EsR0FBRyx5QkFBeUIsc0JBQXNCLDZCQUE2QixXQUFXO0FBQzFGO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsb0RBQW9ELGVBQWU7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsMkJBQTJCLFdBQVcscUJBQXFCLFdBQVcsU0FBUyxHQUFHLFdBQVcsRUFBRTtBQUNsRztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE9BQU87QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sOERBQThEO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0EsS0FBSztBQUNMLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxZQUFZO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLEdBQUc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsZ0JBQWdCLFdBQVc7QUFDOUI7QUFDQTtBQUNBLEdBQUcsa0JBQWtCLGFBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxvQ0FBb0MsS0FBSztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsOENBQThDLFNBQVM7QUFDMUQ7QUFDQTtBQUNBLEdBQUcsNkJBQTZCLFNBQVM7QUFDekM7QUFDQTtBQUNBLEdBQUcsU0FBUyxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxTQUFTLGFBQWEsa0NBQWtDLGFBQWE7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsR0FBRyxpRUFBaUUsU0FBUztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLFNBQVMsTUFBTTtBQUNsQiwwREFBMEQsU0FBUztBQUNuRTtBQUNBO0FBQ0EsR0FBRyxTQUFTLFNBQVM7QUFDckI7QUFDQTtBQUNBLEdBQUcsU0FBUyxTQUFTO0FBQ3JCO0FBQ0E7QUFDQSxHQUFHLFNBQVMsU0FBUztBQUNyQixxREFBcUQsU0FBUztBQUM5RDtBQUNBO0FBQ0EsR0FBRyxTQUFTLG9CQUFvQiwyQkFBMkIsb0JBQW9CO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGlFQUFpRSxTQUFTO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDhCQUE4QixtQkFBbUIsZ0RBQWdELGtCQUFrQjtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyw4RkFBOEYsS0FBSztBQUN0RyxnREFBZ0QsS0FBSztBQUNyRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLG1GQUFtRixxRkFBcUY7QUFDeEssT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxxRkFBcUYscUZBQXFGO0FBQzFLLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELEVBQUU7QUFDN0QsbUdBQW1HLGFBQWE7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsRUFBRTtBQUN0RCx5SUFBeUksVUFBVTtBQUNuSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxtQ0FBbUMsWUFBWSxxRUFBcUU7QUFDaE07QUFDQTtBQUNBLE1BQU07QUFDTix3RUFBd0UsbUJBQW1CLFlBQVkscUVBQXFFO0FBQzVLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlKQUFpSixFQUFFO0FBQ25KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4QkFBOEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsdUJBQXVCO0FBQ3ZCLGdCQUFnQjtBQUNoQiIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvLnBucG0vQGJhYmVsK3BhcnNlckA3LjI4LjAvbm9kZV9tb2R1bGVzL0BiYWJlbC9wYXJzZXIvbGliL2luZGV4LmpzPzM1NjkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHIsIGUpIHtcbiAgaWYgKG51bGwgPT0gcikgcmV0dXJuIHt9O1xuICB2YXIgdCA9IHt9O1xuICBmb3IgKHZhciBuIGluIHIpIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsIG4pKSB7XG4gICAgaWYgKC0xICE9PSBlLmluZGV4T2YobikpIGNvbnRpbnVlO1xuICAgIHRbbl0gPSByW25dO1xuICB9XG4gIHJldHVybiB0O1xufVxuY2xhc3MgUG9zaXRpb24ge1xuICBjb25zdHJ1Y3RvcihsaW5lLCBjb2wsIGluZGV4KSB7XG4gICAgdGhpcy5saW5lID0gdm9pZCAwO1xuICAgIHRoaXMuY29sdW1uID0gdm9pZCAwO1xuICAgIHRoaXMuaW5kZXggPSB2b2lkIDA7XG4gICAgdGhpcy5saW5lID0gbGluZTtcbiAgICB0aGlzLmNvbHVtbiA9IGNvbDtcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gIH1cbn1cbmNsYXNzIFNvdXJjZUxvY2F0aW9uIHtcbiAgY29uc3RydWN0b3Ioc3RhcnQsIGVuZCkge1xuICAgIHRoaXMuc3RhcnQgPSB2b2lkIDA7XG4gICAgdGhpcy5lbmQgPSB2b2lkIDA7XG4gICAgdGhpcy5maWxlbmFtZSA9IHZvaWQgMDtcbiAgICB0aGlzLmlkZW50aWZpZXJOYW1lID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLmVuZCA9IGVuZDtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25XaXRoQ29sdW1uT2Zmc2V0KHBvc2l0aW9uLCBjb2x1bW5PZmZzZXQpIHtcbiAgY29uc3Qge1xuICAgIGxpbmUsXG4gICAgY29sdW1uLFxuICAgIGluZGV4XG4gIH0gPSBwb3NpdGlvbjtcbiAgcmV0dXJuIG5ldyBQb3NpdGlvbihsaW5lLCBjb2x1bW4gKyBjb2x1bW5PZmZzZXQsIGluZGV4ICsgY29sdW1uT2Zmc2V0KTtcbn1cbmNvbnN0IGNvZGUgPSBcIkJBQkVMX1BBUlNFUl9TT1VSQ0VUWVBFX01PRFVMRV9SRVFVSVJFRFwiO1xudmFyIE1vZHVsZUVycm9ycyA9IHtcbiAgSW1wb3J0TWV0YU91dHNpZGVNb2R1bGU6IHtcbiAgICBtZXNzYWdlOiBgaW1wb3J0Lm1ldGEgbWF5IGFwcGVhciBvbmx5IHdpdGggJ3NvdXJjZVR5cGU6IFwibW9kdWxlXCInYCxcbiAgICBjb2RlXG4gIH0sXG4gIEltcG9ydE91dHNpZGVNb2R1bGU6IHtcbiAgICBtZXNzYWdlOiBgJ2ltcG9ydCcgYW5kICdleHBvcnQnIG1heSBhcHBlYXIgb25seSB3aXRoICdzb3VyY2VUeXBlOiBcIm1vZHVsZVwiJ2AsXG4gICAgY29kZVxuICB9XG59O1xuY29uc3QgTm9kZURlc2NyaXB0aW9ucyA9IHtcbiAgQXJyYXlQYXR0ZXJuOiBcImFycmF5IGRlc3RydWN0dXJpbmcgcGF0dGVyblwiLFxuICBBc3NpZ25tZW50RXhwcmVzc2lvbjogXCJhc3NpZ25tZW50IGV4cHJlc3Npb25cIixcbiAgQXNzaWdubWVudFBhdHRlcm46IFwiYXNzaWdubWVudCBleHByZXNzaW9uXCIsXG4gIEFycm93RnVuY3Rpb25FeHByZXNzaW9uOiBcImFycm93IGZ1bmN0aW9uIGV4cHJlc3Npb25cIixcbiAgQ29uZGl0aW9uYWxFeHByZXNzaW9uOiBcImNvbmRpdGlvbmFsIGV4cHJlc3Npb25cIixcbiAgQ2F0Y2hDbGF1c2U6IFwiY2F0Y2ggY2xhdXNlXCIsXG4gIEZvck9mU3RhdGVtZW50OiBcImZvci1vZiBzdGF0ZW1lbnRcIixcbiAgRm9ySW5TdGF0ZW1lbnQ6IFwiZm9yLWluIHN0YXRlbWVudFwiLFxuICBGb3JTdGF0ZW1lbnQ6IFwiZm9yLWxvb3BcIixcbiAgRm9ybWFsUGFyYW1ldGVyczogXCJmdW5jdGlvbiBwYXJhbWV0ZXIgbGlzdFwiLFxuICBJZGVudGlmaWVyOiBcImlkZW50aWZpZXJcIixcbiAgSW1wb3J0U3BlY2lmaWVyOiBcImltcG9ydCBzcGVjaWZpZXJcIixcbiAgSW1wb3J0RGVmYXVsdFNwZWNpZmllcjogXCJpbXBvcnQgZGVmYXVsdCBzcGVjaWZpZXJcIixcbiAgSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyOiBcImltcG9ydCBuYW1lc3BhY2Ugc3BlY2lmaWVyXCIsXG4gIE9iamVjdFBhdHRlcm46IFwib2JqZWN0IGRlc3RydWN0dXJpbmcgcGF0dGVyblwiLFxuICBQYXJlbnRoZXNpemVkRXhwcmVzc2lvbjogXCJwYXJlbnRoZXNpemVkIGV4cHJlc3Npb25cIixcbiAgUmVzdEVsZW1lbnQ6IFwicmVzdCBlbGVtZW50XCIsXG4gIFVwZGF0ZUV4cHJlc3Npb246IHtcbiAgICB0cnVlOiBcInByZWZpeCBvcGVyYXRpb25cIixcbiAgICBmYWxzZTogXCJwb3N0Zml4IG9wZXJhdGlvblwiXG4gIH0sXG4gIFZhcmlhYmxlRGVjbGFyYXRvcjogXCJ2YXJpYWJsZSBkZWNsYXJhdGlvblwiLFxuICBZaWVsZEV4cHJlc3Npb246IFwieWllbGQgZXhwcmVzc2lvblwiXG59O1xuY29uc3QgdG9Ob2RlRGVzY3JpcHRpb24gPSBub2RlID0+IG5vZGUudHlwZSA9PT0gXCJVcGRhdGVFeHByZXNzaW9uXCIgPyBOb2RlRGVzY3JpcHRpb25zLlVwZGF0ZUV4cHJlc3Npb25bYCR7bm9kZS5wcmVmaXh9YF0gOiBOb2RlRGVzY3JpcHRpb25zW25vZGUudHlwZV07XG52YXIgU3RhbmRhcmRFcnJvcnMgPSB7XG4gIEFjY2Vzc29ySXNHZW5lcmF0b3I6ICh7XG4gICAga2luZFxuICB9KSA9PiBgQSAke2tpbmR9dGVyIGNhbm5vdCBiZSBhIGdlbmVyYXRvci5gLFxuICBBcmd1bWVudHNJbkNsYXNzOiBcIidhcmd1bWVudHMnIGlzIG9ubHkgYWxsb3dlZCBpbiBmdW5jdGlvbnMgYW5kIGNsYXNzIG1ldGhvZHMuXCIsXG4gIEFzeW5jRnVuY3Rpb25JblNpbmdsZVN0YXRlbWVudENvbnRleHQ6IFwiQXN5bmMgZnVuY3Rpb25zIGNhbiBvbmx5IGJlIGRlY2xhcmVkIGF0IHRoZSB0b3AgbGV2ZWwgb3IgaW5zaWRlIGEgYmxvY2suXCIsXG4gIEF3YWl0QmluZGluZ0lkZW50aWZpZXI6IFwiQ2FuIG5vdCB1c2UgJ2F3YWl0JyBhcyBpZGVudGlmaWVyIGluc2lkZSBhbiBhc3luYyBmdW5jdGlvbi5cIixcbiAgQXdhaXRCaW5kaW5nSWRlbnRpZmllckluU3RhdGljQmxvY2s6IFwiQ2FuIG5vdCB1c2UgJ2F3YWl0JyBhcyBpZGVudGlmaWVyIGluc2lkZSBhIHN0YXRpYyBibG9jay5cIixcbiAgQXdhaXRFeHByZXNzaW9uRm9ybWFsUGFyYW1ldGVyOiBcIidhd2FpdCcgaXMgbm90IGFsbG93ZWQgaW4gYXN5bmMgZnVuY3Rpb24gcGFyYW1ldGVycy5cIixcbiAgQXdhaXRVc2luZ05vdEluQXN5bmNDb250ZXh0OiBcIidhd2FpdCB1c2luZycgaXMgb25seSBhbGxvd2VkIHdpdGhpbiBhc3luYyBmdW5jdGlvbnMgYW5kIGF0IHRoZSB0b3AgbGV2ZWxzIG9mIG1vZHVsZXMuXCIsXG4gIEF3YWl0Tm90SW5Bc3luY0NvbnRleHQ6IFwiJ2F3YWl0JyBpcyBvbmx5IGFsbG93ZWQgd2l0aGluIGFzeW5jIGZ1bmN0aW9ucyBhbmQgYXQgdGhlIHRvcCBsZXZlbHMgb2YgbW9kdWxlcy5cIixcbiAgQmFkR2V0dGVyQXJpdHk6IFwiQSAnZ2V0JyBhY2Nlc3NvciBtdXN0IG5vdCBoYXZlIGFueSBmb3JtYWwgcGFyYW1ldGVycy5cIixcbiAgQmFkU2V0dGVyQXJpdHk6IFwiQSAnc2V0JyBhY2Nlc3NvciBtdXN0IGhhdmUgZXhhY3RseSBvbmUgZm9ybWFsIHBhcmFtZXRlci5cIixcbiAgQmFkU2V0dGVyUmVzdFBhcmFtZXRlcjogXCJBICdzZXQnIGFjY2Vzc29yIGZ1bmN0aW9uIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgcmVzdCBwYXJhbWV0ZXIuXCIsXG4gIENvbnN0cnVjdG9yQ2xhc3NGaWVsZDogXCJDbGFzc2VzIG1heSBub3QgaGF2ZSBhIGZpZWxkIG5hbWVkICdjb25zdHJ1Y3RvcicuXCIsXG4gIENvbnN0cnVjdG9yQ2xhc3NQcml2YXRlRmllbGQ6IFwiQ2xhc3NlcyBtYXkgbm90IGhhdmUgYSBwcml2YXRlIGZpZWxkIG5hbWVkICcjY29uc3RydWN0b3InLlwiLFxuICBDb25zdHJ1Y3RvcklzQWNjZXNzb3I6IFwiQ2xhc3MgY29uc3RydWN0b3IgbWF5IG5vdCBiZSBhbiBhY2Nlc3Nvci5cIixcbiAgQ29uc3RydWN0b3JJc0FzeW5jOiBcIkNvbnN0cnVjdG9yIGNhbid0IGJlIGFuIGFzeW5jIGZ1bmN0aW9uLlwiLFxuICBDb25zdHJ1Y3RvcklzR2VuZXJhdG9yOiBcIkNvbnN0cnVjdG9yIGNhbid0IGJlIGEgZ2VuZXJhdG9yLlwiLFxuICBEZWNsYXJhdGlvbk1pc3NpbmdJbml0aWFsaXplcjogKHtcbiAgICBraW5kXG4gIH0pID0+IGBNaXNzaW5nIGluaXRpYWxpemVyIGluICR7a2luZH0gZGVjbGFyYXRpb24uYCxcbiAgRGVjb3JhdG9yQXJndW1lbnRzT3V0c2lkZVBhcmVudGhlc2VzOiBcIkRlY29yYXRvciBhcmd1bWVudHMgbXVzdCBiZSBtb3ZlZCBpbnNpZGUgcGFyZW50aGVzZXM6IHVzZSAnQChkZWNvcmF0b3IoYXJncykpJyBpbnN0ZWFkIG9mICdAKGRlY29yYXRvcikoYXJncyknLlwiLFxuICBEZWNvcmF0b3JCZWZvcmVFeHBvcnQ6IFwiRGVjb3JhdG9ycyBtdXN0IGJlIHBsYWNlZCAqYmVmb3JlKiB0aGUgJ2V4cG9ydCcga2V5d29yZC4gUmVtb3ZlIHRoZSAnZGVjb3JhdG9yc0JlZm9yZUV4cG9ydDogdHJ1ZScgb3B0aW9uIHRvIHVzZSB0aGUgJ2V4cG9ydCBAZGVjb3JhdG9yIGNsYXNzIHt9JyBzeW50YXguXCIsXG4gIERlY29yYXRvcnNCZWZvcmVBZnRlckV4cG9ydDogXCJEZWNvcmF0b3JzIGNhbiBiZSBwbGFjZWQgKmVpdGhlciogYmVmb3JlIG9yIGFmdGVyIHRoZSAnZXhwb3J0JyBrZXl3b3JkLCBidXQgbm90IGluIGJvdGggbG9jYXRpb25zIGF0IHRoZSBzYW1lIHRpbWUuXCIsXG4gIERlY29yYXRvckNvbnN0cnVjdG9yOiBcIkRlY29yYXRvcnMgY2FuJ3QgYmUgdXNlZCB3aXRoIGEgY29uc3RydWN0b3IuIERpZCB5b3UgbWVhbiAnQGRlYyBjbGFzcyB7IC4uLiB9Jz9cIixcbiAgRGVjb3JhdG9yRXhwb3J0Q2xhc3M6IFwiRGVjb3JhdG9ycyBtdXN0IGJlIHBsYWNlZCAqYWZ0ZXIqIHRoZSAnZXhwb3J0JyBrZXl3b3JkLiBSZW1vdmUgdGhlICdkZWNvcmF0b3JzQmVmb3JlRXhwb3J0OiBmYWxzZScgb3B0aW9uIHRvIHVzZSB0aGUgJ0BkZWNvcmF0b3IgZXhwb3J0IGNsYXNzIHt9JyBzeW50YXguXCIsXG4gIERlY29yYXRvclNlbWljb2xvbjogXCJEZWNvcmF0b3JzIG11c3Qgbm90IGJlIGZvbGxvd2VkIGJ5IGEgc2VtaWNvbG9uLlwiLFxuICBEZWNvcmF0b3JTdGF0aWNCbG9jazogXCJEZWNvcmF0b3JzIGNhbid0IGJlIHVzZWQgd2l0aCBhIHN0YXRpYyBibG9jay5cIixcbiAgRGVmZXJJbXBvcnRSZXF1aXJlc05hbWVzcGFjZTogJ09ubHkgYGltcG9ydCBkZWZlciAqIGFzIHggZnJvbSBcIi4vbW9kdWxlXCJgIGlzIHZhbGlkLicsXG4gIERlbGV0ZVByaXZhdGVGaWVsZDogXCJEZWxldGluZyBhIHByaXZhdGUgZmllbGQgaXMgbm90IGFsbG93ZWQuXCIsXG4gIERlc3RydWN0dXJlTmFtZWRJbXBvcnQ6IFwiRVMyMDE1IG5hbWVkIGltcG9ydHMgZG8gbm90IGRlc3RydWN0dXJlLiBVc2UgYW5vdGhlciBzdGF0ZW1lbnQgZm9yIGRlc3RydWN0dXJpbmcgYWZ0ZXIgdGhlIGltcG9ydC5cIixcbiAgRHVwbGljYXRlQ29uc3RydWN0b3I6IFwiRHVwbGljYXRlIGNvbnN0cnVjdG9yIGluIHRoZSBzYW1lIGNsYXNzLlwiLFxuICBEdXBsaWNhdGVEZWZhdWx0RXhwb3J0OiBcIk9ubHkgb25lIGRlZmF1bHQgZXhwb3J0IGFsbG93ZWQgcGVyIG1vZHVsZS5cIixcbiAgRHVwbGljYXRlRXhwb3J0OiAoe1xuICAgIGV4cG9ydE5hbWVcbiAgfSkgPT4gYFxcYCR7ZXhwb3J0TmFtZX1cXGAgaGFzIGFscmVhZHkgYmVlbiBleHBvcnRlZC4gRXhwb3J0ZWQgaWRlbnRpZmllcnMgbXVzdCBiZSB1bmlxdWUuYCxcbiAgRHVwbGljYXRlUHJvdG86IFwiUmVkZWZpbml0aW9uIG9mIF9fcHJvdG9fXyBwcm9wZXJ0eS5cIixcbiAgRHVwbGljYXRlUmVnRXhwRmxhZ3M6IFwiRHVwbGljYXRlIHJlZ3VsYXIgZXhwcmVzc2lvbiBmbGFnLlwiLFxuICBFbGVtZW50QWZ0ZXJSZXN0OiBcIlJlc3QgZWxlbWVudCBtdXN0IGJlIGxhc3QgZWxlbWVudC5cIixcbiAgRXNjYXBlZENoYXJOb3RBbklkZW50aWZpZXI6IFwiSW52YWxpZCBVbmljb2RlIGVzY2FwZS5cIixcbiAgRXhwb3J0QmluZGluZ0lzU3RyaW5nOiAoe1xuICAgIGxvY2FsTmFtZSxcbiAgICBleHBvcnROYW1lXG4gIH0pID0+IGBBIHN0cmluZyBsaXRlcmFsIGNhbm5vdCBiZSB1c2VkIGFzIGFuIGV4cG9ydGVkIGJpbmRpbmcgd2l0aG91dCBcXGBmcm9tXFxgLlxcbi0gRGlkIHlvdSBtZWFuIFxcYGV4cG9ydCB7ICcke2xvY2FsTmFtZX0nIGFzICcke2V4cG9ydE5hbWV9JyB9IGZyb20gJ3NvbWUtbW9kdWxlJ1xcYD9gLFxuICBFeHBvcnREZWZhdWx0RnJvbUFzSWRlbnRpZmllcjogXCInZnJvbScgaXMgbm90IGFsbG93ZWQgYXMgYW4gaWRlbnRpZmllciBhZnRlciAnZXhwb3J0IGRlZmF1bHQnLlwiLFxuICBGb3JJbk9mTG9vcEluaXRpYWxpemVyOiAoe1xuICAgIHR5cGVcbiAgfSkgPT4gYCcke3R5cGUgPT09IFwiRm9ySW5TdGF0ZW1lbnRcIiA/IFwiZm9yLWluXCIgOiBcImZvci1vZlwifScgbG9vcCB2YXJpYWJsZSBkZWNsYXJhdGlvbiBtYXkgbm90IGhhdmUgYW4gaW5pdGlhbGl6ZXIuYCxcbiAgRm9ySW5Vc2luZzogXCJGb3ItaW4gbG9vcCBtYXkgbm90IHN0YXJ0IHdpdGggJ3VzaW5nJyBkZWNsYXJhdGlvbi5cIixcbiAgRm9yT2ZBc3luYzogXCJUaGUgbGVmdC1oYW5kIHNpZGUgb2YgYSBmb3Itb2YgbG9vcCBtYXkgbm90IGJlICdhc3luYycuXCIsXG4gIEZvck9mTGV0OiBcIlRoZSBsZWZ0LWhhbmQgc2lkZSBvZiBhIGZvci1vZiBsb29wIG1heSBub3Qgc3RhcnQgd2l0aCAnbGV0Jy5cIixcbiAgR2VuZXJhdG9ySW5TaW5nbGVTdGF0ZW1lbnRDb250ZXh0OiBcIkdlbmVyYXRvcnMgY2FuIG9ubHkgYmUgZGVjbGFyZWQgYXQgdGhlIHRvcCBsZXZlbCBvciBpbnNpZGUgYSBibG9jay5cIixcbiAgSWxsZWdhbEJyZWFrQ29udGludWU6ICh7XG4gICAgdHlwZVxuICB9KSA9PiBgVW5zeW50YWN0aWMgJHt0eXBlID09PSBcIkJyZWFrU3RhdGVtZW50XCIgPyBcImJyZWFrXCIgOiBcImNvbnRpbnVlXCJ9LmAsXG4gIElsbGVnYWxMYW5ndWFnZU1vZGVEaXJlY3RpdmU6IFwiSWxsZWdhbCAndXNlIHN0cmljdCcgZGlyZWN0aXZlIGluIGZ1bmN0aW9uIHdpdGggbm9uLXNpbXBsZSBwYXJhbWV0ZXIgbGlzdC5cIixcbiAgSWxsZWdhbFJldHVybjogXCIncmV0dXJuJyBvdXRzaWRlIG9mIGZ1bmN0aW9uLlwiLFxuICBJbXBvcnRBdHRyaWJ1dGVzVXNlQXNzZXJ0OiBcIlRoZSBgYXNzZXJ0YCBrZXl3b3JkIGluIGltcG9ydCBhdHRyaWJ1dGVzIGlzIGRlcHJlY2F0ZWQgYW5kIGl0IGhhcyBiZWVuIHJlcGxhY2VkIGJ5IHRoZSBgd2l0aGAga2V5d29yZC4gWW91IGNhbiBlbmFibGUgdGhlIGBkZXByZWNhdGVkSW1wb3J0QXNzZXJ0YCBwYXJzZXIgcGx1Z2luIHRvIHN1cHByZXNzIHRoaXMgZXJyb3IuXCIsXG4gIEltcG9ydEJpbmRpbmdJc1N0cmluZzogKHtcbiAgICBpbXBvcnROYW1lXG4gIH0pID0+IGBBIHN0cmluZyBsaXRlcmFsIGNhbm5vdCBiZSB1c2VkIGFzIGFuIGltcG9ydGVkIGJpbmRpbmcuXFxuLSBEaWQgeW91IG1lYW4gXFxgaW1wb3J0IHsgXCIke2ltcG9ydE5hbWV9XCIgYXMgZm9vIH1cXGA/YCxcbiAgSW1wb3J0Q2FsbEFyaXR5OiBgXFxgaW1wb3J0KClcXGAgcmVxdWlyZXMgZXhhY3RseSBvbmUgb3IgdHdvIGFyZ3VtZW50cy5gLFxuICBJbXBvcnRDYWxsTm90TmV3RXhwcmVzc2lvbjogXCJDYW5ub3QgdXNlIG5ldyB3aXRoIGltcG9ydCguLi4pLlwiLFxuICBJbXBvcnRDYWxsU3ByZWFkQXJndW1lbnQ6IFwiYC4uLmAgaXMgbm90IGFsbG93ZWQgaW4gYGltcG9ydCgpYC5cIixcbiAgSW1wb3J0SlNPTkJpbmRpbmdOb3REZWZhdWx0OiBcIkEgSlNPTiBtb2R1bGUgY2FuIG9ubHkgYmUgaW1wb3J0ZWQgd2l0aCBgZGVmYXVsdGAuXCIsXG4gIEltcG9ydFJlZmxlY3Rpb25IYXNBc3NlcnRpb246IFwiYGltcG9ydCBtb2R1bGUgeGAgY2Fubm90IGhhdmUgYXNzZXJ0aW9ucy5cIixcbiAgSW1wb3J0UmVmbGVjdGlvbk5vdEJpbmRpbmc6ICdPbmx5IGBpbXBvcnQgbW9kdWxlIHggZnJvbSBcIi4vbW9kdWxlXCJgIGlzIHZhbGlkLicsXG4gIEluY29tcGF0aWJsZVJlZ0V4cFVWRmxhZ3M6IFwiVGhlICd1JyBhbmQgJ3YnIHJlZ3VsYXIgZXhwcmVzc2lvbiBmbGFncyBjYW5ub3QgYmUgZW5hYmxlZCBhdCB0aGUgc2FtZSB0aW1lLlwiLFxuICBJbnZhbGlkQmlnSW50TGl0ZXJhbDogXCJJbnZhbGlkIEJpZ0ludExpdGVyYWwuXCIsXG4gIEludmFsaWRDb2RlUG9pbnQ6IFwiQ29kZSBwb2ludCBvdXQgb2YgYm91bmRzLlwiLFxuICBJbnZhbGlkQ292ZXJEaXNjYXJkRWxlbWVudDogXCIndm9pZCcgbXVzdCBiZSBmb2xsb3dlZCBieSBhbiBleHByZXNzaW9uIHdoZW4gbm90IHVzZWQgaW4gYSBiaW5kaW5nIHBvc2l0aW9uLlwiLFxuICBJbnZhbGlkQ292ZXJJbml0aWFsaXplZE5hbWU6IFwiSW52YWxpZCBzaG9ydGhhbmQgcHJvcGVydHkgaW5pdGlhbGl6ZXIuXCIsXG4gIEludmFsaWREZWNpbWFsOiBcIkludmFsaWQgZGVjaW1hbC5cIixcbiAgSW52YWxpZERpZ2l0OiAoe1xuICAgIHJhZGl4XG4gIH0pID0+IGBFeHBlY3RlZCBudW1iZXIgaW4gcmFkaXggJHtyYWRpeH0uYCxcbiAgSW52YWxpZEVzY2FwZVNlcXVlbmNlOiBcIkJhZCBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlLlwiLFxuICBJbnZhbGlkRXNjYXBlU2VxdWVuY2VUZW1wbGF0ZTogXCJJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZSBpbiB0ZW1wbGF0ZS5cIixcbiAgSW52YWxpZEVzY2FwZWRSZXNlcnZlZFdvcmQ6ICh7XG4gICAgcmVzZXJ2ZWRXb3JkXG4gIH0pID0+IGBFc2NhcGUgc2VxdWVuY2UgaW4ga2V5d29yZCAke3Jlc2VydmVkV29yZH0uYCxcbiAgSW52YWxpZElkZW50aWZpZXI6ICh7XG4gICAgaWRlbnRpZmllck5hbWVcbiAgfSkgPT4gYEludmFsaWQgaWRlbnRpZmllciAke2lkZW50aWZpZXJOYW1lfS5gLFxuICBJbnZhbGlkTGhzOiAoe1xuICAgIGFuY2VzdG9yXG4gIH0pID0+IGBJbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluICR7dG9Ob2RlRGVzY3JpcHRpb24oYW5jZXN0b3IpfS5gLFxuICBJbnZhbGlkTGhzQmluZGluZzogKHtcbiAgICBhbmNlc3RvclxuICB9KSA9PiBgQmluZGluZyBpbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluICR7dG9Ob2RlRGVzY3JpcHRpb24oYW5jZXN0b3IpfS5gLFxuICBJbnZhbGlkTGhzT3B0aW9uYWxDaGFpbmluZzogKHtcbiAgICBhbmNlc3RvclxuICB9KSA9PiBgSW52YWxpZCBvcHRpb25hbCBjaGFpbmluZyBpbiB0aGUgbGVmdC1oYW5kIHNpZGUgb2YgJHt0b05vZGVEZXNjcmlwdGlvbihhbmNlc3Rvcil9LmAsXG4gIEludmFsaWROdW1iZXI6IFwiSW52YWxpZCBudW1iZXIuXCIsXG4gIEludmFsaWRPck1pc3NpbmdFeHBvbmVudDogXCJGbG9hdGluZy1wb2ludCBudW1iZXJzIHJlcXVpcmUgYSB2YWxpZCBleHBvbmVudCBhZnRlciB0aGUgJ2UnLlwiLFxuICBJbnZhbGlkT3JVbmV4cGVjdGVkVG9rZW46ICh7XG4gICAgdW5leHBlY3RlZFxuICB9KSA9PiBgVW5leHBlY3RlZCBjaGFyYWN0ZXIgJyR7dW5leHBlY3RlZH0nLmAsXG4gIEludmFsaWRQYXJlbnRoZXNpemVkQXNzaWdubWVudDogXCJJbnZhbGlkIHBhcmVudGhlc2l6ZWQgYXNzaWdubWVudCBwYXR0ZXJuLlwiLFxuICBJbnZhbGlkUHJpdmF0ZUZpZWxkUmVzb2x1dGlvbjogKHtcbiAgICBpZGVudGlmaWVyTmFtZVxuICB9KSA9PiBgUHJpdmF0ZSBuYW1lICMke2lkZW50aWZpZXJOYW1lfSBpcyBub3QgZGVmaW5lZC5gLFxuICBJbnZhbGlkUHJvcGVydHlCaW5kaW5nUGF0dGVybjogXCJCaW5kaW5nIG1lbWJlciBleHByZXNzaW9uLlwiLFxuICBJbnZhbGlkUmVjb3JkUHJvcGVydHk6IFwiT25seSBwcm9wZXJ0aWVzIGFuZCBzcHJlYWQgZWxlbWVudHMgYXJlIGFsbG93ZWQgaW4gcmVjb3JkIGRlZmluaXRpb25zLlwiLFxuICBJbnZhbGlkUmVzdEFzc2lnbm1lbnRQYXR0ZXJuOiBcIkludmFsaWQgcmVzdCBvcGVyYXRvcidzIGFyZ3VtZW50LlwiLFxuICBMYWJlbFJlZGVjbGFyYXRpb246ICh7XG4gICAgbGFiZWxOYW1lXG4gIH0pID0+IGBMYWJlbCAnJHtsYWJlbE5hbWV9JyBpcyBhbHJlYWR5IGRlY2xhcmVkLmAsXG4gIExldEluTGV4aWNhbEJpbmRpbmc6IFwiJ2xldCcgaXMgZGlzYWxsb3dlZCBhcyBhIGxleGljYWxseSBib3VuZCBuYW1lLlwiLFxuICBMaW5lVGVybWluYXRvckJlZm9yZUFycm93OiBcIk5vIGxpbmUgYnJlYWsgaXMgYWxsb3dlZCBiZWZvcmUgJz0+Jy5cIixcbiAgTWFsZm9ybWVkUmVnRXhwRmxhZ3M6IFwiSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24gZmxhZy5cIixcbiAgTWlzc2luZ0NsYXNzTmFtZTogXCJBIGNsYXNzIG5hbWUgaXMgcmVxdWlyZWQuXCIsXG4gIE1pc3NpbmdFcUluQXNzaWdubWVudDogXCJPbmx5ICc9JyBvcGVyYXRvciBjYW4gYmUgdXNlZCBmb3Igc3BlY2lmeWluZyBkZWZhdWx0IHZhbHVlLlwiLFxuICBNaXNzaW5nU2VtaWNvbG9uOiBcIk1pc3Npbmcgc2VtaWNvbG9uLlwiLFxuICBNaXNzaW5nUGx1Z2luOiAoe1xuICAgIG1pc3NpbmdQbHVnaW5cbiAgfSkgPT4gYFRoaXMgZXhwZXJpbWVudGFsIHN5bnRheCByZXF1aXJlcyBlbmFibGluZyB0aGUgcGFyc2VyIHBsdWdpbjogJHttaXNzaW5nUGx1Z2luLm1hcChuYW1lID0+IEpTT04uc3RyaW5naWZ5KG5hbWUpKS5qb2luKFwiLCBcIil9LmAsXG4gIE1pc3NpbmdPbmVPZlBsdWdpbnM6ICh7XG4gICAgbWlzc2luZ1BsdWdpblxuICB9KSA9PiBgVGhpcyBleHBlcmltZW50YWwgc3ludGF4IHJlcXVpcmVzIGVuYWJsaW5nIG9uZSBvZiB0aGUgZm9sbG93aW5nIHBhcnNlciBwbHVnaW4ocyk6ICR7bWlzc2luZ1BsdWdpbi5tYXAobmFtZSA9PiBKU09OLnN0cmluZ2lmeShuYW1lKSkuam9pbihcIiwgXCIpfS5gLFxuICBNaXNzaW5nVW5pY29kZUVzY2FwZTogXCJFeHBlY3RpbmcgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UgXFxcXHVYWFhYLlwiLFxuICBNaXhpbmdDb2FsZXNjZVdpdGhMb2dpY2FsOiBcIk51bGxpc2ggY29hbGVzY2luZyBvcGVyYXRvcig/PykgcmVxdWlyZXMgcGFyZW5zIHdoZW4gbWl4aW5nIHdpdGggbG9naWNhbCBvcGVyYXRvcnMuXCIsXG4gIE1vZHVsZUF0dHJpYnV0ZURpZmZlcmVudEZyb21UeXBlOiBcIlRoZSBvbmx5IGFjY2VwdGVkIG1vZHVsZSBhdHRyaWJ1dGUgaXMgYHR5cGVgLlwiLFxuICBNb2R1bGVBdHRyaWJ1dGVJbnZhbGlkVmFsdWU6IFwiT25seSBzdHJpbmcgbGl0ZXJhbHMgYXJlIGFsbG93ZWQgYXMgbW9kdWxlIGF0dHJpYnV0ZSB2YWx1ZXMuXCIsXG4gIE1vZHVsZUF0dHJpYnV0ZXNXaXRoRHVwbGljYXRlS2V5czogKHtcbiAgICBrZXlcbiAgfSkgPT4gYER1cGxpY2F0ZSBrZXkgXCIke2tleX1cIiBpcyBub3QgYWxsb3dlZCBpbiBtb2R1bGUgYXR0cmlidXRlcy5gLFxuICBNb2R1bGVFeHBvcnROYW1lSGFzTG9uZVN1cnJvZ2F0ZTogKHtcbiAgICBzdXJyb2dhdGVDaGFyQ29kZVxuICB9KSA9PiBgQW4gZXhwb3J0IG5hbWUgY2Fubm90IGluY2x1ZGUgYSBsb25lIHN1cnJvZ2F0ZSwgZm91bmQgJ1xcXFx1JHtzdXJyb2dhdGVDaGFyQ29kZS50b1N0cmluZygxNil9Jy5gLFxuICBNb2R1bGVFeHBvcnRVbmRlZmluZWQ6ICh7XG4gICAgbG9jYWxOYW1lXG4gIH0pID0+IGBFeHBvcnQgJyR7bG9jYWxOYW1lfScgaXMgbm90IGRlZmluZWQuYCxcbiAgTXVsdGlwbGVEZWZhdWx0c0luU3dpdGNoOiBcIk11bHRpcGxlIGRlZmF1bHQgY2xhdXNlcy5cIixcbiAgTmV3bGluZUFmdGVyVGhyb3c6IFwiSWxsZWdhbCBuZXdsaW5lIGFmdGVyIHRocm93LlwiLFxuICBOb0NhdGNoT3JGaW5hbGx5OiBcIk1pc3NpbmcgY2F0Y2ggb3IgZmluYWxseSBjbGF1c2UuXCIsXG4gIE51bWJlcklkZW50aWZpZXI6IFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXIuXCIsXG4gIE51bWVyaWNTZXBhcmF0b3JJbkVzY2FwZVNlcXVlbmNlOiBcIk51bWVyaWMgc2VwYXJhdG9ycyBhcmUgbm90IGFsbG93ZWQgaW5zaWRlIHVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlcyBvciBoZXggZXNjYXBlIHNlcXVlbmNlcy5cIixcbiAgT2Jzb2xldGVBd2FpdFN0YXI6IFwiJ2F3YWl0KicgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBhc3luYyBmdW5jdGlvbnMgcHJvcG9zYWwuIFVzZSBQcm9taXNlLmFsbCgpIGluc3RlYWQuXCIsXG4gIE9wdGlvbmFsQ2hhaW5pbmdOb05ldzogXCJDb25zdHJ1Y3RvcnMgaW4vYWZ0ZXIgYW4gT3B0aW9uYWwgQ2hhaW4gYXJlIG5vdCBhbGxvd2VkLlwiLFxuICBPcHRpb25hbENoYWluaW5nTm9UZW1wbGF0ZTogXCJUYWdnZWQgVGVtcGxhdGUgTGl0ZXJhbHMgYXJlIG5vdCBhbGxvd2VkIGluIG9wdGlvbmFsQ2hhaW4uXCIsXG4gIE92ZXJyaWRlT25Db25zdHJ1Y3RvcjogXCInb3ZlcnJpZGUnIG1vZGlmaWVyIGNhbm5vdCBhcHBlYXIgb24gYSBjb25zdHJ1Y3RvciBkZWNsYXJhdGlvbi5cIixcbiAgUGFyYW1EdXBlOiBcIkFyZ3VtZW50IG5hbWUgY2xhc2guXCIsXG4gIFBhdHRlcm5IYXNBY2Nlc3NvcjogXCJPYmplY3QgcGF0dGVybiBjYW4ndCBjb250YWluIGdldHRlciBvciBzZXR0ZXIuXCIsXG4gIFBhdHRlcm5IYXNNZXRob2Q6IFwiT2JqZWN0IHBhdHRlcm4gY2FuJ3QgY29udGFpbiBtZXRob2RzLlwiLFxuICBQcml2YXRlSW5FeHBlY3RlZEluOiAoe1xuICAgIGlkZW50aWZpZXJOYW1lXG4gIH0pID0+IGBQcml2YXRlIG5hbWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gcHJvcGVydHkgYWNjZXNzZXMgKFxcYG9iai4jJHtpZGVudGlmaWVyTmFtZX1cXGApIG9yIGluIFxcYGluXFxgIGV4cHJlc3Npb25zIChcXGAjJHtpZGVudGlmaWVyTmFtZX0gaW4gb2JqXFxgKS5gLFxuICBQcml2YXRlTmFtZVJlZGVjbGFyYXRpb246ICh7XG4gICAgaWRlbnRpZmllck5hbWVcbiAgfSkgPT4gYER1cGxpY2F0ZSBwcml2YXRlIG5hbWUgIyR7aWRlbnRpZmllck5hbWV9LmAsXG4gIFJlY29yZEV4cHJlc3Npb25CYXJJbmNvcnJlY3RFbmRTeW50YXhUeXBlOiBcIlJlY29yZCBleHByZXNzaW9ucyBlbmRpbmcgd2l0aCAnfH0nIGFyZSBvbmx5IGFsbG93ZWQgd2hlbiB0aGUgJ3N5bnRheFR5cGUnIG9wdGlvbiBvZiB0aGUgJ3JlY29yZEFuZFR1cGxlJyBwbHVnaW4gaXMgc2V0IHRvICdiYXInLlwiLFxuICBSZWNvcmRFeHByZXNzaW9uQmFySW5jb3JyZWN0U3RhcnRTeW50YXhUeXBlOiBcIlJlY29yZCBleHByZXNzaW9ucyBzdGFydGluZyB3aXRoICd7fCcgYXJlIG9ubHkgYWxsb3dlZCB3aGVuIHRoZSAnc3ludGF4VHlwZScgb3B0aW9uIG9mIHRoZSAncmVjb3JkQW5kVHVwbGUnIHBsdWdpbiBpcyBzZXQgdG8gJ2JhcicuXCIsXG4gIFJlY29yZEV4cHJlc3Npb25IYXNoSW5jb3JyZWN0U3RhcnRTeW50YXhUeXBlOiBcIlJlY29yZCBleHByZXNzaW9ucyBzdGFydGluZyB3aXRoICcjeycgYXJlIG9ubHkgYWxsb3dlZCB3aGVuIHRoZSAnc3ludGF4VHlwZScgb3B0aW9uIG9mIHRoZSAncmVjb3JkQW5kVHVwbGUnIHBsdWdpbiBpcyBzZXQgdG8gJ2hhc2gnLlwiLFxuICBSZWNvcmROb1Byb3RvOiBcIidfX3Byb3RvX18nIGlzIG5vdCBhbGxvd2VkIGluIFJlY29yZCBleHByZXNzaW9ucy5cIixcbiAgUmVzdFRyYWlsaW5nQ29tbWE6IFwiVW5leHBlY3RlZCB0cmFpbGluZyBjb21tYSBhZnRlciByZXN0IGVsZW1lbnQuXCIsXG4gIFNsb3BweUZ1bmN0aW9uOiBcIkluIG5vbi1zdHJpY3QgbW9kZSBjb2RlLCBmdW5jdGlvbnMgY2FuIG9ubHkgYmUgZGVjbGFyZWQgYXQgdG9wIGxldmVsIG9yIGluc2lkZSBhIGJsb2NrLlwiLFxuICBTbG9wcHlGdW5jdGlvbkFubmV4QjogXCJJbiBub24tc3RyaWN0IG1vZGUgY29kZSwgZnVuY3Rpb25zIGNhbiBvbmx5IGJlIGRlY2xhcmVkIGF0IHRvcCBsZXZlbCwgaW5zaWRlIGEgYmxvY2ssIG9yIGFzIHRoZSBib2R5IG9mIGFuIGlmIHN0YXRlbWVudC5cIixcbiAgU291cmNlUGhhc2VJbXBvcnRSZXF1aXJlc0RlZmF1bHQ6ICdPbmx5IGBpbXBvcnQgc291cmNlIHggZnJvbSBcIi4vbW9kdWxlXCJgIGlzIHZhbGlkLicsXG4gIFN0YXRpY1Byb3RvdHlwZTogXCJDbGFzc2VzIG1heSBub3QgaGF2ZSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgcHJvdG90eXBlLlwiLFxuICBTdXBlck5vdEFsbG93ZWQ6IFwiYHN1cGVyKClgIGlzIG9ubHkgdmFsaWQgaW5zaWRlIGEgY2xhc3MgY29uc3RydWN0b3Igb2YgYSBzdWJjbGFzcy4gTWF5YmUgYSB0eXBvIGluIHRoZSBtZXRob2QgbmFtZSAoJ2NvbnN0cnVjdG9yJykgb3Igbm90IGV4dGVuZGluZyBhbm90aGVyIGNsYXNzP1wiLFxuICBTdXBlclByaXZhdGVGaWVsZDogXCJQcml2YXRlIGZpZWxkcyBjYW4ndCBiZSBhY2Nlc3NlZCBvbiBzdXBlci5cIixcbiAgVHJhaWxpbmdEZWNvcmF0b3I6IFwiRGVjb3JhdG9ycyBtdXN0IGJlIGF0dGFjaGVkIHRvIGEgY2xhc3MgZWxlbWVudC5cIixcbiAgVHVwbGVFeHByZXNzaW9uQmFySW5jb3JyZWN0RW5kU3ludGF4VHlwZTogXCJUdXBsZSBleHByZXNzaW9ucyBlbmRpbmcgd2l0aCAnfF0nIGFyZSBvbmx5IGFsbG93ZWQgd2hlbiB0aGUgJ3N5bnRheFR5cGUnIG9wdGlvbiBvZiB0aGUgJ3JlY29yZEFuZFR1cGxlJyBwbHVnaW4gaXMgc2V0IHRvICdiYXInLlwiLFxuICBUdXBsZUV4cHJlc3Npb25CYXJJbmNvcnJlY3RTdGFydFN5bnRheFR5cGU6IFwiVHVwbGUgZXhwcmVzc2lvbnMgc3RhcnRpbmcgd2l0aCAnW3wnIGFyZSBvbmx5IGFsbG93ZWQgd2hlbiB0aGUgJ3N5bnRheFR5cGUnIG9wdGlvbiBvZiB0aGUgJ3JlY29yZEFuZFR1cGxlJyBwbHVnaW4gaXMgc2V0IHRvICdiYXInLlwiLFxuICBUdXBsZUV4cHJlc3Npb25IYXNoSW5jb3JyZWN0U3RhcnRTeW50YXhUeXBlOiBcIlR1cGxlIGV4cHJlc3Npb25zIHN0YXJ0aW5nIHdpdGggJyNbJyBhcmUgb25seSBhbGxvd2VkIHdoZW4gdGhlICdzeW50YXhUeXBlJyBvcHRpb24gb2YgdGhlICdyZWNvcmRBbmRUdXBsZScgcGx1Z2luIGlzIHNldCB0byAnaGFzaCcuXCIsXG4gIFVuZXhwZWN0ZWRBcmd1bWVudFBsYWNlaG9sZGVyOiBcIlVuZXhwZWN0ZWQgYXJndW1lbnQgcGxhY2Vob2xkZXIuXCIsXG4gIFVuZXhwZWN0ZWRBd2FpdEFmdGVyUGlwZWxpbmVCb2R5OiAnVW5leHBlY3RlZCBcImF3YWl0XCIgYWZ0ZXIgcGlwZWxpbmUgYm9keTsgYXdhaXQgbXVzdCBoYXZlIHBhcmVudGhlc2VzIGluIG1pbmltYWwgcHJvcG9zYWwuJyxcbiAgVW5leHBlY3RlZERpZ2l0QWZ0ZXJIYXNoOiBcIlVuZXhwZWN0ZWQgZGlnaXQgYWZ0ZXIgaGFzaCB0b2tlbi5cIixcbiAgVW5leHBlY3RlZEltcG9ydEV4cG9ydDogXCInaW1wb3J0JyBhbmQgJ2V4cG9ydCcgbWF5IG9ubHkgYXBwZWFyIGF0IHRoZSB0b3AgbGV2ZWwuXCIsXG4gIFVuZXhwZWN0ZWRLZXl3b3JkOiAoe1xuICAgIGtleXdvcmRcbiAgfSkgPT4gYFVuZXhwZWN0ZWQga2V5d29yZCAnJHtrZXl3b3JkfScuYCxcbiAgVW5leHBlY3RlZExlYWRpbmdEZWNvcmF0b3I6IFwiTGVhZGluZyBkZWNvcmF0b3JzIG11c3QgYmUgYXR0YWNoZWQgdG8gYSBjbGFzcyBkZWNsYXJhdGlvbi5cIixcbiAgVW5leHBlY3RlZExleGljYWxEZWNsYXJhdGlvbjogXCJMZXhpY2FsIGRlY2xhcmF0aW9uIGNhbm5vdCBhcHBlYXIgaW4gYSBzaW5nbGUtc3RhdGVtZW50IGNvbnRleHQuXCIsXG4gIFVuZXhwZWN0ZWROZXdUYXJnZXQ6IFwiYG5ldy50YXJnZXRgIGNhbiBvbmx5IGJlIHVzZWQgaW4gZnVuY3Rpb25zIG9yIGNsYXNzIHByb3BlcnRpZXMuXCIsXG4gIFVuZXhwZWN0ZWROdW1lcmljU2VwYXJhdG9yOiBcIkEgbnVtZXJpYyBzZXBhcmF0b3IgaXMgb25seSBhbGxvd2VkIGJldHdlZW4gdHdvIGRpZ2l0cy5cIixcbiAgVW5leHBlY3RlZFByaXZhdGVGaWVsZDogXCJVbmV4cGVjdGVkIHByaXZhdGUgbmFtZS5cIixcbiAgVW5leHBlY3RlZFJlc2VydmVkV29yZDogKHtcbiAgICByZXNlcnZlZFdvcmRcbiAgfSkgPT4gYFVuZXhwZWN0ZWQgcmVzZXJ2ZWQgd29yZCAnJHtyZXNlcnZlZFdvcmR9Jy5gLFxuICBVbmV4cGVjdGVkU3VwZXI6IFwiJ3N1cGVyJyBpcyBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1ldGhvZHMgYW5kIGNsYXNzZXMuXCIsXG4gIFVuZXhwZWN0ZWRUb2tlbjogKHtcbiAgICBleHBlY3RlZCxcbiAgICB1bmV4cGVjdGVkXG4gIH0pID0+IGBVbmV4cGVjdGVkIHRva2VuJHt1bmV4cGVjdGVkID8gYCAnJHt1bmV4cGVjdGVkfScuYCA6IFwiXCJ9JHtleHBlY3RlZCA/IGAsIGV4cGVjdGVkIFwiJHtleHBlY3RlZH1cImAgOiBcIlwifWAsXG4gIFVuZXhwZWN0ZWRUb2tlblVuYXJ5RXhwb25lbnRpYXRpb246IFwiSWxsZWdhbCBleHByZXNzaW9uLiBXcmFwIGxlZnQgaGFuZCBzaWRlIG9yIGVudGlyZSBleHBvbmVudGlhdGlvbiBpbiBwYXJlbnRoZXNlcy5cIixcbiAgVW5leHBlY3RlZFVzaW5nRGVjbGFyYXRpb246IFwiVXNpbmcgZGVjbGFyYXRpb24gY2Fubm90IGFwcGVhciBpbiB0aGUgdG9wIGxldmVsIHdoZW4gc291cmNlIHR5cGUgaXMgYHNjcmlwdGAgb3IgaW4gdGhlIGJhcmUgY2FzZSBzdGF0ZW1lbnQuXCIsXG4gIFVuZXhwZWN0ZWRWb2lkUGF0dGVybjogXCJVbmV4cGVjdGVkIHZvaWQgYmluZGluZy5cIixcbiAgVW5zdXBwb3J0ZWRCaW5kOiBcIkJpbmRpbmcgc2hvdWxkIGJlIHBlcmZvcm1lZCBvbiBvYmplY3QgcHJvcGVydHkuXCIsXG4gIFVuc3VwcG9ydGVkRGVjb3JhdG9yRXhwb3J0OiBcIkEgZGVjb3JhdGVkIGV4cG9ydCBtdXN0IGV4cG9ydCBhIGNsYXNzIGRlY2xhcmF0aW9uLlwiLFxuICBVbnN1cHBvcnRlZERlZmF1bHRFeHBvcnQ6IFwiT25seSBleHByZXNzaW9ucywgZnVuY3Rpb25zIG9yIGNsYXNzZXMgYXJlIGFsbG93ZWQgYXMgdGhlIGBkZWZhdWx0YCBleHBvcnQuXCIsXG4gIFVuc3VwcG9ydGVkSW1wb3J0OiBcImBpbXBvcnRgIGNhbiBvbmx5IGJlIHVzZWQgaW4gYGltcG9ydCgpYCBvciBgaW1wb3J0Lm1ldGFgLlwiLFxuICBVbnN1cHBvcnRlZE1ldGFQcm9wZXJ0eTogKHtcbiAgICB0YXJnZXQsXG4gICAgb25seVZhbGlkUHJvcGVydHlOYW1lXG4gIH0pID0+IGBUaGUgb25seSB2YWxpZCBtZXRhIHByb3BlcnR5IGZvciAke3RhcmdldH0gaXMgJHt0YXJnZXR9LiR7b25seVZhbGlkUHJvcGVydHlOYW1lfS5gLFxuICBVbnN1cHBvcnRlZFBhcmFtZXRlckRlY29yYXRvcjogXCJEZWNvcmF0b3JzIGNhbm5vdCBiZSB1c2VkIHRvIGRlY29yYXRlIHBhcmFtZXRlcnMuXCIsXG4gIFVuc3VwcG9ydGVkUHJvcGVydHlEZWNvcmF0b3I6IFwiRGVjb3JhdG9ycyBjYW5ub3QgYmUgdXNlZCB0byBkZWNvcmF0ZSBvYmplY3QgbGl0ZXJhbCBwcm9wZXJ0aWVzLlwiLFxuICBVbnN1cHBvcnRlZFN1cGVyOiBcIidzdXBlcicgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIGZ1bmN0aW9uIGNhbGxzIChpLmUuIHN1cGVyKCkpIG9yIGluIHByb3BlcnR5IGFjY2Vzc2VzIChpLmUuIHN1cGVyLnByb3Agb3Igc3VwZXJbcHJvcF0pLlwiLFxuICBVbnRlcm1pbmF0ZWRDb21tZW50OiBcIlVudGVybWluYXRlZCBjb21tZW50LlwiLFxuICBVbnRlcm1pbmF0ZWRSZWdFeHA6IFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvbi5cIixcbiAgVW50ZXJtaW5hdGVkU3RyaW5nOiBcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnQuXCIsXG4gIFVudGVybWluYXRlZFRlbXBsYXRlOiBcIlVudGVybWluYXRlZCB0ZW1wbGF0ZS5cIixcbiAgVXNpbmdEZWNsYXJhdGlvbkV4cG9ydDogXCJVc2luZyBkZWNsYXJhdGlvbiBjYW5ub3QgYmUgZXhwb3J0ZWQuXCIsXG4gIFVzaW5nRGVjbGFyYXRpb25IYXNCaW5kaW5nUGF0dGVybjogXCJVc2luZyBkZWNsYXJhdGlvbiBjYW5ub3QgaGF2ZSBkZXN0cnVjdHVyaW5nIHBhdHRlcm5zLlwiLFxuICBWYXJSZWRlY2xhcmF0aW9uOiAoe1xuICAgIGlkZW50aWZpZXJOYW1lXG4gIH0pID0+IGBJZGVudGlmaWVyICcke2lkZW50aWZpZXJOYW1lfScgaGFzIGFscmVhZHkgYmVlbiBkZWNsYXJlZC5gLFxuICBWb2lkUGF0dGVybkNhdGNoQ2xhdXNlUGFyYW06IFwiQSB2b2lkIGJpbmRpbmcgY2FuIG5vdCBiZSB0aGUgY2F0Y2ggY2xhdXNlIHBhcmFtZXRlci4gVXNlIGB0cnkgeyAuLi4gfSBjYXRjaCB7IC4uLiB9YCBpZiB5b3Ugd2FudCB0byBkaXNjYXJkIHRoZSBjYXVnaHQgZXJyb3IuXCIsXG4gIFZvaWRQYXR0ZXJuSW5pdGlhbGl6ZXI6IFwiQSB2b2lkIGJpbmRpbmcgbWF5IG5vdCBoYXZlIGFuIGluaXRpYWxpemVyLlwiLFxuICBZaWVsZEJpbmRpbmdJZGVudGlmaWVyOiBcIkNhbiBub3QgdXNlICd5aWVsZCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYSBnZW5lcmF0b3IuXCIsXG4gIFlpZWxkSW5QYXJhbWV0ZXI6IFwiWWllbGQgZXhwcmVzc2lvbiBpcyBub3QgYWxsb3dlZCBpbiBmb3JtYWwgcGFyYW1ldGVycy5cIixcbiAgWWllbGROb3RJbkdlbmVyYXRvckZ1bmN0aW9uOiBcIid5aWVsZCcgaXMgb25seSBhbGxvd2VkIHdpdGhpbiBnZW5lcmF0b3IgZnVuY3Rpb25zLlwiLFxuICBaZXJvRGlnaXROdW1lcmljU2VwYXJhdG9yOiBcIk51bWVyaWMgc2VwYXJhdG9yIGNhbiBub3QgYmUgdXNlZCBhZnRlciBsZWFkaW5nIDAuXCJcbn07XG52YXIgU3RyaWN0TW9kZUVycm9ycyA9IHtcbiAgU3RyaWN0RGVsZXRlOiBcIkRlbGV0aW5nIGxvY2FsIHZhcmlhYmxlIGluIHN0cmljdCBtb2RlLlwiLFxuICBTdHJpY3RFdmFsQXJndW1lbnRzOiAoe1xuICAgIHJlZmVyZW5jZU5hbWVcbiAgfSkgPT4gYEFzc2lnbmluZyB0byAnJHtyZWZlcmVuY2VOYW1lfScgaW4gc3RyaWN0IG1vZGUuYCxcbiAgU3RyaWN0RXZhbEFyZ3VtZW50c0JpbmRpbmc6ICh7XG4gICAgYmluZGluZ05hbWVcbiAgfSkgPT4gYEJpbmRpbmcgJyR7YmluZGluZ05hbWV9JyBpbiBzdHJpY3QgbW9kZS5gLFxuICBTdHJpY3RGdW5jdGlvbjogXCJJbiBzdHJpY3QgbW9kZSBjb2RlLCBmdW5jdGlvbnMgY2FuIG9ubHkgYmUgZGVjbGFyZWQgYXQgdG9wIGxldmVsIG9yIGluc2lkZSBhIGJsb2NrLlwiLFxuICBTdHJpY3ROdW1lcmljRXNjYXBlOiBcIlRoZSBvbmx5IHZhbGlkIG51bWVyaWMgZXNjYXBlIGluIHN0cmljdCBtb2RlIGlzICdcXFxcMCcuXCIsXG4gIFN0cmljdE9jdGFsTGl0ZXJhbDogXCJMZWdhY3kgb2N0YWwgbGl0ZXJhbHMgYXJlIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlLlwiLFxuICBTdHJpY3RXaXRoOiBcIid3aXRoJyBpbiBzdHJpY3QgbW9kZS5cIlxufTtcbnZhciBQYXJzZUV4cHJlc3Npb25FcnJvcnMgPSB7XG4gIFBhcnNlRXhwcmVzc2lvbkVtcHR5SW5wdXQ6IFwiVW5leHBlY3RlZCBwYXJzZUV4cHJlc3Npb24oKSBpbnB1dDogVGhlIGlucHV0IGlzIGVtcHR5IG9yIGNvbnRhaW5zIG9ubHkgY29tbWVudHMuXCIsXG4gIFBhcnNlRXhwcmVzc2lvbkV4cGVjdHNFT0Y6ICh7XG4gICAgdW5leHBlY3RlZFxuICB9KSA9PiBgVW5leHBlY3RlZCBwYXJzZUV4cHJlc3Npb24oKSBpbnB1dDogVGhlIGlucHV0IHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIGV4cHJlc3Npb24sIGJ1dCB0aGUgZmlyc3QgZXhwcmVzc2lvbiBpcyBmb2xsb3dlZCBieSB0aGUgdW5leHBlY3RlZCBjaGFyYWN0ZXIgXFxgJHtTdHJpbmcuZnJvbUNvZGVQb2ludCh1bmV4cGVjdGVkKX1cXGAuYFxufTtcbmNvbnN0IFVucGFyZW50aGVzaXplZFBpcGVCb2R5RGVzY3JpcHRpb25zID0gbmV3IFNldChbXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiLCBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIsIFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIsIFwiWWllbGRFeHByZXNzaW9uXCJdKTtcbnZhciBQaXBlbGluZU9wZXJhdG9yRXJyb3JzID0gT2JqZWN0LmFzc2lnbih7XG4gIFBpcGVCb2R5SXNUaWdodGVyOiBcIlVuZXhwZWN0ZWQgeWllbGQgYWZ0ZXIgcGlwZWxpbmUgYm9keTsgYW55IHlpZWxkIGV4cHJlc3Npb24gYWN0aW5nIGFzIEhhY2stc3R5bGUgcGlwZSBib2R5IG11c3QgYmUgcGFyZW50aGVzaXplZCBkdWUgdG8gaXRzIGxvb3NlIG9wZXJhdG9yIHByZWNlZGVuY2UuXCIsXG4gIFBpcGVUb3BpY1JlcXVpcmVzSGFja1BpcGVzOiAnVG9waWMgcmVmZXJlbmNlIGlzIHVzZWQsIGJ1dCB0aGUgcGlwZWxpbmVPcGVyYXRvciBwbHVnaW4gd2FzIG5vdCBwYXNzZWQgYSBcInByb3Bvc2FsXCI6IFwiaGFja1wiIG9yIFwic21hcnRcIiBvcHRpb24uJyxcbiAgUGlwZVRvcGljVW5ib3VuZDogXCJUb3BpYyByZWZlcmVuY2UgaXMgdW5ib3VuZDsgaXQgbXVzdCBiZSBpbnNpZGUgYSBwaXBlIGJvZHkuXCIsXG4gIFBpcGVUb3BpY1VuY29uZmlndXJlZFRva2VuOiAoe1xuICAgIHRva2VuXG4gIH0pID0+IGBJbnZhbGlkIHRvcGljIHRva2VuICR7dG9rZW59LiBJbiBvcmRlciB0byB1c2UgJHt0b2tlbn0gYXMgYSB0b3BpYyByZWZlcmVuY2UsIHRoZSBwaXBlbGluZU9wZXJhdG9yIHBsdWdpbiBtdXN0IGJlIGNvbmZpZ3VyZWQgd2l0aCB7IFwicHJvcG9zYWxcIjogXCJoYWNrXCIsIFwidG9waWNUb2tlblwiOiBcIiR7dG9rZW59XCIgfS5gLFxuICBQaXBlVG9waWNVbnVzZWQ6IFwiSGFjay1zdHlsZSBwaXBlIGJvZHkgZG9lcyBub3QgY29udGFpbiBhIHRvcGljIHJlZmVyZW5jZTsgSGFjay1zdHlsZSBwaXBlcyBtdXN0IHVzZSB0b3BpYyBhdCBsZWFzdCBvbmNlLlwiLFxuICBQaXBlVW5wYXJlbnRoZXNpemVkQm9keTogKHtcbiAgICB0eXBlXG4gIH0pID0+IGBIYWNrLXN0eWxlIHBpcGUgYm9keSBjYW5ub3QgYmUgYW4gdW5wYXJlbnRoZXNpemVkICR7dG9Ob2RlRGVzY3JpcHRpb24oe1xuICAgIHR5cGVcbiAgfSl9OyBwbGVhc2Ugd3JhcCBpdCBpbiBwYXJlbnRoZXNlcy5gXG59LCB7XG4gIFBpcGVsaW5lQm9keU5vQXJyb3c6ICdVbmV4cGVjdGVkIGFycm93IFwiPT5cIiBhZnRlciBwaXBlbGluZSBib2R5OyBhcnJvdyBmdW5jdGlvbiBpbiBwaXBlbGluZSBib2R5IG11c3QgYmUgcGFyZW50aGVzaXplZC4nLFxuICBQaXBlbGluZUJvZHlTZXF1ZW5jZUV4cHJlc3Npb246IFwiUGlwZWxpbmUgYm9keSBtYXkgbm90IGJlIGEgY29tbWEtc2VwYXJhdGVkIHNlcXVlbmNlIGV4cHJlc3Npb24uXCIsXG4gIFBpcGVsaW5lSGVhZFNlcXVlbmNlRXhwcmVzc2lvbjogXCJQaXBlbGluZSBoZWFkIHNob3VsZCBub3QgYmUgYSBjb21tYS1zZXBhcmF0ZWQgc2VxdWVuY2UgZXhwcmVzc2lvbi5cIixcbiAgUGlwZWxpbmVUb3BpY1VudXNlZDogXCJQaXBlbGluZSBpcyBpbiB0b3BpYyBzdHlsZSBidXQgZG9lcyBub3QgdXNlIHRvcGljIHJlZmVyZW5jZS5cIixcbiAgUHJpbWFyeVRvcGljTm90QWxsb3dlZDogXCJUb3BpYyByZWZlcmVuY2Ugd2FzIHVzZWQgaW4gYSBsZXhpY2FsIGNvbnRleHQgd2l0aG91dCB0b3BpYyBiaW5kaW5nLlwiLFxuICBQcmltYXJ5VG9waWNSZXF1aXJlc1NtYXJ0UGlwZWxpbmU6ICdUb3BpYyByZWZlcmVuY2UgaXMgdXNlZCwgYnV0IHRoZSBwaXBlbGluZU9wZXJhdG9yIHBsdWdpbiB3YXMgbm90IHBhc3NlZCBhIFwicHJvcG9zYWxcIjogXCJoYWNrXCIgb3IgXCJzbWFydFwiIG9wdGlvbi4nXG59KTtcbmNvbnN0IF9leGNsdWRlZCA9IFtcIm1lc3NhZ2VcIl07XG5mdW5jdGlvbiBkZWZpbmVIaWRkZW4ob2JqLCBrZXksIHZhbHVlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIHRvUGFyc2VFcnJvckNvbnN0cnVjdG9yKHtcbiAgdG9NZXNzYWdlLFxuICBjb2RlLFxuICByZWFzb25Db2RlLFxuICBzeW50YXhQbHVnaW5cbn0pIHtcbiAgY29uc3QgaGFzTWlzc2luZ1BsdWdpbiA9IHJlYXNvbkNvZGUgPT09IFwiTWlzc2luZ1BsdWdpblwiIHx8IHJlYXNvbkNvZGUgPT09IFwiTWlzc2luZ09uZU9mUGx1Z2luc1wiO1xuICB7XG4gICAgY29uc3Qgb2xkUmVhc29uQ29kZXMgPSB7XG4gICAgICBBY2Nlc3NvckNhbm5vdERlY2xhcmVUaGlzUGFyYW1ldGVyOiBcIkFjY2Vzb3JDYW5ub3REZWNsYXJlVGhpc1BhcmFtZXRlclwiLFxuICAgICAgQWNjZXNzb3JDYW5ub3RIYXZlVHlwZVBhcmFtZXRlcnM6IFwiQWNjZXNvckNhbm5vdEhhdmVUeXBlUGFyYW1ldGVyc1wiLFxuICAgICAgQ29uc3RJbml0aWFsaXplck11c3RCZVN0cmluZ09yTnVtZXJpY0xpdGVyYWxPckxpdGVyYWxFbnVtUmVmZXJlbmNlOiBcIkNvbnN0SW5pdGlhaWxpemVyTXVzdEJlU3RyaW5nT3JOdW1lcmljTGl0ZXJhbE9yTGl0ZXJhbEVudW1SZWZlcmVuY2VcIixcbiAgICAgIFNldEFjY2Vzc29yQ2Fubm90SGF2ZU9wdGlvbmFsUGFyYW1ldGVyOiBcIlNldEFjY2Vzb3JDYW5ub3RIYXZlT3B0aW9uYWxQYXJhbWV0ZXJcIixcbiAgICAgIFNldEFjY2Vzc29yQ2Fubm90SGF2ZVJlc3RQYXJhbWV0ZXI6IFwiU2V0QWNjZXNvckNhbm5vdEhhdmVSZXN0UGFyYW1ldGVyXCIsXG4gICAgICBTZXRBY2Nlc3NvckNhbm5vdEhhdmVSZXR1cm5UeXBlOiBcIlNldEFjY2Vzb3JDYW5ub3RIYXZlUmV0dXJuVHlwZVwiXG4gICAgfTtcbiAgICBpZiAob2xkUmVhc29uQ29kZXNbcmVhc29uQ29kZV0pIHtcbiAgICAgIHJlYXNvbkNvZGUgPSBvbGRSZWFzb25Db2Rlc1tyZWFzb25Db2RlXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdG9yKGxvYywgZGV0YWlscykge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IFN5bnRheEVycm9yKCk7XG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gICAgZXJyb3IucmVhc29uQ29kZSA9IHJlYXNvbkNvZGU7XG4gICAgZXJyb3IubG9jID0gbG9jO1xuICAgIGVycm9yLnBvcyA9IGxvYy5pbmRleDtcbiAgICBlcnJvci5zeW50YXhQbHVnaW4gPSBzeW50YXhQbHVnaW47XG4gICAgaWYgKGhhc01pc3NpbmdQbHVnaW4pIHtcbiAgICAgIGVycm9yLm1pc3NpbmdQbHVnaW4gPSBkZXRhaWxzLm1pc3NpbmdQbHVnaW47XG4gICAgfVxuICAgIGRlZmluZUhpZGRlbihlcnJvciwgXCJjbG9uZVwiLCBmdW5jdGlvbiBjbG9uZShvdmVycmlkZXMgPSB7fSkge1xuICAgICAgdmFyIF9vdmVycmlkZXMkbG9jO1xuICAgICAgY29uc3Qge1xuICAgICAgICBsaW5lLFxuICAgICAgICBjb2x1bW4sXG4gICAgICAgIGluZGV4XG4gICAgICB9ID0gKF9vdmVycmlkZXMkbG9jID0gb3ZlcnJpZGVzLmxvYykgIT0gbnVsbCA/IF9vdmVycmlkZXMkbG9jIDogbG9jO1xuICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yKG5ldyBQb3NpdGlvbihsaW5lLCBjb2x1bW4sIGluZGV4KSwgT2JqZWN0LmFzc2lnbih7fSwgZGV0YWlscywgb3ZlcnJpZGVzLmRldGFpbHMpKTtcbiAgICB9KTtcbiAgICBkZWZpbmVIaWRkZW4oZXJyb3IsIFwiZGV0YWlsc1wiLCBkZXRhaWxzKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyb3IsIFwibWVzc2FnZVwiLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgJHt0b01lc3NhZ2UoZGV0YWlscyl9ICgke2xvYy5saW5lfToke2xvYy5jb2x1bW59KWA7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgfSxcbiAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXNzYWdlXCIsIHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH07XG59XG5mdW5jdGlvbiBQYXJzZUVycm9yRW51bShhcmd1bWVudCwgc3ludGF4UGx1Z2luKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFyZ3VtZW50KSkge1xuICAgIHJldHVybiBwYXJzZUVycm9yVGVtcGxhdGVzID0+IFBhcnNlRXJyb3JFbnVtKHBhcnNlRXJyb3JUZW1wbGF0ZXMsIGFyZ3VtZW50WzBdKTtcbiAgfVxuICBjb25zdCBQYXJzZUVycm9yQ29uc3RydWN0b3JzID0ge307XG4gIGZvciAoY29uc3QgcmVhc29uQ29kZSBvZiBPYmplY3Qua2V5cyhhcmd1bWVudCkpIHtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IGFyZ3VtZW50W3JlYXNvbkNvZGVdO1xuICAgIGNvbnN0IF9yZWYgPSB0eXBlb2YgdGVtcGxhdGUgPT09IFwic3RyaW5nXCIgPyB7XG4gICAgICAgIG1lc3NhZ2U6ICgpID0+IHRlbXBsYXRlXG4gICAgICB9IDogdHlwZW9mIHRlbXBsYXRlID09PSBcImZ1bmN0aW9uXCIgPyB7XG4gICAgICAgIG1lc3NhZ2U6IHRlbXBsYXRlXG4gICAgICB9IDogdGVtcGxhdGUsXG4gICAgICB7XG4gICAgICAgIG1lc3NhZ2VcbiAgICAgIH0gPSBfcmVmLFxuICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIF9leGNsdWRlZCk7XG4gICAgY29uc3QgdG9NZXNzYWdlID0gdHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyAoKSA9PiBtZXNzYWdlIDogbWVzc2FnZTtcbiAgICBQYXJzZUVycm9yQ29uc3RydWN0b3JzW3JlYXNvbkNvZGVdID0gdG9QYXJzZUVycm9yQ29uc3RydWN0b3IoT2JqZWN0LmFzc2lnbih7XG4gICAgICBjb2RlOiBcIkJBQkVMX1BBUlNFUl9TWU5UQVhfRVJST1JcIixcbiAgICAgIHJlYXNvbkNvZGUsXG4gICAgICB0b01lc3NhZ2VcbiAgICB9LCBzeW50YXhQbHVnaW4gPyB7XG4gICAgICBzeW50YXhQbHVnaW5cbiAgICB9IDoge30sIHJlc3QpKTtcbiAgfVxuICByZXR1cm4gUGFyc2VFcnJvckNvbnN0cnVjdG9ycztcbn1cbmNvbnN0IEVycm9ycyA9IE9iamVjdC5hc3NpZ24oe30sIFBhcnNlRXJyb3JFbnVtKE1vZHVsZUVycm9ycyksIFBhcnNlRXJyb3JFbnVtKFN0YW5kYXJkRXJyb3JzKSwgUGFyc2VFcnJvckVudW0oU3RyaWN0TW9kZUVycm9ycyksIFBhcnNlRXJyb3JFbnVtKFBhcnNlRXhwcmVzc2lvbkVycm9ycyksIFBhcnNlRXJyb3JFbnVtYHBpcGVsaW5lT3BlcmF0b3JgKFBpcGVsaW5lT3BlcmF0b3JFcnJvcnMpKTtcbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRPcHRpb25zKCkge1xuICByZXR1cm4ge1xuICAgIHNvdXJjZVR5cGU6IFwic2NyaXB0XCIsXG4gICAgc291cmNlRmlsZW5hbWU6IHVuZGVmaW5lZCxcbiAgICBzdGFydEluZGV4OiAwLFxuICAgIHN0YXJ0Q29sdW1uOiAwLFxuICAgIHN0YXJ0TGluZTogMSxcbiAgICBhbGxvd0F3YWl0T3V0c2lkZUZ1bmN0aW9uOiBmYWxzZSxcbiAgICBhbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbjogZmFsc2UsXG4gICAgYWxsb3dOZXdUYXJnZXRPdXRzaWRlRnVuY3Rpb246IGZhbHNlLFxuICAgIGFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZTogZmFsc2UsXG4gICAgYWxsb3dTdXBlck91dHNpZGVNZXRob2Q6IGZhbHNlLFxuICAgIGFsbG93VW5kZWNsYXJlZEV4cG9ydHM6IGZhbHNlLFxuICAgIGFsbG93WWllbGRPdXRzaWRlRnVuY3Rpb246IGZhbHNlLFxuICAgIHBsdWdpbnM6IFtdLFxuICAgIHN0cmljdE1vZGU6IG51bGwsXG4gICAgcmFuZ2VzOiBmYWxzZSxcbiAgICB0b2tlbnM6IGZhbHNlLFxuICAgIGNyZWF0ZUltcG9ydEV4cHJlc3Npb25zOiBmYWxzZSxcbiAgICBjcmVhdGVQYXJlbnRoZXNpemVkRXhwcmVzc2lvbnM6IGZhbHNlLFxuICAgIGVycm9yUmVjb3Zlcnk6IGZhbHNlLFxuICAgIGF0dGFjaENvbW1lbnQ6IHRydWUsXG4gICAgYW5uZXhCOiB0cnVlXG4gIH07XG59XG5mdW5jdGlvbiBnZXRPcHRpb25zKG9wdHMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGNyZWF0ZURlZmF1bHRPcHRpb25zKCk7XG4gIGlmIChvcHRzID09IG51bGwpIHtcbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxuICBpZiAob3B0cy5hbm5leEIgIT0gbnVsbCAmJiBvcHRzLmFubmV4QiAhPT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYGFubmV4QmAgb3B0aW9uIGNhbiBvbmx5IGJlIHNldCB0byBgZmFsc2VgLlwiKTtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvcHRpb25zKSkge1xuICAgIGlmIChvcHRzW2tleV0gIT0gbnVsbCkgb3B0aW9uc1trZXldID0gb3B0c1trZXldO1xuICB9XG4gIGlmIChvcHRpb25zLnN0YXJ0TGluZSA9PT0gMSkge1xuICAgIGlmIChvcHRzLnN0YXJ0SW5kZXggPT0gbnVsbCAmJiBvcHRpb25zLnN0YXJ0Q29sdW1uID4gMCkge1xuICAgICAgb3B0aW9ucy5zdGFydEluZGV4ID0gb3B0aW9ucy5zdGFydENvbHVtbjtcbiAgICB9IGVsc2UgaWYgKG9wdHMuc3RhcnRDb2x1bW4gPT0gbnVsbCAmJiBvcHRpb25zLnN0YXJ0SW5kZXggPiAwKSB7XG4gICAgICBvcHRpb25zLnN0YXJ0Q29sdW1uID0gb3B0aW9ucy5zdGFydEluZGV4O1xuICAgIH1cbiAgfSBlbHNlIGlmIChvcHRzLnN0YXJ0Q29sdW1uID09IG51bGwgfHwgb3B0cy5zdGFydEluZGV4ID09IG51bGwpIHtcbiAgICBpZiAob3B0cy5zdGFydEluZGV4ICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIldpdGggYSBgc3RhcnRMaW5lID4gMWAgeW91IG11c3QgYWxzbyBzcGVjaWZ5IGBzdGFydEluZGV4YCBhbmQgYHN0YXJ0Q29sdW1uYC5cIik7XG4gICAgfVxuICB9XG4gIGlmIChvcHRpb25zLnNvdXJjZVR5cGUgPT09IFwiY29tbW9uanNcIikge1xuICAgIGlmIChvcHRzLmFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb24gIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGBhbGxvd0F3YWl0T3V0c2lkZUZ1bmN0aW9uYCBvcHRpb24gY2Fubm90IGJlIHVzZWQgd2l0aCBgc291cmNlVHlwZTogJ2NvbW1vbmpzJ2AuXCIpO1xuICAgIH1cbiAgICBpZiAob3B0cy5hbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbiAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgc291cmNlVHlwZTogJ2NvbW1vbmpzJ2AgaW1wbGllcyBgYWxsb3dSZXR1cm5PdXRzaWRlRnVuY3Rpb246IHRydWVgLCBwbGVhc2UgcmVtb3ZlIHRoZSBgYWxsb3dSZXR1cm5PdXRzaWRlRnVuY3Rpb25gIG9wdGlvbiBvciB1c2UgYHNvdXJjZVR5cGU6ICdzY3JpcHQnYC5cIik7XG4gICAgfVxuICAgIGlmIChvcHRzLmFsbG93TmV3VGFyZ2V0T3V0c2lkZUZ1bmN0aW9uICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImBzb3VyY2VUeXBlOiAnY29tbW9uanMnYCBpbXBsaWVzIGBhbGxvd05ld1RhcmdldE91dHNpZGVGdW5jdGlvbjogdHJ1ZWAsIHBsZWFzZSByZW1vdmUgdGhlIGBhbGxvd05ld1RhcmdldE91dHNpZGVGdW5jdGlvbmAgb3B0aW9uIG9yIHVzZSBgc291cmNlVHlwZTogJ3NjcmlwdCdgLlwiKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5jb25zdCB7XG4gIGRlZmluZVByb3BlcnR5XG59ID0gT2JqZWN0O1xuY29uc3QgdG9VbmVudW1lcmFibGUgPSAob2JqZWN0LCBrZXkpID0+IHtcbiAgaWYgKG9iamVjdCkge1xuICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBvYmplY3Rba2V5XVxuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gdG9FU1RyZWVMb2NhdGlvbihub2RlKSB7XG4gIHRvVW5lbnVtZXJhYmxlKG5vZGUubG9jLnN0YXJ0LCBcImluZGV4XCIpO1xuICB0b1VuZW51bWVyYWJsZShub2RlLmxvYy5lbmQsIFwiaW5kZXhcIik7XG4gIHJldHVybiBub2RlO1xufVxudmFyIGVzdHJlZSA9IHN1cGVyQ2xhc3MgPT4gY2xhc3MgRVNUcmVlUGFyc2VyTWl4aW4gZXh0ZW5kcyBzdXBlckNsYXNzIHtcbiAgcGFyc2UoKSB7XG4gICAgY29uc3QgZmlsZSA9IHRvRVNUcmVlTG9jYXRpb24oc3VwZXIucGFyc2UoKSk7XG4gICAgaWYgKHRoaXMub3B0aW9uRmxhZ3MgJiAyNTYpIHtcbiAgICAgIGZpbGUudG9rZW5zID0gZmlsZS50b2tlbnMubWFwKHRvRVNUcmVlTG9jYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gZmlsZTtcbiAgfVxuICBwYXJzZVJlZ0V4cExpdGVyYWwoe1xuICAgIHBhdHRlcm4sXG4gICAgZmxhZ3NcbiAgfSkge1xuICAgIGxldCByZWdleCA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XG4gICAgfSBjYXRjaCAoXykge31cbiAgICBjb25zdCBub2RlID0gdGhpcy5lc3RyZWVQYXJzZUxpdGVyYWwocmVnZXgpO1xuICAgIG5vZGUucmVnZXggPSB7XG4gICAgICBwYXR0ZXJuLFxuICAgICAgZmxhZ3NcbiAgICB9O1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHBhcnNlQmlnSW50TGl0ZXJhbCh2YWx1ZSkge1xuICAgIGxldCBiaWdJbnQ7XG4gICAgdHJ5IHtcbiAgICAgIGJpZ0ludCA9IEJpZ0ludCh2YWx1ZSk7XG4gICAgfSBjYXRjaCAoX3VudXNlZCkge1xuICAgICAgYmlnSW50ID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuZXN0cmVlUGFyc2VMaXRlcmFsKGJpZ0ludCk7XG4gICAgbm9kZS5iaWdpbnQgPSBTdHJpbmcobm9kZS52YWx1ZSB8fCB2YWx1ZSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcGFyc2VEZWNpbWFsTGl0ZXJhbCh2YWx1ZSkge1xuICAgIGNvbnN0IGRlY2ltYWwgPSBudWxsO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLmVzdHJlZVBhcnNlTGl0ZXJhbChkZWNpbWFsKTtcbiAgICBub2RlLmRlY2ltYWwgPSBTdHJpbmcobm9kZS52YWx1ZSB8fCB2YWx1ZSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgZXN0cmVlUGFyc2VMaXRlcmFsKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsKHZhbHVlLCBcIkxpdGVyYWxcIik7XG4gIH1cbiAgcGFyc2VTdHJpbmdMaXRlcmFsKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZXN0cmVlUGFyc2VMaXRlcmFsKHZhbHVlKTtcbiAgfVxuICBwYXJzZU51bWVyaWNMaXRlcmFsKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZXN0cmVlUGFyc2VMaXRlcmFsKHZhbHVlKTtcbiAgfVxuICBwYXJzZU51bGxMaXRlcmFsKCkge1xuICAgIHJldHVybiB0aGlzLmVzdHJlZVBhcnNlTGl0ZXJhbChudWxsKTtcbiAgfVxuICBwYXJzZUJvb2xlYW5MaXRlcmFsKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZXN0cmVlUGFyc2VMaXRlcmFsKHZhbHVlKTtcbiAgfVxuICBlc3RyZWVQYXJzZUNoYWluRXhwcmVzc2lvbihub2RlLCBlbmRMb2MpIHtcbiAgICBjb25zdCBjaGFpbiA9IHRoaXMuc3RhcnROb2RlQXROb2RlKG5vZGUpO1xuICAgIGNoYWluLmV4cHJlc3Npb24gPSBub2RlO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGVBdChjaGFpbiwgXCJDaGFpbkV4cHJlc3Npb25cIiwgZW5kTG9jKTtcbiAgfVxuICBkaXJlY3RpdmVUb1N0bXQoZGlyZWN0aXZlKSB7XG4gICAgY29uc3QgZXhwcmVzc2lvbiA9IGRpcmVjdGl2ZS52YWx1ZTtcbiAgICBkZWxldGUgZGlyZWN0aXZlLnZhbHVlO1xuICAgIHRoaXMuY2FzdE5vZGVUbyhleHByZXNzaW9uLCBcIkxpdGVyYWxcIik7XG4gICAgZXhwcmVzc2lvbi5yYXcgPSBleHByZXNzaW9uLmV4dHJhLnJhdztcbiAgICBleHByZXNzaW9uLnZhbHVlID0gZXhwcmVzc2lvbi5leHRyYS5leHByZXNzaW9uVmFsdWU7XG4gICAgY29uc3Qgc3RtdCA9IHRoaXMuY2FzdE5vZGVUbyhkaXJlY3RpdmUsIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiKTtcbiAgICBzdG10LmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgIHN0bXQuZGlyZWN0aXZlID0gZXhwcmVzc2lvbi5leHRyYS5yYXdWYWx1ZTtcbiAgICBkZWxldGUgZXhwcmVzc2lvbi5leHRyYTtcbiAgICByZXR1cm4gc3RtdDtcbiAgfVxuICBmaWxsT3B0aW9uYWxQcm9wZXJ0aWVzRm9yVFNFU0xpbnQobm9kZSkge31cbiAgY2xvbmVFc3RyZWVTdHJpbmdMaXRlcmFsKG5vZGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFydCxcbiAgICAgIGVuZCxcbiAgICAgIGxvYyxcbiAgICAgIHJhbmdlLFxuICAgICAgcmF3LFxuICAgICAgdmFsdWVcbiAgICB9ID0gbm9kZTtcbiAgICBjb25zdCBjbG9uZWQgPSBPYmplY3QuY3JlYXRlKG5vZGUuY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICBjbG9uZWQudHlwZSA9IFwiTGl0ZXJhbFwiO1xuICAgIGNsb25lZC5zdGFydCA9IHN0YXJ0O1xuICAgIGNsb25lZC5lbmQgPSBlbmQ7XG4gICAgY2xvbmVkLmxvYyA9IGxvYztcbiAgICBjbG9uZWQucmFuZ2UgPSByYW5nZTtcbiAgICBjbG9uZWQucmF3ID0gcmF3O1xuICAgIGNsb25lZC52YWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybiBjbG9uZWQ7XG4gIH1cbiAgaW5pdEZ1bmN0aW9uKG5vZGUsIGlzQXN5bmMpIHtcbiAgICBzdXBlci5pbml0RnVuY3Rpb24obm9kZSwgaXNBc3luYyk7XG4gICAgbm9kZS5leHByZXNzaW9uID0gZmFsc2U7XG4gIH1cbiAgY2hlY2tEZWNsYXJhdGlvbihub2RlKSB7XG4gICAgaWYgKG5vZGUgIT0gbnVsbCAmJiB0aGlzLmlzT2JqZWN0UHJvcGVydHkobm9kZSkpIHtcbiAgICAgIHRoaXMuY2hlY2tEZWNsYXJhdGlvbihub2RlLnZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIuY2hlY2tEZWNsYXJhdGlvbihub2RlKTtcbiAgICB9XG4gIH1cbiAgZ2V0T2JqZWN0T3JDbGFzc01ldGhvZFBhcmFtcyhtZXRob2QpIHtcbiAgICByZXR1cm4gbWV0aG9kLnZhbHVlLnBhcmFtcztcbiAgfVxuICBpc1ZhbGlkRGlyZWN0aXZlKHN0bXQpIHtcbiAgICB2YXIgX3N0bXQkZXhwcmVzc2lvbiRleHRyO1xuICAgIHJldHVybiBzdG10LnR5cGUgPT09IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiICYmIHN0bXQuZXhwcmVzc2lvbi50eXBlID09PSBcIkxpdGVyYWxcIiAmJiB0eXBlb2Ygc3RtdC5leHByZXNzaW9uLnZhbHVlID09PSBcInN0cmluZ1wiICYmICEoKF9zdG10JGV4cHJlc3Npb24kZXh0ciA9IHN0bXQuZXhwcmVzc2lvbi5leHRyYSkgIT0gbnVsbCAmJiBfc3RtdCRleHByZXNzaW9uJGV4dHIucGFyZW50aGVzaXplZCk7XG4gIH1cbiAgcGFyc2VCbG9ja0JvZHkobm9kZSwgYWxsb3dEaXJlY3RpdmVzLCB0b3BMZXZlbCwgZW5kLCBhZnRlckJsb2NrUGFyc2UpIHtcbiAgICBzdXBlci5wYXJzZUJsb2NrQm9keShub2RlLCBhbGxvd0RpcmVjdGl2ZXMsIHRvcExldmVsLCBlbmQsIGFmdGVyQmxvY2tQYXJzZSk7XG4gICAgY29uc3QgZGlyZWN0aXZlU3RhdGVtZW50cyA9IG5vZGUuZGlyZWN0aXZlcy5tYXAoZCA9PiB0aGlzLmRpcmVjdGl2ZVRvU3RtdChkKSk7XG4gICAgbm9kZS5ib2R5ID0gZGlyZWN0aXZlU3RhdGVtZW50cy5jb25jYXQobm9kZS5ib2R5KTtcbiAgICBkZWxldGUgbm9kZS5kaXJlY3RpdmVzO1xuICB9XG4gIHBhcnNlUHJpdmF0ZU5hbWUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHN1cGVyLnBhcnNlUHJpdmF0ZU5hbWUoKTtcbiAgICB7XG4gICAgICBpZiAoIXRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwiZXN0cmVlXCIsIFwiY2xhc3NGZWF0dXJlc1wiKSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udmVydFByaXZhdGVOYW1lVG9Qcml2YXRlSWRlbnRpZmllcihub2RlKTtcbiAgfVxuICBjb252ZXJ0UHJpdmF0ZU5hbWVUb1ByaXZhdGVJZGVudGlmaWVyKG5vZGUpIHtcbiAgICBjb25zdCBuYW1lID0gc3VwZXIuZ2V0UHJpdmF0ZU5hbWVTVihub2RlKTtcbiAgICBub2RlID0gbm9kZTtcbiAgICBkZWxldGUgbm9kZS5pZDtcbiAgICBub2RlLm5hbWUgPSBuYW1lO1xuICAgIHJldHVybiB0aGlzLmNhc3ROb2RlVG8obm9kZSwgXCJQcml2YXRlSWRlbnRpZmllclwiKTtcbiAgfVxuICBpc1ByaXZhdGVOYW1lKG5vZGUpIHtcbiAgICB7XG4gICAgICBpZiAoIXRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwiZXN0cmVlXCIsIFwiY2xhc3NGZWF0dXJlc1wiKSkge1xuICAgICAgICByZXR1cm4gc3VwZXIuaXNQcml2YXRlTmFtZShub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJQcml2YXRlSWRlbnRpZmllclwiO1xuICB9XG4gIGdldFByaXZhdGVOYW1lU1Yobm9kZSkge1xuICAgIHtcbiAgICAgIGlmICghdGhpcy5nZXRQbHVnaW5PcHRpb24oXCJlc3RyZWVcIiwgXCJjbGFzc0ZlYXR1cmVzXCIpKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5nZXRQcml2YXRlTmFtZVNWKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZS5uYW1lO1xuICB9XG4gIHBhcnNlTGl0ZXJhbCh2YWx1ZSwgdHlwZSkge1xuICAgIGNvbnN0IG5vZGUgPSBzdXBlci5wYXJzZUxpdGVyYWwodmFsdWUsIHR5cGUpO1xuICAgIG5vZGUucmF3ID0gbm9kZS5leHRyYS5yYXc7XG4gICAgZGVsZXRlIG5vZGUuZXh0cmE7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgYWxsb3dFeHByZXNzaW9uLCBpc01ldGhvZCA9IGZhbHNlKSB7XG4gICAgc3VwZXIucGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgYWxsb3dFeHByZXNzaW9uLCBpc01ldGhvZCk7XG4gICAgbm9kZS5leHByZXNzaW9uID0gbm9kZS5ib2R5LnR5cGUgIT09IFwiQmxvY2tTdGF0ZW1lbnRcIjtcbiAgfVxuICBwYXJzZU1ldGhvZChub2RlLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNDb25zdHJ1Y3RvciwgYWxsb3dEaXJlY3RTdXBlciwgdHlwZSwgaW5DbGFzc1Njb3BlID0gZmFsc2UpIHtcbiAgICBsZXQgZnVuY05vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGZ1bmNOb2RlLmtpbmQgPSBub2RlLmtpbmQ7XG4gICAgZnVuY05vZGUgPSBzdXBlci5wYXJzZU1ldGhvZChmdW5jTm9kZSwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzQ29uc3RydWN0b3IsIGFsbG93RGlyZWN0U3VwZXIsIHR5cGUsIGluQ2xhc3NTY29wZSk7XG4gICAgZGVsZXRlIGZ1bmNOb2RlLmtpbmQ7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVBhcmFtZXRlcnNcbiAgICB9ID0gbm9kZTtcbiAgICBpZiAodHlwZVBhcmFtZXRlcnMpIHtcbiAgICAgIGRlbGV0ZSBub2RlLnR5cGVQYXJhbWV0ZXJzO1xuICAgICAgZnVuY05vZGUudHlwZVBhcmFtZXRlcnMgPSB0eXBlUGFyYW1ldGVycztcbiAgICAgIHRoaXMucmVzZXRTdGFydExvY2F0aW9uRnJvbU5vZGUoZnVuY05vZGUsIHR5cGVQYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWVOb2RlID0gdGhpcy5jYXN0Tm9kZVRvKGZ1bmNOb2RlLCBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKTtcbiAgICBub2RlLnZhbHVlID0gdmFsdWVOb2RlO1xuICAgIGlmICh0eXBlID09PSBcIkNsYXNzUHJpdmF0ZU1ldGhvZFwiKSB7XG4gICAgICBub2RlLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcIk9iamVjdE1ldGhvZFwiKSB7XG4gICAgICBpZiAobm9kZS5raW5kID09PSBcIm1ldGhvZFwiKSB7XG4gICAgICAgIG5vZGUua2luZCA9IFwiaW5pdFwiO1xuICAgICAgfVxuICAgICAgbm9kZS5zaG9ydGhhbmQgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJQcm9wZXJ0eVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1ldGhvZERlZmluaXRpb25cIik7XG4gICAgfVxuICB9XG4gIG5hbWVJc0NvbnN0cnVjdG9yKGtleSkge1xuICAgIGlmIChrZXkudHlwZSA9PT0gXCJMaXRlcmFsXCIpIHJldHVybiBrZXkudmFsdWUgPT09IFwiY29uc3RydWN0b3JcIjtcbiAgICByZXR1cm4gc3VwZXIubmFtZUlzQ29uc3RydWN0b3Ioa2V5KTtcbiAgfVxuICBwYXJzZUNsYXNzUHJvcGVydHkoLi4uYXJncykge1xuICAgIGNvbnN0IHByb3BlcnR5Tm9kZSA9IHN1cGVyLnBhcnNlQ2xhc3NQcm9wZXJ0eSguLi5hcmdzKTtcbiAgICB7XG4gICAgICBpZiAoIXRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwiZXN0cmVlXCIsIFwiY2xhc3NGZWF0dXJlc1wiKSkge1xuICAgICAgICByZXR1cm4gcHJvcGVydHlOb2RlO1xuICAgICAgfVxuICAgIH1cbiAgICB7XG4gICAgICB0aGlzLmNhc3ROb2RlVG8ocHJvcGVydHlOb2RlLCBcIlByb3BlcnR5RGVmaW5pdGlvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3BlcnR5Tm9kZTtcbiAgfVxuICBwYXJzZUNsYXNzUHJpdmF0ZVByb3BlcnR5KC4uLmFyZ3MpIHtcbiAgICBjb25zdCBwcm9wZXJ0eU5vZGUgPSBzdXBlci5wYXJzZUNsYXNzUHJpdmF0ZVByb3BlcnR5KC4uLmFyZ3MpO1xuICAgIHtcbiAgICAgIGlmICghdGhpcy5nZXRQbHVnaW5PcHRpb24oXCJlc3RyZWVcIiwgXCJjbGFzc0ZlYXR1cmVzXCIpKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eU5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIHtcbiAgICAgIHRoaXMuY2FzdE5vZGVUbyhwcm9wZXJ0eU5vZGUsIFwiUHJvcGVydHlEZWZpbml0aW9uXCIpO1xuICAgIH1cbiAgICBwcm9wZXJ0eU5vZGUuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gcHJvcGVydHlOb2RlO1xuICB9XG4gIHBhcnNlQ2xhc3NBY2Nlc3NvclByb3BlcnR5KG5vZGUpIHtcbiAgICBjb25zdCBhY2Nlc3NvclByb3BlcnR5Tm9kZSA9IHN1cGVyLnBhcnNlQ2xhc3NBY2Nlc3NvclByb3BlcnR5KG5vZGUpO1xuICAgIHtcbiAgICAgIGlmICghdGhpcy5nZXRQbHVnaW5PcHRpb24oXCJlc3RyZWVcIiwgXCJjbGFzc0ZlYXR1cmVzXCIpKSB7XG4gICAgICAgIHJldHVybiBhY2Nlc3NvclByb3BlcnR5Tm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFjY2Vzc29yUHJvcGVydHlOb2RlLmFic3RyYWN0ICYmIHRoaXMuaGFzUGx1Z2luKFwidHlwZXNjcmlwdFwiKSkge1xuICAgICAgZGVsZXRlIGFjY2Vzc29yUHJvcGVydHlOb2RlLmFic3RyYWN0O1xuICAgICAgdGhpcy5jYXN0Tm9kZVRvKGFjY2Vzc29yUHJvcGVydHlOb2RlLCBcIlRTQWJzdHJhY3RBY2Nlc3NvclByb3BlcnR5XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNhc3ROb2RlVG8oYWNjZXNzb3JQcm9wZXJ0eU5vZGUsIFwiQWNjZXNzb3JQcm9wZXJ0eVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY2Vzc29yUHJvcGVydHlOb2RlO1xuICB9XG4gIHBhcnNlT2JqZWN0UHJvcGVydHkocHJvcCwgc3RhcnRMb2MsIGlzUGF0dGVybiwgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGNvbnN0IG5vZGUgPSBzdXBlci5wYXJzZU9iamVjdFByb3BlcnR5KHByb3AsIHN0YXJ0TG9jLCBpc1BhdHRlcm4sIHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgIGlmIChub2RlKSB7XG4gICAgICBub2RlLmtpbmQgPSBcImluaXRcIjtcbiAgICAgIHRoaXMuY2FzdE5vZGVUbyhub2RlLCBcIlByb3BlcnR5XCIpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBmaW5pc2hPYmplY3RQcm9wZXJ0eShub2RlKSB7XG4gICAgbm9kZS5raW5kID0gXCJpbml0XCI7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlByb3BlcnR5XCIpO1xuICB9XG4gIGlzVmFsaWRMVmFsKHR5cGUsIGlzVW5wYXJlbnRoZXNpemVkSW5Bc3NpZ24sIGJpbmRpbmcpIHtcbiAgICByZXR1cm4gdHlwZSA9PT0gXCJQcm9wZXJ0eVwiID8gXCJ2YWx1ZVwiIDogc3VwZXIuaXNWYWxpZExWYWwodHlwZSwgaXNVbnBhcmVudGhlc2l6ZWRJbkFzc2lnbiwgYmluZGluZyk7XG4gIH1cbiAgaXNBc3NpZ25hYmxlKG5vZGUsIGlzQmluZGluZykge1xuICAgIGlmIChub2RlICE9IG51bGwgJiYgdGhpcy5pc09iamVjdFByb3BlcnR5KG5vZGUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc0Fzc2lnbmFibGUobm9kZS52YWx1ZSwgaXNCaW5kaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmlzQXNzaWduYWJsZShub2RlLCBpc0JpbmRpbmcpO1xuICB9XG4gIHRvQXNzaWduYWJsZShub2RlLCBpc0xIUyA9IGZhbHNlKSB7XG4gICAgaWYgKG5vZGUgIT0gbnVsbCAmJiB0aGlzLmlzT2JqZWN0UHJvcGVydHkobm9kZSkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAga2V5LFxuICAgICAgICB2YWx1ZVxuICAgICAgfSA9IG5vZGU7XG4gICAgICBpZiAodGhpcy5pc1ByaXZhdGVOYW1lKGtleSkpIHtcbiAgICAgICAgdGhpcy5jbGFzc1Njb3BlLnVzZVByaXZhdGVOYW1lKHRoaXMuZ2V0UHJpdmF0ZU5hbWVTVihrZXkpLCBrZXkubG9jLnN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKHZhbHVlLCBpc0xIUyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLnRvQXNzaWduYWJsZShub2RlLCBpc0xIUyk7XG4gICAgfVxuICB9XG4gIHRvQXNzaWduYWJsZU9iamVjdEV4cHJlc3Npb25Qcm9wKHByb3AsIGlzTGFzdCwgaXNMSFMpIHtcbiAgICBpZiAocHJvcC50eXBlID09PSBcIlByb3BlcnR5XCIgJiYgKHByb3Aua2luZCA9PT0gXCJnZXRcIiB8fCBwcm9wLmtpbmQgPT09IFwic2V0XCIpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5QYXR0ZXJuSGFzQWNjZXNzb3IsIHByb3Aua2V5KTtcbiAgICB9IGVsc2UgaWYgKHByb3AudHlwZSA9PT0gXCJQcm9wZXJ0eVwiICYmIHByb3AubWV0aG9kKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5QYXR0ZXJuSGFzTWV0aG9kLCBwcm9wLmtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLnRvQXNzaWduYWJsZU9iamVjdEV4cHJlc3Npb25Qcm9wKHByb3AsIGlzTGFzdCwgaXNMSFMpO1xuICAgIH1cbiAgfVxuICBmaW5pc2hDYWxsRXhwcmVzc2lvbih1bmZpbmlzaGVkLCBvcHRpb25hbCkge1xuICAgIGNvbnN0IG5vZGUgPSBzdXBlci5maW5pc2hDYWxsRXhwcmVzc2lvbih1bmZpbmlzaGVkLCBvcHRpb25hbCk7XG4gICAgaWYgKG5vZGUuY2FsbGVlLnR5cGUgPT09IFwiSW1wb3J0XCIpIHtcbiAgICAgIHZhciBfcmVmLCBfcmVmMjtcbiAgICAgIHRoaXMuY2FzdE5vZGVUbyhub2RlLCBcIkltcG9ydEV4cHJlc3Npb25cIik7XG4gICAgICBub2RlLnNvdXJjZSA9IG5vZGUuYXJndW1lbnRzWzBdO1xuICAgICAgbm9kZS5vcHRpb25zID0gKF9yZWYgPSBub2RlLmFyZ3VtZW50c1sxXSkgIT0gbnVsbCA/IF9yZWYgOiBudWxsO1xuICAgICAgbm9kZS5hdHRyaWJ1dGVzID0gKF9yZWYyID0gbm9kZS5hcmd1bWVudHNbMV0pICE9IG51bGwgPyBfcmVmMiA6IG51bGw7XG4gICAgICBkZWxldGUgbm9kZS5hcmd1bWVudHM7XG4gICAgICBkZWxldGUgbm9kZS5jYWxsZWU7XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiKSB7XG4gICAgICB0aGlzLmNhc3ROb2RlVG8obm9kZSwgXCJDYWxsRXhwcmVzc2lvblwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5vcHRpb25hbCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICB0b1JlZmVyZW5jZWRBcmd1bWVudHMobm9kZSkge1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiSW1wb3J0RXhwcmVzc2lvblwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLnRvUmVmZXJlbmNlZEFyZ3VtZW50cyhub2RlKTtcbiAgfVxuICBwYXJzZUV4cG9ydCh1bmZpbmlzaGVkLCBkZWNvcmF0b3JzKSB7XG4gICAgY29uc3QgZXhwb3J0U3RhcnRMb2MgPSB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYztcbiAgICBjb25zdCBub2RlID0gc3VwZXIucGFyc2VFeHBvcnQodW5maW5pc2hlZCwgZGVjb3JhdG9ycyk7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiOlxuICAgICAgICBub2RlLmV4cG9ydGVkID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiOlxuICAgICAgICBpZiAobm9kZS5zcGVjaWZpZXJzLmxlbmd0aCA9PT0gMSAmJiBub2RlLnNwZWNpZmllcnNbMF0udHlwZSA9PT0gXCJFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIikge1xuICAgICAgICAgIHRoaXMuY2FzdE5vZGVUbyhub2RlLCBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIpO1xuICAgICAgICAgIG5vZGUuZXhwb3J0ZWQgPSBub2RlLnNwZWNpZmllcnNbMF0uZXhwb3J0ZWQ7XG4gICAgICAgICAgZGVsZXRlIG5vZGUuc3BlY2lmaWVycztcbiAgICAgICAgfVxuICAgICAgY2FzZSBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9kZWNsYXJhdGlvbiRkZWNvcmF0bztcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBkZWNsYXJhdGlvblxuICAgICAgICAgIH0gPSBub2RlO1xuICAgICAgICAgIGlmICgoZGVjbGFyYXRpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGRlY2xhcmF0aW9uLnR5cGUpID09PSBcIkNsYXNzRGVjbGFyYXRpb25cIiAmJiAoKF9kZWNsYXJhdGlvbiRkZWNvcmF0byA9IGRlY2xhcmF0aW9uLmRlY29yYXRvcnMpID09IG51bGwgPyB2b2lkIDAgOiBfZGVjbGFyYXRpb24kZGVjb3JhdG8ubGVuZ3RoKSA+IDAgJiYgZGVjbGFyYXRpb24uc3RhcnQgPT09IG5vZGUuc3RhcnQpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRTdGFydExvY2F0aW9uKG5vZGUsIGV4cG9ydFN0YXJ0TG9jKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHN0b3BQYXJzZVN1YnNjcmlwdChiYXNlLCBzdGF0ZSkge1xuICAgIGNvbnN0IG5vZGUgPSBzdXBlci5zdG9wUGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhdGUpO1xuICAgIGlmIChzdGF0ZS5vcHRpb25hbENoYWluTWVtYmVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5lc3RyZWVQYXJzZUNoYWluRXhwcmVzc2lvbihub2RlLCBiYXNlLmxvYy5lbmQpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBwYXJzZU1lbWJlcihiYXNlLCBzdGFydExvYywgc3RhdGUsIGNvbXB1dGVkLCBvcHRpb25hbCkge1xuICAgIGNvbnN0IG5vZGUgPSBzdXBlci5wYXJzZU1lbWJlcihiYXNlLCBzdGFydExvYywgc3RhdGUsIGNvbXB1dGVkLCBvcHRpb25hbCk7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIikge1xuICAgICAgdGhpcy5jYXN0Tm9kZVRvKG5vZGUsIFwiTWVtYmVyRXhwcmVzc2lvblwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5vcHRpb25hbCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBpc09wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbihub2RlKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJDaGFpbkV4cHJlc3Npb25cIikge1xuICAgICAgcmV0dXJuIG5vZGUuZXhwcmVzc2lvbi50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIjtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmlzT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uKG5vZGUpO1xuICB9XG4gIGhhc1Byb3BlcnR5QXNQcml2YXRlTmFtZShub2RlKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJDaGFpbkV4cHJlc3Npb25cIikge1xuICAgICAgbm9kZSA9IG5vZGUuZXhwcmVzc2lvbjtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmhhc1Byb3BlcnR5QXNQcml2YXRlTmFtZShub2RlKTtcbiAgfVxuICBpc09iamVjdFByb3BlcnR5KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcIlByb3BlcnR5XCIgJiYgbm9kZS5raW5kID09PSBcImluaXRcIiAmJiAhbm9kZS5tZXRob2Q7XG4gIH1cbiAgaXNPYmplY3RNZXRob2Qobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiUHJvcGVydHlcIiAmJiAobm9kZS5tZXRob2QgfHwgbm9kZS5raW5kID09PSBcImdldFwiIHx8IG5vZGUua2luZCA9PT0gXCJzZXRcIik7XG4gIH1cbiAgY2FzdE5vZGVUbyhub2RlLCB0eXBlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gc3VwZXIuY2FzdE5vZGVUbyhub2RlLCB0eXBlKTtcbiAgICB0aGlzLmZpbGxPcHRpb25hbFByb3BlcnRpZXNGb3JUU0VTTGludChyZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY2xvbmVJZGVudGlmaWVyKG5vZGUpIHtcbiAgICBjb25zdCBjbG9uZWQgPSBzdXBlci5jbG9uZUlkZW50aWZpZXIobm9kZSk7XG4gICAgdGhpcy5maWxsT3B0aW9uYWxQcm9wZXJ0aWVzRm9yVFNFU0xpbnQoY2xvbmVkKTtcbiAgICByZXR1cm4gY2xvbmVkO1xuICB9XG4gIGNsb25lU3RyaW5nTGl0ZXJhbChub2RlKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJMaXRlcmFsXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsb25lRXN0cmVlU3RyaW5nTGl0ZXJhbChub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmNsb25lU3RyaW5nTGl0ZXJhbChub2RlKTtcbiAgfVxuICBmaW5pc2hOb2RlQXQobm9kZSwgdHlwZSwgZW5kTG9jKSB7XG4gICAgcmV0dXJuIHRvRVNUcmVlTG9jYXRpb24oc3VwZXIuZmluaXNoTm9kZUF0KG5vZGUsIHR5cGUsIGVuZExvYykpO1xuICB9XG4gIGZpbmlzaE5vZGUobm9kZSwgdHlwZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLmZpbmlzaE5vZGUobm9kZSwgdHlwZSk7XG4gICAgdGhpcy5maWxsT3B0aW9uYWxQcm9wZXJ0aWVzRm9yVFNFU0xpbnQocmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJlc2V0U3RhcnRMb2NhdGlvbihub2RlLCBzdGFydExvYykge1xuICAgIHN1cGVyLnJlc2V0U3RhcnRMb2NhdGlvbihub2RlLCBzdGFydExvYyk7XG4gICAgdG9FU1RyZWVMb2NhdGlvbihub2RlKTtcbiAgfVxuICByZXNldEVuZExvY2F0aW9uKG5vZGUsIGVuZExvYyA9IHRoaXMuc3RhdGUubGFzdFRva0VuZExvYykge1xuICAgIHN1cGVyLnJlc2V0RW5kTG9jYXRpb24obm9kZSwgZW5kTG9jKTtcbiAgICB0b0VTVHJlZUxvY2F0aW9uKG5vZGUpO1xuICB9XG59O1xuY2xhc3MgVG9rQ29udGV4dCB7XG4gIGNvbnN0cnVjdG9yKHRva2VuLCBwcmVzZXJ2ZVNwYWNlKSB7XG4gICAgdGhpcy50b2tlbiA9IHZvaWQgMDtcbiAgICB0aGlzLnByZXNlcnZlU3BhY2UgPSB2b2lkIDA7XG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgIHRoaXMucHJlc2VydmVTcGFjZSA9ICEhcHJlc2VydmVTcGFjZTtcbiAgfVxufVxuY29uc3QgdHlwZXMgPSB7XG4gIGJyYWNlOiBuZXcgVG9rQ29udGV4dChcIntcIiksXG4gIGpfb1RhZzogbmV3IFRva0NvbnRleHQoXCI8dGFnXCIpLFxuICBqX2NUYWc6IG5ldyBUb2tDb250ZXh0KFwiPC90YWdcIiksXG4gIGpfZXhwcjogbmV3IFRva0NvbnRleHQoXCI8dGFnPi4uLjwvdGFnPlwiLCB0cnVlKVxufTtcbntcbiAgdHlwZXMudGVtcGxhdGUgPSBuZXcgVG9rQ29udGV4dChcImBcIiwgdHJ1ZSk7XG59XG5jb25zdCBiZWZvcmVFeHByID0gdHJ1ZTtcbmNvbnN0IHN0YXJ0c0V4cHIgPSB0cnVlO1xuY29uc3QgaXNMb29wID0gdHJ1ZTtcbmNvbnN0IGlzQXNzaWduID0gdHJ1ZTtcbmNvbnN0IHByZWZpeCA9IHRydWU7XG5jb25zdCBwb3N0Zml4ID0gdHJ1ZTtcbmNsYXNzIEV4cG9ydGVkVG9rZW5UeXBlIHtcbiAgY29uc3RydWN0b3IobGFiZWwsIGNvbmYgPSB7fSkge1xuICAgIHRoaXMubGFiZWwgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXl3b3JkID0gdm9pZCAwO1xuICAgIHRoaXMuYmVmb3JlRXhwciA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YXJ0c0V4cHIgPSB2b2lkIDA7XG4gICAgdGhpcy5yaWdodEFzc29jaWF0aXZlID0gdm9pZCAwO1xuICAgIHRoaXMuaXNMb29wID0gdm9pZCAwO1xuICAgIHRoaXMuaXNBc3NpZ24gPSB2b2lkIDA7XG4gICAgdGhpcy5wcmVmaXggPSB2b2lkIDA7XG4gICAgdGhpcy5wb3N0Zml4ID0gdm9pZCAwO1xuICAgIHRoaXMuYmlub3AgPSB2b2lkIDA7XG4gICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgIHRoaXMua2V5d29yZCA9IGNvbmYua2V5d29yZDtcbiAgICB0aGlzLmJlZm9yZUV4cHIgPSAhIWNvbmYuYmVmb3JlRXhwcjtcbiAgICB0aGlzLnN0YXJ0c0V4cHIgPSAhIWNvbmYuc3RhcnRzRXhwcjtcbiAgICB0aGlzLnJpZ2h0QXNzb2NpYXRpdmUgPSAhIWNvbmYucmlnaHRBc3NvY2lhdGl2ZTtcbiAgICB0aGlzLmlzTG9vcCA9ICEhY29uZi5pc0xvb3A7XG4gICAgdGhpcy5pc0Fzc2lnbiA9ICEhY29uZi5pc0Fzc2lnbjtcbiAgICB0aGlzLnByZWZpeCA9ICEhY29uZi5wcmVmaXg7XG4gICAgdGhpcy5wb3N0Zml4ID0gISFjb25mLnBvc3RmaXg7XG4gICAgdGhpcy5iaW5vcCA9IGNvbmYuYmlub3AgIT0gbnVsbCA/IGNvbmYuYmlub3AgOiBudWxsO1xuICAgIHtcbiAgICAgIHRoaXMudXBkYXRlQ29udGV4dCA9IG51bGw7XG4gICAgfVxuICB9XG59XG5jb25zdCBrZXl3b3JkcyQxID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gY3JlYXRlS2V5d29yZChuYW1lLCBvcHRpb25zID0ge30pIHtcbiAgb3B0aW9ucy5rZXl3b3JkID0gbmFtZTtcbiAgY29uc3QgdG9rZW4gPSBjcmVhdGVUb2tlbihuYW1lLCBvcHRpb25zKTtcbiAga2V5d29yZHMkMS5zZXQobmFtZSwgdG9rZW4pO1xuICByZXR1cm4gdG9rZW47XG59XG5mdW5jdGlvbiBjcmVhdGVCaW5vcChuYW1lLCBiaW5vcCkge1xuICByZXR1cm4gY3JlYXRlVG9rZW4obmFtZSwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgYmlub3BcbiAgfSk7XG59XG5sZXQgdG9rZW5UeXBlQ291bnRlciA9IC0xO1xuY29uc3QgdG9rZW5UeXBlcyA9IFtdO1xuY29uc3QgdG9rZW5MYWJlbHMgPSBbXTtcbmNvbnN0IHRva2VuQmlub3BzID0gW107XG5jb25zdCB0b2tlbkJlZm9yZUV4cHJzID0gW107XG5jb25zdCB0b2tlblN0YXJ0c0V4cHJzID0gW107XG5jb25zdCB0b2tlblByZWZpeGVzID0gW107XG5mdW5jdGlvbiBjcmVhdGVUb2tlbihuYW1lLCBvcHRpb25zID0ge30pIHtcbiAgdmFyIF9vcHRpb25zJGJpbm9wLCBfb3B0aW9ucyRiZWZvcmVFeHByLCBfb3B0aW9ucyRzdGFydHNFeHByLCBfb3B0aW9ucyRwcmVmaXg7XG4gICsrdG9rZW5UeXBlQ291bnRlcjtcbiAgdG9rZW5MYWJlbHMucHVzaChuYW1lKTtcbiAgdG9rZW5CaW5vcHMucHVzaCgoX29wdGlvbnMkYmlub3AgPSBvcHRpb25zLmJpbm9wKSAhPSBudWxsID8gX29wdGlvbnMkYmlub3AgOiAtMSk7XG4gIHRva2VuQmVmb3JlRXhwcnMucHVzaCgoX29wdGlvbnMkYmVmb3JlRXhwciA9IG9wdGlvbnMuYmVmb3JlRXhwcikgIT0gbnVsbCA/IF9vcHRpb25zJGJlZm9yZUV4cHIgOiBmYWxzZSk7XG4gIHRva2VuU3RhcnRzRXhwcnMucHVzaCgoX29wdGlvbnMkc3RhcnRzRXhwciA9IG9wdGlvbnMuc3RhcnRzRXhwcikgIT0gbnVsbCA/IF9vcHRpb25zJHN0YXJ0c0V4cHIgOiBmYWxzZSk7XG4gIHRva2VuUHJlZml4ZXMucHVzaCgoX29wdGlvbnMkcHJlZml4ID0gb3B0aW9ucy5wcmVmaXgpICE9IG51bGwgPyBfb3B0aW9ucyRwcmVmaXggOiBmYWxzZSk7XG4gIHRva2VuVHlwZXMucHVzaChuZXcgRXhwb3J0ZWRUb2tlblR5cGUobmFtZSwgb3B0aW9ucykpO1xuICByZXR1cm4gdG9rZW5UeXBlQ291bnRlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUtleXdvcmRMaWtlKG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICB2YXIgX29wdGlvbnMkYmlub3AyLCBfb3B0aW9ucyRiZWZvcmVFeHByMiwgX29wdGlvbnMkc3RhcnRzRXhwcjIsIF9vcHRpb25zJHByZWZpeDI7XG4gICsrdG9rZW5UeXBlQ291bnRlcjtcbiAga2V5d29yZHMkMS5zZXQobmFtZSwgdG9rZW5UeXBlQ291bnRlcik7XG4gIHRva2VuTGFiZWxzLnB1c2gobmFtZSk7XG4gIHRva2VuQmlub3BzLnB1c2goKF9vcHRpb25zJGJpbm9wMiA9IG9wdGlvbnMuYmlub3ApICE9IG51bGwgPyBfb3B0aW9ucyRiaW5vcDIgOiAtMSk7XG4gIHRva2VuQmVmb3JlRXhwcnMucHVzaCgoX29wdGlvbnMkYmVmb3JlRXhwcjIgPSBvcHRpb25zLmJlZm9yZUV4cHIpICE9IG51bGwgPyBfb3B0aW9ucyRiZWZvcmVFeHByMiA6IGZhbHNlKTtcbiAgdG9rZW5TdGFydHNFeHBycy5wdXNoKChfb3B0aW9ucyRzdGFydHNFeHByMiA9IG9wdGlvbnMuc3RhcnRzRXhwcikgIT0gbnVsbCA/IF9vcHRpb25zJHN0YXJ0c0V4cHIyIDogZmFsc2UpO1xuICB0b2tlblByZWZpeGVzLnB1c2goKF9vcHRpb25zJHByZWZpeDIgPSBvcHRpb25zLnByZWZpeCkgIT0gbnVsbCA/IF9vcHRpb25zJHByZWZpeDIgOiBmYWxzZSk7XG4gIHRva2VuVHlwZXMucHVzaChuZXcgRXhwb3J0ZWRUb2tlblR5cGUoXCJuYW1lXCIsIG9wdGlvbnMpKTtcbiAgcmV0dXJuIHRva2VuVHlwZUNvdW50ZXI7XG59XG5jb25zdCB0dCA9IHtcbiAgYnJhY2tldEw6IGNyZWF0ZVRva2VuKFwiW1wiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBicmFja2V0SGFzaEw6IGNyZWF0ZVRva2VuKFwiI1tcIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgYnJhY2tldEJhckw6IGNyZWF0ZVRva2VuKFwiW3xcIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgYnJhY2tldFI6IGNyZWF0ZVRva2VuKFwiXVwiKSxcbiAgYnJhY2tldEJhclI6IGNyZWF0ZVRva2VuKFwifF1cIiksXG4gIGJyYWNlTDogY3JlYXRlVG9rZW4oXCJ7XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIGJyYWNlQmFyTDogY3JlYXRlVG9rZW4oXCJ7fFwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBicmFjZUhhc2hMOiBjcmVhdGVUb2tlbihcIiN7XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIGJyYWNlUjogY3JlYXRlVG9rZW4oXCJ9XCIpLFxuICBicmFjZUJhclI6IGNyZWF0ZVRva2VuKFwifH1cIiksXG4gIHBhcmVuTDogY3JlYXRlVG9rZW4oXCIoXCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIHBhcmVuUjogY3JlYXRlVG9rZW4oXCIpXCIpLFxuICBjb21tYTogY3JlYXRlVG9rZW4oXCIsXCIsIHtcbiAgICBiZWZvcmVFeHByXG4gIH0pLFxuICBzZW1pOiBjcmVhdGVUb2tlbihcIjtcIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIGNvbG9uOiBjcmVhdGVUb2tlbihcIjpcIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIGRvdWJsZUNvbG9uOiBjcmVhdGVUb2tlbihcIjo6XCIsIHtcbiAgICBiZWZvcmVFeHByXG4gIH0pLFxuICBkb3Q6IGNyZWF0ZVRva2VuKFwiLlwiKSxcbiAgcXVlc3Rpb246IGNyZWF0ZVRva2VuKFwiP1wiLCB7XG4gICAgYmVmb3JlRXhwclxuICB9KSxcbiAgcXVlc3Rpb25Eb3Q6IGNyZWF0ZVRva2VuKFwiPy5cIiksXG4gIGFycm93OiBjcmVhdGVUb2tlbihcIj0+XCIsIHtcbiAgICBiZWZvcmVFeHByXG4gIH0pLFxuICB0ZW1wbGF0ZTogY3JlYXRlVG9rZW4oXCJ0ZW1wbGF0ZVwiKSxcbiAgZWxsaXBzaXM6IGNyZWF0ZVRva2VuKFwiLi4uXCIsIHtcbiAgICBiZWZvcmVFeHByXG4gIH0pLFxuICBiYWNrUXVvdGU6IGNyZWF0ZVRva2VuKFwiYFwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgZG9sbGFyQnJhY2VMOiBjcmVhdGVUb2tlbihcIiR7XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIHRlbXBsYXRlVGFpbDogY3JlYXRlVG9rZW4oXCIuLi5gXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICB0ZW1wbGF0ZU5vblRhaWw6IGNyZWF0ZVRva2VuKFwiLi4uJHtcIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgYXQ6IGNyZWF0ZVRva2VuKFwiQFwiKSxcbiAgaGFzaDogY3JlYXRlVG9rZW4oXCIjXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBpbnRlcnByZXRlckRpcmVjdGl2ZTogY3JlYXRlVG9rZW4oXCIjIS4uLlwiKSxcbiAgZXE6IGNyZWF0ZVRva2VuKFwiPVwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBpc0Fzc2lnblxuICB9KSxcbiAgYXNzaWduOiBjcmVhdGVUb2tlbihcIl89XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIGlzQXNzaWduXG4gIH0pLFxuICBzbGFzaEFzc2lnbjogY3JlYXRlVG9rZW4oXCJfPVwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBpc0Fzc2lnblxuICB9KSxcbiAgeG9yQXNzaWduOiBjcmVhdGVUb2tlbihcIl89XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIGlzQXNzaWduXG4gIH0pLFxuICBtb2R1bG9Bc3NpZ246IGNyZWF0ZVRva2VuKFwiXz1cIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgaXNBc3NpZ25cbiAgfSksXG4gIGluY0RlYzogY3JlYXRlVG9rZW4oXCIrKy8tLVwiLCB7XG4gICAgcHJlZml4LFxuICAgIHBvc3RmaXgsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgYmFuZzogY3JlYXRlVG9rZW4oXCIhXCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHByZWZpeCxcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICB0aWxkZTogY3JlYXRlVG9rZW4oXCJ+XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHByZWZpeCxcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBkb3VibGVDYXJldDogY3JlYXRlVG9rZW4oXCJeXlwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgZG91YmxlQXQ6IGNyZWF0ZVRva2VuKFwiQEBcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIHBpcGVsaW5lOiBjcmVhdGVCaW5vcChcInw+XCIsIDApLFxuICBudWxsaXNoQ29hbGVzY2luZzogY3JlYXRlQmlub3AoXCI/P1wiLCAxKSxcbiAgbG9naWNhbE9SOiBjcmVhdGVCaW5vcChcInx8XCIsIDEpLFxuICBsb2dpY2FsQU5EOiBjcmVhdGVCaW5vcChcIiYmXCIsIDIpLFxuICBiaXR3aXNlT1I6IGNyZWF0ZUJpbm9wKFwifFwiLCAzKSxcbiAgYml0d2lzZVhPUjogY3JlYXRlQmlub3AoXCJeXCIsIDQpLFxuICBiaXR3aXNlQU5EOiBjcmVhdGVCaW5vcChcIiZcIiwgNSksXG4gIGVxdWFsaXR5OiBjcmVhdGVCaW5vcChcIj09LyE9Lz09PS8hPT1cIiwgNiksXG4gIGx0OiBjcmVhdGVCaW5vcChcIjwvPi88PS8+PVwiLCA3KSxcbiAgZ3Q6IGNyZWF0ZUJpbm9wKFwiPC8+Lzw9Lz49XCIsIDcpLFxuICByZWxhdGlvbmFsOiBjcmVhdGVCaW5vcChcIjwvPi88PS8+PVwiLCA3KSxcbiAgYml0U2hpZnQ6IGNyZWF0ZUJpbm9wKFwiPDwvPj4vPj4+XCIsIDgpLFxuICBiaXRTaGlmdEw6IGNyZWF0ZUJpbm9wKFwiPDwvPj4vPj4+XCIsIDgpLFxuICBiaXRTaGlmdFI6IGNyZWF0ZUJpbm9wKFwiPDwvPj4vPj4+XCIsIDgpLFxuICBwbHVzTWluOiBjcmVhdGVUb2tlbihcIisvLVwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBiaW5vcDogOSxcbiAgICBwcmVmaXgsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgbW9kdWxvOiBjcmVhdGVUb2tlbihcIiVcIiwge1xuICAgIGJpbm9wOiAxMCxcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBzdGFyOiBjcmVhdGVUb2tlbihcIipcIiwge1xuICAgIGJpbm9wOiAxMFxuICB9KSxcbiAgc2xhc2g6IGNyZWF0ZUJpbm9wKFwiL1wiLCAxMCksXG4gIGV4cG9uZW50OiBjcmVhdGVUb2tlbihcIioqXCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIGJpbm9wOiAxMSxcbiAgICByaWdodEFzc29jaWF0aXZlOiB0cnVlXG4gIH0pLFxuICBfaW46IGNyZWF0ZUtleXdvcmQoXCJpblwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBiaW5vcDogN1xuICB9KSxcbiAgX2luc3RhbmNlb2Y6IGNyZWF0ZUtleXdvcmQoXCJpbnN0YW5jZW9mXCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIGJpbm9wOiA3XG4gIH0pLFxuICBfYnJlYWs6IGNyZWF0ZUtleXdvcmQoXCJicmVha1wiKSxcbiAgX2Nhc2U6IGNyZWF0ZUtleXdvcmQoXCJjYXNlXCIsIHtcbiAgICBiZWZvcmVFeHByXG4gIH0pLFxuICBfY2F0Y2g6IGNyZWF0ZUtleXdvcmQoXCJjYXRjaFwiKSxcbiAgX2NvbnRpbnVlOiBjcmVhdGVLZXl3b3JkKFwiY29udGludWVcIiksXG4gIF9kZWJ1Z2dlcjogY3JlYXRlS2V5d29yZChcImRlYnVnZ2VyXCIpLFxuICBfZGVmYXVsdDogY3JlYXRlS2V5d29yZChcImRlZmF1bHRcIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIF9lbHNlOiBjcmVhdGVLZXl3b3JkKFwiZWxzZVwiLCB7XG4gICAgYmVmb3JlRXhwclxuICB9KSxcbiAgX2ZpbmFsbHk6IGNyZWF0ZUtleXdvcmQoXCJmaW5hbGx5XCIpLFxuICBfZnVuY3Rpb246IGNyZWF0ZUtleXdvcmQoXCJmdW5jdGlvblwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2lmOiBjcmVhdGVLZXl3b3JkKFwiaWZcIiksXG4gIF9yZXR1cm46IGNyZWF0ZUtleXdvcmQoXCJyZXR1cm5cIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIF9zd2l0Y2g6IGNyZWF0ZUtleXdvcmQoXCJzd2l0Y2hcIiksXG4gIF90aHJvdzogY3JlYXRlS2V5d29yZChcInRocm93XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHByZWZpeCxcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfdHJ5OiBjcmVhdGVLZXl3b3JkKFwidHJ5XCIpLFxuICBfdmFyOiBjcmVhdGVLZXl3b3JkKFwidmFyXCIpLFxuICBfY29uc3Q6IGNyZWF0ZUtleXdvcmQoXCJjb25zdFwiKSxcbiAgX3dpdGg6IGNyZWF0ZUtleXdvcmQoXCJ3aXRoXCIpLFxuICBfbmV3OiBjcmVhdGVLZXl3b3JkKFwibmV3XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF90aGlzOiBjcmVhdGVLZXl3b3JkKFwidGhpc1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3N1cGVyOiBjcmVhdGVLZXl3b3JkKFwic3VwZXJcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9jbGFzczogY3JlYXRlS2V5d29yZChcImNsYXNzXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfZXh0ZW5kczogY3JlYXRlS2V5d29yZChcImV4dGVuZHNcIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIF9leHBvcnQ6IGNyZWF0ZUtleXdvcmQoXCJleHBvcnRcIiksXG4gIF9pbXBvcnQ6IGNyZWF0ZUtleXdvcmQoXCJpbXBvcnRcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9udWxsOiBjcmVhdGVLZXl3b3JkKFwibnVsbFwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3RydWU6IGNyZWF0ZUtleXdvcmQoXCJ0cnVlXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfZmFsc2U6IGNyZWF0ZUtleXdvcmQoXCJmYWxzZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3R5cGVvZjogY3JlYXRlS2V5d29yZChcInR5cGVvZlwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBwcmVmaXgsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3ZvaWQ6IGNyZWF0ZUtleXdvcmQoXCJ2b2lkXCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHByZWZpeCxcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfZGVsZXRlOiBjcmVhdGVLZXl3b3JkKFwiZGVsZXRlXCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHByZWZpeCxcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfZG86IGNyZWF0ZUtleXdvcmQoXCJkb1wiLCB7XG4gICAgaXNMb29wLFxuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIF9mb3I6IGNyZWF0ZUtleXdvcmQoXCJmb3JcIiwge1xuICAgIGlzTG9vcFxuICB9KSxcbiAgX3doaWxlOiBjcmVhdGVLZXl3b3JkKFwid2hpbGVcIiwge1xuICAgIGlzTG9vcFxuICB9KSxcbiAgX2FzOiBjcmVhdGVLZXl3b3JkTGlrZShcImFzXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfYXNzZXJ0OiBjcmVhdGVLZXl3b3JkTGlrZShcImFzc2VydFwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2FzeW5jOiBjcmVhdGVLZXl3b3JkTGlrZShcImFzeW5jXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfYXdhaXQ6IGNyZWF0ZUtleXdvcmRMaWtlKFwiYXdhaXRcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9kZWZlcjogY3JlYXRlS2V5d29yZExpa2UoXCJkZWZlclwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2Zyb206IGNyZWF0ZUtleXdvcmRMaWtlKFwiZnJvbVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2dldDogY3JlYXRlS2V5d29yZExpa2UoXCJnZXRcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9sZXQ6IGNyZWF0ZUtleXdvcmRMaWtlKFwibGV0XCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfbWV0YTogY3JlYXRlS2V5d29yZExpa2UoXCJtZXRhXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfb2Y6IGNyZWF0ZUtleXdvcmRMaWtlKFwib2ZcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9zZW50OiBjcmVhdGVLZXl3b3JkTGlrZShcInNlbnRcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9zZXQ6IGNyZWF0ZUtleXdvcmRMaWtlKFwic2V0XCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfc291cmNlOiBjcmVhdGVLZXl3b3JkTGlrZShcInNvdXJjZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3N0YXRpYzogY3JlYXRlS2V5d29yZExpa2UoXCJzdGF0aWNcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF91c2luZzogY3JlYXRlS2V5d29yZExpa2UoXCJ1c2luZ1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3lpZWxkOiBjcmVhdGVLZXl3b3JkTGlrZShcInlpZWxkXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfYXNzZXJ0czogY3JlYXRlS2V5d29yZExpa2UoXCJhc3NlcnRzXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfY2hlY2tzOiBjcmVhdGVLZXl3b3JkTGlrZShcImNoZWNrc1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2V4cG9ydHM6IGNyZWF0ZUtleXdvcmRMaWtlKFwiZXhwb3J0c1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2dsb2JhbDogY3JlYXRlS2V5d29yZExpa2UoXCJnbG9iYWxcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9pbXBsZW1lbnRzOiBjcmVhdGVLZXl3b3JkTGlrZShcImltcGxlbWVudHNcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9pbnRyaW5zaWM6IGNyZWF0ZUtleXdvcmRMaWtlKFwiaW50cmluc2ljXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfaW5mZXI6IGNyZWF0ZUtleXdvcmRMaWtlKFwiaW5mZXJcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9pczogY3JlYXRlS2V5d29yZExpa2UoXCJpc1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX21peGluczogY3JlYXRlS2V5d29yZExpa2UoXCJtaXhpbnNcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9wcm90bzogY3JlYXRlS2V5d29yZExpa2UoXCJwcm90b1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3JlcXVpcmU6IGNyZWF0ZUtleXdvcmRMaWtlKFwicmVxdWlyZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3NhdGlzZmllczogY3JlYXRlS2V5d29yZExpa2UoXCJzYXRpc2ZpZXNcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9rZXlvZjogY3JlYXRlS2V5d29yZExpa2UoXCJrZXlvZlwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3JlYWRvbmx5OiBjcmVhdGVLZXl3b3JkTGlrZShcInJlYWRvbmx5XCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfdW5pcXVlOiBjcmVhdGVLZXl3b3JkTGlrZShcInVuaXF1ZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2Fic3RyYWN0OiBjcmVhdGVLZXl3b3JkTGlrZShcImFic3RyYWN0XCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfZGVjbGFyZTogY3JlYXRlS2V5d29yZExpa2UoXCJkZWNsYXJlXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfZW51bTogY3JlYXRlS2V5d29yZExpa2UoXCJlbnVtXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfbW9kdWxlOiBjcmVhdGVLZXl3b3JkTGlrZShcIm1vZHVsZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX25hbWVzcGFjZTogY3JlYXRlS2V5d29yZExpa2UoXCJuYW1lc3BhY2VcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9pbnRlcmZhY2U6IGNyZWF0ZUtleXdvcmRMaWtlKFwiaW50ZXJmYWNlXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfdHlwZTogY3JlYXRlS2V5d29yZExpa2UoXCJ0eXBlXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfb3BhcXVlOiBjcmVhdGVLZXl3b3JkTGlrZShcIm9wYXF1ZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgbmFtZTogY3JlYXRlVG9rZW4oXCJuYW1lXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBwbGFjZWhvbGRlcjogY3JlYXRlVG9rZW4oXCIlJVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgc3RyaW5nOiBjcmVhdGVUb2tlbihcInN0cmluZ1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgbnVtOiBjcmVhdGVUb2tlbihcIm51bVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgYmlnaW50OiBjcmVhdGVUb2tlbihcImJpZ2ludFwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgZGVjaW1hbDogY3JlYXRlVG9rZW4oXCJkZWNpbWFsXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICByZWdleHA6IGNyZWF0ZVRva2VuKFwicmVnZXhwXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBwcml2YXRlTmFtZTogY3JlYXRlVG9rZW4oXCIjbmFtZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgZW9mOiBjcmVhdGVUb2tlbihcImVvZlwiKSxcbiAganN4TmFtZTogY3JlYXRlVG9rZW4oXCJqc3hOYW1lXCIpLFxuICBqc3hUZXh0OiBjcmVhdGVUb2tlbihcImpzeFRleHRcIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIGpzeFRhZ1N0YXJ0OiBjcmVhdGVUb2tlbihcImpzeFRhZ1N0YXJ0XCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBqc3hUYWdFbmQ6IGNyZWF0ZVRva2VuKFwianN4VGFnRW5kXCIpXG59O1xuZnVuY3Rpb24gdG9rZW5Jc0lkZW50aWZpZXIodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuID49IDkzICYmIHRva2VuIDw9IDEzMztcbn1cbmZ1bmN0aW9uIHRva2VuS2V5d29yZE9ySWRlbnRpZmllcklzS2V5d29yZCh0b2tlbikge1xuICByZXR1cm4gdG9rZW4gPD0gOTI7XG59XG5mdW5jdGlvbiB0b2tlbklzS2V5d29yZE9ySWRlbnRpZmllcih0b2tlbikge1xuICByZXR1cm4gdG9rZW4gPj0gNTggJiYgdG9rZW4gPD0gMTMzO1xufVxuZnVuY3Rpb24gdG9rZW5Jc0xpdGVyYWxQcm9wZXJ0eU5hbWUodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuID49IDU4ICYmIHRva2VuIDw9IDEzNztcbn1cbmZ1bmN0aW9uIHRva2VuQ29tZXNCZWZvcmVFeHByZXNzaW9uKHRva2VuKSB7XG4gIHJldHVybiB0b2tlbkJlZm9yZUV4cHJzW3Rva2VuXTtcbn1cbmZ1bmN0aW9uIHRva2VuQ2FuU3RhcnRFeHByZXNzaW9uKHRva2VuKSB7XG4gIHJldHVybiB0b2tlblN0YXJ0c0V4cHJzW3Rva2VuXTtcbn1cbmZ1bmN0aW9uIHRva2VuSXNBc3NpZ25tZW50KHRva2VuKSB7XG4gIHJldHVybiB0b2tlbiA+PSAyOSAmJiB0b2tlbiA8PSAzMztcbn1cbmZ1bmN0aW9uIHRva2VuSXNGbG93SW50ZXJmYWNlT3JUeXBlT3JPcGFxdWUodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuID49IDEyOSAmJiB0b2tlbiA8PSAxMzE7XG59XG5mdW5jdGlvbiB0b2tlbklzTG9vcCh0b2tlbikge1xuICByZXR1cm4gdG9rZW4gPj0gOTAgJiYgdG9rZW4gPD0gOTI7XG59XG5mdW5jdGlvbiB0b2tlbklzS2V5d29yZCh0b2tlbikge1xuICByZXR1cm4gdG9rZW4gPj0gNTggJiYgdG9rZW4gPD0gOTI7XG59XG5mdW5jdGlvbiB0b2tlbklzT3BlcmF0b3IodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuID49IDM5ICYmIHRva2VuIDw9IDU5O1xufVxuZnVuY3Rpb24gdG9rZW5Jc1Bvc3RmaXgodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuID09PSAzNDtcbn1cbmZ1bmN0aW9uIHRva2VuSXNQcmVmaXgodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuUHJlZml4ZXNbdG9rZW5dO1xufVxuZnVuY3Rpb24gdG9rZW5Jc1RTVHlwZU9wZXJhdG9yKHRva2VuKSB7XG4gIHJldHVybiB0b2tlbiA+PSAxMjEgJiYgdG9rZW4gPD0gMTIzO1xufVxuZnVuY3Rpb24gdG9rZW5Jc1RTRGVjbGFyYXRpb25TdGFydCh0b2tlbikge1xuICByZXR1cm4gdG9rZW4gPj0gMTI0ICYmIHRva2VuIDw9IDEzMDtcbn1cbmZ1bmN0aW9uIHRva2VuTGFiZWxOYW1lKHRva2VuKSB7XG4gIHJldHVybiB0b2tlbkxhYmVsc1t0b2tlbl07XG59XG5mdW5jdGlvbiB0b2tlbk9wZXJhdG9yUHJlY2VkZW5jZSh0b2tlbikge1xuICByZXR1cm4gdG9rZW5CaW5vcHNbdG9rZW5dO1xufVxuZnVuY3Rpb24gdG9rZW5Jc1JpZ2h0QXNzb2NpYXRpdmUodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuID09PSA1Nztcbn1cbmZ1bmN0aW9uIHRva2VuSXNUZW1wbGF0ZSh0b2tlbikge1xuICByZXR1cm4gdG9rZW4gPj0gMjQgJiYgdG9rZW4gPD0gMjU7XG59XG5mdW5jdGlvbiBnZXRFeHBvcnRlZFRva2VuKHRva2VuKSB7XG4gIHJldHVybiB0b2tlblR5cGVzW3Rva2VuXTtcbn1cbntcbiAgdG9rZW5UeXBlc1s4XS51cGRhdGVDb250ZXh0ID0gY29udGV4dCA9PiB7XG4gICAgY29udGV4dC5wb3AoKTtcbiAgfTtcbiAgdG9rZW5UeXBlc1s1XS51cGRhdGVDb250ZXh0ID0gdG9rZW5UeXBlc1s3XS51cGRhdGVDb250ZXh0ID0gdG9rZW5UeXBlc1syM10udXBkYXRlQ29udGV4dCA9IGNvbnRleHQgPT4ge1xuICAgIGNvbnRleHQucHVzaCh0eXBlcy5icmFjZSk7XG4gIH07XG4gIHRva2VuVHlwZXNbMjJdLnVwZGF0ZUNvbnRleHQgPSBjb250ZXh0ID0+IHtcbiAgICBpZiAoY29udGV4dFtjb250ZXh0Lmxlbmd0aCAtIDFdID09PSB0eXBlcy50ZW1wbGF0ZSkge1xuICAgICAgY29udGV4dC5wb3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5wdXNoKHR5cGVzLnRlbXBsYXRlKTtcbiAgICB9XG4gIH07XG4gIHRva2VuVHlwZXNbMTQzXS51cGRhdGVDb250ZXh0ID0gY29udGV4dCA9PiB7XG4gICAgY29udGV4dC5wdXNoKHR5cGVzLmpfZXhwciwgdHlwZXMual9vVGFnKTtcbiAgfTtcbn1cbmxldCBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gXCJcXHhhYVxceGI1XFx4YmFcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJjMVxcdTAyYzYtXFx1MDJkMVxcdTAyZTAtXFx1MDJlNFxcdTAyZWNcXHUwMmVlXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdhLVxcdTAzN2RcXHUwMzdmXFx1MDM4NlxcdTAzODgtXFx1MDM4YVxcdTAzOGNcXHUwMzhlLVxcdTAzYTFcXHUwM2EzLVxcdTAzZjVcXHUwM2Y3LVxcdTA0ODFcXHUwNDhhLVxcdTA1MmZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MC1cXHUwNTg4XFx1MDVkMC1cXHUwNWVhXFx1MDVlZi1cXHUwNWYyXFx1MDYyMC1cXHUwNjRhXFx1MDY2ZVxcdTA2NmZcXHUwNjcxLVxcdTA2ZDNcXHUwNmQ1XFx1MDZlNVxcdTA2ZTZcXHUwNmVlXFx1MDZlZlxcdTA2ZmEtXFx1MDZmY1xcdTA2ZmZcXHUwNzEwXFx1MDcxMi1cXHUwNzJmXFx1MDc0ZC1cXHUwN2E1XFx1MDdiMVxcdTA3Y2EtXFx1MDdlYVxcdTA3ZjRcXHUwN2Y1XFx1MDdmYVxcdTA4MDAtXFx1MDgxNVxcdTA4MWFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4NjAtXFx1MDg2YVxcdTA4NzAtXFx1MDg4N1xcdTA4ODktXFx1MDg4ZVxcdTA4YTAtXFx1MDhjOVxcdTA5MDQtXFx1MDkzOVxcdTA5M2RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThjXFx1MDk4ZlxcdTA5OTBcXHUwOTkzLVxcdTA5YThcXHUwOWFhLVxcdTA5YjBcXHUwOWIyXFx1MDliNi1cXHUwOWI5XFx1MDliZFxcdTA5Y2VcXHUwOWRjXFx1MDlkZFxcdTA5ZGYtXFx1MDllMVxcdTA5ZjBcXHUwOWYxXFx1MDlmY1xcdTBhMDUtXFx1MGEwYVxcdTBhMGZcXHUwYTEwXFx1MGExMy1cXHUwYTI4XFx1MGEyYS1cXHUwYTMwXFx1MGEzMlxcdTBhMzNcXHUwYTM1XFx1MGEzNlxcdTBhMzhcXHUwYTM5XFx1MGE1OS1cXHUwYTVjXFx1MGE1ZVxcdTBhNzItXFx1MGE3NFxcdTBhODUtXFx1MGE4ZFxcdTBhOGYtXFx1MGE5MVxcdTBhOTMtXFx1MGFhOFxcdTBhYWEtXFx1MGFiMFxcdTBhYjJcXHUwYWIzXFx1MGFiNS1cXHUwYWI5XFx1MGFiZFxcdTBhZDBcXHUwYWUwXFx1MGFlMVxcdTBhZjlcXHUwYjA1LVxcdTBiMGNcXHUwYjBmXFx1MGIxMFxcdTBiMTMtXFx1MGIyOFxcdTBiMmEtXFx1MGIzMFxcdTBiMzJcXHUwYjMzXFx1MGIzNS1cXHUwYjM5XFx1MGIzZFxcdTBiNWNcXHUwYjVkXFx1MGI1Zi1cXHUwYjYxXFx1MGI3MVxcdTBiODNcXHUwYjg1LVxcdTBiOGFcXHUwYjhlLVxcdTBiOTBcXHUwYjkyLVxcdTBiOTVcXHUwYjk5XFx1MGI5YVxcdTBiOWNcXHUwYjllXFx1MGI5ZlxcdTBiYTNcXHUwYmE0XFx1MGJhOC1cXHUwYmFhXFx1MGJhZS1cXHUwYmI5XFx1MGJkMFxcdTBjMDUtXFx1MGMwY1xcdTBjMGUtXFx1MGMxMFxcdTBjMTItXFx1MGMyOFxcdTBjMmEtXFx1MGMzOVxcdTBjM2RcXHUwYzU4LVxcdTBjNWFcXHUwYzVkXFx1MGM2MFxcdTBjNjFcXHUwYzgwXFx1MGM4NS1cXHUwYzhjXFx1MGM4ZS1cXHUwYzkwXFx1MGM5Mi1cXHUwY2E4XFx1MGNhYS1cXHUwY2IzXFx1MGNiNS1cXHUwY2I5XFx1MGNiZFxcdTBjZGRcXHUwY2RlXFx1MGNlMFxcdTBjZTFcXHUwY2YxXFx1MGNmMlxcdTBkMDQtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2RcXHUwZDRlXFx1MGQ1NC1cXHUwZDU2XFx1MGQ1Zi1cXHUwZDYxXFx1MGQ3YS1cXHUwZDdmXFx1MGQ4NS1cXHUwZDk2XFx1MGQ5YS1cXHUwZGIxXFx1MGRiMy1cXHUwZGJiXFx1MGRiZFxcdTBkYzAtXFx1MGRjNlxcdTBlMDEtXFx1MGUzMFxcdTBlMzJcXHUwZTMzXFx1MGU0MC1cXHUwZTQ2XFx1MGU4MVxcdTBlODJcXHUwZTg0XFx1MGU4Ni1cXHUwZThhXFx1MGU4Yy1cXHUwZWEzXFx1MGVhNVxcdTBlYTctXFx1MGViMFxcdTBlYjJcXHUwZWIzXFx1MGViZFxcdTBlYzAtXFx1MGVjNFxcdTBlYzZcXHUwZWRjLVxcdTBlZGZcXHUwZjAwXFx1MGY0MC1cXHUwZjQ3XFx1MGY0OS1cXHUwZjZjXFx1MGY4OC1cXHUwZjhjXFx1MTAwMC1cXHUxMDJhXFx1MTAzZlxcdTEwNTAtXFx1MTA1NVxcdTEwNWEtXFx1MTA1ZFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNmUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOGVcXHUxMGEwLVxcdTEwYzVcXHUxMGM3XFx1MTBjZFxcdTEwZDAtXFx1MTBmYVxcdTEwZmMtXFx1MTI0OFxcdTEyNGEtXFx1MTI0ZFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVhLVxcdTEyNWRcXHUxMjYwLVxcdTEyODhcXHUxMjhhLVxcdTEyOGRcXHUxMjkwLVxcdTEyYjBcXHUxMmIyLVxcdTEyYjVcXHUxMmI4LVxcdTEyYmVcXHUxMmMwXFx1MTJjMi1cXHUxMmM1XFx1MTJjOC1cXHUxMmQ2XFx1MTJkOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVhXFx1MTM4MC1cXHUxMzhmXFx1MTNhMC1cXHUxM2Y1XFx1MTNmOC1cXHUxM2ZkXFx1MTQwMS1cXHUxNjZjXFx1MTY2Zi1cXHUxNjdmXFx1MTY4MS1cXHUxNjlhXFx1MTZhMC1cXHUxNmVhXFx1MTZlZS1cXHUxNmY4XFx1MTcwMC1cXHUxNzExXFx1MTcxZi1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZjXFx1MTc2ZS1cXHUxNzcwXFx1MTc4MC1cXHUxN2IzXFx1MTdkN1xcdTE3ZGNcXHUxODIwLVxcdTE4NzhcXHUxODgwLVxcdTE4YThcXHUxOGFhXFx1MThiMC1cXHUxOGY1XFx1MTkwMC1cXHUxOTFlXFx1MTk1MC1cXHUxOTZkXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOWFiXFx1MTliMC1cXHUxOWM5XFx1MWEwMC1cXHUxYTE2XFx1MWEyMC1cXHUxYTU0XFx1MWFhN1xcdTFiMDUtXFx1MWIzM1xcdTFiNDUtXFx1MWI0Y1xcdTFiODMtXFx1MWJhMFxcdTFiYWVcXHUxYmFmXFx1MWJiYS1cXHUxYmU1XFx1MWMwMC1cXHUxYzIzXFx1MWM0ZC1cXHUxYzRmXFx1MWM1YS1cXHUxYzdkXFx1MWM4MC1cXHUxYzhhXFx1MWM5MC1cXHUxY2JhXFx1MWNiZC1cXHUxY2JmXFx1MWNlOS1cXHUxY2VjXFx1MWNlZS1cXHUxY2YzXFx1MWNmNVxcdTFjZjZcXHUxY2ZhXFx1MWQwMC1cXHUxZGJmXFx1MWUwMC1cXHUxZjE1XFx1MWYxOC1cXHUxZjFkXFx1MWYyMC1cXHUxZjQ1XFx1MWY0OC1cXHUxZjRkXFx1MWY1MC1cXHUxZjU3XFx1MWY1OVxcdTFmNWJcXHUxZjVkXFx1MWY1Zi1cXHUxZjdkXFx1MWY4MC1cXHUxZmI0XFx1MWZiNi1cXHUxZmJjXFx1MWZiZVxcdTFmYzItXFx1MWZjNFxcdTFmYzYtXFx1MWZjY1xcdTFmZDAtXFx1MWZkM1xcdTFmZDYtXFx1MWZkYlxcdTFmZTAtXFx1MWZlY1xcdTFmZjItXFx1MWZmNFxcdTFmZjYtXFx1MWZmY1xcdTIwNzFcXHUyMDdmXFx1MjA5MC1cXHUyMDljXFx1MjEwMlxcdTIxMDdcXHUyMTBhLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFkXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyYS1cXHUyMTM5XFx1MjEzYy1cXHUyMTNmXFx1MjE0NS1cXHUyMTQ5XFx1MjE0ZVxcdTIxNjAtXFx1MjE4OFxcdTJjMDAtXFx1MmNlNFxcdTJjZWItXFx1MmNlZVxcdTJjZjJcXHUyY2YzXFx1MmQwMC1cXHUyZDI1XFx1MmQyN1xcdTJkMmRcXHUyZDMwLVxcdTJkNjdcXHUyZDZmXFx1MmQ4MC1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5Yi1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJmXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJmXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGJmXFx1NGUwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjFmXFx1YTYyYVxcdWE2MmJcXHVhNjQwLVxcdWE2NmVcXHVhNjdmLVxcdWE2OWRcXHVhNmEwLVxcdWE2ZWZcXHVhNzE3LVxcdWE3MWZcXHVhNzIyLVxcdWE3ODhcXHVhNzhiLVxcdWE3Y2RcXHVhN2QwXFx1YTdkMVxcdWE3ZDNcXHVhN2Q1LVxcdWE3ZGNcXHVhN2YyLVxcdWE4MDFcXHVhODAzLVxcdWE4MDVcXHVhODA3LVxcdWE4MGFcXHVhODBjLVxcdWE4MjJcXHVhODQwLVxcdWE4NzNcXHVhODgyLVxcdWE4YjNcXHVhOGYyLVxcdWE4ZjdcXHVhOGZiXFx1YThmZFxcdWE4ZmVcXHVhOTBhLVxcdWE5MjVcXHVhOTMwLVxcdWE5NDZcXHVhOTYwLVxcdWE5N2NcXHVhOTg0LVxcdWE5YjJcXHVhOWNmXFx1YTllMC1cXHVhOWU0XFx1YTllNi1cXHVhOWVmXFx1YTlmYS1cXHVhOWZlXFx1YWEwMC1cXHVhYTI4XFx1YWE0MC1cXHVhYTQyXFx1YWE0NC1cXHVhYTRiXFx1YWE2MC1cXHVhYTc2XFx1YWE3YVxcdWFhN2UtXFx1YWFhZlxcdWFhYjFcXHVhYWI1XFx1YWFiNlxcdWFhYjktXFx1YWFiZFxcdWFhYzBcXHVhYWMyXFx1YWFkYi1cXHVhYWRkXFx1YWFlMC1cXHVhYWVhXFx1YWFmMi1cXHVhYWY0XFx1YWIwMS1cXHVhYjA2XFx1YWIwOS1cXHVhYjBlXFx1YWIxMS1cXHVhYjE2XFx1YWIyMC1cXHVhYjI2XFx1YWIyOC1cXHVhYjJlXFx1YWIzMC1cXHVhYjVhXFx1YWI1Yy1cXHVhYjY5XFx1YWI3MC1cXHVhYmUyXFx1YWMwMC1cXHVkN2EzXFx1ZDdiMC1cXHVkN2M2XFx1ZDdjYi1cXHVkN2ZiXFx1ZjkwMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIwMC1cXHVmYjA2XFx1ZmIxMy1cXHVmYjE3XFx1ZmIxZFxcdWZiMWYtXFx1ZmIyOFxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwXFx1ZmI0MVxcdWZiNDNcXHVmYjQ0XFx1ZmI0Ni1cXHVmYmIxXFx1ZmJkMy1cXHVmZDNkXFx1ZmQ1MC1cXHVmZDhmXFx1ZmQ5Mi1cXHVmZGM3XFx1ZmRmMC1cXHVmZGZiXFx1ZmU3MC1cXHVmZTc0XFx1ZmU3Ni1cXHVmZWZjXFx1ZmYyMS1cXHVmZjNhXFx1ZmY0MS1cXHVmZjVhXFx1ZmY2Ni1cXHVmZmJlXFx1ZmZjMi1cXHVmZmM3XFx1ZmZjYS1cXHVmZmNmXFx1ZmZkMi1cXHVmZmQ3XFx1ZmZkYS1cXHVmZmRjXCI7XG5sZXQgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSBcIlxceGI3XFx1MDMwMC1cXHUwMzZmXFx1MDM4N1xcdTA0ODMtXFx1MDQ4N1xcdTA1OTEtXFx1MDViZFxcdTA1YmZcXHUwNWMxXFx1MDVjMlxcdTA1YzRcXHUwNWM1XFx1MDVjN1xcdTA2MTAtXFx1MDYxYVxcdTA2NGItXFx1MDY2OVxcdTA2NzBcXHUwNmQ2LVxcdTA2ZGNcXHUwNmRmLVxcdTA2ZTRcXHUwNmU3XFx1MDZlOFxcdTA2ZWEtXFx1MDZlZFxcdTA2ZjAtXFx1MDZmOVxcdTA3MTFcXHUwNzMwLVxcdTA3NGFcXHUwN2E2LVxcdTA3YjBcXHUwN2MwLVxcdTA3YzlcXHUwN2ViLVxcdTA3ZjNcXHUwN2ZkXFx1MDgxNi1cXHUwODE5XFx1MDgxYi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJkXFx1MDg1OS1cXHUwODViXFx1MDg5Ny1cXHUwODlmXFx1MDhjYS1cXHUwOGUxXFx1MDhlMy1cXHUwOTAzXFx1MDkzYS1cXHUwOTNjXFx1MDkzZS1cXHUwOTRmXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTY2LVxcdTA5NmZcXHUwOTgxLVxcdTA5ODNcXHUwOWJjXFx1MDliZS1cXHUwOWM0XFx1MDljN1xcdTA5YzhcXHUwOWNiLVxcdTA5Y2RcXHUwOWQ3XFx1MDllMlxcdTA5ZTNcXHUwOWU2LVxcdTA5ZWZcXHUwOWZlXFx1MGEwMS1cXHUwYTAzXFx1MGEzY1xcdTBhM2UtXFx1MGE0MlxcdTBhNDdcXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNjYtXFx1MGE3MVxcdTBhNzVcXHUwYTgxLVxcdTBhODNcXHUwYWJjXFx1MGFiZS1cXHUwYWM1XFx1MGFjNy1cXHUwYWM5XFx1MGFjYi1cXHUwYWNkXFx1MGFlMlxcdTBhZTNcXHUwYWU2LVxcdTBhZWZcXHUwYWZhLVxcdTBhZmZcXHUwYjAxLVxcdTBiMDNcXHUwYjNjXFx1MGIzZS1cXHUwYjQ0XFx1MGI0N1xcdTBiNDhcXHUwYjRiLVxcdTBiNGRcXHUwYjU1LVxcdTBiNTdcXHUwYjYyXFx1MGI2M1xcdTBiNjYtXFx1MGI2ZlxcdTBiODJcXHUwYmJlLVxcdTBiYzJcXHUwYmM2LVxcdTBiYzhcXHUwYmNhLVxcdTBiY2RcXHUwYmQ3XFx1MGJlNi1cXHUwYmVmXFx1MGMwMC1cXHUwYzA0XFx1MGMzY1xcdTBjM2UtXFx1MGM0NFxcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTVcXHUwYzU2XFx1MGM2MlxcdTBjNjNcXHUwYzY2LVxcdTBjNmZcXHUwYzgxLVxcdTBjODNcXHUwY2JjXFx1MGNiZS1cXHUwY2M0XFx1MGNjNi1cXHUwY2M4XFx1MGNjYS1cXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2UyXFx1MGNlM1xcdTBjZTYtXFx1MGNlZlxcdTBjZjNcXHUwZDAwLVxcdTBkMDNcXHUwZDNiXFx1MGQzY1xcdTBkM2UtXFx1MGQ0NFxcdTBkNDYtXFx1MGQ0OFxcdTBkNGEtXFx1MGQ0ZFxcdTBkNTdcXHUwZDYyXFx1MGQ2M1xcdTBkNjYtXFx1MGQ2ZlxcdTBkODEtXFx1MGQ4M1xcdTBkY2FcXHUwZGNmLVxcdTBkZDRcXHUwZGQ2XFx1MGRkOC1cXHUwZGRmXFx1MGRlNi1cXHUwZGVmXFx1MGRmMlxcdTBkZjNcXHUwZTMxXFx1MGUzNC1cXHUwZTNhXFx1MGU0Ny1cXHUwZTRlXFx1MGU1MC1cXHUwZTU5XFx1MGViMVxcdTBlYjQtXFx1MGViY1xcdTBlYzgtXFx1MGVjZVxcdTBlZDAtXFx1MGVkOVxcdTBmMThcXHUwZjE5XFx1MGYyMC1cXHUwZjI5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGYzZVxcdTBmM2ZcXHUwZjcxLVxcdTBmODRcXHUwZjg2XFx1MGY4N1xcdTBmOGQtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDJiLVxcdTEwM2VcXHUxMDQwLVxcdTEwNDlcXHUxMDU2LVxcdTEwNTlcXHUxMDVlLVxcdTEwNjBcXHUxMDYyLVxcdTEwNjRcXHUxMDY3LVxcdTEwNmRcXHUxMDcxLVxcdTEwNzRcXHUxMDgyLVxcdTEwOGRcXHUxMDhmLVxcdTEwOWRcXHUxMzVkLVxcdTEzNWZcXHUxMzY5LVxcdTEzNzFcXHUxNzEyLVxcdTE3MTVcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdiNC1cXHUxN2QzXFx1MTdkZFxcdTE3ZTAtXFx1MTdlOVxcdTE4MGItXFx1MTgwZFxcdTE4MGYtXFx1MTgxOVxcdTE4YTlcXHUxOTIwLVxcdTE5MmJcXHUxOTMwLVxcdTE5M2JcXHUxOTQ2LVxcdTE5NGZcXHUxOWQwLVxcdTE5ZGFcXHUxYTE3LVxcdTFhMWJcXHUxYTU1LVxcdTFhNWVcXHUxYTYwLVxcdTFhN2NcXHUxYTdmLVxcdTFhODlcXHUxYTkwLVxcdTFhOTlcXHUxYWIwLVxcdTFhYmRcXHUxYWJmLVxcdTFhY2VcXHUxYjAwLVxcdTFiMDRcXHUxYjM0LVxcdTFiNDRcXHUxYjUwLVxcdTFiNTlcXHUxYjZiLVxcdTFiNzNcXHUxYjgwLVxcdTFiODJcXHUxYmExLVxcdTFiYWRcXHUxYmIwLVxcdTFiYjlcXHUxYmU2LVxcdTFiZjNcXHUxYzI0LVxcdTFjMzdcXHUxYzQwLVxcdTFjNDlcXHUxYzUwLVxcdTFjNTlcXHUxY2QwLVxcdTFjZDJcXHUxY2Q0LVxcdTFjZThcXHUxY2VkXFx1MWNmNFxcdTFjZjctXFx1MWNmOVxcdTFkYzAtXFx1MWRmZlxcdTIwMGNcXHUyMDBkXFx1MjAzZlxcdTIwNDBcXHUyMDU0XFx1MjBkMC1cXHUyMGRjXFx1MjBlMVxcdTIwZTUtXFx1MjBmMFxcdTJjZWYtXFx1MmNmMVxcdTJkN2ZcXHUyZGUwLVxcdTJkZmZcXHUzMDJhLVxcdTMwMmZcXHUzMDk5XFx1MzA5YVxcdTMwZmJcXHVhNjIwLVxcdWE2MjlcXHVhNjZmXFx1YTY3NC1cXHVhNjdkXFx1YTY5ZVxcdWE2OWZcXHVhNmYwXFx1YTZmMVxcdWE4MDJcXHVhODA2XFx1YTgwYlxcdWE4MjMtXFx1YTgyN1xcdWE4MmNcXHVhODgwXFx1YTg4MVxcdWE4YjQtXFx1YThjNVxcdWE4ZDAtXFx1YThkOVxcdWE4ZTAtXFx1YThmMVxcdWE4ZmYtXFx1YTkwOVxcdWE5MjYtXFx1YTkyZFxcdWE5NDctXFx1YTk1M1xcdWE5ODAtXFx1YTk4M1xcdWE5YjMtXFx1YTljMFxcdWE5ZDAtXFx1YTlkOVxcdWE5ZTVcXHVhOWYwLVxcdWE5ZjlcXHVhYTI5LVxcdWFhMzZcXHVhYTQzXFx1YWE0Y1xcdWFhNGRcXHVhYTUwLVxcdWFhNTlcXHVhYTdiLVxcdWFhN2RcXHVhYWIwXFx1YWFiMi1cXHVhYWI0XFx1YWFiN1xcdWFhYjhcXHVhYWJlXFx1YWFiZlxcdWFhYzFcXHVhYWViLVxcdWFhZWZcXHVhYWY1XFx1YWFmNlxcdWFiZTMtXFx1YWJlYVxcdWFiZWNcXHVhYmVkXFx1YWJmMC1cXHVhYmY5XFx1ZmIxZVxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyZlxcdWZlMzNcXHVmZTM0XFx1ZmU0ZC1cXHVmZTRmXFx1ZmYxMC1cXHVmZjE5XFx1ZmYzZlxcdWZmNjVcIjtcbmNvbnN0IG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0ID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBcIl1cIik7XG5jb25zdCBub25BU0NJSWlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzICsgXCJdXCIpO1xubm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gbnVsbDtcbmNvbnN0IGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzID0gWzAsIDExLCAyLCAyNSwgMiwgMTgsIDIsIDEsIDIsIDE0LCAzLCAxMywgMzUsIDEyMiwgNzAsIDUyLCAyNjgsIDI4LCA0LCA0OCwgNDgsIDMxLCAxNCwgMjksIDYsIDM3LCAxMSwgMjksIDMsIDM1LCA1LCA3LCAyLCA0LCA0MywgMTU3LCAxOSwgMzUsIDUsIDM1LCA1LCAzOSwgOSwgNTEsIDEzLCAxMCwgMiwgMTQsIDIsIDYsIDIsIDEsIDIsIDEwLCAyLCAxNCwgMiwgNiwgMiwgMSwgNCwgNTEsIDEzLCAzMTAsIDEwLCAyMSwgMTEsIDcsIDI1LCA1LCAyLCA0MSwgMiwgOCwgNzAsIDUsIDMsIDAsIDIsIDQzLCAyLCAxLCA0LCAwLCAzLCAyMiwgMTEsIDIyLCAxMCwgMzAsIDY2LCAxOCwgMiwgMSwgMTEsIDIxLCAxMSwgMjUsIDcxLCA1NSwgNywgMSwgNjUsIDAsIDE2LCAzLCAyLCAyLCAyLCAyOCwgNDMsIDI4LCA0LCAyOCwgMzYsIDcsIDIsIDI3LCAyOCwgNTMsIDExLCAyMSwgMTEsIDE4LCAxNCwgMTcsIDExMSwgNzIsIDU2LCA1MCwgMTQsIDUwLCAxNCwgMzUsIDM5LCAyNywgMTAsIDIyLCAyNTEsIDQxLCA3LCAxLCAxNywgMiwgNjAsIDI4LCAxMSwgMCwgOSwgMjEsIDQzLCAxNywgNDcsIDIwLCAyOCwgMjIsIDEzLCA1MiwgNTgsIDEsIDMsIDAsIDE0LCA0NCwgMzMsIDI0LCAyNywgMzUsIDMwLCAwLCAzLCAwLCA5LCAzNCwgNCwgMCwgMTMsIDQ3LCAxNSwgMywgMjIsIDAsIDIsIDAsIDM2LCAxNywgMiwgMjQsIDIwLCAxLCA2NCwgNiwgMiwgMCwgMiwgMywgMiwgMTQsIDIsIDksIDgsIDQ2LCAzOSwgNywgMywgMSwgMywgMjEsIDIsIDYsIDIsIDEsIDIsIDQsIDQsIDAsIDE5LCAwLCAxMywgNCwgMzEsIDksIDIsIDAsIDMsIDAsIDIsIDM3LCAyLCAwLCAyNiwgMCwgMiwgMCwgNDUsIDUyLCAxOSwgMywgMjEsIDIsIDMxLCA0NywgMjEsIDEsIDIsIDAsIDE4NSwgNDYsIDQyLCAzLCAzNywgNDcsIDIxLCAwLCA2MCwgNDIsIDE0LCAwLCA3MiwgMjYsIDM4LCA2LCAxODYsIDQzLCAxMTcsIDYzLCAzMiwgNywgMywgMCwgMywgNywgMiwgMSwgMiwgMjMsIDE2LCAwLCAyLCAwLCA5NSwgNywgMywgMzgsIDE3LCAwLCAyLCAwLCAyOSwgMCwgMTEsIDM5LCA4LCAwLCAyMiwgMCwgMTIsIDQ1LCAyMCwgMCwgMTksIDcyLCAyMDAsIDMyLCAzMiwgOCwgMiwgMzYsIDE4LCAwLCA1MCwgMjksIDExMywgNiwgMiwgMSwgMiwgMzcsIDIyLCAwLCAyNiwgNSwgMiwgMSwgMiwgMzEsIDE1LCAwLCAzMjgsIDE4LCAxNiwgMCwgMiwgMTIsIDIsIDMzLCAxMjUsIDAsIDgwLCA5MjEsIDEwMywgMTEwLCAxOCwgMTk1LCAyNjM3LCA5NiwgMTYsIDEwNzEsIDE4LCA1LCAyNiwgMzk5NCwgNiwgNTgyLCA2ODQyLCAyOSwgMTc2MywgNTY4LCA4LCAzMCwgMTgsIDc4LCAxOCwgMjksIDE5LCA0NywgMTcsIDMsIDMyLCAyMCwgNiwgMTgsIDQzMywgNDQsIDIxMiwgNjMsIDEyOSwgNzQsIDYsIDAsIDY3LCAxMiwgNjUsIDEsIDIsIDAsIDI5LCA2MTM1LCA5LCAxMjM3LCA0MiwgOSwgODkzNiwgMywgMiwgNiwgMiwgMSwgMiwgMjkwLCAxNiwgMCwgMzAsIDIsIDMsIDAsIDE1LCAzLCA5LCAzOTUsIDIzMDksIDEwNiwgNiwgMTIsIDQsIDgsIDgsIDksIDU5OTEsIDg0LCAyLCA3MCwgMiwgMSwgMywgMCwgMywgMSwgMywgMywgMiwgMTEsIDIsIDAsIDIsIDYsIDIsIDY0LCAyLCAzLCAzLCA3LCAyLCA2LCAyLCAyNywgMiwgMywgMiwgNCwgMiwgMCwgNCwgNiwgMiwgMzM5LCAzLCAyNCwgMiwgMjQsIDIsIDMwLCAyLCAyNCwgMiwgMzAsIDIsIDI0LCAyLCAzMCwgMiwgMjQsIDIsIDMwLCAyLCAyNCwgMiwgNywgMTg0NSwgMzAsIDcsIDUsIDI2MiwgNjEsIDE0NywgNDQsIDExLCA2LCAxNywgMCwgMzIyLCAyOSwgMTksIDQzLCA0ODUsIDI3LCAyMjksIDI5LCAzLCAwLCA0OTYsIDYsIDIsIDMsIDIsIDEsIDIsIDE0LCAyLCAxOTYsIDYwLCA2NywgOCwgMCwgMTIwNSwgMywgMiwgMjYsIDIsIDEsIDIsIDAsIDMsIDAsIDIsIDksIDIsIDMsIDIsIDAsIDIsIDAsIDcsIDAsIDUsIDAsIDIsIDAsIDIsIDAsIDIsIDIsIDIsIDEsIDIsIDAsIDMsIDAsIDIsIDAsIDIsIDAsIDIsIDAsIDIsIDAsIDIsIDEsIDIsIDAsIDMsIDMsIDIsIDYsIDIsIDMsIDIsIDMsIDIsIDAsIDIsIDksIDIsIDE2LCA2LCAyLCAyLCA0LCAyLCAxNiwgNDQyMSwgNDI3MTksIDMzLCA0MTUzLCA3LCAyMjEsIDMsIDU3NjEsIDE1LCA3NDcyLCAxNiwgNjIxLCAyNDY3LCA1NDEsIDE1MDcsIDQ5MzgsIDYsIDQxOTFdO1xuY29uc3QgYXN0cmFsSWRlbnRpZmllckNvZGVzID0gWzUwOSwgMCwgMjI3LCAwLCAxNTAsIDQsIDI5NCwgOSwgMTM2OCwgMiwgMiwgMSwgNiwgMywgNDEsIDIsIDUsIDAsIDE2NiwgMSwgNTc0LCAzLCA5LCA5LCA3LCA5LCAzMiwgNCwgMzE4LCAxLCA4MCwgMywgNzEsIDEwLCA1MCwgMywgMTIzLCAyLCA1NCwgMTQsIDMyLCAxMCwgMywgMSwgMTEsIDMsIDQ2LCAxMCwgOCwgMCwgNDYsIDksIDcsIDIsIDM3LCAxMywgMiwgOSwgNiwgMSwgNDUsIDAsIDEzLCAyLCA0OSwgMTMsIDksIDMsIDIsIDExLCA4MywgMTEsIDcsIDAsIDMsIDAsIDE1OCwgMTEsIDYsIDksIDcsIDMsIDU2LCAxLCAyLCA2LCAzLCAxLCAzLCAyLCAxMCwgMCwgMTEsIDEsIDMsIDYsIDQsIDQsIDY4LCA4LCAyLCAwLCAzLCAwLCAyLCAzLCAyLCA0LCAyLCAwLCAxNSwgMSwgODMsIDE3LCAxMCwgOSwgNSwgMCwgODIsIDE5LCAxMywgOSwgMjE0LCA2LCAzLCA4LCAyOCwgMSwgODMsIDE2LCAxNiwgOSwgODIsIDEyLCA5LCA5LCA3LCAxOSwgNTgsIDE0LCA1LCA5LCAyNDMsIDE0LCAxNjYsIDksIDcxLCA1LCAyLCAxLCAzLCAzLCAyLCAwLCAyLCAxLCAxMywgOSwgMTIwLCA2LCAzLCA2LCA0LCAwLCAyOSwgOSwgNDEsIDYsIDIsIDMsIDksIDAsIDEwLCAxMCwgNDcsIDE1LCAzNDMsIDksIDU0LCA3LCAyLCA3LCAxNywgOSwgNTcsIDIxLCAyLCAxMywgMTIzLCA1LCA0LCAwLCAyLCAxLCAyLCA2LCAyLCAwLCA5LCA5LCA0OSwgNCwgMiwgMSwgMiwgNCwgOSwgOSwgMzMwLCAzLCAxMCwgMSwgMiwgMCwgNDksIDYsIDQsIDQsIDE0LCAxMCwgNTM1MCwgMCwgNywgMTQsIDExNDY1LCAyNywgMjM0MywgOSwgODcsIDksIDM5LCA0LCA2MCwgNiwgMjYsIDksIDUzNSwgOSwgNDcwLCAwLCAyLCA1NCwgOCwgMywgODIsIDAsIDEyLCAxLCAxOTYyOCwgMSwgNDE3OCwgOSwgNTE5LCA0NSwgMywgMjIsIDU0MywgNCwgNCwgNSwgOSwgNywgMywgNiwgMzEsIDMsIDE0OSwgMiwgMTQxOCwgNDksIDUxMywgNTQsIDUsIDQ5LCA5LCAwLCAxNSwgMCwgMjMsIDQsIDIsIDE0LCAxMzYxLCA2LCAyLCAxNiwgMywgNiwgMiwgMSwgMiwgNCwgMTAxLCAwLCAxNjEsIDYsIDEwLCA5LCAzNTcsIDAsIDYyLCAxMywgNDk5LCAxMywgMjQ1LCAxLCAyLCA5LCA3MjYsIDYsIDExMCwgNiwgNiwgOSwgNDc1OSwgOSwgNzg3NzE5LCAyMzldO1xuZnVuY3Rpb24gaXNJbkFzdHJhbFNldChjb2RlLCBzZXQpIHtcbiAgbGV0IHBvcyA9IDB4MTAwMDA7XG4gIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBzZXQubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDIpIHtcbiAgICBwb3MgKz0gc2V0W2ldO1xuICAgIGlmIChwb3MgPiBjb2RlKSByZXR1cm4gZmFsc2U7XG4gICAgcG9zICs9IHNldFtpICsgMV07XG4gICAgaWYgKHBvcyA+PSBjb2RlKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydChjb2RlKSB7XG4gIGlmIChjb2RlIDwgNjUpIHJldHVybiBjb2RlID09PSAzNjtcbiAgaWYgKGNvZGUgPD0gOTApIHJldHVybiB0cnVlO1xuICBpZiAoY29kZSA8IDk3KSByZXR1cm4gY29kZSA9PT0gOTU7XG4gIGlmIChjb2RlIDw9IDEyMikgcmV0dXJuIHRydWU7XG4gIGlmIChjb2RlIDw9IDB4ZmZmZikge1xuICAgIHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbiAgfVxuICByZXR1cm4gaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2Rlcyk7XG59XG5mdW5jdGlvbiBpc0lkZW50aWZpZXJDaGFyKGNvZGUpIHtcbiAgaWYgKGNvZGUgPCA0OCkgcmV0dXJuIGNvZGUgPT09IDM2O1xuICBpZiAoY29kZSA8IDU4KSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGNvZGUgPCA2NSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoY29kZSA8PSA5MCkgcmV0dXJuIHRydWU7XG4gIGlmIChjb2RlIDwgOTcpIHJldHVybiBjb2RlID09PSA5NTtcbiAgaWYgKGNvZGUgPD0gMTIyKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGNvZGUgPD0gMHhmZmZmKSB7XG4gICAgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXIudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbiAgfVxuICByZXR1cm4gaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcykgfHwgaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyQ29kZXMpO1xufVxuY29uc3QgcmVzZXJ2ZWRXb3JkcyA9IHtcbiAga2V5d29yZDogW1wiYnJlYWtcIiwgXCJjYXNlXCIsIFwiY2F0Y2hcIiwgXCJjb250aW51ZVwiLCBcImRlYnVnZ2VyXCIsIFwiZGVmYXVsdFwiLCBcImRvXCIsIFwiZWxzZVwiLCBcImZpbmFsbHlcIiwgXCJmb3JcIiwgXCJmdW5jdGlvblwiLCBcImlmXCIsIFwicmV0dXJuXCIsIFwic3dpdGNoXCIsIFwidGhyb3dcIiwgXCJ0cnlcIiwgXCJ2YXJcIiwgXCJjb25zdFwiLCBcIndoaWxlXCIsIFwid2l0aFwiLCBcIm5ld1wiLCBcInRoaXNcIiwgXCJzdXBlclwiLCBcImNsYXNzXCIsIFwiZXh0ZW5kc1wiLCBcImV4cG9ydFwiLCBcImltcG9ydFwiLCBcIm51bGxcIiwgXCJ0cnVlXCIsIFwiZmFsc2VcIiwgXCJpblwiLCBcImluc3RhbmNlb2ZcIiwgXCJ0eXBlb2ZcIiwgXCJ2b2lkXCIsIFwiZGVsZXRlXCJdLFxuICBzdHJpY3Q6IFtcImltcGxlbWVudHNcIiwgXCJpbnRlcmZhY2VcIiwgXCJsZXRcIiwgXCJwYWNrYWdlXCIsIFwicHJpdmF0ZVwiLCBcInByb3RlY3RlZFwiLCBcInB1YmxpY1wiLCBcInN0YXRpY1wiLCBcInlpZWxkXCJdLFxuICBzdHJpY3RCaW5kOiBbXCJldmFsXCIsIFwiYXJndW1lbnRzXCJdXG59O1xuY29uc3Qga2V5d29yZHMgPSBuZXcgU2V0KHJlc2VydmVkV29yZHMua2V5d29yZCk7XG5jb25zdCByZXNlcnZlZFdvcmRzU3RyaWN0U2V0ID0gbmV3IFNldChyZXNlcnZlZFdvcmRzLnN0cmljdCk7XG5jb25zdCByZXNlcnZlZFdvcmRzU3RyaWN0QmluZFNldCA9IG5ldyBTZXQocmVzZXJ2ZWRXb3Jkcy5zdHJpY3RCaW5kKTtcbmZ1bmN0aW9uIGlzUmVzZXJ2ZWRXb3JkKHdvcmQsIGluTW9kdWxlKSB7XG4gIHJldHVybiBpbk1vZHVsZSAmJiB3b3JkID09PSBcImF3YWl0XCIgfHwgd29yZCA9PT0gXCJlbnVtXCI7XG59XG5mdW5jdGlvbiBpc1N0cmljdFJlc2VydmVkV29yZCh3b3JkLCBpbk1vZHVsZSkge1xuICByZXR1cm4gaXNSZXNlcnZlZFdvcmQod29yZCwgaW5Nb2R1bGUpIHx8IHJlc2VydmVkV29yZHNTdHJpY3RTZXQuaGFzKHdvcmQpO1xufVxuZnVuY3Rpb24gaXNTdHJpY3RCaW5kT25seVJlc2VydmVkV29yZCh3b3JkKSB7XG4gIHJldHVybiByZXNlcnZlZFdvcmRzU3RyaWN0QmluZFNldC5oYXMod29yZCk7XG59XG5mdW5jdGlvbiBpc1N0cmljdEJpbmRSZXNlcnZlZFdvcmQod29yZCwgaW5Nb2R1bGUpIHtcbiAgcmV0dXJuIGlzU3RyaWN0UmVzZXJ2ZWRXb3JkKHdvcmQsIGluTW9kdWxlKSB8fCBpc1N0cmljdEJpbmRPbmx5UmVzZXJ2ZWRXb3JkKHdvcmQpO1xufVxuZnVuY3Rpb24gaXNLZXl3b3JkKHdvcmQpIHtcbiAgcmV0dXJuIGtleXdvcmRzLmhhcyh3b3JkKTtcbn1cbmZ1bmN0aW9uIGlzSXRlcmF0b3JTdGFydChjdXJyZW50LCBuZXh0LCBuZXh0Mikge1xuICByZXR1cm4gY3VycmVudCA9PT0gNjQgJiYgbmV4dCA9PT0gNjQgJiYgaXNJZGVudGlmaWVyU3RhcnQobmV4dDIpO1xufVxuY29uc3QgcmVzZXJ2ZWRXb3JkTGlrZVNldCA9IG5ldyBTZXQoW1wiYnJlYWtcIiwgXCJjYXNlXCIsIFwiY2F0Y2hcIiwgXCJjb250aW51ZVwiLCBcImRlYnVnZ2VyXCIsIFwiZGVmYXVsdFwiLCBcImRvXCIsIFwiZWxzZVwiLCBcImZpbmFsbHlcIiwgXCJmb3JcIiwgXCJmdW5jdGlvblwiLCBcImlmXCIsIFwicmV0dXJuXCIsIFwic3dpdGNoXCIsIFwidGhyb3dcIiwgXCJ0cnlcIiwgXCJ2YXJcIiwgXCJjb25zdFwiLCBcIndoaWxlXCIsIFwid2l0aFwiLCBcIm5ld1wiLCBcInRoaXNcIiwgXCJzdXBlclwiLCBcImNsYXNzXCIsIFwiZXh0ZW5kc1wiLCBcImV4cG9ydFwiLCBcImltcG9ydFwiLCBcIm51bGxcIiwgXCJ0cnVlXCIsIFwiZmFsc2VcIiwgXCJpblwiLCBcImluc3RhbmNlb2ZcIiwgXCJ0eXBlb2ZcIiwgXCJ2b2lkXCIsIFwiZGVsZXRlXCIsIFwiaW1wbGVtZW50c1wiLCBcImludGVyZmFjZVwiLCBcImxldFwiLCBcInBhY2thZ2VcIiwgXCJwcml2YXRlXCIsIFwicHJvdGVjdGVkXCIsIFwicHVibGljXCIsIFwic3RhdGljXCIsIFwieWllbGRcIiwgXCJldmFsXCIsIFwiYXJndW1lbnRzXCIsIFwiZW51bVwiLCBcImF3YWl0XCJdKTtcbmZ1bmN0aW9uIGNhbkJlUmVzZXJ2ZWRXb3JkKHdvcmQpIHtcbiAgcmV0dXJuIHJlc2VydmVkV29yZExpa2VTZXQuaGFzKHdvcmQpO1xufVxuY2xhc3MgU2NvcGUge1xuICBjb25zdHJ1Y3RvcihmbGFncykge1xuICAgIHRoaXMuZmxhZ3MgPSAwO1xuICAgIHRoaXMubmFtZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5maXJzdExleGljYWxOYW1lID0gXCJcIjtcbiAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gIH1cbn1cbmNsYXNzIFNjb3BlSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlciwgaW5Nb2R1bGUpIHtcbiAgICB0aGlzLnBhcnNlciA9IHZvaWQgMDtcbiAgICB0aGlzLnNjb3BlU3RhY2sgPSBbXTtcbiAgICB0aGlzLmluTW9kdWxlID0gdm9pZCAwO1xuICAgIHRoaXMudW5kZWZpbmVkRXhwb3J0cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLmluTW9kdWxlID0gaW5Nb2R1bGU7XG4gIH1cbiAgZ2V0IGluVG9wTGV2ZWwoKSB7XG4gICAgcmV0dXJuICh0aGlzLmN1cnJlbnRTY29wZSgpLmZsYWdzICYgMSkgPiAwO1xuICB9XG4gIGdldCBpbkZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5jdXJyZW50VmFyU2NvcGVGbGFncygpICYgMikgPiAwO1xuICB9XG4gIGdldCBhbGxvd1N1cGVyKCkge1xuICAgIHJldHVybiAodGhpcy5jdXJyZW50VGhpc1Njb3BlRmxhZ3MoKSAmIDE2KSA+IDA7XG4gIH1cbiAgZ2V0IGFsbG93RGlyZWN0U3VwZXIoKSB7XG4gICAgcmV0dXJuICh0aGlzLmN1cnJlbnRUaGlzU2NvcGVGbGFncygpICYgMzIpID4gMDtcbiAgfVxuICBnZXQgYWxsb3dOZXdUYXJnZXQoKSB7XG4gICAgcmV0dXJuICh0aGlzLmN1cnJlbnRUaGlzU2NvcGVGbGFncygpICYgNTEyKSA+IDA7XG4gIH1cbiAgZ2V0IGluQ2xhc3MoKSB7XG4gICAgcmV0dXJuICh0aGlzLmN1cnJlbnRUaGlzU2NvcGVGbGFncygpICYgNjQpID4gMDtcbiAgfVxuICBnZXQgaW5DbGFzc0FuZE5vdEluTm9uQXJyb3dGdW5jdGlvbigpIHtcbiAgICBjb25zdCBmbGFncyA9IHRoaXMuY3VycmVudFRoaXNTY29wZUZsYWdzKCk7XG4gICAgcmV0dXJuIChmbGFncyAmIDY0KSA+IDAgJiYgKGZsYWdzICYgMikgPT09IDA7XG4gIH1cbiAgZ2V0IGluU3RhdGljQmxvY2soKSB7XG4gICAgZm9yIChsZXQgaSA9IHRoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxOzsgaS0tKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZsYWdzXG4gICAgICB9ID0gdGhpcy5zY29wZVN0YWNrW2ldO1xuICAgICAgaWYgKGZsYWdzICYgMTI4KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGZsYWdzICYgKDE2NjcgfCA2NCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgaW5Ob25BcnJvd0Z1bmN0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5jdXJyZW50VGhpc1Njb3BlRmxhZ3MoKSAmIDIpID4gMDtcbiAgfVxuICBnZXQgaW5CYXJlQ2FzZVN0YXRlbWVudCgpIHtcbiAgICByZXR1cm4gKHRoaXMuY3VycmVudFNjb3BlKCkuZmxhZ3MgJiAyNTYpID4gMDtcbiAgfVxuICBnZXQgdHJlYXRGdW5jdGlvbnNBc1ZhcigpIHtcbiAgICByZXR1cm4gdGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZSh0aGlzLmN1cnJlbnRTY29wZSgpKTtcbiAgfVxuICBjcmVhdGVTY29wZShmbGFncykge1xuICAgIHJldHVybiBuZXcgU2NvcGUoZmxhZ3MpO1xuICB9XG4gIGVudGVyKGZsYWdzKSB7XG4gICAgdGhpcy5zY29wZVN0YWNrLnB1c2godGhpcy5jcmVhdGVTY29wZShmbGFncykpO1xuICB9XG4gIGV4aXQoKSB7XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzLnNjb3BlU3RhY2sucG9wKCk7XG4gICAgcmV0dXJuIHNjb3BlLmZsYWdzO1xuICB9XG4gIHRyZWF0RnVuY3Rpb25zQXNWYXJJblNjb3BlKHNjb3BlKSB7XG4gICAgcmV0dXJuICEhKHNjb3BlLmZsYWdzICYgKDIgfCAxMjgpIHx8ICF0aGlzLnBhcnNlci5pbk1vZHVsZSAmJiBzY29wZS5mbGFncyAmIDEpO1xuICB9XG4gIGRlY2xhcmVOYW1lKG5hbWUsIGJpbmRpbmdUeXBlLCBsb2MpIHtcbiAgICBsZXQgc2NvcGUgPSB0aGlzLmN1cnJlbnRTY29wZSgpO1xuICAgIGlmIChiaW5kaW5nVHlwZSAmIDggfHwgYmluZGluZ1R5cGUgJiAxNikge1xuICAgICAgdGhpcy5jaGVja1JlZGVjbGFyYXRpb25JblNjb3BlKHNjb3BlLCBuYW1lLCBiaW5kaW5nVHlwZSwgbG9jKTtcbiAgICAgIGxldCB0eXBlID0gc2NvcGUubmFtZXMuZ2V0KG5hbWUpIHx8IDA7XG4gICAgICBpZiAoYmluZGluZ1R5cGUgJiAxNikge1xuICAgICAgICB0eXBlID0gdHlwZSB8IDQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXNjb3BlLmZpcnN0TGV4aWNhbE5hbWUpIHtcbiAgICAgICAgICBzY29wZS5maXJzdExleGljYWxOYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICB0eXBlID0gdHlwZSB8IDI7XG4gICAgICB9XG4gICAgICBzY29wZS5uYW1lcy5zZXQobmFtZSwgdHlwZSk7XG4gICAgICBpZiAoYmluZGluZ1R5cGUgJiA4KSB7XG4gICAgICAgIHRoaXMubWF5YmVFeHBvcnREZWZpbmVkKHNjb3BlLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGJpbmRpbmdUeXBlICYgNCkge1xuICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBzY29wZSA9IHRoaXMuc2NvcGVTdGFja1tpXTtcbiAgICAgICAgdGhpcy5jaGVja1JlZGVjbGFyYXRpb25JblNjb3BlKHNjb3BlLCBuYW1lLCBiaW5kaW5nVHlwZSwgbG9jKTtcbiAgICAgICAgc2NvcGUubmFtZXMuc2V0KG5hbWUsIChzY29wZS5uYW1lcy5nZXQobmFtZSkgfHwgMCkgfCAxKTtcbiAgICAgICAgdGhpcy5tYXliZUV4cG9ydERlZmluZWQoc2NvcGUsIG5hbWUpO1xuICAgICAgICBpZiAoc2NvcGUuZmxhZ3MgJiAxNjY3KSBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMucGFyc2VyLmluTW9kdWxlICYmIHNjb3BlLmZsYWdzICYgMSkge1xuICAgICAgdGhpcy51bmRlZmluZWRFeHBvcnRzLmRlbGV0ZShuYW1lKTtcbiAgICB9XG4gIH1cbiAgbWF5YmVFeHBvcnREZWZpbmVkKHNjb3BlLCBuYW1lKSB7XG4gICAgaWYgKHRoaXMucGFyc2VyLmluTW9kdWxlICYmIHNjb3BlLmZsYWdzICYgMSkge1xuICAgICAgdGhpcy51bmRlZmluZWRFeHBvcnRzLmRlbGV0ZShuYW1lKTtcbiAgICB9XG4gIH1cbiAgY2hlY2tSZWRlY2xhcmF0aW9uSW5TY29wZShzY29wZSwgbmFtZSwgYmluZGluZ1R5cGUsIGxvYykge1xuICAgIGlmICh0aGlzLmlzUmVkZWNsYXJlZEluU2NvcGUoc2NvcGUsIG5hbWUsIGJpbmRpbmdUeXBlKSkge1xuICAgICAgdGhpcy5wYXJzZXIucmFpc2UoRXJyb3JzLlZhclJlZGVjbGFyYXRpb24sIGxvYywge1xuICAgICAgICBpZGVudGlmaWVyTmFtZTogbmFtZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlzUmVkZWNsYXJlZEluU2NvcGUoc2NvcGUsIG5hbWUsIGJpbmRpbmdUeXBlKSB7XG4gICAgaWYgKCEoYmluZGluZ1R5cGUgJiAxKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChiaW5kaW5nVHlwZSAmIDgpIHtcbiAgICAgIHJldHVybiBzY29wZS5uYW1lcy5oYXMobmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSBzY29wZS5uYW1lcy5nZXQobmFtZSk7XG4gICAgaWYgKGJpbmRpbmdUeXBlICYgMTYpIHtcbiAgICAgIHJldHVybiAodHlwZSAmIDIpID4gMCB8fCAhdGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZShzY29wZSkgJiYgKHR5cGUgJiAxKSA+IDA7XG4gICAgfVxuICAgIHJldHVybiAodHlwZSAmIDIpID4gMCAmJiAhKHNjb3BlLmZsYWdzICYgOCAmJiBzY29wZS5maXJzdExleGljYWxOYW1lID09PSBuYW1lKSB8fCAhdGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZShzY29wZSkgJiYgKHR5cGUgJiA0KSA+IDA7XG4gIH1cbiAgY2hlY2tMb2NhbEV4cG9ydChpZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG5hbWVcbiAgICB9ID0gaWQ7XG4gICAgY29uc3QgdG9wTGV2ZWxTY29wZSA9IHRoaXMuc2NvcGVTdGFja1swXTtcbiAgICBpZiAoIXRvcExldmVsU2NvcGUubmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICB0aGlzLnVuZGVmaW5lZEV4cG9ydHMuc2V0KG5hbWUsIGlkLmxvYy5zdGFydCk7XG4gICAgfVxuICB9XG4gIGN1cnJlbnRTY29wZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zY29wZVN0YWNrW3RoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxXTtcbiAgfVxuICBjdXJyZW50VmFyU2NvcGVGbGFncygpIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDE7OyBpLS0pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZmxhZ3NcbiAgICAgIH0gPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgICBpZiAoZmxhZ3MgJiAxNjY3KSB7XG4gICAgICAgIHJldHVybiBmbGFncztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY3VycmVudFRoaXNTY29wZUZsYWdzKCkge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTs7IGktLSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBmbGFnc1xuICAgICAgfSA9IHRoaXMuc2NvcGVTdGFja1tpXTtcbiAgICAgIGlmIChmbGFncyAmICgxNjY3IHwgNjQpICYmICEoZmxhZ3MgJiA0KSkge1xuICAgICAgICByZXR1cm4gZmxhZ3M7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5jbGFzcyBGbG93U2NvcGUgZXh0ZW5kcyBTY29wZSB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICB0aGlzLmRlY2xhcmVGdW5jdGlvbnMgPSBuZXcgU2V0KCk7XG4gIH1cbn1cbmNsYXNzIEZsb3dTY29wZUhhbmRsZXIgZXh0ZW5kcyBTY29wZUhhbmRsZXIge1xuICBjcmVhdGVTY29wZShmbGFncykge1xuICAgIHJldHVybiBuZXcgRmxvd1Njb3BlKGZsYWdzKTtcbiAgfVxuICBkZWNsYXJlTmFtZShuYW1lLCBiaW5kaW5nVHlwZSwgbG9jKSB7XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzLmN1cnJlbnRTY29wZSgpO1xuICAgIGlmIChiaW5kaW5nVHlwZSAmIDIwNDgpIHtcbiAgICAgIHRoaXMuY2hlY2tSZWRlY2xhcmF0aW9uSW5TY29wZShzY29wZSwgbmFtZSwgYmluZGluZ1R5cGUsIGxvYyk7XG4gICAgICB0aGlzLm1heWJlRXhwb3J0RGVmaW5lZChzY29wZSwgbmFtZSk7XG4gICAgICBzY29wZS5kZWNsYXJlRnVuY3Rpb25zLmFkZChuYW1lKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIuZGVjbGFyZU5hbWUobmFtZSwgYmluZGluZ1R5cGUsIGxvYyk7XG4gIH1cbiAgaXNSZWRlY2xhcmVkSW5TY29wZShzY29wZSwgbmFtZSwgYmluZGluZ1R5cGUpIHtcbiAgICBpZiAoc3VwZXIuaXNSZWRlY2xhcmVkSW5TY29wZShzY29wZSwgbmFtZSwgYmluZGluZ1R5cGUpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoYmluZGluZ1R5cGUgJiAyMDQ4ICYmICFzY29wZS5kZWNsYXJlRnVuY3Rpb25zLmhhcyhuYW1lKSkge1xuICAgICAgY29uc3QgdHlwZSA9IHNjb3BlLm5hbWVzLmdldChuYW1lKTtcbiAgICAgIHJldHVybiAodHlwZSAmIDQpID4gMCB8fCAodHlwZSAmIDIpID4gMDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNoZWNrTG9jYWxFeHBvcnQoaWQpIHtcbiAgICBpZiAoIXRoaXMuc2NvcGVTdGFja1swXS5kZWNsYXJlRnVuY3Rpb25zLmhhcyhpZC5uYW1lKSkge1xuICAgICAgc3VwZXIuY2hlY2tMb2NhbEV4cG9ydChpZCk7XG4gICAgfVxuICB9XG59XG5jb25zdCByZXNlcnZlZFR5cGVzID0gbmV3IFNldChbXCJfXCIsIFwiYW55XCIsIFwiYm9vbFwiLCBcImJvb2xlYW5cIiwgXCJlbXB0eVwiLCBcImV4dGVuZHNcIiwgXCJmYWxzZVwiLCBcImludGVyZmFjZVwiLCBcIm1peGVkXCIsIFwibnVsbFwiLCBcIm51bWJlclwiLCBcInN0YXRpY1wiLCBcInN0cmluZ1wiLCBcInRydWVcIiwgXCJ0eXBlb2ZcIiwgXCJ2b2lkXCJdKTtcbmNvbnN0IEZsb3dFcnJvcnMgPSBQYXJzZUVycm9yRW51bWBmbG93YCh7XG4gIEFtYmlndW91c0NvbmRpdGlvbmFsQXJyb3c6IFwiQW1iaWd1b3VzIGV4cHJlc3Npb246IHdyYXAgdGhlIGFycm93IGZ1bmN0aW9ucyBpbiBwYXJlbnRoZXNlcyB0byBkaXNhbWJpZ3VhdGUuXCIsXG4gIEFtYmlndW91c0RlY2xhcmVNb2R1bGVLaW5kOiBcIkZvdW5kIGJvdGggYGRlY2xhcmUgbW9kdWxlLmV4cG9ydHNgIGFuZCBgZGVjbGFyZSBleHBvcnRgIGluIHRoZSBzYW1lIG1vZHVsZS4gTW9kdWxlcyBjYW4gb25seSBoYXZlIDEgc2luY2UgdGhleSBhcmUgZWl0aGVyIGFuIEVTIG1vZHVsZSBvciB0aGV5IGFyZSBhIENvbW1vbkpTIG1vZHVsZS5cIixcbiAgQXNzaWduUmVzZXJ2ZWRUeXBlOiAoe1xuICAgIHJlc2VydmVkVHlwZVxuICB9KSA9PiBgQ2Fubm90IG92ZXJ3cml0ZSByZXNlcnZlZCB0eXBlICR7cmVzZXJ2ZWRUeXBlfS5gLFxuICBEZWNsYXJlQ2xhc3NFbGVtZW50OiBcIlRoZSBgZGVjbGFyZWAgbW9kaWZpZXIgY2FuIG9ubHkgYXBwZWFyIG9uIGNsYXNzIGZpZWxkcy5cIixcbiAgRGVjbGFyZUNsYXNzRmllbGRJbml0aWFsaXplcjogXCJJbml0aWFsaXplcnMgYXJlIG5vdCBhbGxvd2VkIGluIGZpZWxkcyB3aXRoIHRoZSBgZGVjbGFyZWAgbW9kaWZpZXIuXCIsXG4gIER1cGxpY2F0ZURlY2xhcmVNb2R1bGVFeHBvcnRzOiBcIkR1cGxpY2F0ZSBgZGVjbGFyZSBtb2R1bGUuZXhwb3J0c2Agc3RhdGVtZW50LlwiLFxuICBFbnVtQm9vbGVhbk1lbWJlck5vdEluaXRpYWxpemVkOiAoe1xuICAgIG1lbWJlck5hbWUsXG4gICAgZW51bU5hbWVcbiAgfSkgPT4gYEJvb2xlYW4gZW51bSBtZW1iZXJzIG5lZWQgdG8gYmUgaW5pdGlhbGl6ZWQuIFVzZSBlaXRoZXIgXFxgJHttZW1iZXJOYW1lfSA9IHRydWUsXFxgIG9yIFxcYCR7bWVtYmVyTmFtZX0gPSBmYWxzZSxcXGAgaW4gZW51bSBcXGAke2VudW1OYW1lfVxcYC5gLFxuICBFbnVtRHVwbGljYXRlTWVtYmVyTmFtZTogKHtcbiAgICBtZW1iZXJOYW1lLFxuICAgIGVudW1OYW1lXG4gIH0pID0+IGBFbnVtIG1lbWJlciBuYW1lcyBuZWVkIHRvIGJlIHVuaXF1ZSwgYnV0IHRoZSBuYW1lIFxcYCR7bWVtYmVyTmFtZX1cXGAgaGFzIGFscmVhZHkgYmVlbiB1c2VkIGJlZm9yZSBpbiBlbnVtIFxcYCR7ZW51bU5hbWV9XFxgLmAsXG4gIEVudW1JbmNvbnNpc3RlbnRNZW1iZXJWYWx1ZXM6ICh7XG4gICAgZW51bU5hbWVcbiAgfSkgPT4gYEVudW0gXFxgJHtlbnVtTmFtZX1cXGAgaGFzIGluY29uc2lzdGVudCBtZW1iZXIgaW5pdGlhbGl6ZXJzLiBFaXRoZXIgdXNlIG5vIGluaXRpYWxpemVycywgb3IgY29uc2lzdGVudGx5IHVzZSBsaXRlcmFscyAoZWl0aGVyIGJvb2xlYW5zLCBudW1iZXJzLCBvciBzdHJpbmdzKSBmb3IgYWxsIG1lbWJlciBpbml0aWFsaXplcnMuYCxcbiAgRW51bUludmFsaWRFeHBsaWNpdFR5cGU6ICh7XG4gICAgaW52YWxpZEVudW1UeXBlLFxuICAgIGVudW1OYW1lXG4gIH0pID0+IGBFbnVtIHR5cGUgXFxgJHtpbnZhbGlkRW51bVR5cGV9XFxgIGlzIG5vdCB2YWxpZC4gVXNlIG9uZSBvZiBcXGBib29sZWFuXFxgLCBcXGBudW1iZXJcXGAsIFxcYHN0cmluZ1xcYCwgb3IgXFxgc3ltYm9sXFxgIGluIGVudW0gXFxgJHtlbnVtTmFtZX1cXGAuYCxcbiAgRW51bUludmFsaWRFeHBsaWNpdFR5cGVVbmtub3duU3VwcGxpZWQ6ICh7XG4gICAgZW51bU5hbWVcbiAgfSkgPT4gYFN1cHBsaWVkIGVudW0gdHlwZSBpcyBub3QgdmFsaWQuIFVzZSBvbmUgb2YgXFxgYm9vbGVhblxcYCwgXFxgbnVtYmVyXFxgLCBcXGBzdHJpbmdcXGAsIG9yIFxcYHN5bWJvbFxcYCBpbiBlbnVtIFxcYCR7ZW51bU5hbWV9XFxgLmAsXG4gIEVudW1JbnZhbGlkTWVtYmVySW5pdGlhbGl6ZXJQcmltYXJ5VHlwZTogKHtcbiAgICBlbnVtTmFtZSxcbiAgICBtZW1iZXJOYW1lLFxuICAgIGV4cGxpY2l0VHlwZVxuICB9KSA9PiBgRW51bSBcXGAke2VudW1OYW1lfVxcYCBoYXMgdHlwZSBcXGAke2V4cGxpY2l0VHlwZX1cXGAsIHNvIHRoZSBpbml0aWFsaXplciBvZiBcXGAke21lbWJlck5hbWV9XFxgIG5lZWRzIHRvIGJlIGEgJHtleHBsaWNpdFR5cGV9IGxpdGVyYWwuYCxcbiAgRW51bUludmFsaWRNZW1iZXJJbml0aWFsaXplclN5bWJvbFR5cGU6ICh7XG4gICAgZW51bU5hbWUsXG4gICAgbWVtYmVyTmFtZVxuICB9KSA9PiBgU3ltYm9sIGVudW0gbWVtYmVycyBjYW5ub3QgYmUgaW5pdGlhbGl6ZWQuIFVzZSBcXGAke21lbWJlck5hbWV9LFxcYCBpbiBlbnVtIFxcYCR7ZW51bU5hbWV9XFxgLmAsXG4gIEVudW1JbnZhbGlkTWVtYmVySW5pdGlhbGl6ZXJVbmtub3duVHlwZTogKHtcbiAgICBlbnVtTmFtZSxcbiAgICBtZW1iZXJOYW1lXG4gIH0pID0+IGBUaGUgZW51bSBtZW1iZXIgaW5pdGlhbGl6ZXIgZm9yIFxcYCR7bWVtYmVyTmFtZX1cXGAgbmVlZHMgdG8gYmUgYSBsaXRlcmFsIChlaXRoZXIgYSBib29sZWFuLCBudW1iZXIsIG9yIHN0cmluZykgaW4gZW51bSBcXGAke2VudW1OYW1lfVxcYC5gLFxuICBFbnVtSW52YWxpZE1lbWJlck5hbWU6ICh7XG4gICAgZW51bU5hbWUsXG4gICAgbWVtYmVyTmFtZSxcbiAgICBzdWdnZXN0aW9uXG4gIH0pID0+IGBFbnVtIG1lbWJlciBuYW1lcyBjYW5ub3Qgc3RhcnQgd2l0aCBsb3dlcmNhc2UgJ2EnIHRocm91Z2ggJ3onLiBJbnN0ZWFkIG9mIHVzaW5nIFxcYCR7bWVtYmVyTmFtZX1cXGAsIGNvbnNpZGVyIHVzaW5nIFxcYCR7c3VnZ2VzdGlvbn1cXGAsIGluIGVudW0gXFxgJHtlbnVtTmFtZX1cXGAuYCxcbiAgRW51bU51bWJlck1lbWJlck5vdEluaXRpYWxpemVkOiAoe1xuICAgIGVudW1OYW1lLFxuICAgIG1lbWJlck5hbWVcbiAgfSkgPT4gYE51bWJlciBlbnVtIG1lbWJlcnMgbmVlZCB0byBiZSBpbml0aWFsaXplZCwgZS5nLiBcXGAke21lbWJlck5hbWV9ID0gMVxcYCBpbiBlbnVtIFxcYCR7ZW51bU5hbWV9XFxgLmAsXG4gIEVudW1TdHJpbmdNZW1iZXJJbmNvbnNpc3RlbnRseUluaXRpYWxpemVkOiAoe1xuICAgIGVudW1OYW1lXG4gIH0pID0+IGBTdHJpbmcgZW51bSBtZW1iZXJzIG5lZWQgdG8gY29uc2lzdGVudGx5IGVpdGhlciBhbGwgdXNlIGluaXRpYWxpemVycywgb3IgdXNlIG5vIGluaXRpYWxpemVycywgaW4gZW51bSBcXGAke2VudW1OYW1lfVxcYC5gLFxuICBHZXR0ZXJNYXlOb3RIYXZlVGhpc1BhcmFtOiBcIkEgZ2V0dGVyIGNhbm5vdCBoYXZlIGEgYHRoaXNgIHBhcmFtZXRlci5cIixcbiAgSW1wb3J0UmVmbGVjdGlvbkhhc0ltcG9ydFR5cGU6IFwiQW4gYGltcG9ydCBtb2R1bGVgIGRlY2xhcmF0aW9uIGNhbiBub3QgdXNlIGB0eXBlYCBvciBgdHlwZW9mYCBrZXl3b3JkLlwiLFxuICBJbXBvcnRUeXBlU2hvcnRoYW5kT25seUluUHVyZUltcG9ydDogXCJUaGUgYHR5cGVgIGFuZCBgdHlwZW9mYCBrZXl3b3JkcyBvbiBuYW1lZCBpbXBvcnRzIGNhbiBvbmx5IGJlIHVzZWQgb24gcmVndWxhciBgaW1wb3J0YCBzdGF0ZW1lbnRzLiBJdCBjYW5ub3QgYmUgdXNlZCB3aXRoIGBpbXBvcnQgdHlwZWAgb3IgYGltcG9ydCB0eXBlb2ZgIHN0YXRlbWVudHMuXCIsXG4gIEluZXhhY3RJbnNpZGVFeGFjdDogXCJFeHBsaWNpdCBpbmV4YWN0IHN5bnRheCBjYW5ub3QgYXBwZWFyIGluc2lkZSBhbiBleHBsaWNpdCBleGFjdCBvYmplY3QgdHlwZS5cIixcbiAgSW5leGFjdEluc2lkZU5vbk9iamVjdDogXCJFeHBsaWNpdCBpbmV4YWN0IHN5bnRheCBjYW5ub3QgYXBwZWFyIGluIGNsYXNzIG9yIGludGVyZmFjZSBkZWZpbml0aW9ucy5cIixcbiAgSW5leGFjdFZhcmlhbmNlOiBcIkV4cGxpY2l0IGluZXhhY3Qgc3ludGF4IGNhbm5vdCBoYXZlIHZhcmlhbmNlLlwiLFxuICBJbnZhbGlkTm9uVHlwZUltcG9ydEluRGVjbGFyZU1vZHVsZTogXCJJbXBvcnRzIHdpdGhpbiBhIGBkZWNsYXJlIG1vZHVsZWAgYm9keSBtdXN0IGFsd2F5cyBiZSBgaW1wb3J0IHR5cGVgIG9yIGBpbXBvcnQgdHlwZW9mYC5cIixcbiAgTWlzc2luZ1R5cGVQYXJhbURlZmF1bHQ6IFwiVHlwZSBwYXJhbWV0ZXIgZGVjbGFyYXRpb24gbmVlZHMgYSBkZWZhdWx0LCBzaW5jZSBhIHByZWNlZGluZyB0eXBlIHBhcmFtZXRlciBkZWNsYXJhdGlvbiBoYXMgYSBkZWZhdWx0LlwiLFxuICBOZXN0ZWREZWNsYXJlTW9kdWxlOiBcImBkZWNsYXJlIG1vZHVsZWAgY2Fubm90IGJlIHVzZWQgaW5zaWRlIGFub3RoZXIgYGRlY2xhcmUgbW9kdWxlYC5cIixcbiAgTmVzdGVkRmxvd0NvbW1lbnQ6IFwiQ2Fubm90IGhhdmUgYSBmbG93IGNvbW1lbnQgaW5zaWRlIGFub3RoZXIgZmxvdyBjb21tZW50LlwiLFxuICBQYXR0ZXJuSXNPcHRpb25hbDogT2JqZWN0LmFzc2lnbih7XG4gICAgbWVzc2FnZTogXCJBIGJpbmRpbmcgcGF0dGVybiBwYXJhbWV0ZXIgY2Fubm90IGJlIG9wdGlvbmFsIGluIGFuIGltcGxlbWVudGF0aW9uIHNpZ25hdHVyZS5cIlxuICB9LCB7XG4gICAgcmVhc29uQ29kZTogXCJPcHRpb25hbEJpbmRpbmdQYXR0ZXJuXCJcbiAgfSksXG4gIFNldHRlck1heU5vdEhhdmVUaGlzUGFyYW06IFwiQSBzZXR0ZXIgY2Fubm90IGhhdmUgYSBgdGhpc2AgcGFyYW1ldGVyLlwiLFxuICBTcHJlYWRWYXJpYW5jZTogXCJTcHJlYWQgcHJvcGVydGllcyBjYW5ub3QgaGF2ZSB2YXJpYW5jZS5cIixcbiAgVGhpc1BhcmFtQW5ub3RhdGlvblJlcXVpcmVkOiBcIkEgdHlwZSBhbm5vdGF0aW9uIGlzIHJlcXVpcmVkIGZvciB0aGUgYHRoaXNgIHBhcmFtZXRlci5cIixcbiAgVGhpc1BhcmFtQmFubmVkSW5Db25zdHJ1Y3RvcjogXCJDb25zdHJ1Y3RvcnMgY2Fubm90IGhhdmUgYSBgdGhpc2AgcGFyYW1ldGVyOyBjb25zdHJ1Y3RvcnMgZG9uJ3QgYmluZCBgdGhpc2AgbGlrZSBvdGhlciBmdW5jdGlvbnMuXCIsXG4gIFRoaXNQYXJhbU1heU5vdEJlT3B0aW9uYWw6IFwiVGhlIGB0aGlzYCBwYXJhbWV0ZXIgY2Fubm90IGJlIG9wdGlvbmFsLlwiLFxuICBUaGlzUGFyYW1NdXN0QmVGaXJzdDogXCJUaGUgYHRoaXNgIHBhcmFtZXRlciBtdXN0IGJlIHRoZSBmaXJzdCBmdW5jdGlvbiBwYXJhbWV0ZXIuXCIsXG4gIFRoaXNQYXJhbU5vRGVmYXVsdDogXCJUaGUgYHRoaXNgIHBhcmFtZXRlciBtYXkgbm90IGhhdmUgYSBkZWZhdWx0IHZhbHVlLlwiLFxuICBUeXBlQmVmb3JlSW5pdGlhbGl6ZXI6IFwiVHlwZSBhbm5vdGF0aW9ucyBtdXN0IGNvbWUgYmVmb3JlIGRlZmF1bHQgYXNzaWdubWVudHMsIGUuZy4gaW5zdGVhZCBvZiBgYWdlID0gMjU6IG51bWJlcmAgdXNlIGBhZ2U6IG51bWJlciA9IDI1YC5cIixcbiAgVHlwZUNhc3RJblBhdHRlcm46IFwiVGhlIHR5cGUgY2FzdCBleHByZXNzaW9uIGlzIGV4cGVjdGVkIHRvIGJlIHdyYXBwZWQgd2l0aCBwYXJlbnRoZXNpcy5cIixcbiAgVW5leHBlY3RlZEV4cGxpY2l0SW5leGFjdEluT2JqZWN0OiBcIkV4cGxpY2l0IGluZXhhY3Qgc3ludGF4IG11c3QgYXBwZWFyIGF0IHRoZSBlbmQgb2YgYW4gaW5leGFjdCBvYmplY3QuXCIsXG4gIFVuZXhwZWN0ZWRSZXNlcnZlZFR5cGU6ICh7XG4gICAgcmVzZXJ2ZWRUeXBlXG4gIH0pID0+IGBVbmV4cGVjdGVkIHJlc2VydmVkIHR5cGUgJHtyZXNlcnZlZFR5cGV9LmAsXG4gIFVuZXhwZWN0ZWRSZXNlcnZlZFVuZGVyc2NvcmU6IFwiYF9gIGlzIG9ubHkgYWxsb3dlZCBhcyBhIHR5cGUgYXJndW1lbnQgdG8gY2FsbCBvciBuZXcuXCIsXG4gIFVuZXhwZWN0ZWRTcGFjZUJldHdlZW5Nb2R1bG9DaGVja3M6IFwiU3BhY2VzIGJldHdlZW4gYCVgIGFuZCBgY2hlY2tzYCBhcmUgbm90IGFsbG93ZWQgaGVyZS5cIixcbiAgVW5leHBlY3RlZFNwcmVhZFR5cGU6IFwiU3ByZWFkIG9wZXJhdG9yIGNhbm5vdCBhcHBlYXIgaW4gY2xhc3Mgb3IgaW50ZXJmYWNlIGRlZmluaXRpb25zLlwiLFxuICBVbmV4cGVjdGVkU3VidHJhY3Rpb25PcGVyYW5kOiAnVW5leHBlY3RlZCB0b2tlbiwgZXhwZWN0ZWQgXCJudW1iZXJcIiBvciBcImJpZ2ludFwiLicsXG4gIFVuZXhwZWN0ZWRUb2tlbkFmdGVyVHlwZVBhcmFtZXRlcjogXCJFeHBlY3RlZCBhbiBhcnJvdyBmdW5jdGlvbiBhZnRlciB0aGlzIHR5cGUgcGFyYW1ldGVyIGRlY2xhcmF0aW9uLlwiLFxuICBVbmV4cGVjdGVkVHlwZVBhcmFtZXRlckJlZm9yZUFzeW5jQXJyb3dGdW5jdGlvbjogXCJUeXBlIHBhcmFtZXRlcnMgbXVzdCBjb21lIGFmdGVyIHRoZSBhc3luYyBrZXl3b3JkLCBlLmcuIGluc3RlYWQgb2YgYDxUPiBhc3luYyAoKSA9PiB7fWAsIHVzZSBgYXN5bmMgPFQ+KCkgPT4ge31gLlwiLFxuICBVbnN1cHBvcnRlZERlY2xhcmVFeHBvcnRLaW5kOiAoe1xuICAgIHVuc3VwcG9ydGVkRXhwb3J0S2luZCxcbiAgICBzdWdnZXN0aW9uXG4gIH0pID0+IGBcXGBkZWNsYXJlIGV4cG9ydCAke3Vuc3VwcG9ydGVkRXhwb3J0S2luZH1cXGAgaXMgbm90IHN1cHBvcnRlZC4gVXNlIFxcYCR7c3VnZ2VzdGlvbn1cXGAgaW5zdGVhZC5gLFxuICBVbnN1cHBvcnRlZFN0YXRlbWVudEluRGVjbGFyZU1vZHVsZTogXCJPbmx5IGRlY2xhcmVzIGFuZCB0eXBlIGltcG9ydHMgYXJlIGFsbG93ZWQgaW5zaWRlIGRlY2xhcmUgbW9kdWxlLlwiLFxuICBVbnRlcm1pbmF0ZWRGbG93Q29tbWVudDogXCJVbnRlcm1pbmF0ZWQgZmxvdy1jb21tZW50LlwiXG59KTtcbmZ1bmN0aW9uIGlzRXNNb2R1bGVUeXBlKGJvZHlFbGVtZW50KSB7XG4gIHJldHVybiBib2R5RWxlbWVudC50eXBlID09PSBcIkRlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvblwiIHx8IGJvZHlFbGVtZW50LnR5cGUgPT09IFwiRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uXCIgJiYgKCFib2R5RWxlbWVudC5kZWNsYXJhdGlvbiB8fCBib2R5RWxlbWVudC5kZWNsYXJhdGlvbi50eXBlICE9PSBcIlR5cGVBbGlhc1wiICYmIGJvZHlFbGVtZW50LmRlY2xhcmF0aW9uLnR5cGUgIT09IFwiSW50ZXJmYWNlRGVjbGFyYXRpb25cIik7XG59XG5mdW5jdGlvbiBoYXNUeXBlSW1wb3J0S2luZChub2RlKSB7XG4gIHJldHVybiBub2RlLmltcG9ydEtpbmQgPT09IFwidHlwZVwiIHx8IG5vZGUuaW1wb3J0S2luZCA9PT0gXCJ0eXBlb2ZcIjtcbn1cbmNvbnN0IGV4cG9ydFN1Z2dlc3Rpb25zID0ge1xuICBjb25zdDogXCJkZWNsYXJlIGV4cG9ydCB2YXJcIixcbiAgbGV0OiBcImRlY2xhcmUgZXhwb3J0IHZhclwiLFxuICB0eXBlOiBcImV4cG9ydCB0eXBlXCIsXG4gIGludGVyZmFjZTogXCJleHBvcnQgaW50ZXJmYWNlXCJcbn07XG5mdW5jdGlvbiBwYXJ0aXRpb24obGlzdCwgdGVzdCkge1xuICBjb25zdCBsaXN0MSA9IFtdO1xuICBjb25zdCBsaXN0MiA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAodGVzdChsaXN0W2ldLCBpLCBsaXN0KSA/IGxpc3QxIDogbGlzdDIpLnB1c2gobGlzdFtpXSk7XG4gIH1cbiAgcmV0dXJuIFtsaXN0MSwgbGlzdDJdO1xufVxuY29uc3QgRkxPV19QUkFHTUFfUkVHRVggPSAvXFwqP1xccypAKCg/Om5vKT9mbG93KVxcYi87XG52YXIgZmxvdyA9IHN1cGVyQ2xhc3MgPT4gY2xhc3MgRmxvd1BhcnNlck1peGluIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICB0aGlzLmZsb3dQcmFnbWEgPSB1bmRlZmluZWQ7XG4gIH1cbiAgZ2V0U2NvcGVIYW5kbGVyKCkge1xuICAgIHJldHVybiBGbG93U2NvcGVIYW5kbGVyO1xuICB9XG4gIHNob3VsZFBhcnNlVHlwZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwiZmxvd1wiLCBcImFsbFwiKSB8fCB0aGlzLmZsb3dQcmFnbWEgPT09IFwiZmxvd1wiO1xuICB9XG4gIGZpbmlzaFRva2VuKHR5cGUsIHZhbCkge1xuICAgIGlmICh0eXBlICE9PSAxMzQgJiYgdHlwZSAhPT0gMTMgJiYgdHlwZSAhPT0gMjgpIHtcbiAgICAgIGlmICh0aGlzLmZsb3dQcmFnbWEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmZsb3dQcmFnbWEgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBzdXBlci5maW5pc2hUb2tlbih0eXBlLCB2YWwpO1xuICB9XG4gIGFkZENvbW1lbnQoY29tbWVudCkge1xuICAgIGlmICh0aGlzLmZsb3dQcmFnbWEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgbWF0Y2hlcyA9IEZMT1dfUFJBR01BX1JFR0VYLmV4ZWMoY29tbWVudC52YWx1ZSk7XG4gICAgICBpZiAoIW1hdGNoZXMpIDtlbHNlIGlmIChtYXRjaGVzWzFdID09PSBcImZsb3dcIikge1xuICAgICAgICB0aGlzLmZsb3dQcmFnbWEgPSBcImZsb3dcIjtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2hlc1sxXSA9PT0gXCJub2Zsb3dcIikge1xuICAgICAgICB0aGlzLmZsb3dQcmFnbWEgPSBcIm5vZmxvd1wiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBmbG93IHByYWdtYVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3VwZXIuYWRkQ29tbWVudChjb21tZW50KTtcbiAgfVxuICBmbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIodG9rKSB7XG4gICAgY29uc3Qgb2xkSW5UeXBlID0gdGhpcy5zdGF0ZS5pblR5cGU7XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSB0cnVlO1xuICAgIHRoaXMuZXhwZWN0KHRvayB8fCAxNCk7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gb2xkSW5UeXBlO1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIGZsb3dQYXJzZVByZWRpY2F0ZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCBtb2R1bG9Mb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbCgxMTApO1xuICAgIGlmICh0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYy5pbmRleCA+IG1vZHVsb0xvYy5pbmRleCArIDEpIHtcbiAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5VbmV4cGVjdGVkU3BhY2VCZXR3ZWVuTW9kdWxvQ2hlY2tzLCBtb2R1bG9Mb2MpO1xuICAgIH1cbiAgICBpZiAodGhpcy5lYXQoMTApKSB7XG4gICAgICBub2RlLnZhbHVlID0gc3VwZXIucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICB0aGlzLmV4cGVjdCgxMSk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVjbGFyZWRQcmVkaWNhdGVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbmZlcnJlZFByZWRpY2F0ZVwiKTtcbiAgICB9XG4gIH1cbiAgZmxvd1BhcnNlVHlwZUFuZFByZWRpY2F0ZUluaXRpYWxpc2VyKCkge1xuICAgIGNvbnN0IG9sZEluVHlwZSA9IHRoaXMuc3RhdGUuaW5UeXBlO1xuICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gdHJ1ZTtcbiAgICB0aGlzLmV4cGVjdCgxNCk7XG4gICAgbGV0IHR5cGUgPSBudWxsO1xuICAgIGxldCBwcmVkaWNhdGUgPSBudWxsO1xuICAgIGlmICh0aGlzLm1hdGNoKDU0KSkge1xuICAgICAgdGhpcy5zdGF0ZS5pblR5cGUgPSBvbGRJblR5cGU7XG4gICAgICBwcmVkaWNhdGUgPSB0aGlzLmZsb3dQYXJzZVByZWRpY2F0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gICAgICB0aGlzLnN0YXRlLmluVHlwZSA9IG9sZEluVHlwZTtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDU0KSkge1xuICAgICAgICBwcmVkaWNhdGUgPSB0aGlzLmZsb3dQYXJzZVByZWRpY2F0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW3R5cGUsIHByZWRpY2F0ZV07XG4gIH1cbiAgZmxvd1BhcnNlRGVjbGFyZUNsYXNzKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLmZsb3dQYXJzZUludGVyZmFjZWlzaChub2RlLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVjbGFyZUNsYXNzXCIpO1xuICB9XG4gIGZsb3dQYXJzZURlY2xhcmVGdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgY29uc3QgaWQgPSBub2RlLmlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICBjb25zdCB0eXBlTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3QgdHlwZUNvbnRhaW5lciA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICB0eXBlTm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGVOb2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5leHBlY3QoMTApO1xuICAgIGNvbnN0IHRtcCA9IHRoaXMuZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW1zKCk7XG4gICAgdHlwZU5vZGUucGFyYW1zID0gdG1wLnBhcmFtcztcbiAgICB0eXBlTm9kZS5yZXN0ID0gdG1wLnJlc3Q7XG4gICAgdHlwZU5vZGUudGhpcyA9IHRtcC5fdGhpcztcbiAgICB0aGlzLmV4cGVjdCgxMSk7XG4gICAgW3R5cGVOb2RlLnJldHVyblR5cGUsIG5vZGUucHJlZGljYXRlXSA9IHRoaXMuZmxvd1BhcnNlVHlwZUFuZFByZWRpY2F0ZUluaXRpYWxpc2VyKCk7XG4gICAgdHlwZUNvbnRhaW5lci50eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmluaXNoTm9kZSh0eXBlTm9kZSwgXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCIpO1xuICAgIGlkLnR5cGVBbm5vdGF0aW9uID0gdGhpcy5maW5pc2hOb2RlKHR5cGVDb250YWluZXIsIFwiVHlwZUFubm90YXRpb25cIik7XG4gICAgdGhpcy5yZXNldEVuZExvY2F0aW9uKGlkKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHRoaXMuc2NvcGUuZGVjbGFyZU5hbWUobm9kZS5pZC5uYW1lLCAyMDQ4LCBub2RlLmlkLmxvYy5zdGFydCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlY2xhcmVGdW5jdGlvblwiKTtcbiAgfVxuICBmbG93UGFyc2VEZWNsYXJlKG5vZGUsIGluc2lkZU1vZHVsZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKDgwKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlRGVjbGFyZUNsYXNzKG5vZGUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tYXRjaCg2OCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVGdW5jdGlvbihub2RlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2goNzQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VEZWNsYXJlVmFyaWFibGUobm9kZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmVhdENvbnRleHR1YWwoMTI3KSkge1xuICAgICAgaWYgKHRoaXMubWF0Y2goMTYpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVNb2R1bGVFeHBvcnRzKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGluc2lkZU1vZHVsZSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5OZXN0ZWREZWNsYXJlTW9kdWxlLCB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlRGVjbGFyZU1vZHVsZShub2RlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEzMCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVUeXBlQWxpYXMobm9kZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMzEpKSB7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VEZWNsYXJlT3BhcXVlVHlwZShub2RlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEyOSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVJbnRlcmZhY2Uobm9kZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKDgyKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUsIGluc2lkZU1vZHVsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgfVxuICBmbG93UGFyc2VEZWNsYXJlVmFyaWFibGUobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuaWQgPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0YWJsZUlkZW50aWZpZXIodHJ1ZSk7XG4gICAgdGhpcy5zY29wZS5kZWNsYXJlTmFtZShub2RlLmlkLm5hbWUsIDUsIG5vZGUuaWQubG9jLnN0YXJ0KTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWNsYXJlVmFyaWFibGVcIik7XG4gIH1cbiAgZmxvd1BhcnNlRGVjbGFyZU1vZHVsZShub2RlKSB7XG4gICAgdGhpcy5zY29wZS5lbnRlcigwKTtcbiAgICBpZiAodGhpcy5tYXRjaCgxMzQpKSB7XG4gICAgICBub2RlLmlkID0gc3VwZXIucGFyc2VFeHByQXRvbSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICB9XG4gICAgY29uc3QgYm9keU5vZGUgPSBub2RlLmJvZHkgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGNvbnN0IGJvZHkgPSBib2R5Tm9kZS5ib2R5ID0gW107XG4gICAgdGhpcy5leHBlY3QoNSk7XG4gICAgd2hpbGUgKCF0aGlzLm1hdGNoKDgpKSB7XG4gICAgICBsZXQgYm9keU5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgaWYgKHRoaXMubWF0Y2goODMpKSB7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBpZiAoIXRoaXMuaXNDb250ZXh0dWFsKDEzMCkgJiYgIXRoaXMubWF0Y2goODcpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLkludmFsaWROb25UeXBlSW1wb3J0SW5EZWNsYXJlTW9kdWxlLCB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIucGFyc2VJbXBvcnQoYm9keU5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKDEyNSwgRmxvd0Vycm9ycy5VbnN1cHBvcnRlZFN0YXRlbWVudEluRGVjbGFyZU1vZHVsZSk7XG4gICAgICAgIGJvZHlOb2RlID0gdGhpcy5mbG93UGFyc2VEZWNsYXJlKGJvZHlOb2RlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGJvZHkucHVzaChib2R5Tm9kZSk7XG4gICAgfVxuICAgIHRoaXMuc2NvcGUuZXhpdCgpO1xuICAgIHRoaXMuZXhwZWN0KDgpO1xuICAgIHRoaXMuZmluaXNoTm9kZShib2R5Tm9kZSwgXCJCbG9ja1N0YXRlbWVudFwiKTtcbiAgICBsZXQga2luZCA9IG51bGw7XG4gICAgbGV0IGhhc01vZHVsZUV4cG9ydCA9IGZhbHNlO1xuICAgIGJvZHkuZm9yRWFjaChib2R5RWxlbWVudCA9PiB7XG4gICAgICBpZiAoaXNFc01vZHVsZVR5cGUoYm9keUVsZW1lbnQpKSB7XG4gICAgICAgIGlmIChraW5kID09PSBcIkNvbW1vbkpTXCIpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuQW1iaWd1b3VzRGVjbGFyZU1vZHVsZUtpbmQsIGJvZHlFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBraW5kID0gXCJFU1wiO1xuICAgICAgfSBlbHNlIGlmIChib2R5RWxlbWVudC50eXBlID09PSBcIkRlY2xhcmVNb2R1bGVFeHBvcnRzXCIpIHtcbiAgICAgICAgaWYgKGhhc01vZHVsZUV4cG9ydCkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5EdXBsaWNhdGVEZWNsYXJlTW9kdWxlRXhwb3J0cywgYm9keUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChraW5kID09PSBcIkVTXCIpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuQW1iaWd1b3VzRGVjbGFyZU1vZHVsZUtpbmQsIGJvZHlFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBraW5kID0gXCJDb21tb25KU1wiO1xuICAgICAgICBoYXNNb2R1bGVFeHBvcnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG5vZGUua2luZCA9IGtpbmQgfHwgXCJDb21tb25KU1wiO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWNsYXJlTW9kdWxlXCIpO1xuICB9XG4gIGZsb3dQYXJzZURlY2xhcmVFeHBvcnREZWNsYXJhdGlvbihub2RlLCBpbnNpZGVNb2R1bGUpIHtcbiAgICB0aGlzLmV4cGVjdCg4Mik7XG4gICAgaWYgKHRoaXMuZWF0KDY1KSkge1xuICAgICAgaWYgKHRoaXMubWF0Y2goNjgpIHx8IHRoaXMubWF0Y2goODApKSB7XG4gICAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLmZsb3dQYXJzZURlY2xhcmUodGhpcy5zdGFydE5vZGUoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gICAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgICB9XG4gICAgICBub2RlLmRlZmF1bHQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlY2xhcmVFeHBvcnREZWNsYXJhdGlvblwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMubWF0Y2goNzUpIHx8IHRoaXMuaXNMZXQoKSB8fCAodGhpcy5pc0NvbnRleHR1YWwoMTMwKSB8fCB0aGlzLmlzQ29udGV4dHVhbCgxMjkpKSAmJiAhaW5zaWRlTW9kdWxlKSB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShGbG93RXJyb3JzLlVuc3VwcG9ydGVkRGVjbGFyZUV4cG9ydEtpbmQsIHRoaXMuc3RhdGUuc3RhcnRMb2MsIHtcbiAgICAgICAgICB1bnN1cHBvcnRlZEV4cG9ydEtpbmQ6IGxhYmVsLFxuICAgICAgICAgIHN1Z2dlc3Rpb246IGV4cG9ydFN1Z2dlc3Rpb25zW2xhYmVsXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm1hdGNoKDc0KSB8fCB0aGlzLm1hdGNoKDY4KSB8fCB0aGlzLm1hdGNoKDgwKSB8fCB0aGlzLmlzQ29udGV4dHVhbCgxMzEpKSB7XG4gICAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLmZsb3dQYXJzZURlY2xhcmUodGhpcy5zdGFydE5vZGUoKSk7XG4gICAgICAgIG5vZGUuZGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uXCIpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKDU1KSB8fCB0aGlzLm1hdGNoKDUpIHx8IHRoaXMuaXNDb250ZXh0dWFsKDEyOSkgfHwgdGhpcy5pc0NvbnRleHR1YWwoMTMwKSB8fCB0aGlzLmlzQ29udGV4dHVhbCgxMzEpKSB7XG4gICAgICAgIG5vZGUgPSB0aGlzLnBhcnNlRXhwb3J0KG5vZGUsIG51bGwpO1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIikge1xuICAgICAgICAgIG5vZGUuZGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICAgIGRlbGV0ZSBub2RlLmV4cG9ydEtpbmQ7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY2FzdE5vZGVUbyhub2RlLCBcIkRlY2xhcmVFeHBvcnREZWNsYXJhdGlvblwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jYXN0Tm9kZVRvKG5vZGUsIFwiRGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICB9XG4gIGZsb3dQYXJzZURlY2xhcmVNb2R1bGVFeHBvcnRzKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoMTExKTtcbiAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy5mbG93UGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlY2xhcmVNb2R1bGVFeHBvcnRzXCIpO1xuICB9XG4gIGZsb3dQYXJzZURlY2xhcmVUeXBlQWxpYXMobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGNvbnN0IGZpbmlzaGVkID0gdGhpcy5mbG93UGFyc2VUeXBlQWxpYXMobm9kZSk7XG4gICAgdGhpcy5jYXN0Tm9kZVRvKGZpbmlzaGVkLCBcIkRlY2xhcmVUeXBlQWxpYXNcIik7XG4gICAgcmV0dXJuIGZpbmlzaGVkO1xuICB9XG4gIGZsb3dQYXJzZURlY2xhcmVPcGFxdWVUeXBlKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBjb25zdCBmaW5pc2hlZCA9IHRoaXMuZmxvd1BhcnNlT3BhcXVlVHlwZShub2RlLCB0cnVlKTtcbiAgICB0aGlzLmNhc3ROb2RlVG8oZmluaXNoZWQsIFwiRGVjbGFyZU9wYXF1ZVR5cGVcIik7XG4gICAgcmV0dXJuIGZpbmlzaGVkO1xuICB9XG4gIGZsb3dQYXJzZURlY2xhcmVJbnRlcmZhY2Uobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMuZmxvd1BhcnNlSW50ZXJmYWNlaXNoKG5vZGUsIGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVjbGFyZUludGVyZmFjZVwiKTtcbiAgfVxuICBmbG93UGFyc2VJbnRlcmZhY2Vpc2gobm9kZSwgaXNDbGFzcykge1xuICAgIG5vZGUuaWQgPSB0aGlzLmZsb3dQYXJzZVJlc3RyaWN0ZWRJZGVudGlmaWVyKCFpc0NsYXNzLCB0cnVlKTtcbiAgICB0aGlzLnNjb3BlLmRlY2xhcmVOYW1lKG5vZGUuaWQubmFtZSwgaXNDbGFzcyA/IDE3IDogODIwMSwgbm9kZS5pZC5sb2Muc3RhcnQpO1xuICAgIGlmICh0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICAgIH1cbiAgICBub2RlLmV4dGVuZHMgPSBbXTtcbiAgICBpZiAodGhpcy5lYXQoODEpKSB7XG4gICAgICBkbyB7XG4gICAgICAgIG5vZGUuZXh0ZW5kcy5wdXNoKHRoaXMuZmxvd1BhcnNlSW50ZXJmYWNlRXh0ZW5kcygpKTtcbiAgICAgIH0gd2hpbGUgKCFpc0NsYXNzICYmIHRoaXMuZWF0KDEyKSk7XG4gICAgfVxuICAgIGlmIChpc0NsYXNzKSB7XG4gICAgICBub2RlLmltcGxlbWVudHMgPSBbXTtcbiAgICAgIG5vZGUubWl4aW5zID0gW107XG4gICAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKDExNykpIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIG5vZGUubWl4aW5zLnB1c2godGhpcy5mbG93UGFyc2VJbnRlcmZhY2VFeHRlbmRzKCkpO1xuICAgICAgICB9IHdoaWxlICh0aGlzLmVhdCgxMikpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbCgxMTMpKSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBub2RlLmltcGxlbWVudHMucHVzaCh0aGlzLmZsb3dQYXJzZUludGVyZmFjZUV4dGVuZHMoKSk7XG4gICAgICAgIH0gd2hpbGUgKHRoaXMuZWF0KDEyKSk7XG4gICAgICB9XG4gICAgfVxuICAgIG5vZGUuYm9keSA9IHRoaXMuZmxvd1BhcnNlT2JqZWN0VHlwZSh7XG4gICAgICBhbGxvd1N0YXRpYzogaXNDbGFzcyxcbiAgICAgIGFsbG93RXhhY3Q6IGZhbHNlLFxuICAgICAgYWxsb3dTcHJlYWQ6IGZhbHNlLFxuICAgICAgYWxsb3dQcm90bzogaXNDbGFzcyxcbiAgICAgIGFsbG93SW5leGFjdDogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBmbG93UGFyc2VJbnRlcmZhY2VFeHRlbmRzKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUuaWQgPSB0aGlzLmZsb3dQYXJzZVF1YWxpZmllZFR5cGVJZGVudGlmaWVyKCk7XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkludGVyZmFjZUV4dGVuZHNcIik7XG4gIH1cbiAgZmxvd1BhcnNlSW50ZXJmYWNlKG5vZGUpIHtcbiAgICB0aGlzLmZsb3dQYXJzZUludGVyZmFjZWlzaChub2RlLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkludGVyZmFjZURlY2xhcmF0aW9uXCIpO1xuICB9XG4gIGNoZWNrTm90VW5kZXJzY29yZSh3b3JkKSB7XG4gICAgaWYgKHdvcmQgPT09IFwiX1wiKSB7XG4gICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVW5leHBlY3RlZFJlc2VydmVkVW5kZXJzY29yZSwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgfVxuICB9XG4gIGNoZWNrUmVzZXJ2ZWRUeXBlKHdvcmQsIHN0YXJ0TG9jLCBkZWNsYXJhdGlvbikge1xuICAgIGlmICghcmVzZXJ2ZWRUeXBlcy5oYXMod29yZCkpIHJldHVybjtcbiAgICB0aGlzLnJhaXNlKGRlY2xhcmF0aW9uID8gRmxvd0Vycm9ycy5Bc3NpZ25SZXNlcnZlZFR5cGUgOiBGbG93RXJyb3JzLlVuZXhwZWN0ZWRSZXNlcnZlZFR5cGUsIHN0YXJ0TG9jLCB7XG4gICAgICByZXNlcnZlZFR5cGU6IHdvcmRcbiAgICB9KTtcbiAgfVxuICBmbG93UGFyc2VSZXN0cmljdGVkSWRlbnRpZmllcihsaWJlcmFsLCBkZWNsYXJhdGlvbikge1xuICAgIHRoaXMuY2hlY2tSZXNlcnZlZFR5cGUodGhpcy5zdGF0ZS52YWx1ZSwgdGhpcy5zdGF0ZS5zdGFydExvYywgZGVjbGFyYXRpb24pO1xuICAgIHJldHVybiB0aGlzLnBhcnNlSWRlbnRpZmllcihsaWJlcmFsKTtcbiAgfVxuICBmbG93UGFyc2VUeXBlQWxpYXMobm9kZSkge1xuICAgIG5vZGUuaWQgPSB0aGlzLmZsb3dQYXJzZVJlc3RyaWN0ZWRJZGVudGlmaWVyKGZhbHNlLCB0cnVlKTtcbiAgICB0aGlzLnNjb3BlLmRlY2xhcmVOYW1lKG5vZGUuaWQubmFtZSwgODIwMSwgbm9kZS5pZC5sb2Muc3RhcnQpO1xuICAgIGlmICh0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICAgIH1cbiAgICBub2RlLnJpZ2h0ID0gdGhpcy5mbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIoMjkpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlR5cGVBbGlhc1wiKTtcbiAgfVxuICBmbG93UGFyc2VPcGFxdWVUeXBlKG5vZGUsIGRlY2xhcmUpIHtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoMTMwKTtcbiAgICBub2RlLmlkID0gdGhpcy5mbG93UGFyc2VSZXN0cmljdGVkSWRlbnRpZmllcih0cnVlLCB0cnVlKTtcbiAgICB0aGlzLnNjb3BlLmRlY2xhcmVOYW1lKG5vZGUuaWQubmFtZSwgODIwMSwgbm9kZS5pZC5sb2Muc3RhcnQpO1xuICAgIGlmICh0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICAgIH1cbiAgICBub2RlLnN1cGVydHlwZSA9IG51bGw7XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICBub2RlLnN1cGVydHlwZSA9IHRoaXMuZmxvd1BhcnNlVHlwZUluaXRpYWxpc2VyKDE0KTtcbiAgICB9XG4gICAgbm9kZS5pbXBsdHlwZSA9IG51bGw7XG4gICAgaWYgKCFkZWNsYXJlKSB7XG4gICAgICBub2RlLmltcGx0eXBlID0gdGhpcy5mbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIoMjkpO1xuICAgIH1cbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJPcGFxdWVUeXBlXCIpO1xuICB9XG4gIGZsb3dQYXJzZVR5cGVQYXJhbWV0ZXIocmVxdWlyZURlZmF1bHQgPSBmYWxzZSkge1xuICAgIGNvbnN0IG5vZGVTdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3QgdmFyaWFuY2UgPSB0aGlzLmZsb3dQYXJzZVZhcmlhbmNlKCk7XG4gICAgY29uc3QgaWRlbnQgPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0YWJsZUlkZW50aWZpZXIoKTtcbiAgICBub2RlLm5hbWUgPSBpZGVudC5uYW1lO1xuICAgIG5vZGUudmFyaWFuY2UgPSB2YXJpYW5jZTtcbiAgICBub2RlLmJvdW5kID0gaWRlbnQudHlwZUFubm90YXRpb247XG4gICAgaWYgKHRoaXMubWF0Y2goMjkpKSB7XG4gICAgICB0aGlzLmVhdCgyOSk7XG4gICAgICBub2RlLmRlZmF1bHQgPSB0aGlzLmZsb3dQYXJzZVR5cGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJlcXVpcmVEZWZhdWx0KSB7XG4gICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5NaXNzaW5nVHlwZVBhcmFtRGVmYXVsdCwgbm9kZVN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlR5cGVQYXJhbWV0ZXJcIik7XG4gIH1cbiAgZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCkge1xuICAgIGNvbnN0IG9sZEluVHlwZSA9IHRoaXMuc3RhdGUuaW5UeXBlO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUucGFyYW1zID0gW107XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSB0cnVlO1xuICAgIGlmICh0aGlzLm1hdGNoKDQ3KSB8fCB0aGlzLm1hdGNoKDE0MykpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gICAgbGV0IGRlZmF1bHRSZXF1aXJlZCA9IGZhbHNlO1xuICAgIGRvIHtcbiAgICAgIGNvbnN0IHR5cGVQYXJhbWV0ZXIgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXIoZGVmYXVsdFJlcXVpcmVkKTtcbiAgICAgIG5vZGUucGFyYW1zLnB1c2godHlwZVBhcmFtZXRlcik7XG4gICAgICBpZiAodHlwZVBhcmFtZXRlci5kZWZhdWx0KSB7XG4gICAgICAgIGRlZmF1bHRSZXF1aXJlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMubWF0Y2goNDgpKSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KDEyKTtcbiAgICAgIH1cbiAgICB9IHdoaWxlICghdGhpcy5tYXRjaCg0OCkpO1xuICAgIHRoaXMuZXhwZWN0KDQ4KTtcbiAgICB0aGlzLnN0YXRlLmluVHlwZSA9IG9sZEluVHlwZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIpO1xuICB9XG4gIGZsb3dJblRvcExldmVsQ29udGV4dChjYikge1xuICAgIGlmICh0aGlzLmN1ckNvbnRleHQoKSAhPT0gdHlwZXMuYnJhY2UpIHtcbiAgICAgIGNvbnN0IG9sZENvbnRleHQgPSB0aGlzLnN0YXRlLmNvbnRleHQ7XG4gICAgICB0aGlzLnN0YXRlLmNvbnRleHQgPSBbb2xkQ29udGV4dFswXV07XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gY2IoKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuc3RhdGUuY29udGV4dCA9IG9sZENvbnRleHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjYigpO1xuICAgIH1cbiAgfVxuICBmbG93UGFyc2VUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbkluRXhwcmVzc2lvbigpIHtcbiAgICBpZiAodGhpcy5yZVNjYW5fbHQoKSAhPT0gNDcpIHJldHVybjtcbiAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbigpO1xuICB9XG4gIGZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGNvbnN0IG9sZEluVHlwZSA9IHRoaXMuc3RhdGUuaW5UeXBlO1xuICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gdHJ1ZTtcbiAgICBub2RlLnBhcmFtcyA9IFtdO1xuICAgIHRoaXMuZmxvd0luVG9wTGV2ZWxDb250ZXh0KCgpID0+IHtcbiAgICAgIHRoaXMuZXhwZWN0KDQ3KTtcbiAgICAgIGNvbnN0IG9sZE5vQW5vbkZ1bmN0aW9uVHlwZSA9IHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlO1xuICAgICAgdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGUgPSBmYWxzZTtcbiAgICAgIHdoaWxlICghdGhpcy5tYXRjaCg0OCkpIHtcbiAgICAgICAgbm9kZS5wYXJhbXMucHVzaCh0aGlzLmZsb3dQYXJzZVR5cGUoKSk7XG4gICAgICAgIGlmICghdGhpcy5tYXRjaCg0OCkpIHtcbiAgICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlID0gb2xkTm9Bbm9uRnVuY3Rpb25UeXBlO1xuICAgIH0pO1xuICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gb2xkSW5UeXBlO1xuICAgIGlmICghdGhpcy5zdGF0ZS5pblR5cGUgJiYgdGhpcy5jdXJDb250ZXh0KCkgPT09IHR5cGVzLmJyYWNlKSB7XG4gICAgICB0aGlzLnJlU2Nhbl9sdF9ndCgpO1xuICAgIH1cbiAgICB0aGlzLmV4cGVjdCg0OCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpO1xuICB9XG4gIGZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uQ2FsbE9yTmV3KCkge1xuICAgIGlmICh0aGlzLnJlU2Nhbl9sdCgpICE9PSA0NykgcmV0dXJuO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGNvbnN0IG9sZEluVHlwZSA9IHRoaXMuc3RhdGUuaW5UeXBlO1xuICAgIG5vZGUucGFyYW1zID0gW107XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSB0cnVlO1xuICAgIHRoaXMuZXhwZWN0KDQ3KTtcbiAgICB3aGlsZSAoIXRoaXMubWF0Y2goNDgpKSB7XG4gICAgICBub2RlLnBhcmFtcy5wdXNoKHRoaXMuZmxvd1BhcnNlVHlwZU9ySW1wbGljaXRJbnN0YW50aWF0aW9uKCkpO1xuICAgICAgaWYgKCF0aGlzLm1hdGNoKDQ4KSkge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0KDQ4KTtcbiAgICB0aGlzLnN0YXRlLmluVHlwZSA9IG9sZEluVHlwZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIik7XG4gIH1cbiAgZmxvd1BhcnNlSW50ZXJmYWNlVHlwZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoMTI5KTtcbiAgICBub2RlLmV4dGVuZHMgPSBbXTtcbiAgICBpZiAodGhpcy5lYXQoODEpKSB7XG4gICAgICBkbyB7XG4gICAgICAgIG5vZGUuZXh0ZW5kcy5wdXNoKHRoaXMuZmxvd1BhcnNlSW50ZXJmYWNlRXh0ZW5kcygpKTtcbiAgICAgIH0gd2hpbGUgKHRoaXMuZWF0KDEyKSk7XG4gICAgfVxuICAgIG5vZGUuYm9keSA9IHRoaXMuZmxvd1BhcnNlT2JqZWN0VHlwZSh7XG4gICAgICBhbGxvd1N0YXRpYzogZmFsc2UsXG4gICAgICBhbGxvd0V4YWN0OiBmYWxzZSxcbiAgICAgIGFsbG93U3ByZWFkOiBmYWxzZSxcbiAgICAgIGFsbG93UHJvdG86IGZhbHNlLFxuICAgICAgYWxsb3dJbmV4YWN0OiBmYWxzZVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbnRlcmZhY2VUeXBlQW5ub3RhdGlvblwiKTtcbiAgfVxuICBmbG93UGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgxMzUpIHx8IHRoaXMubWF0Y2goMTM0KSA/IHN1cGVyLnBhcnNlRXhwckF0b20oKSA6IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICB9XG4gIGZsb3dQYXJzZU9iamVjdFR5cGVJbmRleGVyKG5vZGUsIGlzU3RhdGljLCB2YXJpYW5jZSkge1xuICAgIG5vZGUuc3RhdGljID0gaXNTdGF0aWM7XG4gICAgaWYgKHRoaXMubG9va2FoZWFkKCkudHlwZSA9PT0gMTQpIHtcbiAgICAgIG5vZGUuaWQgPSB0aGlzLmZsb3dQYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG4gICAgICBub2RlLmtleSA9IHRoaXMuZmxvd1BhcnNlVHlwZUluaXRpYWxpc2VyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuaWQgPSBudWxsO1xuICAgICAgbm9kZS5rZXkgPSB0aGlzLmZsb3dQYXJzZVR5cGUoKTtcbiAgICB9XG4gICAgdGhpcy5leHBlY3QoMyk7XG4gICAgbm9kZS52YWx1ZSA9IHRoaXMuZmxvd1BhcnNlVHlwZUluaXRpYWxpc2VyKCk7XG4gICAgbm9kZS52YXJpYW5jZSA9IHZhcmlhbmNlO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJPYmplY3RUeXBlSW5kZXhlclwiKTtcbiAgfVxuICBmbG93UGFyc2VPYmplY3RUeXBlSW50ZXJuYWxTbG90KG5vZGUsIGlzU3RhdGljKSB7XG4gICAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYztcbiAgICBub2RlLmlkID0gdGhpcy5mbG93UGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuICAgIHRoaXMuZXhwZWN0KDMpO1xuICAgIHRoaXMuZXhwZWN0KDMpO1xuICAgIGlmICh0aGlzLm1hdGNoKDQ3KSB8fCB0aGlzLm1hdGNoKDEwKSkge1xuICAgICAgbm9kZS5tZXRob2QgPSB0cnVlO1xuICAgICAgbm9kZS5vcHRpb25hbCA9IGZhbHNlO1xuICAgICAgbm9kZS52YWx1ZSA9IHRoaXMuZmxvd1BhcnNlT2JqZWN0VHlwZU1ldGhvZGlzaCh0aGlzLnN0YXJ0Tm9kZUF0KG5vZGUubG9jLnN0YXJ0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUubWV0aG9kID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5lYXQoMTcpKSB7XG4gICAgICAgIG5vZGUub3B0aW9uYWwgPSB0cnVlO1xuICAgICAgfVxuICAgICAgbm9kZS52YWx1ZSA9IHRoaXMuZmxvd1BhcnNlVHlwZUluaXRpYWxpc2VyKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJPYmplY3RUeXBlSW50ZXJuYWxTbG90XCIpO1xuICB9XG4gIGZsb3dQYXJzZU9iamVjdFR5cGVNZXRob2Rpc2gobm9kZSkge1xuICAgIG5vZGUucGFyYW1zID0gW107XG4gICAgbm9kZS5yZXN0ID0gbnVsbDtcbiAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcbiAgICBub2RlLnRoaXMgPSBudWxsO1xuICAgIGlmICh0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0KDEwKTtcbiAgICBpZiAodGhpcy5tYXRjaCg3OCkpIHtcbiAgICAgIG5vZGUudGhpcyA9IHRoaXMuZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW0odHJ1ZSk7XG4gICAgICBub2RlLnRoaXMubmFtZSA9IG51bGw7XG4gICAgICBpZiAoIXRoaXMubWF0Y2goMTEpKSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KDEyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKCF0aGlzLm1hdGNoKDExKSAmJiAhdGhpcy5tYXRjaCgyMSkpIHtcbiAgICAgIG5vZGUucGFyYW1zLnB1c2godGhpcy5mbG93UGFyc2VGdW5jdGlvblR5cGVQYXJhbShmYWxzZSkpO1xuICAgICAgaWYgKCF0aGlzLm1hdGNoKDExKSkge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmVhdCgyMSkpIHtcbiAgICAgIG5vZGUucmVzdCA9IHRoaXMuZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW0oZmFsc2UpO1xuICAgIH1cbiAgICB0aGlzLmV4cGVjdCgxMSk7XG4gICAgbm9kZS5yZXR1cm5UeXBlID0gdGhpcy5mbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiKTtcbiAgfVxuICBmbG93UGFyc2VPYmplY3RUeXBlQ2FsbFByb3BlcnR5KG5vZGUsIGlzU3RhdGljKSB7XG4gICAgY29uc3QgdmFsdWVOb2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLnN0YXRpYyA9IGlzU3RhdGljO1xuICAgIG5vZGUudmFsdWUgPSB0aGlzLmZsb3dQYXJzZU9iamVjdFR5cGVNZXRob2Rpc2godmFsdWVOb2RlKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eVwiKTtcbiAgfVxuICBmbG93UGFyc2VPYmplY3RUeXBlKHtcbiAgICBhbGxvd1N0YXRpYyxcbiAgICBhbGxvd0V4YWN0LFxuICAgIGFsbG93U3ByZWFkLFxuICAgIGFsbG93UHJvdG8sXG4gICAgYWxsb3dJbmV4YWN0XG4gIH0pIHtcbiAgICBjb25zdCBvbGRJblR5cGUgPSB0aGlzLnN0YXRlLmluVHlwZTtcbiAgICB0aGlzLnN0YXRlLmluVHlwZSA9IHRydWU7XG4gICAgY29uc3Qgbm9kZVN0YXJ0ID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlU3RhcnQuY2FsbFByb3BlcnRpZXMgPSBbXTtcbiAgICBub2RlU3RhcnQucHJvcGVydGllcyA9IFtdO1xuICAgIG5vZGVTdGFydC5pbmRleGVycyA9IFtdO1xuICAgIG5vZGVTdGFydC5pbnRlcm5hbFNsb3RzID0gW107XG4gICAgbGV0IGVuZERlbGltO1xuICAgIGxldCBleGFjdDtcbiAgICBsZXQgaW5leGFjdCA9IGZhbHNlO1xuICAgIGlmIChhbGxvd0V4YWN0ICYmIHRoaXMubWF0Y2goNikpIHtcbiAgICAgIHRoaXMuZXhwZWN0KDYpO1xuICAgICAgZW5kRGVsaW0gPSA5O1xuICAgICAgZXhhY3QgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV4cGVjdCg1KTtcbiAgICAgIGVuZERlbGltID0gODtcbiAgICAgIGV4YWN0ID0gZmFsc2U7XG4gICAgfVxuICAgIG5vZGVTdGFydC5leGFjdCA9IGV4YWN0O1xuICAgIHdoaWxlICghdGhpcy5tYXRjaChlbmREZWxpbSkpIHtcbiAgICAgIGxldCBpc1N0YXRpYyA9IGZhbHNlO1xuICAgICAgbGV0IHByb3RvU3RhcnRMb2MgPSBudWxsO1xuICAgICAgbGV0IGluZXhhY3RTdGFydExvYyA9IG51bGw7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIGlmIChhbGxvd1Byb3RvICYmIHRoaXMuaXNDb250ZXh0dWFsKDExOCkpIHtcbiAgICAgICAgY29uc3QgbG9va2FoZWFkID0gdGhpcy5sb29rYWhlYWQoKTtcbiAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlICE9PSAxNCAmJiBsb29rYWhlYWQudHlwZSAhPT0gMTcpIHtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICBwcm90b1N0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgICAgICBhbGxvd1N0YXRpYyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYWxsb3dTdGF0aWMgJiYgdGhpcy5pc0NvbnRleHR1YWwoMTA2KSkge1xuICAgICAgICBjb25zdCBsb29rYWhlYWQgPSB0aGlzLmxvb2thaGVhZCgpO1xuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IDE0ICYmIGxvb2thaGVhZC50eXBlICE9PSAxNykge1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIGlzU3RhdGljID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgdmFyaWFuY2UgPSB0aGlzLmZsb3dQYXJzZVZhcmlhbmNlKCk7XG4gICAgICBpZiAodGhpcy5lYXQoMCkpIHtcbiAgICAgICAgaWYgKHByb3RvU3RhcnRMb2MgIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMudW5leHBlY3RlZChwcm90b1N0YXJ0TG9jKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lYXQoMCkpIHtcbiAgICAgICAgICBpZiAodmFyaWFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMudW5leHBlY3RlZCh2YXJpYW5jZS5sb2Muc3RhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlU3RhcnQuaW50ZXJuYWxTbG90cy5wdXNoKHRoaXMuZmxvd1BhcnNlT2JqZWN0VHlwZUludGVybmFsU2xvdChub2RlLCBpc1N0YXRpYykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGVTdGFydC5pbmRleGVycy5wdXNoKHRoaXMuZmxvd1BhcnNlT2JqZWN0VHlwZUluZGV4ZXIobm9kZSwgaXNTdGF0aWMsIHZhcmlhbmNlKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5tYXRjaCgxMCkgfHwgdGhpcy5tYXRjaCg0NykpIHtcbiAgICAgICAgaWYgKHByb3RvU3RhcnRMb2MgIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMudW5leHBlY3RlZChwcm90b1N0YXJ0TG9jKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFyaWFuY2UpIHtcbiAgICAgICAgICB0aGlzLnVuZXhwZWN0ZWQodmFyaWFuY2UubG9jLnN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBub2RlU3RhcnQuY2FsbFByb3BlcnRpZXMucHVzaCh0aGlzLmZsb3dQYXJzZU9iamVjdFR5cGVDYWxsUHJvcGVydHkobm9kZSwgaXNTdGF0aWMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBraW5kID0gXCJpbml0XCI7XG4gICAgICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCg5OSkgfHwgdGhpcy5pc0NvbnRleHR1YWwoMTA0KSkge1xuICAgICAgICAgIGNvbnN0IGxvb2thaGVhZCA9IHRoaXMubG9va2FoZWFkKCk7XG4gICAgICAgICAgaWYgKHRva2VuSXNMaXRlcmFsUHJvcGVydHlOYW1lKGxvb2thaGVhZC50eXBlKSkge1xuICAgICAgICAgICAga2luZCA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvcE9ySW5leGFjdCA9IHRoaXMuZmxvd1BhcnNlT2JqZWN0VHlwZVByb3BlcnR5KG5vZGUsIGlzU3RhdGljLCBwcm90b1N0YXJ0TG9jLCB2YXJpYW5jZSwga2luZCwgYWxsb3dTcHJlYWQsIGFsbG93SW5leGFjdCAhPSBudWxsID8gYWxsb3dJbmV4YWN0IDogIWV4YWN0KTtcbiAgICAgICAgaWYgKHByb3BPckluZXhhY3QgPT09IG51bGwpIHtcbiAgICAgICAgICBpbmV4YWN0ID0gdHJ1ZTtcbiAgICAgICAgICBpbmV4YWN0U3RhcnRMb2MgPSB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlU3RhcnQucHJvcGVydGllcy5wdXNoKHByb3BPckluZXhhY3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmZsb3dPYmplY3RUeXBlU2VtaWNvbG9uKCk7XG4gICAgICBpZiAoaW5leGFjdFN0YXJ0TG9jICYmICF0aGlzLm1hdGNoKDgpICYmICF0aGlzLm1hdGNoKDkpKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5VbmV4cGVjdGVkRXhwbGljaXRJbmV4YWN0SW5PYmplY3QsIGluZXhhY3RTdGFydExvYyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0KGVuZERlbGltKTtcbiAgICBpZiAoYWxsb3dTcHJlYWQpIHtcbiAgICAgIG5vZGVTdGFydC5pbmV4YWN0ID0gaW5leGFjdDtcbiAgICB9XG4gICAgY29uc3Qgb3V0ID0gdGhpcy5maW5pc2hOb2RlKG5vZGVTdGFydCwgXCJPYmplY3RUeXBlQW5ub3RhdGlvblwiKTtcbiAgICB0aGlzLnN0YXRlLmluVHlwZSA9IG9sZEluVHlwZTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIGZsb3dQYXJzZU9iamVjdFR5cGVQcm9wZXJ0eShub2RlLCBpc1N0YXRpYywgcHJvdG9TdGFydExvYywgdmFyaWFuY2UsIGtpbmQsIGFsbG93U3ByZWFkLCBhbGxvd0luZXhhY3QpIHtcbiAgICBpZiAodGhpcy5lYXQoMjEpKSB7XG4gICAgICBjb25zdCBpc0luZXhhY3RUb2tlbiA9IHRoaXMubWF0Y2goMTIpIHx8IHRoaXMubWF0Y2goMTMpIHx8IHRoaXMubWF0Y2goOCkgfHwgdGhpcy5tYXRjaCg5KTtcbiAgICAgIGlmIChpc0luZXhhY3RUb2tlbikge1xuICAgICAgICBpZiAoIWFsbG93U3ByZWFkKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLkluZXhhY3RJbnNpZGVOb25PYmplY3QsIHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0TG9jKTtcbiAgICAgICAgfSBlbHNlIGlmICghYWxsb3dJbmV4YWN0KSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLkluZXhhY3RJbnNpZGVFeGFjdCwgdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnRMb2MpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YXJpYW5jZSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5JbmV4YWN0VmFyaWFuY2UsIHZhcmlhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICghYWxsb3dTcHJlYWQpIHtcbiAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLlVuZXhwZWN0ZWRTcHJlYWRUeXBlLCB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYyk7XG4gICAgICB9XG4gICAgICBpZiAocHJvdG9TdGFydExvYyAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZChwcm90b1N0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YXJpYW5jZSkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuU3ByZWFkVmFyaWFuY2UsIHZhcmlhbmNlKTtcbiAgICAgIH1cbiAgICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLmZsb3dQYXJzZVR5cGUoKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJPYmplY3RUeXBlU3ByZWFkUHJvcGVydHlcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUua2V5ID0gdGhpcy5mbG93UGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuICAgICAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYztcbiAgICAgIG5vZGUucHJvdG8gPSBwcm90b1N0YXJ0TG9jICE9IG51bGw7XG4gICAgICBub2RlLmtpbmQgPSBraW5kO1xuICAgICAgbGV0IG9wdGlvbmFsID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5tYXRjaCg0NykgfHwgdGhpcy5tYXRjaCgxMCkpIHtcbiAgICAgICAgbm9kZS5tZXRob2QgPSB0cnVlO1xuICAgICAgICBpZiAocHJvdG9TdGFydExvYyAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy51bmV4cGVjdGVkKHByb3RvU3RhcnRMb2MpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YXJpYW5jZSkge1xuICAgICAgICAgIHRoaXMudW5leHBlY3RlZCh2YXJpYW5jZS5sb2Muc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUudmFsdWUgPSB0aGlzLmZsb3dQYXJzZU9iamVjdFR5cGVNZXRob2Rpc2godGhpcy5zdGFydE5vZGVBdChub2RlLmxvYy5zdGFydCkpO1xuICAgICAgICBpZiAoa2luZCA9PT0gXCJnZXRcIiB8fCBraW5kID09PSBcInNldFwiKSB7XG4gICAgICAgICAgdGhpcy5mbG93Q2hlY2tHZXR0ZXJTZXR0ZXJQYXJhbXMobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhbGxvd1NwcmVhZCAmJiBub2RlLmtleS5uYW1lID09PSBcImNvbnN0cnVjdG9yXCIgJiYgbm9kZS52YWx1ZS50aGlzKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLlRoaXNQYXJhbUJhbm5lZEluQ29uc3RydWN0b3IsIG5vZGUudmFsdWUudGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChraW5kICE9PSBcImluaXRcIikgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICAgIG5vZGUubWV0aG9kID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmVhdCgxNykpIHtcbiAgICAgICAgICBvcHRpb25hbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS52YWx1ZSA9IHRoaXMuZmxvd1BhcnNlVHlwZUluaXRpYWxpc2VyKCk7XG4gICAgICAgIG5vZGUudmFyaWFuY2UgPSB2YXJpYW5jZTtcbiAgICAgIH1cbiAgICAgIG5vZGUub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJPYmplY3RUeXBlUHJvcGVydHlcIik7XG4gICAgfVxuICB9XG4gIGZsb3dDaGVja0dldHRlclNldHRlclBhcmFtcyhwcm9wZXJ0eSkge1xuICAgIGNvbnN0IHBhcmFtQ291bnQgPSBwcm9wZXJ0eS5raW5kID09PSBcImdldFwiID8gMCA6IDE7XG4gICAgY29uc3QgbGVuZ3RoID0gcHJvcGVydHkudmFsdWUucGFyYW1zLmxlbmd0aCArIChwcm9wZXJ0eS52YWx1ZS5yZXN0ID8gMSA6IDApO1xuICAgIGlmIChwcm9wZXJ0eS52YWx1ZS50aGlzKSB7XG4gICAgICB0aGlzLnJhaXNlKHByb3BlcnR5LmtpbmQgPT09IFwiZ2V0XCIgPyBGbG93RXJyb3JzLkdldHRlck1heU5vdEhhdmVUaGlzUGFyYW0gOiBGbG93RXJyb3JzLlNldHRlck1heU5vdEhhdmVUaGlzUGFyYW0sIHByb3BlcnR5LnZhbHVlLnRoaXMpO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoICE9PSBwYXJhbUNvdW50KSB7XG4gICAgICB0aGlzLnJhaXNlKHByb3BlcnR5LmtpbmQgPT09IFwiZ2V0XCIgPyBFcnJvcnMuQmFkR2V0dGVyQXJpdHkgOiBFcnJvcnMuQmFkU2V0dGVyQXJpdHksIHByb3BlcnR5KTtcbiAgICB9XG4gICAgaWYgKHByb3BlcnR5LmtpbmQgPT09IFwic2V0XCIgJiYgcHJvcGVydHkudmFsdWUucmVzdCkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQmFkU2V0dGVyUmVzdFBhcmFtZXRlciwgcHJvcGVydHkpO1xuICAgIH1cbiAgfVxuICBmbG93T2JqZWN0VHlwZVNlbWljb2xvbigpIHtcbiAgICBpZiAoIXRoaXMuZWF0KDEzKSAmJiAhdGhpcy5lYXQoMTIpICYmICF0aGlzLm1hdGNoKDgpICYmICF0aGlzLm1hdGNoKDkpKSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gIH1cbiAgZmxvd1BhcnNlUXVhbGlmaWVkVHlwZUlkZW50aWZpZXIoc3RhcnRMb2MsIGlkKSB7XG4gICAgc3RhcnRMb2MgIT0gbnVsbCA/IHN0YXJ0TG9jIDogc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGxldCBub2RlID0gaWQgfHwgdGhpcy5mbG93UGFyc2VSZXN0cmljdGVkSWRlbnRpZmllcih0cnVlKTtcbiAgICB3aGlsZSAodGhpcy5lYXQoMTYpKSB7XG4gICAgICBjb25zdCBub2RlMiA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgbm9kZTIucXVhbGlmaWNhdGlvbiA9IG5vZGU7XG4gICAgICBub2RlMi5pZCA9IHRoaXMuZmxvd1BhcnNlUmVzdHJpY3RlZElkZW50aWZpZXIodHJ1ZSk7XG4gICAgICBub2RlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUyLCBcIlF1YWxpZmllZFR5cGVJZGVudGlmaWVyXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBmbG93UGFyc2VHZW5lcmljVHlwZShzdGFydExvYywgaWQpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IG51bGw7XG4gICAgbm9kZS5pZCA9IHRoaXMuZmxvd1BhcnNlUXVhbGlmaWVkVHlwZUlkZW50aWZpZXIoc3RhcnRMb2MsIGlkKTtcbiAgICBpZiAodGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJHZW5lcmljVHlwZUFubm90YXRpb25cIik7XG4gIH1cbiAgZmxvd1BhcnNlVHlwZW9mVHlwZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLmV4cGVjdCg4Nyk7XG4gICAgbm9kZS5hcmd1bWVudCA9IHRoaXMuZmxvd1BhcnNlUHJpbWFyeVR5cGUoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHlwZW9mVHlwZUFubm90YXRpb25cIik7XG4gIH1cbiAgZmxvd1BhcnNlVHVwbGVUeXBlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUudHlwZXMgPSBbXTtcbiAgICB0aGlzLmV4cGVjdCgwKTtcbiAgICB3aGlsZSAodGhpcy5zdGF0ZS5wb3MgPCB0aGlzLmxlbmd0aCAmJiAhdGhpcy5tYXRjaCgzKSkge1xuICAgICAgbm9kZS50eXBlcy5wdXNoKHRoaXMuZmxvd1BhcnNlVHlwZSgpKTtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDMpKSBicmVhaztcbiAgICAgIHRoaXMuZXhwZWN0KDEyKTtcbiAgICB9XG4gICAgdGhpcy5leHBlY3QoMyk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlR1cGxlVHlwZUFubm90YXRpb25cIik7XG4gIH1cbiAgZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW0oZmlyc3QpIHtcbiAgICBsZXQgbmFtZSA9IG51bGw7XG4gICAgbGV0IG9wdGlvbmFsID0gZmFsc2U7XG4gICAgbGV0IHR5cGVBbm5vdGF0aW9uID0gbnVsbDtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCBsaCA9IHRoaXMubG9va2FoZWFkKCk7XG4gICAgY29uc3QgaXNUaGlzID0gdGhpcy5zdGF0ZS50eXBlID09PSA3ODtcbiAgICBpZiAobGgudHlwZSA9PT0gMTQgfHwgbGgudHlwZSA9PT0gMTcpIHtcbiAgICAgIGlmIChpc1RoaXMgJiYgIWZpcnN0KSB7XG4gICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5UaGlzUGFyYW1NdXN0QmVGaXJzdCwgbm9kZSk7XG4gICAgICB9XG4gICAgICBuYW1lID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoaXNUaGlzKTtcbiAgICAgIGlmICh0aGlzLmVhdCgxNykpIHtcbiAgICAgICAgb3B0aW9uYWwgPSB0cnVlO1xuICAgICAgICBpZiAoaXNUaGlzKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLlRoaXNQYXJhbU1heU5vdEJlT3B0aW9uYWwsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmxvd1BhcnNlVHlwZUluaXRpYWxpc2VyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGVBbm5vdGF0aW9uID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gICAgfVxuICAgIG5vZGUubmFtZSA9IG5hbWU7XG4gICAgbm9kZS5vcHRpb25hbCA9IG9wdGlvbmFsO1xuICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0eXBlQW5ub3RhdGlvbjtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25UeXBlUGFyYW1cIik7XG4gIH1cbiAgcmVpbnRlcnByZXRUeXBlQXNGdW5jdGlvblR5cGVQYXJhbSh0eXBlKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQodHlwZS5sb2Muc3RhcnQpO1xuICAgIG5vZGUubmFtZSA9IG51bGw7XG4gICAgbm9kZS5vcHRpb25hbCA9IGZhbHNlO1xuICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0eXBlO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJGdW5jdGlvblR5cGVQYXJhbVwiKTtcbiAgfVxuICBmbG93UGFyc2VGdW5jdGlvblR5cGVQYXJhbXMocGFyYW1zID0gW10pIHtcbiAgICBsZXQgcmVzdCA9IG51bGw7XG4gICAgbGV0IF90aGlzID0gbnVsbDtcbiAgICBpZiAodGhpcy5tYXRjaCg3OCkpIHtcbiAgICAgIF90aGlzID0gdGhpcy5mbG93UGFyc2VGdW5jdGlvblR5cGVQYXJhbSh0cnVlKTtcbiAgICAgIF90aGlzLm5hbWUgPSBudWxsO1xuICAgICAgaWYgKCF0aGlzLm1hdGNoKDExKSkge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgICB9XG4gICAgfVxuICAgIHdoaWxlICghdGhpcy5tYXRjaCgxMSkgJiYgIXRoaXMubWF0Y2goMjEpKSB7XG4gICAgICBwYXJhbXMucHVzaCh0aGlzLmZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtKGZhbHNlKSk7XG4gICAgICBpZiAoIXRoaXMubWF0Y2goMTEpKSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KDEyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuZWF0KDIxKSkge1xuICAgICAgcmVzdCA9IHRoaXMuZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW0oZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcGFyYW1zLFxuICAgICAgcmVzdCxcbiAgICAgIF90aGlzXG4gICAgfTtcbiAgfVxuICBmbG93SWRlbnRUb1R5cGVBbm5vdGF0aW9uKHN0YXJ0TG9jLCBub2RlLCBpZCkge1xuICAgIHN3aXRjaCAoaWQubmFtZSkge1xuICAgICAgY2FzZSBcImFueVwiOlxuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQW55VHlwZUFubm90YXRpb25cIik7XG4gICAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkJvb2xlYW5UeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgIGNhc2UgXCJtaXhlZFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTWl4ZWRUeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgIGNhc2UgXCJlbXB0eVwiOlxuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW1wdHlUeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk51bWJlclR5cGVBbm5vdGF0aW9uXCIpO1xuICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3RyaW5nVHlwZUFubm90YXRpb25cIik7XG4gICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTeW1ib2xUeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuY2hlY2tOb3RVbmRlcnNjb3JlKGlkLm5hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VHZW5lcmljVHlwZShzdGFydExvYywgaWQpO1xuICAgIH1cbiAgfVxuICBmbG93UGFyc2VQcmltYXJ5VHlwZSgpIHtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbGV0IHRtcDtcbiAgICBsZXQgdHlwZTtcbiAgICBsZXQgaXNHcm91cGVkVHlwZSA9IGZhbHNlO1xuICAgIGNvbnN0IG9sZE5vQW5vbkZ1bmN0aW9uVHlwZSA9IHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlO1xuICAgIHN3aXRjaCAodGhpcy5zdGF0ZS50eXBlKSB7XG4gICAgICBjYXNlIDU6XG4gICAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZU9iamVjdFR5cGUoe1xuICAgICAgICAgIGFsbG93U3RhdGljOiBmYWxzZSxcbiAgICAgICAgICBhbGxvd0V4YWN0OiBmYWxzZSxcbiAgICAgICAgICBhbGxvd1NwcmVhZDogdHJ1ZSxcbiAgICAgICAgICBhbGxvd1Byb3RvOiBmYWxzZSxcbiAgICAgICAgICBhbGxvd0luZXhhY3Q6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIDY6XG4gICAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZU9iamVjdFR5cGUoe1xuICAgICAgICAgIGFsbG93U3RhdGljOiBmYWxzZSxcbiAgICAgICAgICBhbGxvd0V4YWN0OiB0cnVlLFxuICAgICAgICAgIGFsbG93U3ByZWFkOiB0cnVlLFxuICAgICAgICAgIGFsbG93UHJvdG86IGZhbHNlLFxuICAgICAgICAgIGFsbG93SW5leGFjdDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlID0gZmFsc2U7XG4gICAgICAgIHR5cGUgPSB0aGlzLmZsb3dQYXJzZVR1cGxlVHlwZSgpO1xuICAgICAgICB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSA9IG9sZE5vQW5vbkZ1bmN0aW9uVHlwZTtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICBjYXNlIDQ3OlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgICAgICAgdGhpcy5leHBlY3QoMTApO1xuICAgICAgICAgIHRtcCA9IHRoaXMuZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW1zKCk7XG4gICAgICAgICAgbm9kZS5wYXJhbXMgPSB0bXAucGFyYW1zO1xuICAgICAgICAgIG5vZGUucmVzdCA9IHRtcC5yZXN0O1xuICAgICAgICAgIG5vZGUudGhpcyA9IHRtcC5fdGhpcztcbiAgICAgICAgICB0aGlzLmV4cGVjdCgxMSk7XG4gICAgICAgICAgdGhpcy5leHBlY3QoMTkpO1xuICAgICAgICAgIG5vZGUucmV0dXJuVHlwZSA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICBjYXNlIDEwOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKDExKSAmJiAhdGhpcy5tYXRjaCgyMSkpIHtcbiAgICAgICAgICAgIGlmICh0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpIHx8IHRoaXMubWF0Y2goNzgpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5sb29rYWhlYWQoKS50eXBlO1xuICAgICAgICAgICAgICBpc0dyb3VwZWRUeXBlID0gdG9rZW4gIT09IDE3ICYmIHRva2VuICE9PSAxNDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlzR3JvdXBlZFR5cGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNHcm91cGVkVHlwZSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHR5cGUgPSB0aGlzLmZsb3dQYXJzZVR5cGUoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlID0gb2xkTm9Bbm9uRnVuY3Rpb25UeXBlO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlIHx8ICEodGhpcy5tYXRjaCgxMikgfHwgdGhpcy5tYXRjaCgxMSkgJiYgdGhpcy5sb29rYWhlYWQoKS50eXBlID09PSAxOSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5leHBlY3QoMTEpO1xuICAgICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuZWF0KDEyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIHRtcCA9IHRoaXMuZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW1zKFt0aGlzLnJlaW50ZXJwcmV0VHlwZUFzRnVuY3Rpb25UeXBlUGFyYW0odHlwZSldKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG1wID0gdGhpcy5mbG93UGFyc2VGdW5jdGlvblR5cGVQYXJhbXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5wYXJhbXMgPSB0bXAucGFyYW1zO1xuICAgICAgICAgIG5vZGUucmVzdCA9IHRtcC5yZXN0O1xuICAgICAgICAgIG5vZGUudGhpcyA9IHRtcC5fdGhpcztcbiAgICAgICAgICB0aGlzLmV4cGVjdCgxMSk7XG4gICAgICAgICAgdGhpcy5leHBlY3QoMTkpO1xuICAgICAgICAgIG5vZGUucmV0dXJuVHlwZSA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICAgICAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICBjYXNlIDEzNDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUsIFwiU3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIpO1xuICAgICAgY2FzZSA4NTpcbiAgICAgIGNhc2UgODY6XG4gICAgICAgIG5vZGUudmFsdWUgPSB0aGlzLm1hdGNoKDg1KTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJCb29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIpO1xuICAgICAgY2FzZSA1MzpcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUudmFsdWUgPT09IFwiLVwiKSB7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgaWYgKHRoaXMubWF0Y2goMTM1KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsQXROb2RlKC10aGlzLnN0YXRlLnZhbHVlLCBcIk51bWJlckxpdGVyYWxUeXBlQW5ub3RhdGlvblwiLCBub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMubWF0Y2goMTM2KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsQXROb2RlKC10aGlzLnN0YXRlLnZhbHVlLCBcIkJpZ0ludExpdGVyYWxUeXBlQW5ub3RhdGlvblwiLCBub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShGbG93RXJyb3JzLlVuZXhwZWN0ZWRTdWJ0cmFjdGlvbk9wZXJhbmQsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDEzNTpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUsIFwiTnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIpO1xuICAgICAgY2FzZSAxMzY6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlLCBcIkJpZ0ludExpdGVyYWxUeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgIGNhc2UgODg6XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVm9pZFR5cGVBbm5vdGF0aW9uXCIpO1xuICAgICAgY2FzZSA4NDpcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJOdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIpO1xuICAgICAgY2FzZSA3ODpcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUaGlzVHlwZUFubm90YXRpb25cIik7XG4gICAgICBjYXNlIDU1OlxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4aXN0c1R5cGVBbm5vdGF0aW9uXCIpO1xuICAgICAgY2FzZSA4NzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlVHlwZW9mVHlwZSgpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHRva2VuSXNLZXl3b3JkKHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgICAgICBjb25zdCBsYWJlbCA9IHRva2VuTGFiZWxOYW1lKHRoaXMuc3RhdGUudHlwZSk7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUlkZW50aWZpZXIobm9kZSwgbGFiZWwpO1xuICAgICAgICB9IGVsc2UgaWYgKHRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgICAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTI5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlSW50ZXJmYWNlVHlwZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5mbG93SWRlbnRUb1R5cGVBbm5vdGF0aW9uKHN0YXJ0TG9jLCBub2RlLCB0aGlzLnBhcnNlSWRlbnRpZmllcigpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxuICBmbG93UGFyc2VQb3N0Zml4VHlwZSgpIHtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgbGV0IHR5cGUgPSB0aGlzLmZsb3dQYXJzZVByaW1hcnlUeXBlKCk7XG4gICAgbGV0IHNlZW5PcHRpb25hbEluZGV4ZWRBY2Nlc3MgPSBmYWxzZTtcbiAgICB3aGlsZSAoKHRoaXMubWF0Y2goMCkgfHwgdGhpcy5tYXRjaCgxOCkpICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICBjb25zdCBvcHRpb25hbCA9IHRoaXMuZWF0KDE4KTtcbiAgICAgIHNlZW5PcHRpb25hbEluZGV4ZWRBY2Nlc3MgPSBzZWVuT3B0aW9uYWxJbmRleGVkQWNjZXNzIHx8IG9wdGlvbmFsO1xuICAgICAgdGhpcy5leHBlY3QoMCk7XG4gICAgICBpZiAoIW9wdGlvbmFsICYmIHRoaXMubWF0Y2goMykpIHtcbiAgICAgICAgbm9kZS5lbGVtZW50VHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICB0eXBlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyYXlUeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUub2JqZWN0VHlwZSA9IHR5cGU7XG4gICAgICAgIG5vZGUuaW5kZXhUeXBlID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gICAgICAgIHRoaXMuZXhwZWN0KDMpO1xuICAgICAgICBpZiAoc2Vlbk9wdGlvbmFsSW5kZXhlZEFjY2Vzcykge1xuICAgICAgICAgIG5vZGUub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICAgICAgICB0eXBlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiT3B0aW9uYWxJbmRleGVkQWNjZXNzVHlwZVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0eXBlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW5kZXhlZEFjY2Vzc1R5cGVcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgZmxvd1BhcnNlUHJlZml4VHlwZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBpZiAodGhpcy5lYXQoMTcpKSB7XG4gICAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy5mbG93UGFyc2VQcmVmaXhUeXBlKCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTnVsbGFibGVUeXBlQW5ub3RhdGlvblwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlUG9zdGZpeFR5cGUoKTtcbiAgICB9XG4gIH1cbiAgZmxvd1BhcnNlQW5vbkZ1bmN0aW9uV2l0aG91dFBhcmVucygpIHtcbiAgICBjb25zdCBwYXJhbSA9IHRoaXMuZmxvd1BhcnNlUHJlZml4VHlwZSgpO1xuICAgIGlmICghdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGUgJiYgdGhpcy5lYXQoMTkpKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChwYXJhbS5sb2Muc3RhcnQpO1xuICAgICAgbm9kZS5wYXJhbXMgPSBbdGhpcy5yZWludGVycHJldFR5cGVBc0Z1bmN0aW9uVHlwZVBhcmFtKHBhcmFtKV07XG4gICAgICBub2RlLnJlc3QgPSBudWxsO1xuICAgICAgbm9kZS50aGlzID0gbnVsbDtcbiAgICAgIG5vZGUucmV0dXJuVHlwZSA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IG51bGw7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtO1xuICB9XG4gIGZsb3dQYXJzZUludGVyc2VjdGlvblR5cGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5lYXQoNDUpO1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLmZsb3dQYXJzZUFub25GdW5jdGlvbldpdGhvdXRQYXJlbnMoKTtcbiAgICBub2RlLnR5cGVzID0gW3R5cGVdO1xuICAgIHdoaWxlICh0aGlzLmVhdCg0NSkpIHtcbiAgICAgIG5vZGUudHlwZXMucHVzaCh0aGlzLmZsb3dQYXJzZUFub25GdW5jdGlvbldpdGhvdXRQYXJlbnMoKSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlLnR5cGVzLmxlbmd0aCA9PT0gMSA/IHR5cGUgOiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvblwiKTtcbiAgfVxuICBmbG93UGFyc2VVbmlvblR5cGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5lYXQoNDMpO1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLmZsb3dQYXJzZUludGVyc2VjdGlvblR5cGUoKTtcbiAgICBub2RlLnR5cGVzID0gW3R5cGVdO1xuICAgIHdoaWxlICh0aGlzLmVhdCg0MykpIHtcbiAgICAgIG5vZGUudHlwZXMucHVzaCh0aGlzLmZsb3dQYXJzZUludGVyc2VjdGlvblR5cGUoKSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlLnR5cGVzLmxlbmd0aCA9PT0gMSA/IHR5cGUgOiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJVbmlvblR5cGVBbm5vdGF0aW9uXCIpO1xuICB9XG4gIGZsb3dQYXJzZVR5cGUoKSB7XG4gICAgY29uc3Qgb2xkSW5UeXBlID0gdGhpcy5zdGF0ZS5pblR5cGU7XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSB0cnVlO1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLmZsb3dQYXJzZVVuaW9uVHlwZSgpO1xuICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gb2xkSW5UeXBlO1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIGZsb3dQYXJzZVR5cGVPckltcGxpY2l0SW5zdGFudGlhdGlvbigpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS50eXBlID09PSAxMzIgJiYgdGhpcy5zdGF0ZS52YWx1ZSA9PT0gXCJfXCIpIHtcbiAgICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlR2VuZXJpY1R5cGUoc3RhcnRMb2MsIG5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gICAgfVxuICB9XG4gIGZsb3dQYXJzZVR5cGVBbm5vdGF0aW9uKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUeXBlQW5ub3RhdGlvblwiKTtcbiAgfVxuICBmbG93UGFyc2VUeXBlQW5ub3RhdGFibGVJZGVudGlmaWVyKGFsbG93UHJpbWl0aXZlT3ZlcnJpZGUpIHtcbiAgICBjb25zdCBpZGVudCA9IGFsbG93UHJpbWl0aXZlT3ZlcnJpZGUgPyB0aGlzLnBhcnNlSWRlbnRpZmllcigpIDogdGhpcy5mbG93UGFyc2VSZXN0cmljdGVkSWRlbnRpZmllcigpO1xuICAgIGlmICh0aGlzLm1hdGNoKDE0KSkge1xuICAgICAgaWRlbnQudHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgICB0aGlzLnJlc2V0RW5kTG9jYXRpb24oaWRlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gaWRlbnQ7XG4gIH1cbiAgdHlwZUNhc3RUb1BhcmFtZXRlcihub2RlKSB7XG4gICAgbm9kZS5leHByZXNzaW9uLnR5cGVBbm5vdGF0aW9uID0gbm9kZS50eXBlQW5ub3RhdGlvbjtcbiAgICB0aGlzLnJlc2V0RW5kTG9jYXRpb24obm9kZS5leHByZXNzaW9uLCBub2RlLnR5cGVBbm5vdGF0aW9uLmxvYy5lbmQpO1xuICAgIHJldHVybiBub2RlLmV4cHJlc3Npb247XG4gIH1cbiAgZmxvd1BhcnNlVmFyaWFuY2UoKSB7XG4gICAgbGV0IHZhcmlhbmNlID0gbnVsbDtcbiAgICBpZiAodGhpcy5tYXRjaCg1MykpIHtcbiAgICAgIHZhcmlhbmNlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIGlmICh0aGlzLnN0YXRlLnZhbHVlID09PSBcIitcIikge1xuICAgICAgICB2YXJpYW5jZS5raW5kID0gXCJwbHVzXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXJpYW5jZS5raW5kID0gXCJtaW51c1wiO1xuICAgICAgfVxuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHZhcmlhbmNlLCBcIlZhcmlhbmNlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdmFyaWFuY2U7XG4gIH1cbiAgcGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgYWxsb3dFeHByZXNzaW9uQm9keSwgaXNNZXRob2QgPSBmYWxzZSkge1xuICAgIGlmIChhbGxvd0V4cHJlc3Npb25Cb2R5KSB7XG4gICAgICB0aGlzLmZvcndhcmROb0Fycm93UGFyYW1zQ29udmVyc2lvbkF0KG5vZGUsICgpID0+IHN1cGVyLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIHRydWUsIGlzTWV0aG9kKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIGZhbHNlLCBpc01ldGhvZCk7XG4gIH1cbiAgcGFyc2VGdW5jdGlvbkJvZHlBbmRGaW5pc2gobm9kZSwgdHlwZSwgaXNNZXRob2QgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKDE0KSkge1xuICAgICAgY29uc3QgdHlwZU5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgW3R5cGVOb2RlLnR5cGVBbm5vdGF0aW9uLCBub2RlLnByZWRpY2F0ZV0gPSB0aGlzLmZsb3dQYXJzZVR5cGVBbmRQcmVkaWNhdGVJbml0aWFsaXNlcigpO1xuICAgICAgbm9kZS5yZXR1cm5UeXBlID0gdHlwZU5vZGUudHlwZUFubm90YXRpb24gPyB0aGlzLmZpbmlzaE5vZGUodHlwZU5vZGUsIFwiVHlwZUFubm90YXRpb25cIikgOiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGFyc2VGdW5jdGlvbkJvZHlBbmRGaW5pc2gobm9kZSwgdHlwZSwgaXNNZXRob2QpO1xuICB9XG4gIHBhcnNlU3RhdGVtZW50TGlrZShmbGFncykge1xuICAgIGlmICh0aGlzLnN0YXRlLnN0cmljdCAmJiB0aGlzLmlzQ29udGV4dHVhbCgxMjkpKSB7XG4gICAgICBjb25zdCBsb29rYWhlYWQgPSB0aGlzLmxvb2thaGVhZCgpO1xuICAgICAgaWYgKHRva2VuSXNLZXl3b3JkT3JJZGVudGlmaWVyKGxvb2thaGVhZC50eXBlKSkge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZUludGVyZmFjZShub2RlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEyNikpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VFbnVtRGVjbGFyYXRpb24obm9kZSk7XG4gICAgfVxuICAgIGNvbnN0IHN0bXQgPSBzdXBlci5wYXJzZVN0YXRlbWVudExpa2UoZmxhZ3MpO1xuICAgIGlmICh0aGlzLmZsb3dQcmFnbWEgPT09IHVuZGVmaW5lZCAmJiAhdGhpcy5pc1ZhbGlkRGlyZWN0aXZlKHN0bXQpKSB7XG4gICAgICB0aGlzLmZsb3dQcmFnbWEgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gc3RtdDtcbiAgfVxuICBwYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgZXhwciwgZGVjb3JhdG9ycykge1xuICAgIGlmIChleHByLnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICBpZiAoZXhwci5uYW1lID09PSBcImRlY2xhcmVcIikge1xuICAgICAgICBpZiAodGhpcy5tYXRjaCg4MCkgfHwgdG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSB8fCB0aGlzLm1hdGNoKDY4KSB8fCB0aGlzLm1hdGNoKDc0KSB8fCB0aGlzLm1hdGNoKDgyKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgICBpZiAoZXhwci5uYW1lID09PSBcImludGVyZmFjZVwiKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlSW50ZXJmYWNlKG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKGV4cHIubmFtZSA9PT0gXCJ0eXBlXCIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VUeXBlQWxpYXMobm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXhwci5uYW1lID09PSBcIm9wYXF1ZVwiKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlT3BhcXVlVHlwZShub2RlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCBleHByLCBkZWNvcmF0b3JzKTtcbiAgfVxuICBzaG91bGRQYXJzZUV4cG9ydERlY2xhcmF0aW9uKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodHlwZSA9PT0gMTI2IHx8IHRva2VuSXNGbG93SW50ZXJmYWNlT3JUeXBlT3JPcGFxdWUodHlwZSkpIHtcbiAgICAgIHJldHVybiAhdGhpcy5zdGF0ZS5jb250YWluc0VzYztcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnNob3VsZFBhcnNlRXhwb3J0RGVjbGFyYXRpb24oKTtcbiAgfVxuICBpc0V4cG9ydERlZmF1bHRTcGVjaWZpZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICh0eXBlID09PSAxMjYgfHwgdG9rZW5Jc0Zsb3dJbnRlcmZhY2VPclR5cGVPck9wYXF1ZSh0eXBlKSkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuY29udGFpbnNFc2M7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5pc0V4cG9ydERlZmF1bHRTcGVjaWZpZXIoKTtcbiAgfVxuICBwYXJzZUV4cG9ydERlZmF1bHRFeHByZXNzaW9uKCkge1xuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMjYpKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlRW51bURlY2xhcmF0aW9uKG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGFyc2VFeHBvcnREZWZhdWx0RXhwcmVzc2lvbigpO1xuICB9XG4gIHBhcnNlQ29uZGl0aW9uYWwoZXhwciwgc3RhcnRMb2MsIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBpZiAoIXRoaXMubWF0Y2goMTcpKSByZXR1cm4gZXhwcjtcbiAgICBpZiAodGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzKSB7XG4gICAgICBjb25zdCBuZXh0Q2ggPSB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCk7XG4gICAgICBpZiAobmV4dENoID09PSA0NCB8fCBuZXh0Q2ggPT09IDYxIHx8IG5leHRDaCA9PT0gNTggfHwgbmV4dENoID09PSA0MSkge1xuICAgICAgICB0aGlzLnNldE9wdGlvbmFsUGFyYW1ldGVyc0Vycm9yKHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5leHBlY3QoMTcpO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZS5jbG9uZSgpO1xuICAgIGNvbnN0IG9yaWdpbmFsTm9BcnJvd0F0ID0gdGhpcy5zdGF0ZS5ub0Fycm93QXQ7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgIGxldCB7XG4gICAgICBjb25zZXF1ZW50LFxuICAgICAgZmFpbGVkXG4gICAgfSA9IHRoaXMudHJ5UGFyc2VDb25kaXRpb25hbENvbnNlcXVlbnQoKTtcbiAgICBsZXQgW3ZhbGlkLCBpbnZhbGlkXSA9IHRoaXMuZ2V0QXJyb3dMaWtlRXhwcmVzc2lvbnMoY29uc2VxdWVudCk7XG4gICAgaWYgKGZhaWxlZCB8fCBpbnZhbGlkLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IG5vQXJyb3dBdCA9IFsuLi5vcmlnaW5hbE5vQXJyb3dBdF07XG4gICAgICBpZiAoaW52YWxpZC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5zdGF0ZS5ub0Fycm93QXQgPSBub0Fycm93QXQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW52YWxpZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5vQXJyb3dBdC5wdXNoKGludmFsaWRbaV0uc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgICh7XG4gICAgICAgICAgY29uc2VxdWVudCxcbiAgICAgICAgICBmYWlsZWRcbiAgICAgICAgfSA9IHRoaXMudHJ5UGFyc2VDb25kaXRpb25hbENvbnNlcXVlbnQoKSk7XG4gICAgICAgIFt2YWxpZCwgaW52YWxpZF0gPSB0aGlzLmdldEFycm93TGlrZUV4cHJlc3Npb25zKGNvbnNlcXVlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKGZhaWxlZCAmJiB2YWxpZC5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5BbWJpZ3VvdXNDb25kaXRpb25hbEFycm93LCBzdGF0ZS5zdGFydExvYyk7XG4gICAgICB9XG4gICAgICBpZiAoZmFpbGVkICYmIHZhbGlkLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIG5vQXJyb3dBdC5wdXNoKHZhbGlkWzBdLnN0YXJ0KTtcbiAgICAgICAgdGhpcy5zdGF0ZS5ub0Fycm93QXQgPSBub0Fycm93QXQ7XG4gICAgICAgICh7XG4gICAgICAgICAgY29uc2VxdWVudCxcbiAgICAgICAgICBmYWlsZWRcbiAgICAgICAgfSA9IHRoaXMudHJ5UGFyc2VDb25kaXRpb25hbENvbnNlcXVlbnQoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZ2V0QXJyb3dMaWtlRXhwcmVzc2lvbnMoY29uc2VxdWVudCwgdHJ1ZSk7XG4gICAgdGhpcy5zdGF0ZS5ub0Fycm93QXQgPSBvcmlnaW5hbE5vQXJyb3dBdDtcbiAgICB0aGlzLmV4cGVjdCgxNCk7XG4gICAgbm9kZS50ZXN0ID0gZXhwcjtcbiAgICBub2RlLmNvbnNlcXVlbnQgPSBjb25zZXF1ZW50O1xuICAgIG5vZGUuYWx0ZXJuYXRlID0gdGhpcy5mb3J3YXJkTm9BcnJvd1BhcmFtc0NvbnZlcnNpb25BdChub2RlLCAoKSA9PiB0aGlzLnBhcnNlTWF5YmVBc3NpZ24odW5kZWZpbmVkLCB1bmRlZmluZWQpKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIpO1xuICB9XG4gIHRyeVBhcnNlQ29uZGl0aW9uYWxDb25zZXF1ZW50KCkge1xuICAgIHRoaXMuc3RhdGUubm9BcnJvd1BhcmFtc0NvbnZlcnNpb25BdC5wdXNoKHRoaXMuc3RhdGUuc3RhcnQpO1xuICAgIGNvbnN0IGNvbnNlcXVlbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKCk7XG4gICAgY29uc3QgZmFpbGVkID0gIXRoaXMubWF0Y2goMTQpO1xuICAgIHRoaXMuc3RhdGUubm9BcnJvd1BhcmFtc0NvbnZlcnNpb25BdC5wb3AoKTtcbiAgICByZXR1cm4ge1xuICAgICAgY29uc2VxdWVudCxcbiAgICAgIGZhaWxlZFxuICAgIH07XG4gIH1cbiAgZ2V0QXJyb3dMaWtlRXhwcmVzc2lvbnMobm9kZSwgZGlzYWxsb3dJbnZhbGlkKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBbbm9kZV07XG4gICAgY29uc3QgYXJyb3dzID0gW107XG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCAhPT0gMCkge1xuICAgICAgY29uc3Qgbm9kZSA9IHN0YWNrLnBvcCgpO1xuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiICYmIG5vZGUuYm9keS50eXBlICE9PSBcIkJsb2NrU3RhdGVtZW50XCIpIHtcbiAgICAgICAgaWYgKG5vZGUudHlwZVBhcmFtZXRlcnMgfHwgIW5vZGUucmV0dXJuVHlwZSkge1xuICAgICAgICAgIHRoaXMuZmluaXNoQXJyb3dWYWxpZGF0aW9uKG5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFycm93cy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnB1c2gobm9kZS5ib2R5KTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiKSB7XG4gICAgICAgIHN0YWNrLnB1c2gobm9kZS5jb25zZXF1ZW50KTtcbiAgICAgICAgc3RhY2sucHVzaChub2RlLmFsdGVybmF0ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkaXNhbGxvd0ludmFsaWQpIHtcbiAgICAgIGFycm93cy5mb3JFYWNoKG5vZGUgPT4gdGhpcy5maW5pc2hBcnJvd1ZhbGlkYXRpb24obm9kZSkpO1xuICAgICAgcmV0dXJuIFthcnJvd3MsIFtdXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRpdGlvbihhcnJvd3MsIG5vZGUgPT4gbm9kZS5wYXJhbXMuZXZlcnkocGFyYW0gPT4gdGhpcy5pc0Fzc2lnbmFibGUocGFyYW0sIHRydWUpKSk7XG4gIH1cbiAgZmluaXNoQXJyb3dWYWxpZGF0aW9uKG5vZGUpIHtcbiAgICB2YXIgX25vZGUkZXh0cmE7XG4gICAgdGhpcy50b0Fzc2lnbmFibGVMaXN0KG5vZGUucGFyYW1zLCAoX25vZGUkZXh0cmEgPSBub2RlLmV4dHJhKSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkZXh0cmEudHJhaWxpbmdDb21tYUxvYywgZmFsc2UpO1xuICAgIHRoaXMuc2NvcGUuZW50ZXIoNTE0IHwgNCk7XG4gICAgc3VwZXIuY2hlY2tQYXJhbXMobm9kZSwgZmFsc2UsIHRydWUpO1xuICAgIHRoaXMuc2NvcGUuZXhpdCgpO1xuICB9XG4gIGZvcndhcmROb0Fycm93UGFyYW1zQ29udmVyc2lvbkF0KG5vZGUsIHBhcnNlKSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAodGhpcy5zdGF0ZS5ub0Fycm93UGFyYW1zQ29udmVyc2lvbkF0LmluY2x1ZGVzKHRoaXMub2Zmc2V0VG9Tb3VyY2VQb3Mobm9kZS5zdGFydCkpKSB7XG4gICAgICB0aGlzLnN0YXRlLm5vQXJyb3dQYXJhbXNDb252ZXJzaW9uQXQucHVzaCh0aGlzLnN0YXRlLnN0YXJ0KTtcbiAgICAgIHJlc3VsdCA9IHBhcnNlKCk7XG4gICAgICB0aGlzLnN0YXRlLm5vQXJyb3dQYXJhbXNDb252ZXJzaW9uQXQucG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IHBhcnNlKCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcGFyc2VQYXJlbkl0ZW0obm9kZSwgc3RhcnRMb2MpIHtcbiAgICBjb25zdCBuZXdOb2RlID0gc3VwZXIucGFyc2VQYXJlbkl0ZW0obm9kZSwgc3RhcnRMb2MpO1xuICAgIGlmICh0aGlzLmVhdCgxNykpIHtcbiAgICAgIG5ld05vZGUub3B0aW9uYWwgPSB0cnVlO1xuICAgICAgdGhpcy5yZXNldEVuZExvY2F0aW9uKG5vZGUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXRjaCgxNCkpIHtcbiAgICAgIGNvbnN0IHR5cGVDYXN0Tm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgdHlwZUNhc3ROb2RlLmV4cHJlc3Npb24gPSBuZXdOb2RlO1xuICAgICAgdHlwZUNhc3ROb2RlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy5mbG93UGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZSh0eXBlQ2FzdE5vZGUsIFwiVHlwZUNhc3RFeHByZXNzaW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3Tm9kZTtcbiAgfVxuICBhc3NlcnRNb2R1bGVOb2RlQWxsb3dlZChub2RlKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJJbXBvcnREZWNsYXJhdGlvblwiICYmIChub2RlLmltcG9ydEtpbmQgPT09IFwidHlwZVwiIHx8IG5vZGUuaW1wb3J0S2luZCA9PT0gXCJ0eXBlb2ZcIikgfHwgbm9kZS50eXBlID09PSBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIiAmJiBub2RlLmV4cG9ydEtpbmQgPT09IFwidHlwZVwiIHx8IG5vZGUudHlwZSA9PT0gXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiICYmIG5vZGUuZXhwb3J0S2luZCA9PT0gXCJ0eXBlXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIuYXNzZXJ0TW9kdWxlTm9kZUFsbG93ZWQobm9kZSk7XG4gIH1cbiAgcGFyc2VFeHBvcnREZWNsYXJhdGlvbihub2RlKSB7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEzMCkpIHtcbiAgICAgIG5vZGUuZXhwb3J0S2luZCA9IFwidHlwZVwiO1xuICAgICAgY29uc3QgZGVjbGFyYXRpb25Ob2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgaWYgKHRoaXMubWF0Y2goNSkpIHtcbiAgICAgICAgbm9kZS5zcGVjaWZpZXJzID0gdGhpcy5wYXJzZUV4cG9ydFNwZWNpZmllcnModHJ1ZSk7XG4gICAgICAgIHN1cGVyLnBhcnNlRXhwb3J0RnJvbShub2RlKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VUeXBlQWxpYXMoZGVjbGFyYXRpb25Ob2RlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEzMSkpIHtcbiAgICAgIG5vZGUuZXhwb3J0S2luZCA9IFwidHlwZVwiO1xuICAgICAgY29uc3QgZGVjbGFyYXRpb25Ob2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlT3BhcXVlVHlwZShkZWNsYXJhdGlvbk5vZGUsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEyOSkpIHtcbiAgICAgIG5vZGUuZXhwb3J0S2luZCA9IFwidHlwZVwiO1xuICAgICAgY29uc3QgZGVjbGFyYXRpb25Ob2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlSW50ZXJmYWNlKGRlY2xhcmF0aW9uTm9kZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMjYpKSB7XG4gICAgICBub2RlLmV4cG9ydEtpbmQgPSBcInZhbHVlXCI7XG4gICAgICBjb25zdCBkZWNsYXJhdGlvbk5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VFbnVtRGVjbGFyYXRpb24oZGVjbGFyYXRpb25Ob2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN1cGVyLnBhcnNlRXhwb3J0RGVjbGFyYXRpb24obm9kZSk7XG4gICAgfVxuICB9XG4gIGVhdEV4cG9ydFN0YXIobm9kZSkge1xuICAgIGlmIChzdXBlci5lYXRFeHBvcnRTdGFyKG5vZGUpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTMwKSAmJiB0aGlzLmxvb2thaGVhZCgpLnR5cGUgPT09IDU1KSB7XG4gICAgICBub2RlLmV4cG9ydEtpbmQgPSBcInR5cGVcIjtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIG1heWJlUGFyc2VFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXIobm9kZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YXJ0TG9jXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgaGFzTmFtZXNwYWNlID0gc3VwZXIubWF5YmVQYXJzZUV4cG9ydE5hbWVzcGFjZVNwZWNpZmllcihub2RlKTtcbiAgICBpZiAoaGFzTmFtZXNwYWNlICYmIG5vZGUuZXhwb3J0S2luZCA9PT0gXCJ0eXBlXCIpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZChzdGFydExvYyk7XG4gICAgfVxuICAgIHJldHVybiBoYXNOYW1lc3BhY2U7XG4gIH1cbiAgcGFyc2VDbGFzc0lkKG5vZGUsIGlzU3RhdGVtZW50LCBvcHRpb25hbElkKSB7XG4gICAgc3VwZXIucGFyc2VDbGFzc0lkKG5vZGUsIGlzU3RhdGVtZW50LCBvcHRpb25hbElkKTtcbiAgICBpZiAodGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgIH1cbiAgfVxuICBwYXJzZUNsYXNzTWVtYmVyKGNsYXNzQm9keSwgbWVtYmVyLCBzdGF0ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YXJ0TG9jXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEyNSkpIHtcbiAgICAgIGlmIChzdXBlci5wYXJzZUNsYXNzTWVtYmVyRnJvbU1vZGlmaWVyKGNsYXNzQm9keSwgbWVtYmVyKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBtZW1iZXIuZGVjbGFyZSA9IHRydWU7XG4gICAgfVxuICAgIHN1cGVyLnBhcnNlQ2xhc3NNZW1iZXIoY2xhc3NCb2R5LCBtZW1iZXIsIHN0YXRlKTtcbiAgICBpZiAobWVtYmVyLmRlY2xhcmUpIHtcbiAgICAgIGlmIChtZW1iZXIudHlwZSAhPT0gXCJDbGFzc1Byb3BlcnR5XCIgJiYgbWVtYmVyLnR5cGUgIT09IFwiQ2xhc3NQcml2YXRlUHJvcGVydHlcIiAmJiBtZW1iZXIudHlwZSAhPT0gXCJQcm9wZXJ0eURlZmluaXRpb25cIikge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuRGVjbGFyZUNsYXNzRWxlbWVudCwgc3RhcnRMb2MpO1xuICAgICAgfSBlbHNlIGlmIChtZW1iZXIudmFsdWUpIHtcbiAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLkRlY2xhcmVDbGFzc0ZpZWxkSW5pdGlhbGl6ZXIsIG1lbWJlci52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlzSXRlcmF0b3Iod29yZCkge1xuICAgIHJldHVybiB3b3JkID09PSBcIml0ZXJhdG9yXCIgfHwgd29yZCA9PT0gXCJhc3luY0l0ZXJhdG9yXCI7XG4gIH1cbiAgcmVhZEl0ZXJhdG9yKCkge1xuICAgIGNvbnN0IHdvcmQgPSBzdXBlci5yZWFkV29yZDEoKTtcbiAgICBjb25zdCBmdWxsV29yZCA9IFwiQEBcIiArIHdvcmQ7XG4gICAgaWYgKCF0aGlzLmlzSXRlcmF0b3Iod29yZCkgfHwgIXRoaXMuc3RhdGUuaW5UeXBlKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkSWRlbnRpZmllciwgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpLCB7XG4gICAgICAgIGlkZW50aWZpZXJOYW1lOiBmdWxsV29yZFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuZmluaXNoVG9rZW4oMTMyLCBmdWxsV29yZCk7XG4gIH1cbiAgZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpO1xuICAgIGlmIChjb2RlID09PSAxMjMgJiYgbmV4dCA9PT0gMTI0KSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKDYsIDIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5pblR5cGUgJiYgKGNvZGUgPT09IDYyIHx8IGNvZGUgPT09IDYwKSkge1xuICAgICAgdGhpcy5maW5pc2hPcChjb2RlID09PSA2MiA/IDQ4IDogNDcsIDEpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5pblR5cGUgJiYgY29kZSA9PT0gNjMpIHtcbiAgICAgIGlmIChuZXh0ID09PSA0Nikge1xuICAgICAgICB0aGlzLmZpbmlzaE9wKDE4LCAyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZmluaXNoT3AoMTcsIDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNJdGVyYXRvclN0YXJ0KGNvZGUsIG5leHQsIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDIpKSkge1xuICAgICAgdGhpcy5zdGF0ZS5wb3MgKz0gMjtcbiAgICAgIHRoaXMucmVhZEl0ZXJhdG9yKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLmdldFRva2VuRnJvbUNvZGUoY29kZSk7XG4gICAgfVxuICB9XG4gIGlzQXNzaWduYWJsZShub2RlLCBpc0JpbmRpbmcpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSBcIlR5cGVDYXN0RXhwcmVzc2lvblwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc0Fzc2lnbmFibGUobm9kZS5leHByZXNzaW9uLCBpc0JpbmRpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3VwZXIuaXNBc3NpZ25hYmxlKG5vZGUsIGlzQmluZGluZyk7XG4gICAgfVxuICB9XG4gIHRvQXNzaWduYWJsZShub2RlLCBpc0xIUyA9IGZhbHNlKSB7XG4gICAgaWYgKCFpc0xIUyAmJiBub2RlLnR5cGUgPT09IFwiQXNzaWdubWVudEV4cHJlc3Npb25cIiAmJiBub2RlLmxlZnQudHlwZSA9PT0gXCJUeXBlQ2FzdEV4cHJlc3Npb25cIikge1xuICAgICAgbm9kZS5sZWZ0ID0gdGhpcy50eXBlQ2FzdFRvUGFyYW1ldGVyKG5vZGUubGVmdCk7XG4gICAgfVxuICAgIHN1cGVyLnRvQXNzaWduYWJsZShub2RlLCBpc0xIUyk7XG4gIH1cbiAgdG9Bc3NpZ25hYmxlTGlzdChleHByTGlzdCwgdHJhaWxpbmdDb21tYUxvYywgaXNMSFMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cHJMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBleHByID0gZXhwckxpc3RbaV07XG4gICAgICBpZiAoKGV4cHIgPT0gbnVsbCA/IHZvaWQgMCA6IGV4cHIudHlwZSkgPT09IFwiVHlwZUNhc3RFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgZXhwckxpc3RbaV0gPSB0aGlzLnR5cGVDYXN0VG9QYXJhbWV0ZXIoZXhwcik7XG4gICAgICB9XG4gICAgfVxuICAgIHN1cGVyLnRvQXNzaWduYWJsZUxpc3QoZXhwckxpc3QsIHRyYWlsaW5nQ29tbWFMb2MsIGlzTEhTKTtcbiAgfVxuICB0b1JlZmVyZW5jZWRMaXN0KGV4cHJMaXN0LCBpc1BhcmVudGhlc2l6ZWRFeHByKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHByTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIF9leHByJGV4dHJhO1xuICAgICAgY29uc3QgZXhwciA9IGV4cHJMaXN0W2ldO1xuICAgICAgaWYgKGV4cHIgJiYgZXhwci50eXBlID09PSBcIlR5cGVDYXN0RXhwcmVzc2lvblwiICYmICEoKF9leHByJGV4dHJhID0gZXhwci5leHRyYSkgIT0gbnVsbCAmJiBfZXhwciRleHRyYS5wYXJlbnRoZXNpemVkKSAmJiAoZXhwckxpc3QubGVuZ3RoID4gMSB8fCAhaXNQYXJlbnRoZXNpemVkRXhwcikpIHtcbiAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLlR5cGVDYXN0SW5QYXR0ZXJuLCBleHByLnR5cGVBbm5vdGF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV4cHJMaXN0O1xuICB9XG4gIHBhcnNlQXJyYXlMaWtlKGNsb3NlLCBjYW5CZVBhdHRlcm4sIGlzVHVwbGUsIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBjb25zdCBub2RlID0gc3VwZXIucGFyc2VBcnJheUxpa2UoY2xvc2UsIGNhbkJlUGF0dGVybiwgaXNUdXBsZSwgcmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgaWYgKGNhbkJlUGF0dGVybiAmJiAhdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzKSB7XG4gICAgICB0aGlzLnRvUmVmZXJlbmNlZExpc3Qobm9kZS5lbGVtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGlzVmFsaWRMVmFsKHR5cGUsIGlzUGFyZW50aGVzaXplZCwgYmluZGluZykge1xuICAgIHJldHVybiB0eXBlID09PSBcIlR5cGVDYXN0RXhwcmVzc2lvblwiIHx8IHN1cGVyLmlzVmFsaWRMVmFsKHR5cGUsIGlzUGFyZW50aGVzaXplZCwgYmluZGluZyk7XG4gIH1cbiAgcGFyc2VDbGFzc1Byb3BlcnR5KG5vZGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxNCkpIHtcbiAgICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZUNsYXNzUHJvcGVydHkobm9kZSk7XG4gIH1cbiAgcGFyc2VDbGFzc1ByaXZhdGVQcm9wZXJ0eShub2RlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy5mbG93UGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGFyc2VDbGFzc1ByaXZhdGVQcm9wZXJ0eShub2RlKTtcbiAgfVxuICBpc0NsYXNzTWV0aG9kKCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKDQ3KSB8fCBzdXBlci5pc0NsYXNzTWV0aG9kKCk7XG4gIH1cbiAgaXNDbGFzc1Byb3BlcnR5KCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKDE0KSB8fCBzdXBlci5pc0NsYXNzUHJvcGVydHkoKTtcbiAgfVxuICBpc05vbnN0YXRpY0NvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgIHJldHVybiAhdGhpcy5tYXRjaCgxNCkgJiYgc3VwZXIuaXNOb25zdGF0aWNDb25zdHJ1Y3RvcihtZXRob2QpO1xuICB9XG4gIHB1c2hDbGFzc01ldGhvZChjbGFzc0JvZHksIG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzQ29uc3RydWN0b3IsIGFsbG93c0RpcmVjdFN1cGVyKSB7XG4gICAgaWYgKG1ldGhvZC52YXJpYW5jZSkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKG1ldGhvZC52YXJpYW5jZS5sb2Muc3RhcnQpO1xuICAgIH1cbiAgICBkZWxldGUgbWV0aG9kLnZhcmlhbmNlO1xuICAgIGlmICh0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgbWV0aG9kLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICB9XG4gICAgc3VwZXIucHVzaENsYXNzTWV0aG9kKGNsYXNzQm9keSwgbWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNDb25zdHJ1Y3RvciwgYWxsb3dzRGlyZWN0U3VwZXIpO1xuICAgIGlmIChtZXRob2QucGFyYW1zICYmIGlzQ29uc3RydWN0b3IpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IG1ldGhvZC5wYXJhbXM7XG4gICAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDAgJiYgdGhpcy5pc1RoaXNQYXJhbShwYXJhbXNbMF0pKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5UaGlzUGFyYW1CYW5uZWRJbkNvbnN0cnVjdG9yLCBtZXRob2QpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobWV0aG9kLnR5cGUgPT09IFwiTWV0aG9kRGVmaW5pdGlvblwiICYmIGlzQ29uc3RydWN0b3IgJiYgbWV0aG9kLnZhbHVlLnBhcmFtcykge1xuICAgICAgY29uc3QgcGFyYW1zID0gbWV0aG9kLnZhbHVlLnBhcmFtcztcbiAgICAgIGlmIChwYXJhbXMubGVuZ3RoID4gMCAmJiB0aGlzLmlzVGhpc1BhcmFtKHBhcmFtc1swXSkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLlRoaXNQYXJhbUJhbm5lZEluQ29uc3RydWN0b3IsIG1ldGhvZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHB1c2hDbGFzc1ByaXZhdGVNZXRob2QoY2xhc3NCb2R5LCBtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jKSB7XG4gICAgaWYgKG1ldGhvZC52YXJpYW5jZSkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKG1ldGhvZC52YXJpYW5jZS5sb2Muc3RhcnQpO1xuICAgIH1cbiAgICBkZWxldGUgbWV0aG9kLnZhcmlhbmNlO1xuICAgIGlmICh0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgbWV0aG9kLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICB9XG4gICAgc3VwZXIucHVzaENsYXNzUHJpdmF0ZU1ldGhvZChjbGFzc0JvZHksIG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMpO1xuICB9XG4gIHBhcnNlQ2xhc3NTdXBlcihub2RlKSB7XG4gICAgc3VwZXIucGFyc2VDbGFzc1N1cGVyKG5vZGUpO1xuICAgIGlmIChub2RlLnN1cGVyQ2xhc3MgJiYgKHRoaXMubWF0Y2goNDcpIHx8IHRoaXMubWF0Y2goNTEpKSkge1xuICAgICAge1xuICAgICAgICBub2RlLnN1cGVyVHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uSW5FeHByZXNzaW9uKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMTMpKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGNvbnN0IGltcGxlbWVudGVkID0gbm9kZS5pbXBsZW1lbnRzID0gW107XG4gICAgICBkbyB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICBub2RlLmlkID0gdGhpcy5mbG93UGFyc2VSZXN0cmljdGVkSWRlbnRpZmllcih0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpbXBsZW1lbnRlZC5wdXNoKHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkNsYXNzSW1wbGVtZW50c1wiKSk7XG4gICAgICB9IHdoaWxlICh0aGlzLmVhdCgxMikpO1xuICAgIH1cbiAgfVxuICBjaGVja0dldHRlclNldHRlclBhcmFtcyhtZXRob2QpIHtcbiAgICBzdXBlci5jaGVja0dldHRlclNldHRlclBhcmFtcyhtZXRob2QpO1xuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuZ2V0T2JqZWN0T3JDbGFzc01ldGhvZFBhcmFtcyhtZXRob2QpO1xuICAgIGlmIChwYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcGFyYW0gPSBwYXJhbXNbMF07XG4gICAgICBpZiAodGhpcy5pc1RoaXNQYXJhbShwYXJhbSkgJiYgbWV0aG9kLmtpbmQgPT09IFwiZ2V0XCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLkdldHRlck1heU5vdEhhdmVUaGlzUGFyYW0sIHBhcmFtKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1RoaXNQYXJhbShwYXJhbSkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLlNldHRlck1heU5vdEhhdmVUaGlzUGFyYW0sIHBhcmFtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcGFyc2VQcm9wZXJ0eU5hbWVQcmVmaXhPcGVyYXRvcihub2RlKSB7XG4gICAgbm9kZS52YXJpYW5jZSA9IHRoaXMuZmxvd1BhcnNlVmFyaWFuY2UoKTtcbiAgfVxuICBwYXJzZU9ialByb3BWYWx1ZShwcm9wLCBzdGFydExvYywgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzUGF0dGVybiwgaXNBY2Nlc3NvciwgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGlmIChwcm9wLnZhcmlhbmNlKSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQocHJvcC52YXJpYW5jZS5sb2Muc3RhcnQpO1xuICAgIH1cbiAgICBkZWxldGUgcHJvcC52YXJpYW5jZTtcbiAgICBsZXQgdHlwZVBhcmFtZXRlcnM7XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpICYmICFpc0FjY2Vzc29yKSB7XG4gICAgICB0eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgICBpZiAoIXRoaXMubWF0Y2goMTApKSB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gc3VwZXIucGFyc2VPYmpQcm9wVmFsdWUocHJvcCwgc3RhcnRMb2MsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc1BhdHRlcm4sIGlzQWNjZXNzb3IsIHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgIGlmICh0eXBlUGFyYW1ldGVycykge1xuICAgICAgKHJlc3VsdC52YWx1ZSB8fCByZXN1bHQpLnR5cGVQYXJhbWV0ZXJzID0gdHlwZVBhcmFtZXRlcnM7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcGFyc2VGdW5jdGlvblBhcmFtVHlwZShwYXJhbSkge1xuICAgIGlmICh0aGlzLmVhdCgxNykpIHtcbiAgICAgIGlmIChwYXJhbS50eXBlICE9PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuUGF0dGVybklzT3B0aW9uYWwsIHBhcmFtKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzVGhpc1BhcmFtKHBhcmFtKSkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVGhpc1BhcmFtTWF5Tm90QmVPcHRpb25hbCwgcGFyYW0pO1xuICAgICAgfVxuICAgICAgcGFyYW0ub3B0aW9uYWwgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXRjaCgxNCkpIHtcbiAgICAgIHBhcmFtLnR5cGVBbm5vdGF0aW9uID0gdGhpcy5mbG93UGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc1RoaXNQYXJhbShwYXJhbSkpIHtcbiAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5UaGlzUGFyYW1Bbm5vdGF0aW9uUmVxdWlyZWQsIHBhcmFtKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF0Y2goMjkpICYmIHRoaXMuaXNUaGlzUGFyYW0ocGFyYW0pKSB7XG4gICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVGhpc1BhcmFtTm9EZWZhdWx0LCBwYXJhbSk7XG4gICAgfVxuICAgIHRoaXMucmVzZXRFbmRMb2NhdGlvbihwYXJhbSk7XG4gICAgcmV0dXJuIHBhcmFtO1xuICB9XG4gIHBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0TG9jLCBsZWZ0KSB7XG4gICAgY29uc3Qgbm9kZSA9IHN1cGVyLnBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0TG9jLCBsZWZ0KTtcbiAgICBpZiAobm9kZS50eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIgJiYgbm9kZS50eXBlQW5ub3RhdGlvbiAmJiBub2RlLnJpZ2h0LnN0YXJ0IDwgbm9kZS50eXBlQW5ub3RhdGlvbi5zdGFydCkge1xuICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLlR5cGVCZWZvcmVJbml0aWFsaXplciwgbm9kZS50eXBlQW5ub3RhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGNoZWNrSW1wb3J0UmVmbGVjdGlvbihub2RlKSB7XG4gICAgc3VwZXIuY2hlY2tJbXBvcnRSZWZsZWN0aW9uKG5vZGUpO1xuICAgIGlmIChub2RlLm1vZHVsZSAmJiBub2RlLmltcG9ydEtpbmQgIT09IFwidmFsdWVcIikge1xuICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLkltcG9ydFJlZmxlY3Rpb25IYXNJbXBvcnRUeXBlLCBub2RlLnNwZWNpZmllcnNbMF0ubG9jLnN0YXJ0KTtcbiAgICB9XG4gIH1cbiAgcGFyc2VJbXBvcnRTcGVjaWZpZXJMb2NhbChub2RlLCBzcGVjaWZpZXIsIHR5cGUpIHtcbiAgICBzcGVjaWZpZXIubG9jYWwgPSBoYXNUeXBlSW1wb3J0S2luZChub2RlKSA/IHRoaXMuZmxvd1BhcnNlUmVzdHJpY3RlZElkZW50aWZpZXIodHJ1ZSwgdHJ1ZSkgOiB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgIG5vZGUuc3BlY2lmaWVycy5wdXNoKHRoaXMuZmluaXNoSW1wb3J0U3BlY2lmaWVyKHNwZWNpZmllciwgdHlwZSkpO1xuICB9XG4gIGlzUG90ZW50aWFsSW1wb3J0UGhhc2UoaXNFeHBvcnQpIHtcbiAgICBpZiAoc3VwZXIuaXNQb3RlbnRpYWxJbXBvcnRQaGFzZShpc0V4cG9ydCkpIHJldHVybiB0cnVlO1xuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMzApKSB7XG4gICAgICBpZiAoIWlzRXhwb3J0KSByZXR1cm4gdHJ1ZTtcbiAgICAgIGNvbnN0IGNoID0gdGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpO1xuICAgICAgcmV0dXJuIGNoID09PSAxMjMgfHwgY2ggPT09IDQyO1xuICAgIH1cbiAgICByZXR1cm4gIWlzRXhwb3J0ICYmIHRoaXMuaXNDb250ZXh0dWFsKDg3KTtcbiAgfVxuICBhcHBseUltcG9ydFBoYXNlKG5vZGUsIGlzRXhwb3J0LCBwaGFzZSwgbG9jKSB7XG4gICAgc3VwZXIuYXBwbHlJbXBvcnRQaGFzZShub2RlLCBpc0V4cG9ydCwgcGhhc2UsIGxvYyk7XG4gICAgaWYgKGlzRXhwb3J0KSB7XG4gICAgICBpZiAoIXBoYXNlICYmIHRoaXMubWF0Y2goNjUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG5vZGUuZXhwb3J0S2luZCA9IHBoYXNlID09PSBcInR5cGVcIiA/IHBoYXNlIDogXCJ2YWx1ZVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGhhc2UgPT09IFwidHlwZVwiICYmIHRoaXMubWF0Y2goNTUpKSB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgIG5vZGUuaW1wb3J0S2luZCA9IHBoYXNlID09PSBcInR5cGVcIiB8fCBwaGFzZSA9PT0gXCJ0eXBlb2ZcIiA/IHBoYXNlIDogXCJ2YWx1ZVwiO1xuICAgIH1cbiAgfVxuICBwYXJzZUltcG9ydFNwZWNpZmllcihzcGVjaWZpZXIsIGltcG9ydGVkSXNTdHJpbmcsIGlzSW5UeXBlT25seUltcG9ydCwgaXNNYXliZVR5cGVPbmx5LCBiaW5kaW5nVHlwZSkge1xuICAgIGNvbnN0IGZpcnN0SWRlbnQgPSBzcGVjaWZpZXIuaW1wb3J0ZWQ7XG4gICAgbGV0IHNwZWNpZmllclR5cGVLaW5kID0gbnVsbDtcbiAgICBpZiAoZmlyc3RJZGVudC50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgaWYgKGZpcnN0SWRlbnQubmFtZSA9PT0gXCJ0eXBlXCIpIHtcbiAgICAgICAgc3BlY2lmaWVyVHlwZUtpbmQgPSBcInR5cGVcIjtcbiAgICAgIH0gZWxzZSBpZiAoZmlyc3RJZGVudC5uYW1lID09PSBcInR5cGVvZlwiKSB7XG4gICAgICAgIHNwZWNpZmllclR5cGVLaW5kID0gXCJ0eXBlb2ZcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGlzQmluZGluZyA9IGZhbHNlO1xuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCg5MykgJiYgIXRoaXMuaXNMb29rYWhlYWRDb250ZXh0dWFsKFwiYXNcIikpIHtcbiAgICAgIGNvbnN0IGFzX2lkZW50ID0gdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG4gICAgICBpZiAoc3BlY2lmaWVyVHlwZUtpbmQgIT09IG51bGwgJiYgIXRva2VuSXNLZXl3b3JkT3JJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgICAgc3BlY2lmaWVyLmltcG9ydGVkID0gYXNfaWRlbnQ7XG4gICAgICAgIHNwZWNpZmllci5pbXBvcnRLaW5kID0gc3BlY2lmaWVyVHlwZUtpbmQ7XG4gICAgICAgIHNwZWNpZmllci5sb2NhbCA9IHRoaXMuY2xvbmVJZGVudGlmaWVyKGFzX2lkZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwZWNpZmllci5pbXBvcnRlZCA9IGZpcnN0SWRlbnQ7XG4gICAgICAgIHNwZWNpZmllci5pbXBvcnRLaW5kID0gbnVsbDtcbiAgICAgICAgc3BlY2lmaWVyLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNwZWNpZmllclR5cGVLaW5kICE9PSBudWxsICYmIHRva2VuSXNLZXl3b3JkT3JJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgICAgc3BlY2lmaWVyLmltcG9ydGVkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG4gICAgICAgIHNwZWNpZmllci5pbXBvcnRLaW5kID0gc3BlY2lmaWVyVHlwZUtpbmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaW1wb3J0ZWRJc1N0cmluZykge1xuICAgICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLkltcG9ydEJpbmRpbmdJc1N0cmluZywgc3BlY2lmaWVyLCB7XG4gICAgICAgICAgICBpbXBvcnROYW1lOiBmaXJzdElkZW50LnZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3BlY2lmaWVyLmltcG9ydGVkID0gZmlyc3RJZGVudDtcbiAgICAgICAgc3BlY2lmaWVyLmltcG9ydEtpbmQgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbCg5MykpIHtcbiAgICAgICAgc3BlY2lmaWVyLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzQmluZGluZyA9IHRydWU7XG4gICAgICAgIHNwZWNpZmllci5sb2NhbCA9IHRoaXMuY2xvbmVJZGVudGlmaWVyKHNwZWNpZmllci5pbXBvcnRlZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNwZWNpZmllcklzVHlwZUltcG9ydCA9IGhhc1R5cGVJbXBvcnRLaW5kKHNwZWNpZmllcik7XG4gICAgaWYgKGlzSW5UeXBlT25seUltcG9ydCAmJiBzcGVjaWZpZXJJc1R5cGVJbXBvcnQpIHtcbiAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5JbXBvcnRUeXBlU2hvcnRoYW5kT25seUluUHVyZUltcG9ydCwgc3BlY2lmaWVyKTtcbiAgICB9XG4gICAgaWYgKGlzSW5UeXBlT25seUltcG9ydCB8fCBzcGVjaWZpZXJJc1R5cGVJbXBvcnQpIHtcbiAgICAgIHRoaXMuY2hlY2tSZXNlcnZlZFR5cGUoc3BlY2lmaWVyLmxvY2FsLm5hbWUsIHNwZWNpZmllci5sb2NhbC5sb2Muc3RhcnQsIHRydWUpO1xuICAgIH1cbiAgICBpZiAoaXNCaW5kaW5nICYmICFpc0luVHlwZU9ubHlJbXBvcnQgJiYgIXNwZWNpZmllcklzVHlwZUltcG9ydCkge1xuICAgICAgdGhpcy5jaGVja1Jlc2VydmVkV29yZChzcGVjaWZpZXIubG9jYWwubmFtZSwgc3BlY2lmaWVyLmxvYy5zdGFydCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaEltcG9ydFNwZWNpZmllcihzcGVjaWZpZXIsIFwiSW1wb3J0U3BlY2lmaWVyXCIpO1xuICB9XG4gIHBhcnNlQmluZGluZ0F0b20oKSB7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlLnR5cGUpIHtcbiAgICAgIGNhc2UgNzg6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBzdXBlci5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gICAgfVxuICB9XG4gIHBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSwgaXNDb25zdHJ1Y3Rvcikge1xuICAgIGNvbnN0IGtpbmQgPSBub2RlLmtpbmQ7XG4gICAgaWYgKGtpbmQgIT09IFwiZ2V0XCIgJiYga2luZCAhPT0gXCJzZXRcIiAmJiB0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgfVxuICAgIHN1cGVyLnBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSwgaXNDb25zdHJ1Y3Rvcik7XG4gIH1cbiAgcGFyc2VWYXJJZChkZWNsLCBraW5kKSB7XG4gICAgc3VwZXIucGFyc2VWYXJJZChkZWNsLCBraW5kKTtcbiAgICBpZiAodGhpcy5tYXRjaCgxNCkpIHtcbiAgICAgIGRlY2wuaWQudHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgICB0aGlzLnJlc2V0RW5kTG9jYXRpb24oZGVjbC5pZCk7XG4gICAgfVxuICB9XG4gIHBhcnNlQXN5bmNBcnJvd0Zyb21DYWxsRXhwcmVzc2lvbihub2RlLCBjYWxsKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICBjb25zdCBvbGROb0Fub25GdW5jdGlvblR5cGUgPSB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZTtcbiAgICAgIHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlID0gdHJ1ZTtcbiAgICAgIG5vZGUucmV0dXJuVHlwZSA9IHRoaXMuZmxvd1BhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICAgIHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlID0gb2xkTm9Bbm9uRnVuY3Rpb25UeXBlO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGFyc2VBc3luY0Fycm93RnJvbUNhbGxFeHByZXNzaW9uKG5vZGUsIGNhbGwpO1xuICB9XG4gIHNob3VsZFBhcnNlQXN5bmNBcnJvdygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgxNCkgfHwgc3VwZXIuc2hvdWxkUGFyc2VBc3luY0Fycm93KCk7XG4gIH1cbiAgcGFyc2VNYXliZUFzc2lnbihyZWZFeHByZXNzaW9uRXJyb3JzLCBhZnRlckxlZnRQYXJzZSkge1xuICAgIHZhciBfanN4O1xuICAgIGxldCBzdGF0ZSA9IG51bGw7XG4gICAgbGV0IGpzeDtcbiAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJqc3hcIikgJiYgKHRoaXMubWF0Y2goMTQzKSB8fCB0aGlzLm1hdGNoKDQ3KSkpIHtcbiAgICAgIHN0YXRlID0gdGhpcy5zdGF0ZS5jbG9uZSgpO1xuICAgICAganN4ID0gdGhpcy50cnlQYXJzZSgoKSA9PiBzdXBlci5wYXJzZU1heWJlQXNzaWduKHJlZkV4cHJlc3Npb25FcnJvcnMsIGFmdGVyTGVmdFBhcnNlKSwgc3RhdGUpO1xuICAgICAgaWYgKCFqc3guZXJyb3IpIHJldHVybiBqc3gubm9kZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29udGV4dFxuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCBjdXJyZW50Q29udGV4dCA9IGNvbnRleHRbY29udGV4dC5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChjdXJyZW50Q29udGV4dCA9PT0gdHlwZXMual9vVGFnIHx8IGN1cnJlbnRDb250ZXh0ID09PSB0eXBlcy5qX2V4cHIpIHtcbiAgICAgICAgY29udGV4dC5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKChfanN4ID0ganN4KSAhPSBudWxsICYmIF9qc3guZXJyb3IgfHwgdGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIHZhciBfanN4MiwgX2pzeDM7XG4gICAgICBzdGF0ZSA9IHN0YXRlIHx8IHRoaXMuc3RhdGUuY2xvbmUoKTtcbiAgICAgIGxldCB0eXBlUGFyYW1ldGVycztcbiAgICAgIGNvbnN0IGFycm93ID0gdGhpcy50cnlQYXJzZShhYm9ydCA9PiB7XG4gICAgICAgIHZhciBfYXJyb3dFeHByZXNzaW9uJGV4dHI7XG4gICAgICAgIHR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICAgICAgY29uc3QgYXJyb3dFeHByZXNzaW9uID0gdGhpcy5mb3J3YXJkTm9BcnJvd1BhcmFtc0NvbnZlcnNpb25BdCh0eXBlUGFyYW1ldGVycywgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLnBhcnNlTWF5YmVBc3NpZ24ocmVmRXhwcmVzc2lvbkVycm9ycywgYWZ0ZXJMZWZ0UGFyc2UpO1xuICAgICAgICAgIHRoaXMucmVzZXRTdGFydExvY2F0aW9uRnJvbU5vZGUocmVzdWx0LCB0eXBlUGFyYW1ldGVycyk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICgoX2Fycm93RXhwcmVzc2lvbiRleHRyID0gYXJyb3dFeHByZXNzaW9uLmV4dHJhKSAhPSBudWxsICYmIF9hcnJvd0V4cHJlc3Npb24kZXh0ci5wYXJlbnRoZXNpemVkKSBhYm9ydCgpO1xuICAgICAgICBjb25zdCBleHByID0gdGhpcy5tYXliZVVud3JhcFR5cGVDYXN0RXhwcmVzc2lvbihhcnJvd0V4cHJlc3Npb24pO1xuICAgICAgICBpZiAoZXhwci50eXBlICE9PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpIGFib3J0KCk7XG4gICAgICAgIGV4cHIudHlwZVBhcmFtZXRlcnMgPSB0eXBlUGFyYW1ldGVycztcbiAgICAgICAgdGhpcy5yZXNldFN0YXJ0TG9jYXRpb25Gcm9tTm9kZShleHByLCB0eXBlUGFyYW1ldGVycyk7XG4gICAgICAgIHJldHVybiBhcnJvd0V4cHJlc3Npb247XG4gICAgICB9LCBzdGF0ZSk7XG4gICAgICBsZXQgYXJyb3dFeHByZXNzaW9uID0gbnVsbDtcbiAgICAgIGlmIChhcnJvdy5ub2RlICYmIHRoaXMubWF5YmVVbndyYXBUeXBlQ2FzdEV4cHJlc3Npb24oYXJyb3cubm9kZSkudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiKSB7XG4gICAgICAgIGlmICghYXJyb3cuZXJyb3IgJiYgIWFycm93LmFib3J0ZWQpIHtcbiAgICAgICAgICBpZiAoYXJyb3cubm9kZS5hc3luYykge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLlVuZXhwZWN0ZWRUeXBlUGFyYW1ldGVyQmVmb3JlQXN5bmNBcnJvd0Z1bmN0aW9uLCB0eXBlUGFyYW1ldGVycyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhcnJvdy5ub2RlO1xuICAgICAgICB9XG4gICAgICAgIGFycm93RXhwcmVzc2lvbiA9IGFycm93Lm5vZGU7XG4gICAgICB9XG4gICAgICBpZiAoKF9qc3gyID0ganN4KSAhPSBudWxsICYmIF9qc3gyLm5vZGUpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IGpzeC5mYWlsU3RhdGU7XG4gICAgICAgIHJldHVybiBqc3gubm9kZTtcbiAgICAgIH1cbiAgICAgIGlmIChhcnJvd0V4cHJlc3Npb24pIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IGFycm93LmZhaWxTdGF0ZTtcbiAgICAgICAgcmV0dXJuIGFycm93RXhwcmVzc2lvbjtcbiAgICAgIH1cbiAgICAgIGlmICgoX2pzeDMgPSBqc3gpICE9IG51bGwgJiYgX2pzeDMudGhyb3duKSB0aHJvdyBqc3guZXJyb3I7XG4gICAgICBpZiAoYXJyb3cudGhyb3duKSB0aHJvdyBhcnJvdy5lcnJvcjtcbiAgICAgIHRocm93IHRoaXMucmFpc2UoRmxvd0Vycm9ycy5VbmV4cGVjdGVkVG9rZW5BZnRlclR5cGVQYXJhbWV0ZXIsIHR5cGVQYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlTWF5YmVBc3NpZ24ocmVmRXhwcmVzc2lvbkVycm9ycywgYWZ0ZXJMZWZ0UGFyc2UpO1xuICB9XG4gIHBhcnNlQXJyb3cobm9kZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKDE0KSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy50cnlQYXJzZSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IG9sZE5vQW5vbkZ1bmN0aW9uVHlwZSA9IHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlO1xuICAgICAgICB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSA9IHRydWU7XG4gICAgICAgIGNvbnN0IHR5cGVOb2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgW3R5cGVOb2RlLnR5cGVBbm5vdGF0aW9uLCBub2RlLnByZWRpY2F0ZV0gPSB0aGlzLmZsb3dQYXJzZVR5cGVBbmRQcmVkaWNhdGVJbml0aWFsaXNlcigpO1xuICAgICAgICB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSA9IG9sZE5vQW5vbkZ1bmN0aW9uVHlwZTtcbiAgICAgICAgaWYgKHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICBpZiAoIXRoaXMubWF0Y2goMTkpKSB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgICAgcmV0dXJuIHR5cGVOb2RlO1xuICAgICAgfSk7XG4gICAgICBpZiAocmVzdWx0LnRocm93bikgcmV0dXJuIG51bGw7XG4gICAgICBpZiAocmVzdWx0LmVycm9yKSB0aGlzLnN0YXRlID0gcmVzdWx0LmZhaWxTdGF0ZTtcbiAgICAgIG5vZGUucmV0dXJuVHlwZSA9IHJlc3VsdC5ub2RlLnR5cGVBbm5vdGF0aW9uID8gdGhpcy5maW5pc2hOb2RlKHJlc3VsdC5ub2RlLCBcIlR5cGVBbm5vdGF0aW9uXCIpIDogbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlQXJyb3cobm9kZSk7XG4gIH1cbiAgc2hvdWxkUGFyc2VBcnJvdyhwYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgxNCkgfHwgc3VwZXIuc2hvdWxkUGFyc2VBcnJvdyhwYXJhbXMpO1xuICB9XG4gIHNldEFycm93RnVuY3Rpb25QYXJhbWV0ZXJzKG5vZGUsIHBhcmFtcykge1xuICAgIGlmICh0aGlzLnN0YXRlLm5vQXJyb3dQYXJhbXNDb252ZXJzaW9uQXQuaW5jbHVkZXModGhpcy5vZmZzZXRUb1NvdXJjZVBvcyhub2RlLnN0YXJ0KSkpIHtcbiAgICAgIG5vZGUucGFyYW1zID0gcGFyYW1zO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlci5zZXRBcnJvd0Z1bmN0aW9uUGFyYW1ldGVycyhub2RlLCBwYXJhbXMpO1xuICAgIH1cbiAgfVxuICBjaGVja1BhcmFtcyhub2RlLCBhbGxvd0R1cGxpY2F0ZXMsIGlzQXJyb3dGdW5jdGlvbiwgc3RyaWN0TW9kZUNoYW5nZWQgPSB0cnVlKSB7XG4gICAgaWYgKGlzQXJyb3dGdW5jdGlvbiAmJiB0aGlzLnN0YXRlLm5vQXJyb3dQYXJhbXNDb252ZXJzaW9uQXQuaW5jbHVkZXModGhpcy5vZmZzZXRUb1NvdXJjZVBvcyhub2RlLnN0YXJ0KSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLnBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuaXNUaGlzUGFyYW0obm9kZS5wYXJhbXNbaV0pICYmIGkgPiAwKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5UaGlzUGFyYW1NdXN0QmVGaXJzdCwgbm9kZS5wYXJhbXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBzdXBlci5jaGVja1BhcmFtcyhub2RlLCBhbGxvd0R1cGxpY2F0ZXMsIGlzQXJyb3dGdW5jdGlvbiwgc3RyaWN0TW9kZUNoYW5nZWQpO1xuICB9XG4gIHBhcnNlUGFyZW5BbmREaXN0aW5ndWlzaEV4cHJlc3Npb24oY2FuQmVBcnJvdykge1xuICAgIHJldHVybiBzdXBlci5wYXJzZVBhcmVuQW5kRGlzdGluZ3Vpc2hFeHByZXNzaW9uKGNhbkJlQXJyb3cgJiYgIXRoaXMuc3RhdGUubm9BcnJvd0F0LmluY2x1ZGVzKHRoaXMuc291cmNlVG9PZmZzZXRQb3ModGhpcy5zdGF0ZS5zdGFydCkpKTtcbiAgfVxuICBwYXJzZVN1YnNjcmlwdHMoYmFzZSwgc3RhcnRMb2MsIG5vQ2FsbHMpIHtcbiAgICBpZiAoYmFzZS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBiYXNlLm5hbWUgPT09IFwiYXN5bmNcIiAmJiB0aGlzLnN0YXRlLm5vQXJyb3dBdC5pbmNsdWRlcyhzdGFydExvYy5pbmRleCkpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgbm9kZS5jYWxsZWUgPSBiYXNlO1xuICAgICAgbm9kZS5hcmd1bWVudHMgPSBzdXBlci5wYXJzZUNhbGxFeHByZXNzaW9uQXJndW1lbnRzKCk7XG4gICAgICBiYXNlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQ2FsbEV4cHJlc3Npb25cIik7XG4gICAgfSBlbHNlIGlmIChiYXNlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGJhc2UubmFtZSA9PT0gXCJhc3luY1wiICYmIHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGUuY2xvbmUoKTtcbiAgICAgIGNvbnN0IGFycm93ID0gdGhpcy50cnlQYXJzZShhYm9ydCA9PiB0aGlzLnBhcnNlQXN5bmNBcnJvd1dpdGhUeXBlUGFyYW1ldGVycyhzdGFydExvYykgfHwgYWJvcnQoKSwgc3RhdGUpO1xuICAgICAgaWYgKCFhcnJvdy5lcnJvciAmJiAhYXJyb3cuYWJvcnRlZCkgcmV0dXJuIGFycm93Lm5vZGU7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnRyeVBhcnNlKCgpID0+IHN1cGVyLnBhcnNlU3Vic2NyaXB0cyhiYXNlLCBzdGFydExvYywgbm9DYWxscyksIHN0YXRlKTtcbiAgICAgIGlmIChyZXN1bHQubm9kZSAmJiAhcmVzdWx0LmVycm9yKSByZXR1cm4gcmVzdWx0Lm5vZGU7XG4gICAgICBpZiAoYXJyb3cubm9kZSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gYXJyb3cuZmFpbFN0YXRlO1xuICAgICAgICByZXR1cm4gYXJyb3cubm9kZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQubm9kZSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gcmVzdWx0LmZhaWxTdGF0ZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5ub2RlO1xuICAgICAgfVxuICAgICAgdGhyb3cgYXJyb3cuZXJyb3IgfHwgcmVzdWx0LmVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGFyc2VTdWJzY3JpcHRzKGJhc2UsIHN0YXJ0TG9jLCBub0NhbGxzKTtcbiAgfVxuICBwYXJzZVN1YnNjcmlwdChiYXNlLCBzdGFydExvYywgbm9DYWxscywgc3Vic2NyaXB0U3RhdGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxOCkgJiYgdGhpcy5pc0xvb2thaGVhZFRva2VuX2x0KCkpIHtcbiAgICAgIHN1YnNjcmlwdFN0YXRlLm9wdGlvbmFsQ2hhaW5NZW1iZXIgPSB0cnVlO1xuICAgICAgaWYgKG5vQ2FsbHMpIHtcbiAgICAgICAgc3Vic2NyaXB0U3RhdGUuc3RvcCA9IHRydWU7XG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgfVxuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICBub2RlLmNhbGxlZSA9IGJhc2U7XG4gICAgICBub2RlLnR5cGVBcmd1bWVudHMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uSW5FeHByZXNzaW9uKCk7XG4gICAgICB0aGlzLmV4cGVjdCgxMCk7XG4gICAgICBub2RlLmFyZ3VtZW50cyA9IHRoaXMucGFyc2VDYWxsRXhwcmVzc2lvbkFyZ3VtZW50cygpO1xuICAgICAgbm9kZS5vcHRpb25hbCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hDYWxsRXhwcmVzc2lvbihub2RlLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKCFub0NhbGxzICYmIHRoaXMuc2hvdWxkUGFyc2VUeXBlcygpICYmICh0aGlzLm1hdGNoKDQ3KSB8fCB0aGlzLm1hdGNoKDUxKSkpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUuY2FsbGVlID0gYmFzZTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudHJ5UGFyc2UoKCkgPT4ge1xuICAgICAgICBub2RlLnR5cGVBcmd1bWVudHMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uQ2FsbE9yTmV3KCk7XG4gICAgICAgIHRoaXMuZXhwZWN0KDEwKTtcbiAgICAgICAgbm9kZS5hcmd1bWVudHMgPSBzdXBlci5wYXJzZUNhbGxFeHByZXNzaW9uQXJndW1lbnRzKCk7XG4gICAgICAgIGlmIChzdWJzY3JpcHRTdGF0ZS5vcHRpb25hbENoYWluTWVtYmVyKSB7XG4gICAgICAgICAgbm9kZS5vcHRpb25hbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaENhbGxFeHByZXNzaW9uKG5vZGUsIHN1YnNjcmlwdFN0YXRlLm9wdGlvbmFsQ2hhaW5NZW1iZXIpO1xuICAgICAgfSk7XG4gICAgICBpZiAocmVzdWx0Lm5vZGUpIHtcbiAgICAgICAgaWYgKHJlc3VsdC5lcnJvcikgdGhpcy5zdGF0ZSA9IHJlc3VsdC5mYWlsU3RhdGU7XG4gICAgICAgIHJldHVybiByZXN1bHQubm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlU3Vic2NyaXB0KGJhc2UsIHN0YXJ0TG9jLCBub0NhbGxzLCBzdWJzY3JpcHRTdGF0ZSk7XG4gIH1cbiAgcGFyc2VOZXdDYWxsZWUobm9kZSkge1xuICAgIHN1cGVyLnBhcnNlTmV3Q2FsbGVlKG5vZGUpO1xuICAgIGxldCB0YXJncyA9IG51bGw7XG4gICAgaWYgKHRoaXMuc2hvdWxkUGFyc2VUeXBlcygpICYmIHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICB0YXJncyA9IHRoaXMudHJ5UGFyc2UoKCkgPT4gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbkNhbGxPck5ldygpKS5ub2RlO1xuICAgIH1cbiAgICBub2RlLnR5cGVBcmd1bWVudHMgPSB0YXJncztcbiAgfVxuICBwYXJzZUFzeW5jQXJyb3dXaXRoVHlwZVBhcmFtZXRlcnMoc3RhcnRMb2MpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgdGhpcy5wYXJzZUZ1bmN0aW9uUGFyYW1zKG5vZGUsIGZhbHNlKTtcbiAgICBpZiAoIXRoaXMucGFyc2VBcnJvdyhub2RlKSkgcmV0dXJuO1xuICAgIHJldHVybiBzdXBlci5wYXJzZUFycm93RXhwcmVzc2lvbihub2RlLCB1bmRlZmluZWQsIHRydWUpO1xuICB9XG4gIHJlYWRUb2tlbl9tdWx0X21vZHVsbyhjb2RlKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpO1xuICAgIGlmIChjb2RlID09PSA0MiAmJiBuZXh0ID09PSA0NyAmJiB0aGlzLnN0YXRlLmhhc0Zsb3dDb21tZW50KSB7XG4gICAgICB0aGlzLnN0YXRlLmhhc0Zsb3dDb21tZW50ID0gZmFsc2U7XG4gICAgICB0aGlzLnN0YXRlLnBvcyArPSAyO1xuICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIucmVhZFRva2VuX211bHRfbW9kdWxvKGNvZGUpO1xuICB9XG4gIHJlYWRUb2tlbl9waXBlX2FtcChjb2RlKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpO1xuICAgIGlmIChjb2RlID09PSAxMjQgJiYgbmV4dCA9PT0gMTI1KSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKDksIDIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5yZWFkVG9rZW5fcGlwZV9hbXAoY29kZSk7XG4gIH1cbiAgcGFyc2VUb3BMZXZlbChmaWxlLCBwcm9ncmFtKSB7XG4gICAgY29uc3QgZmlsZU5vZGUgPSBzdXBlci5wYXJzZVRvcExldmVsKGZpbGUsIHByb2dyYW0pO1xuICAgIGlmICh0aGlzLnN0YXRlLmhhc0Zsb3dDb21tZW50KSB7XG4gICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVW50ZXJtaW5hdGVkRmxvd0NvbW1lbnQsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgfVxuICAgIHJldHVybiBmaWxlTm9kZTtcbiAgfVxuICBza2lwQmxvY2tDb21tZW50KCkge1xuICAgIGlmICh0aGlzLmhhc1BsdWdpbihcImZsb3dDb21tZW50c1wiKSAmJiB0aGlzLnNraXBGbG93Q29tbWVudCgpKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5oYXNGbG93Q29tbWVudCkge1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuTmVzdGVkRmxvd0NvbW1lbnQsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgfVxuICAgICAgdGhpcy5oYXNGbG93Q29tbWVudENvbXBsZXRpb24oKTtcbiAgICAgIGNvbnN0IGNvbW1lbnRTa2lwID0gdGhpcy5za2lwRmxvd0NvbW1lbnQoKTtcbiAgICAgIGlmIChjb21tZW50U2tpcCkge1xuICAgICAgICB0aGlzLnN0YXRlLnBvcyArPSBjb21tZW50U2tpcDtcbiAgICAgICAgdGhpcy5zdGF0ZS5oYXNGbG93Q29tbWVudCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5za2lwQmxvY2tDb21tZW50KHRoaXMuc3RhdGUuaGFzRmxvd0NvbW1lbnQgPyBcIiotL1wiIDogXCIqL1wiKTtcbiAgfVxuICBza2lwRmxvd0NvbW1lbnQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgcG9zXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgbGV0IHNoaWZ0VG9GaXJzdE5vbldoaXRlU3BhY2UgPSAyO1xuICAgIHdoaWxlIChbMzIsIDldLmluY2x1ZGVzKHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MgKyBzaGlmdFRvRmlyc3ROb25XaGl0ZVNwYWNlKSkpIHtcbiAgICAgIHNoaWZ0VG9GaXJzdE5vbldoaXRlU3BhY2UrKztcbiAgICB9XG4gICAgY29uc3QgY2gyID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHNoaWZ0VG9GaXJzdE5vbldoaXRlU3BhY2UgKyBwb3MpO1xuICAgIGNvbnN0IGNoMyA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChzaGlmdFRvRmlyc3ROb25XaGl0ZVNwYWNlICsgcG9zICsgMSk7XG4gICAgaWYgKGNoMiA9PT0gNTggJiYgY2gzID09PSA1OCkge1xuICAgICAgcmV0dXJuIHNoaWZ0VG9GaXJzdE5vbldoaXRlU3BhY2UgKyAyO1xuICAgIH1cbiAgICBpZiAodGhpcy5pbnB1dC5zbGljZShzaGlmdFRvRmlyc3ROb25XaGl0ZVNwYWNlICsgcG9zLCBzaGlmdFRvRmlyc3ROb25XaGl0ZVNwYWNlICsgcG9zICsgMTIpID09PSBcImZsb3ctaW5jbHVkZVwiKSB7XG4gICAgICByZXR1cm4gc2hpZnRUb0ZpcnN0Tm9uV2hpdGVTcGFjZSArIDEyO1xuICAgIH1cbiAgICBpZiAoY2gyID09PSA1OCAmJiBjaDMgIT09IDU4KSB7XG4gICAgICByZXR1cm4gc2hpZnRUb0ZpcnN0Tm9uV2hpdGVTcGFjZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGhhc0Zsb3dDb21tZW50Q29tcGxldGlvbigpIHtcbiAgICBjb25zdCBlbmQgPSB0aGlzLmlucHV0LmluZGV4T2YoXCIqL1wiLCB0aGlzLnN0YXRlLnBvcyk7XG4gICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVudGVybWluYXRlZENvbW1lbnQsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgfVxuICB9XG4gIGZsb3dFbnVtRXJyb3JCb29sZWFuTWVtYmVyTm90SW5pdGlhbGl6ZWQobG9jLCB7XG4gICAgZW51bU5hbWUsXG4gICAgbWVtYmVyTmFtZVxuICB9KSB7XG4gICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLkVudW1Cb29sZWFuTWVtYmVyTm90SW5pdGlhbGl6ZWQsIGxvYywge1xuICAgICAgbWVtYmVyTmFtZSxcbiAgICAgIGVudW1OYW1lXG4gICAgfSk7XG4gIH1cbiAgZmxvd0VudW1FcnJvckludmFsaWRNZW1iZXJJbml0aWFsaXplcihsb2MsIGVudW1Db250ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMucmFpc2UoIWVudW1Db250ZXh0LmV4cGxpY2l0VHlwZSA/IEZsb3dFcnJvcnMuRW51bUludmFsaWRNZW1iZXJJbml0aWFsaXplclVua25vd25UeXBlIDogZW51bUNvbnRleHQuZXhwbGljaXRUeXBlID09PSBcInN5bWJvbFwiID8gRmxvd0Vycm9ycy5FbnVtSW52YWxpZE1lbWJlckluaXRpYWxpemVyU3ltYm9sVHlwZSA6IEZsb3dFcnJvcnMuRW51bUludmFsaWRNZW1iZXJJbml0aWFsaXplclByaW1hcnlUeXBlLCBsb2MsIGVudW1Db250ZXh0KTtcbiAgfVxuICBmbG93RW51bUVycm9yTnVtYmVyTWVtYmVyTm90SW5pdGlhbGl6ZWQobG9jLCBkZXRhaWxzKSB7XG4gICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLkVudW1OdW1iZXJNZW1iZXJOb3RJbml0aWFsaXplZCwgbG9jLCBkZXRhaWxzKTtcbiAgfVxuICBmbG93RW51bUVycm9yU3RyaW5nTWVtYmVySW5jb25zaXN0ZW50bHlJbml0aWFsaXplZChub2RlLCBkZXRhaWxzKSB7XG4gICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLkVudW1TdHJpbmdNZW1iZXJJbmNvbnNpc3RlbnRseUluaXRpYWxpemVkLCBub2RlLCBkZXRhaWxzKTtcbiAgfVxuICBmbG93RW51bU1lbWJlckluaXQoKSB7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGNvbnN0IGVuZE9mSW5pdCA9ICgpID0+IHRoaXMubWF0Y2goMTIpIHx8IHRoaXMubWF0Y2goOCk7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlLnR5cGUpIHtcbiAgICAgIGNhc2UgMTM1OlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgbGl0ZXJhbCA9IHRoaXMucGFyc2VOdW1lcmljTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlKTtcbiAgICAgICAgICBpZiAoZW5kT2ZJbml0KCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgIGxvYzogbGl0ZXJhbC5sb2Muc3RhcnQsXG4gICAgICAgICAgICAgIHZhbHVlOiBsaXRlcmFsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJpbnZhbGlkXCIsXG4gICAgICAgICAgICBsb2M6IHN0YXJ0TG9jXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAxMzQ6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBsaXRlcmFsID0gdGhpcy5wYXJzZVN0cmluZ0xpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSk7XG4gICAgICAgICAgaWYgKGVuZE9mSW5pdCgpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICBsb2M6IGxpdGVyYWwubG9jLnN0YXJ0LFxuICAgICAgICAgICAgICB2YWx1ZTogbGl0ZXJhbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiaW52YWxpZFwiLFxuICAgICAgICAgICAgbG9jOiBzdGFydExvY1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIGNhc2UgODU6XG4gICAgICBjYXNlIDg2OlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgbGl0ZXJhbCA9IHRoaXMucGFyc2VCb29sZWFuTGl0ZXJhbCh0aGlzLm1hdGNoKDg1KSk7XG4gICAgICAgICAgaWYgKGVuZE9mSW5pdCgpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgbG9jOiBsaXRlcmFsLmxvYy5zdGFydCxcbiAgICAgICAgICAgICAgdmFsdWU6IGxpdGVyYWxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcImludmFsaWRcIixcbiAgICAgICAgICAgIGxvYzogc3RhcnRMb2NcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwiaW52YWxpZFwiLFxuICAgICAgICAgIGxvYzogc3RhcnRMb2NcbiAgICAgICAgfTtcbiAgICB9XG4gIH1cbiAgZmxvd0VudW1NZW1iZXJSYXcoKSB7XG4gICAgY29uc3QgbG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBjb25zdCBpZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgIGNvbnN0IGluaXQgPSB0aGlzLmVhdCgyOSkgPyB0aGlzLmZsb3dFbnVtTWVtYmVySW5pdCgpIDoge1xuICAgICAgdHlwZTogXCJub25lXCIsXG4gICAgICBsb2NcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBpZCxcbiAgICAgIGluaXRcbiAgICB9O1xuICB9XG4gIGZsb3dFbnVtQ2hlY2tFeHBsaWNpdFR5cGVNaXNtYXRjaChsb2MsIGNvbnRleHQsIGV4cGVjdGVkVHlwZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGV4cGxpY2l0VHlwZVxuICAgIH0gPSBjb250ZXh0O1xuICAgIGlmIChleHBsaWNpdFR5cGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV4cGxpY2l0VHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICB0aGlzLmZsb3dFbnVtRXJyb3JJbnZhbGlkTWVtYmVySW5pdGlhbGl6ZXIobG9jLCBjb250ZXh0KTtcbiAgICB9XG4gIH1cbiAgZmxvd0VudW1NZW1iZXJzKHtcbiAgICBlbnVtTmFtZSxcbiAgICBleHBsaWNpdFR5cGVcbiAgfSkge1xuICAgIGNvbnN0IHNlZW5OYW1lcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBtZW1iZXJzID0ge1xuICAgICAgYm9vbGVhbk1lbWJlcnM6IFtdLFxuICAgICAgbnVtYmVyTWVtYmVyczogW10sXG4gICAgICBzdHJpbmdNZW1iZXJzOiBbXSxcbiAgICAgIGRlZmF1bHRlZE1lbWJlcnM6IFtdXG4gICAgfTtcbiAgICBsZXQgaGFzVW5rbm93bk1lbWJlcnMgPSBmYWxzZTtcbiAgICB3aGlsZSAoIXRoaXMubWF0Y2goOCkpIHtcbiAgICAgIGlmICh0aGlzLmVhdCgyMSkpIHtcbiAgICAgICAgaGFzVW5rbm93bk1lbWJlcnMgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1lbWJlck5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBpZCxcbiAgICAgICAgaW5pdFxuICAgICAgfSA9IHRoaXMuZmxvd0VudW1NZW1iZXJSYXcoKTtcbiAgICAgIGNvbnN0IG1lbWJlck5hbWUgPSBpZC5uYW1lO1xuICAgICAgaWYgKG1lbWJlck5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoL15bYS16XS8udGVzdChtZW1iZXJOYW1lKSkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuRW51bUludmFsaWRNZW1iZXJOYW1lLCBpZCwge1xuICAgICAgICAgIG1lbWJlck5hbWUsXG4gICAgICAgICAgc3VnZ2VzdGlvbjogbWVtYmVyTmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbWVtYmVyTmFtZS5zbGljZSgxKSxcbiAgICAgICAgICBlbnVtTmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWVuTmFtZXMuaGFzKG1lbWJlck5hbWUpKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5FbnVtRHVwbGljYXRlTWVtYmVyTmFtZSwgaWQsIHtcbiAgICAgICAgICBtZW1iZXJOYW1lLFxuICAgICAgICAgIGVudW1OYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgc2Vlbk5hbWVzLmFkZChtZW1iZXJOYW1lKTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgIGVudW1OYW1lLFxuICAgICAgICBleHBsaWNpdFR5cGUsXG4gICAgICAgIG1lbWJlck5hbWVcbiAgICAgIH07XG4gICAgICBtZW1iZXJOb2RlLmlkID0gaWQ7XG4gICAgICBzd2l0Y2ggKGluaXQudHlwZSkge1xuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZmxvd0VudW1DaGVja0V4cGxpY2l0VHlwZU1pc21hdGNoKGluaXQubG9jLCBjb250ZXh0LCBcImJvb2xlYW5cIik7XG4gICAgICAgICAgICBtZW1iZXJOb2RlLmluaXQgPSBpbml0LnZhbHVlO1xuICAgICAgICAgICAgbWVtYmVycy5ib29sZWFuTWVtYmVycy5wdXNoKHRoaXMuZmluaXNoTm9kZShtZW1iZXJOb2RlLCBcIkVudW1Cb29sZWFuTWVtYmVyXCIpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZmxvd0VudW1DaGVja0V4cGxpY2l0VHlwZU1pc21hdGNoKGluaXQubG9jLCBjb250ZXh0LCBcIm51bWJlclwiKTtcbiAgICAgICAgICAgIG1lbWJlck5vZGUuaW5pdCA9IGluaXQudmFsdWU7XG4gICAgICAgICAgICBtZW1iZXJzLm51bWJlck1lbWJlcnMucHVzaCh0aGlzLmZpbmlzaE5vZGUobWVtYmVyTm9kZSwgXCJFbnVtTnVtYmVyTWVtYmVyXCIpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZmxvd0VudW1DaGVja0V4cGxpY2l0VHlwZU1pc21hdGNoKGluaXQubG9jLCBjb250ZXh0LCBcInN0cmluZ1wiKTtcbiAgICAgICAgICAgIG1lbWJlck5vZGUuaW5pdCA9IGluaXQudmFsdWU7XG4gICAgICAgICAgICBtZW1iZXJzLnN0cmluZ01lbWJlcnMucHVzaCh0aGlzLmZpbmlzaE5vZGUobWVtYmVyTm9kZSwgXCJFbnVtU3RyaW5nTWVtYmVyXCIpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcImludmFsaWRcIjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmZsb3dFbnVtRXJyb3JJbnZhbGlkTWVtYmVySW5pdGlhbGl6ZXIoaW5pdC5sb2MsIGNvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcIm5vbmVcIjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzd2l0Y2ggKGV4cGxpY2l0VHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgICAgIHRoaXMuZmxvd0VudW1FcnJvckJvb2xlYW5NZW1iZXJOb3RJbml0aWFsaXplZChpbml0LmxvYywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dFbnVtRXJyb3JOdW1iZXJNZW1iZXJOb3RJbml0aWFsaXplZChpbml0LmxvYywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgbWVtYmVycy5kZWZhdWx0ZWRNZW1iZXJzLnB1c2godGhpcy5maW5pc2hOb2RlKG1lbWJlck5vZGUsIFwiRW51bURlZmF1bHRlZE1lbWJlclwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLm1hdGNoKDgpKSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KDEyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG1lbWJlcnMsXG4gICAgICBoYXNVbmtub3duTWVtYmVyc1xuICAgIH07XG4gIH1cbiAgZmxvd0VudW1TdHJpbmdNZW1iZXJzKGluaXRpYWxpemVkTWVtYmVycywgZGVmYXVsdGVkTWVtYmVycywge1xuICAgIGVudW1OYW1lXG4gIH0pIHtcbiAgICBpZiAoaW5pdGlhbGl6ZWRNZW1iZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRlZE1lbWJlcnM7XG4gICAgfSBlbHNlIGlmIChkZWZhdWx0ZWRNZW1iZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGluaXRpYWxpemVkTWVtYmVycztcbiAgICB9IGVsc2UgaWYgKGRlZmF1bHRlZE1lbWJlcnMubGVuZ3RoID4gaW5pdGlhbGl6ZWRNZW1iZXJzLmxlbmd0aCkge1xuICAgICAgZm9yIChjb25zdCBtZW1iZXIgb2YgaW5pdGlhbGl6ZWRNZW1iZXJzKSB7XG4gICAgICAgIHRoaXMuZmxvd0VudW1FcnJvclN0cmluZ01lbWJlckluY29uc2lzdGVudGx5SW5pdGlhbGl6ZWQobWVtYmVyLCB7XG4gICAgICAgICAgZW51bU5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmYXVsdGVkTWVtYmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBtZW1iZXIgb2YgZGVmYXVsdGVkTWVtYmVycykge1xuICAgICAgICB0aGlzLmZsb3dFbnVtRXJyb3JTdHJpbmdNZW1iZXJJbmNvbnNpc3RlbnRseUluaXRpYWxpemVkKG1lbWJlciwge1xuICAgICAgICAgIGVudW1OYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluaXRpYWxpemVkTWVtYmVycztcbiAgICB9XG4gIH1cbiAgZmxvd0VudW1QYXJzZUV4cGxpY2l0VHlwZSh7XG4gICAgZW51bU5hbWVcbiAgfSkge1xuICAgIGlmICghdGhpcy5lYXRDb250ZXh0dWFsKDEwMikpIHJldHVybiBudWxsO1xuICAgIGlmICghdG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZShGbG93RXJyb3JzLkVudW1JbnZhbGlkRXhwbGljaXRUeXBlVW5rbm93blN1cHBsaWVkLCB0aGlzLnN0YXRlLnN0YXJ0TG9jLCB7XG4gICAgICAgIGVudW1OYW1lXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgdmFsdWVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodmFsdWUgIT09IFwiYm9vbGVhblwiICYmIHZhbHVlICE9PSBcIm51bWJlclwiICYmIHZhbHVlICE9PSBcInN0cmluZ1wiICYmIHZhbHVlICE9PSBcInN5bWJvbFwiKSB7XG4gICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuRW51bUludmFsaWRFeHBsaWNpdFR5cGUsIHRoaXMuc3RhdGUuc3RhcnRMb2MsIHtcbiAgICAgICAgZW51bU5hbWUsXG4gICAgICAgIGludmFsaWRFbnVtVHlwZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZmxvd0VudW1Cb2R5KG5vZGUsIGlkKSB7XG4gICAgY29uc3QgZW51bU5hbWUgPSBpZC5uYW1lO1xuICAgIGNvbnN0IG5hbWVMb2MgPSBpZC5sb2Muc3RhcnQ7XG4gICAgY29uc3QgZXhwbGljaXRUeXBlID0gdGhpcy5mbG93RW51bVBhcnNlRXhwbGljaXRUeXBlKHtcbiAgICAgIGVudW1OYW1lXG4gICAgfSk7XG4gICAgdGhpcy5leHBlY3QoNSk7XG4gICAgY29uc3Qge1xuICAgICAgbWVtYmVycyxcbiAgICAgIGhhc1Vua25vd25NZW1iZXJzXG4gICAgfSA9IHRoaXMuZmxvd0VudW1NZW1iZXJzKHtcbiAgICAgIGVudW1OYW1lLFxuICAgICAgZXhwbGljaXRUeXBlXG4gICAgfSk7XG4gICAgbm9kZS5oYXNVbmtub3duTWVtYmVycyA9IGhhc1Vua25vd25NZW1iZXJzO1xuICAgIHN3aXRjaCAoZXhwbGljaXRUeXBlKSB7XG4gICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICBub2RlLmV4cGxpY2l0VHlwZSA9IHRydWU7XG4gICAgICAgIG5vZGUubWVtYmVycyA9IG1lbWJlcnMuYm9vbGVhbk1lbWJlcnM7XG4gICAgICAgIHRoaXMuZXhwZWN0KDgpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW51bUJvb2xlYW5Cb2R5XCIpO1xuICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICBub2RlLmV4cGxpY2l0VHlwZSA9IHRydWU7XG4gICAgICAgIG5vZGUubWVtYmVycyA9IG1lbWJlcnMubnVtYmVyTWVtYmVycztcbiAgICAgICAgdGhpcy5leHBlY3QoOCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFbnVtTnVtYmVyQm9keVwiKTtcbiAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgbm9kZS5leHBsaWNpdFR5cGUgPSB0cnVlO1xuICAgICAgICBub2RlLm1lbWJlcnMgPSB0aGlzLmZsb3dFbnVtU3RyaW5nTWVtYmVycyhtZW1iZXJzLnN0cmluZ01lbWJlcnMsIG1lbWJlcnMuZGVmYXVsdGVkTWVtYmVycywge1xuICAgICAgICAgIGVudW1OYW1lXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmV4cGVjdCg4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVudW1TdHJpbmdCb2R5XCIpO1xuICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICBub2RlLm1lbWJlcnMgPSBtZW1iZXJzLmRlZmF1bHRlZE1lbWJlcnM7XG4gICAgICAgIHRoaXMuZXhwZWN0KDgpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW51bVN5bWJvbEJvZHlcIik7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgZW1wdHkgPSAoKSA9PiB7XG4gICAgICAgICAgICBub2RlLm1lbWJlcnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0KDgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVudW1TdHJpbmdCb2R5XCIpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgbm9kZS5leHBsaWNpdFR5cGUgPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCBib29sc0xlbiA9IG1lbWJlcnMuYm9vbGVhbk1lbWJlcnMubGVuZ3RoO1xuICAgICAgICAgIGNvbnN0IG51bXNMZW4gPSBtZW1iZXJzLm51bWJlck1lbWJlcnMubGVuZ3RoO1xuICAgICAgICAgIGNvbnN0IHN0cnNMZW4gPSBtZW1iZXJzLnN0cmluZ01lbWJlcnMubGVuZ3RoO1xuICAgICAgICAgIGNvbnN0IGRlZmF1bHRlZExlbiA9IG1lbWJlcnMuZGVmYXVsdGVkTWVtYmVycy5sZW5ndGg7XG4gICAgICAgICAgaWYgKCFib29sc0xlbiAmJiAhbnVtc0xlbiAmJiAhc3Ryc0xlbiAmJiAhZGVmYXVsdGVkTGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gZW1wdHkoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFib29sc0xlbiAmJiAhbnVtc0xlbikge1xuICAgICAgICAgICAgbm9kZS5tZW1iZXJzID0gdGhpcy5mbG93RW51bVN0cmluZ01lbWJlcnMobWVtYmVycy5zdHJpbmdNZW1iZXJzLCBtZW1iZXJzLmRlZmF1bHRlZE1lbWJlcnMsIHtcbiAgICAgICAgICAgICAgZW51bU5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5leHBlY3QoOCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW51bVN0cmluZ0JvZHlcIik7XG4gICAgICAgICAgfSBlbHNlIGlmICghbnVtc0xlbiAmJiAhc3Ryc0xlbiAmJiBib29sc0xlbiA+PSBkZWZhdWx0ZWRMZW4pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIG1lbWJlcnMuZGVmYXVsdGVkTWVtYmVycykge1xuICAgICAgICAgICAgICB0aGlzLmZsb3dFbnVtRXJyb3JCb29sZWFuTWVtYmVyTm90SW5pdGlhbGl6ZWQobWVtYmVyLmxvYy5zdGFydCwge1xuICAgICAgICAgICAgICAgIGVudW1OYW1lLFxuICAgICAgICAgICAgICAgIG1lbWJlck5hbWU6IG1lbWJlci5pZC5uYW1lXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5tZW1iZXJzID0gbWVtYmVycy5ib29sZWFuTWVtYmVycztcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0KDgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVudW1Cb29sZWFuQm9keVwiKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFib29sc0xlbiAmJiAhc3Ryc0xlbiAmJiBudW1zTGVuID49IGRlZmF1bHRlZExlbikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBtZW1iZXIgb2YgbWVtYmVycy5kZWZhdWx0ZWRNZW1iZXJzKSB7XG4gICAgICAgICAgICAgIHRoaXMuZmxvd0VudW1FcnJvck51bWJlck1lbWJlck5vdEluaXRpYWxpemVkKG1lbWJlci5sb2Muc3RhcnQsIHtcbiAgICAgICAgICAgICAgICBlbnVtTmFtZSxcbiAgICAgICAgICAgICAgICBtZW1iZXJOYW1lOiBtZW1iZXIuaWQubmFtZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUubWVtYmVycyA9IG1lbWJlcnMubnVtYmVyTWVtYmVycztcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0KDgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVudW1OdW1iZXJCb2R5XCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuRW51bUluY29uc2lzdGVudE1lbWJlclZhbHVlcywgbmFtZUxvYywge1xuICAgICAgICAgICAgICBlbnVtTmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZW1wdHkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgZmxvd1BhcnNlRW51bURlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICBjb25zdCBpZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgbm9kZS5pZCA9IGlkO1xuICAgIG5vZGUuYm9keSA9IHRoaXMuZmxvd0VudW1Cb2R5KHRoaXMuc3RhcnROb2RlKCksIGlkKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW51bURlY2xhcmF0aW9uXCIpO1xuICB9XG4gIGpzeFBhcnNlT3BlbmluZ0VsZW1lbnRBZnRlck5hbWUobm9kZSkge1xuICAgIGlmICh0aGlzLnNob3VsZFBhcnNlVHlwZXMoKSkge1xuICAgICAgaWYgKHRoaXMubWF0Y2goNDcpIHx8IHRoaXMubWF0Y2goNTEpKSB7XG4gICAgICAgIG5vZGUudHlwZUFyZ3VtZW50cyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25JbkV4cHJlc3Npb24oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmpzeFBhcnNlT3BlbmluZ0VsZW1lbnRBZnRlck5hbWUobm9kZSk7XG4gIH1cbiAgaXNMb29rYWhlYWRUb2tlbl9sdCgpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5uZXh0VG9rZW5TdGFydCgpO1xuICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQobmV4dCkgPT09IDYwKSB7XG4gICAgICBjb25zdCBhZnRlck5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQobmV4dCArIDEpO1xuICAgICAgcmV0dXJuIGFmdGVyTmV4dCAhPT0gNjAgJiYgYWZ0ZXJOZXh0ICE9PSA2MTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJlU2Nhbl9sdF9ndCgpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHR5cGUgPT09IDQ3KSB7XG4gICAgICB0aGlzLnN0YXRlLnBvcyAtPSAxO1xuICAgICAgdGhpcy5yZWFkVG9rZW5fbHQoKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDQ4KSB7XG4gICAgICB0aGlzLnN0YXRlLnBvcyAtPSAxO1xuICAgICAgdGhpcy5yZWFkVG9rZW5fZ3QoKTtcbiAgICB9XG4gIH1cbiAgcmVTY2FuX2x0KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodHlwZSA9PT0gNTEpIHtcbiAgICAgIHRoaXMuc3RhdGUucG9zIC09IDI7XG4gICAgICB0aGlzLmZpbmlzaE9wKDQ3LCAxKTtcbiAgICAgIHJldHVybiA0NztcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgbWF5YmVVbndyYXBUeXBlQ2FzdEV4cHJlc3Npb24obm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiVHlwZUNhc3RFeHByZXNzaW9uXCIgPyBub2RlLmV4cHJlc3Npb24gOiBub2RlO1xuICB9XG59O1xuY29uc3QgZW50aXRpZXMgPSB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgcXVvdDogXCJcXHUwMDIyXCIsXG4gIGFtcDogXCImXCIsXG4gIGFwb3M6IFwiXFx1MDAyN1wiLFxuICBsdDogXCI8XCIsXG4gIGd0OiBcIj5cIixcbiAgbmJzcDogXCJcXHUwMEEwXCIsXG4gIGlleGNsOiBcIlxcdTAwQTFcIixcbiAgY2VudDogXCJcXHUwMEEyXCIsXG4gIHBvdW5kOiBcIlxcdTAwQTNcIixcbiAgY3VycmVuOiBcIlxcdTAwQTRcIixcbiAgeWVuOiBcIlxcdTAwQTVcIixcbiAgYnJ2YmFyOiBcIlxcdTAwQTZcIixcbiAgc2VjdDogXCJcXHUwMEE3XCIsXG4gIHVtbDogXCJcXHUwMEE4XCIsXG4gIGNvcHk6IFwiXFx1MDBBOVwiLFxuICBvcmRmOiBcIlxcdTAwQUFcIixcbiAgbGFxdW86IFwiXFx1MDBBQlwiLFxuICBub3Q6IFwiXFx1MDBBQ1wiLFxuICBzaHk6IFwiXFx1MDBBRFwiLFxuICByZWc6IFwiXFx1MDBBRVwiLFxuICBtYWNyOiBcIlxcdTAwQUZcIixcbiAgZGVnOiBcIlxcdTAwQjBcIixcbiAgcGx1c21uOiBcIlxcdTAwQjFcIixcbiAgc3VwMjogXCJcXHUwMEIyXCIsXG4gIHN1cDM6IFwiXFx1MDBCM1wiLFxuICBhY3V0ZTogXCJcXHUwMEI0XCIsXG4gIG1pY3JvOiBcIlxcdTAwQjVcIixcbiAgcGFyYTogXCJcXHUwMEI2XCIsXG4gIG1pZGRvdDogXCJcXHUwMEI3XCIsXG4gIGNlZGlsOiBcIlxcdTAwQjhcIixcbiAgc3VwMTogXCJcXHUwMEI5XCIsXG4gIG9yZG06IFwiXFx1MDBCQVwiLFxuICByYXF1bzogXCJcXHUwMEJCXCIsXG4gIGZyYWMxNDogXCJcXHUwMEJDXCIsXG4gIGZyYWMxMjogXCJcXHUwMEJEXCIsXG4gIGZyYWMzNDogXCJcXHUwMEJFXCIsXG4gIGlxdWVzdDogXCJcXHUwMEJGXCIsXG4gIEFncmF2ZTogXCJcXHUwMEMwXCIsXG4gIEFhY3V0ZTogXCJcXHUwMEMxXCIsXG4gIEFjaXJjOiBcIlxcdTAwQzJcIixcbiAgQXRpbGRlOiBcIlxcdTAwQzNcIixcbiAgQXVtbDogXCJcXHUwMEM0XCIsXG4gIEFyaW5nOiBcIlxcdTAwQzVcIixcbiAgQUVsaWc6IFwiXFx1MDBDNlwiLFxuICBDY2VkaWw6IFwiXFx1MDBDN1wiLFxuICBFZ3JhdmU6IFwiXFx1MDBDOFwiLFxuICBFYWN1dGU6IFwiXFx1MDBDOVwiLFxuICBFY2lyYzogXCJcXHUwMENBXCIsXG4gIEV1bWw6IFwiXFx1MDBDQlwiLFxuICBJZ3JhdmU6IFwiXFx1MDBDQ1wiLFxuICBJYWN1dGU6IFwiXFx1MDBDRFwiLFxuICBJY2lyYzogXCJcXHUwMENFXCIsXG4gIEl1bWw6IFwiXFx1MDBDRlwiLFxuICBFVEg6IFwiXFx1MDBEMFwiLFxuICBOdGlsZGU6IFwiXFx1MDBEMVwiLFxuICBPZ3JhdmU6IFwiXFx1MDBEMlwiLFxuICBPYWN1dGU6IFwiXFx1MDBEM1wiLFxuICBPY2lyYzogXCJcXHUwMEQ0XCIsXG4gIE90aWxkZTogXCJcXHUwMEQ1XCIsXG4gIE91bWw6IFwiXFx1MDBENlwiLFxuICB0aW1lczogXCJcXHUwMEQ3XCIsXG4gIE9zbGFzaDogXCJcXHUwMEQ4XCIsXG4gIFVncmF2ZTogXCJcXHUwMEQ5XCIsXG4gIFVhY3V0ZTogXCJcXHUwMERBXCIsXG4gIFVjaXJjOiBcIlxcdTAwREJcIixcbiAgVXVtbDogXCJcXHUwMERDXCIsXG4gIFlhY3V0ZTogXCJcXHUwMEREXCIsXG4gIFRIT1JOOiBcIlxcdTAwREVcIixcbiAgc3psaWc6IFwiXFx1MDBERlwiLFxuICBhZ3JhdmU6IFwiXFx1MDBFMFwiLFxuICBhYWN1dGU6IFwiXFx1MDBFMVwiLFxuICBhY2lyYzogXCJcXHUwMEUyXCIsXG4gIGF0aWxkZTogXCJcXHUwMEUzXCIsXG4gIGF1bWw6IFwiXFx1MDBFNFwiLFxuICBhcmluZzogXCJcXHUwMEU1XCIsXG4gIGFlbGlnOiBcIlxcdTAwRTZcIixcbiAgY2NlZGlsOiBcIlxcdTAwRTdcIixcbiAgZWdyYXZlOiBcIlxcdTAwRThcIixcbiAgZWFjdXRlOiBcIlxcdTAwRTlcIixcbiAgZWNpcmM6IFwiXFx1MDBFQVwiLFxuICBldW1sOiBcIlxcdTAwRUJcIixcbiAgaWdyYXZlOiBcIlxcdTAwRUNcIixcbiAgaWFjdXRlOiBcIlxcdTAwRURcIixcbiAgaWNpcmM6IFwiXFx1MDBFRVwiLFxuICBpdW1sOiBcIlxcdTAwRUZcIixcbiAgZXRoOiBcIlxcdTAwRjBcIixcbiAgbnRpbGRlOiBcIlxcdTAwRjFcIixcbiAgb2dyYXZlOiBcIlxcdTAwRjJcIixcbiAgb2FjdXRlOiBcIlxcdTAwRjNcIixcbiAgb2NpcmM6IFwiXFx1MDBGNFwiLFxuICBvdGlsZGU6IFwiXFx1MDBGNVwiLFxuICBvdW1sOiBcIlxcdTAwRjZcIixcbiAgZGl2aWRlOiBcIlxcdTAwRjdcIixcbiAgb3NsYXNoOiBcIlxcdTAwRjhcIixcbiAgdWdyYXZlOiBcIlxcdTAwRjlcIixcbiAgdWFjdXRlOiBcIlxcdTAwRkFcIixcbiAgdWNpcmM6IFwiXFx1MDBGQlwiLFxuICB1dW1sOiBcIlxcdTAwRkNcIixcbiAgeWFjdXRlOiBcIlxcdTAwRkRcIixcbiAgdGhvcm46IFwiXFx1MDBGRVwiLFxuICB5dW1sOiBcIlxcdTAwRkZcIixcbiAgT0VsaWc6IFwiXFx1MDE1MlwiLFxuICBvZWxpZzogXCJcXHUwMTUzXCIsXG4gIFNjYXJvbjogXCJcXHUwMTYwXCIsXG4gIHNjYXJvbjogXCJcXHUwMTYxXCIsXG4gIFl1bWw6IFwiXFx1MDE3OFwiLFxuICBmbm9mOiBcIlxcdTAxOTJcIixcbiAgY2lyYzogXCJcXHUwMkM2XCIsXG4gIHRpbGRlOiBcIlxcdTAyRENcIixcbiAgQWxwaGE6IFwiXFx1MDM5MVwiLFxuICBCZXRhOiBcIlxcdTAzOTJcIixcbiAgR2FtbWE6IFwiXFx1MDM5M1wiLFxuICBEZWx0YTogXCJcXHUwMzk0XCIsXG4gIEVwc2lsb246IFwiXFx1MDM5NVwiLFxuICBaZXRhOiBcIlxcdTAzOTZcIixcbiAgRXRhOiBcIlxcdTAzOTdcIixcbiAgVGhldGE6IFwiXFx1MDM5OFwiLFxuICBJb3RhOiBcIlxcdTAzOTlcIixcbiAgS2FwcGE6IFwiXFx1MDM5QVwiLFxuICBMYW1iZGE6IFwiXFx1MDM5QlwiLFxuICBNdTogXCJcXHUwMzlDXCIsXG4gIE51OiBcIlxcdTAzOURcIixcbiAgWGk6IFwiXFx1MDM5RVwiLFxuICBPbWljcm9uOiBcIlxcdTAzOUZcIixcbiAgUGk6IFwiXFx1MDNBMFwiLFxuICBSaG86IFwiXFx1MDNBMVwiLFxuICBTaWdtYTogXCJcXHUwM0EzXCIsXG4gIFRhdTogXCJcXHUwM0E0XCIsXG4gIFVwc2lsb246IFwiXFx1MDNBNVwiLFxuICBQaGk6IFwiXFx1MDNBNlwiLFxuICBDaGk6IFwiXFx1MDNBN1wiLFxuICBQc2k6IFwiXFx1MDNBOFwiLFxuICBPbWVnYTogXCJcXHUwM0E5XCIsXG4gIGFscGhhOiBcIlxcdTAzQjFcIixcbiAgYmV0YTogXCJcXHUwM0IyXCIsXG4gIGdhbW1hOiBcIlxcdTAzQjNcIixcbiAgZGVsdGE6IFwiXFx1MDNCNFwiLFxuICBlcHNpbG9uOiBcIlxcdTAzQjVcIixcbiAgemV0YTogXCJcXHUwM0I2XCIsXG4gIGV0YTogXCJcXHUwM0I3XCIsXG4gIHRoZXRhOiBcIlxcdTAzQjhcIixcbiAgaW90YTogXCJcXHUwM0I5XCIsXG4gIGthcHBhOiBcIlxcdTAzQkFcIixcbiAgbGFtYmRhOiBcIlxcdTAzQkJcIixcbiAgbXU6IFwiXFx1MDNCQ1wiLFxuICBudTogXCJcXHUwM0JEXCIsXG4gIHhpOiBcIlxcdTAzQkVcIixcbiAgb21pY3JvbjogXCJcXHUwM0JGXCIsXG4gIHBpOiBcIlxcdTAzQzBcIixcbiAgcmhvOiBcIlxcdTAzQzFcIixcbiAgc2lnbWFmOiBcIlxcdTAzQzJcIixcbiAgc2lnbWE6IFwiXFx1MDNDM1wiLFxuICB0YXU6IFwiXFx1MDNDNFwiLFxuICB1cHNpbG9uOiBcIlxcdTAzQzVcIixcbiAgcGhpOiBcIlxcdTAzQzZcIixcbiAgY2hpOiBcIlxcdTAzQzdcIixcbiAgcHNpOiBcIlxcdTAzQzhcIixcbiAgb21lZ2E6IFwiXFx1MDNDOVwiLFxuICB0aGV0YXN5bTogXCJcXHUwM0QxXCIsXG4gIHVwc2loOiBcIlxcdTAzRDJcIixcbiAgcGl2OiBcIlxcdTAzRDZcIixcbiAgZW5zcDogXCJcXHUyMDAyXCIsXG4gIGVtc3A6IFwiXFx1MjAwM1wiLFxuICB0aGluc3A6IFwiXFx1MjAwOVwiLFxuICB6d25qOiBcIlxcdTIwMENcIixcbiAgendqOiBcIlxcdTIwMERcIixcbiAgbHJtOiBcIlxcdTIwMEVcIixcbiAgcmxtOiBcIlxcdTIwMEZcIixcbiAgbmRhc2g6IFwiXFx1MjAxM1wiLFxuICBtZGFzaDogXCJcXHUyMDE0XCIsXG4gIGxzcXVvOiBcIlxcdTIwMThcIixcbiAgcnNxdW86IFwiXFx1MjAxOVwiLFxuICBzYnF1bzogXCJcXHUyMDFBXCIsXG4gIGxkcXVvOiBcIlxcdTIwMUNcIixcbiAgcmRxdW86IFwiXFx1MjAxRFwiLFxuICBiZHF1bzogXCJcXHUyMDFFXCIsXG4gIGRhZ2dlcjogXCJcXHUyMDIwXCIsXG4gIERhZ2dlcjogXCJcXHUyMDIxXCIsXG4gIGJ1bGw6IFwiXFx1MjAyMlwiLFxuICBoZWxsaXA6IFwiXFx1MjAyNlwiLFxuICBwZXJtaWw6IFwiXFx1MjAzMFwiLFxuICBwcmltZTogXCJcXHUyMDMyXCIsXG4gIFByaW1lOiBcIlxcdTIwMzNcIixcbiAgbHNhcXVvOiBcIlxcdTIwMzlcIixcbiAgcnNhcXVvOiBcIlxcdTIwM0FcIixcbiAgb2xpbmU6IFwiXFx1MjAzRVwiLFxuICBmcmFzbDogXCJcXHUyMDQ0XCIsXG4gIGV1cm86IFwiXFx1MjBBQ1wiLFxuICBpbWFnZTogXCJcXHUyMTExXCIsXG4gIHdlaWVycDogXCJcXHUyMTE4XCIsXG4gIHJlYWw6IFwiXFx1MjExQ1wiLFxuICB0cmFkZTogXCJcXHUyMTIyXCIsXG4gIGFsZWZzeW06IFwiXFx1MjEzNVwiLFxuICBsYXJyOiBcIlxcdTIxOTBcIixcbiAgdWFycjogXCJcXHUyMTkxXCIsXG4gIHJhcnI6IFwiXFx1MjE5MlwiLFxuICBkYXJyOiBcIlxcdTIxOTNcIixcbiAgaGFycjogXCJcXHUyMTk0XCIsXG4gIGNyYXJyOiBcIlxcdTIxQjVcIixcbiAgbEFycjogXCJcXHUyMUQwXCIsXG4gIHVBcnI6IFwiXFx1MjFEMVwiLFxuICByQXJyOiBcIlxcdTIxRDJcIixcbiAgZEFycjogXCJcXHUyMUQzXCIsXG4gIGhBcnI6IFwiXFx1MjFENFwiLFxuICBmb3JhbGw6IFwiXFx1MjIwMFwiLFxuICBwYXJ0OiBcIlxcdTIyMDJcIixcbiAgZXhpc3Q6IFwiXFx1MjIwM1wiLFxuICBlbXB0eTogXCJcXHUyMjA1XCIsXG4gIG5hYmxhOiBcIlxcdTIyMDdcIixcbiAgaXNpbjogXCJcXHUyMjA4XCIsXG4gIG5vdGluOiBcIlxcdTIyMDlcIixcbiAgbmk6IFwiXFx1MjIwQlwiLFxuICBwcm9kOiBcIlxcdTIyMEZcIixcbiAgc3VtOiBcIlxcdTIyMTFcIixcbiAgbWludXM6IFwiXFx1MjIxMlwiLFxuICBsb3dhc3Q6IFwiXFx1MjIxN1wiLFxuICByYWRpYzogXCJcXHUyMjFBXCIsXG4gIHByb3A6IFwiXFx1MjIxRFwiLFxuICBpbmZpbjogXCJcXHUyMjFFXCIsXG4gIGFuZzogXCJcXHUyMjIwXCIsXG4gIGFuZDogXCJcXHUyMjI3XCIsXG4gIG9yOiBcIlxcdTIyMjhcIixcbiAgY2FwOiBcIlxcdTIyMjlcIixcbiAgY3VwOiBcIlxcdTIyMkFcIixcbiAgaW50OiBcIlxcdTIyMkJcIixcbiAgdGhlcmU0OiBcIlxcdTIyMzRcIixcbiAgc2ltOiBcIlxcdTIyM0NcIixcbiAgY29uZzogXCJcXHUyMjQ1XCIsXG4gIGFzeW1wOiBcIlxcdTIyNDhcIixcbiAgbmU6IFwiXFx1MjI2MFwiLFxuICBlcXVpdjogXCJcXHUyMjYxXCIsXG4gIGxlOiBcIlxcdTIyNjRcIixcbiAgZ2U6IFwiXFx1MjI2NVwiLFxuICBzdWI6IFwiXFx1MjI4MlwiLFxuICBzdXA6IFwiXFx1MjI4M1wiLFxuICBuc3ViOiBcIlxcdTIyODRcIixcbiAgc3ViZTogXCJcXHUyMjg2XCIsXG4gIHN1cGU6IFwiXFx1MjI4N1wiLFxuICBvcGx1czogXCJcXHUyMjk1XCIsXG4gIG90aW1lczogXCJcXHUyMjk3XCIsXG4gIHBlcnA6IFwiXFx1MjJBNVwiLFxuICBzZG90OiBcIlxcdTIyQzVcIixcbiAgbGNlaWw6IFwiXFx1MjMwOFwiLFxuICByY2VpbDogXCJcXHUyMzA5XCIsXG4gIGxmbG9vcjogXCJcXHUyMzBBXCIsXG4gIHJmbG9vcjogXCJcXHUyMzBCXCIsXG4gIGxhbmc6IFwiXFx1MjMyOVwiLFxuICByYW5nOiBcIlxcdTIzMkFcIixcbiAgbG96OiBcIlxcdTI1Q0FcIixcbiAgc3BhZGVzOiBcIlxcdTI2NjBcIixcbiAgY2x1YnM6IFwiXFx1MjY2M1wiLFxuICBoZWFydHM6IFwiXFx1MjY2NVwiLFxuICBkaWFtczogXCJcXHUyNjY2XCJcbn07XG5jb25zdCBsaW5lQnJlYWsgPSAvXFxyXFxufFtcXHJcXG5cXHUyMDI4XFx1MjAyOV0vO1xuY29uc3QgbGluZUJyZWFrRyA9IG5ldyBSZWdFeHAobGluZUJyZWFrLnNvdXJjZSwgXCJnXCIpO1xuZnVuY3Rpb24gaXNOZXdMaW5lKGNvZGUpIHtcbiAgc3dpdGNoIChjb2RlKSB7XG4gICAgY2FzZSAxMDpcbiAgICBjYXNlIDEzOlxuICAgIGNhc2UgODIzMjpcbiAgICBjYXNlIDgyMzM6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBoYXNOZXdMaW5lKGlucHV0LCBzdGFydCwgZW5kKSB7XG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKGlzTmV3TGluZShpbnB1dC5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmNvbnN0IHNraXBXaGl0ZVNwYWNlID0gLyg/Olxcc3xcXC9cXC8uKnxcXC9cXCpbXl0qP1xcKlxcLykqL2c7XG5jb25zdCBza2lwV2hpdGVTcGFjZUluTGluZSA9IC8oPzpbXlxcU1xcblxcclxcdTIwMjhcXHUyMDI5XXxcXC9cXC8uKnxcXC9cXCouKj9cXCpcXC8pKi9nO1xuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKGNvZGUpIHtcbiAgc3dpdGNoIChjb2RlKSB7XG4gICAgY2FzZSAweDAwMDk6XG4gICAgY2FzZSAweDAwMGI6XG4gICAgY2FzZSAweDAwMGM6XG4gICAgY2FzZSAzMjpcbiAgICBjYXNlIDE2MDpcbiAgICBjYXNlIDU3NjA6XG4gICAgY2FzZSAweDIwMDA6XG4gICAgY2FzZSAweDIwMDE6XG4gICAgY2FzZSAweDIwMDI6XG4gICAgY2FzZSAweDIwMDM6XG4gICAgY2FzZSAweDIwMDQ6XG4gICAgY2FzZSAweDIwMDU6XG4gICAgY2FzZSAweDIwMDY6XG4gICAgY2FzZSAweDIwMDc6XG4gICAgY2FzZSAweDIwMDg6XG4gICAgY2FzZSAweDIwMDk6XG4gICAgY2FzZSAweDIwMGE6XG4gICAgY2FzZSAweDIwMmY6XG4gICAgY2FzZSAweDIwNWY6XG4gICAgY2FzZSAweDMwMDA6XG4gICAgY2FzZSAweGZlZmY6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5jb25zdCBKc3hFcnJvcnMgPSBQYXJzZUVycm9yRW51bWBqc3hgKHtcbiAgQXR0cmlidXRlSXNFbXB0eTogXCJKU1ggYXR0cmlidXRlcyBtdXN0IG9ubHkgYmUgYXNzaWduZWQgYSBub24tZW1wdHkgZXhwcmVzc2lvbi5cIixcbiAgTWlzc2luZ0Nsb3NpbmdUYWdFbGVtZW50OiAoe1xuICAgIG9wZW5pbmdUYWdOYW1lXG4gIH0pID0+IGBFeHBlY3RlZCBjb3JyZXNwb25kaW5nIEpTWCBjbG9zaW5nIHRhZyBmb3IgPCR7b3BlbmluZ1RhZ05hbWV9Pi5gLFxuICBNaXNzaW5nQ2xvc2luZ1RhZ0ZyYWdtZW50OiBcIkV4cGVjdGVkIGNvcnJlc3BvbmRpbmcgSlNYIGNsb3NpbmcgdGFnIGZvciA8Pi5cIixcbiAgVW5leHBlY3RlZFNlcXVlbmNlRXhwcmVzc2lvbjogXCJTZXF1ZW5jZSBleHByZXNzaW9ucyBjYW5ub3QgYmUgZGlyZWN0bHkgbmVzdGVkIGluc2lkZSBKU1guIERpZCB5b3UgbWVhbiB0byB3cmFwIGl0IGluIHBhcmVudGhlc2VzICguLi4pP1wiLFxuICBVbmV4cGVjdGVkVG9rZW46ICh7XG4gICAgdW5leHBlY3RlZCxcbiAgICBIVE1MRW50aXR5XG4gIH0pID0+IGBVbmV4cGVjdGVkIHRva2VuIFxcYCR7dW5leHBlY3RlZH1cXGAuIERpZCB5b3UgbWVhbiBcXGAke0hUTUxFbnRpdHl9XFxgIG9yIFxcYHsnJHt1bmV4cGVjdGVkfSd9XFxgP2AsXG4gIFVuc3VwcG9ydGVkSnN4VmFsdWU6IFwiSlNYIHZhbHVlIHNob3VsZCBiZSBlaXRoZXIgYW4gZXhwcmVzc2lvbiBvciBhIHF1b3RlZCBKU1ggdGV4dC5cIixcbiAgVW50ZXJtaW5hdGVkSnN4Q29udGVudDogXCJVbnRlcm1pbmF0ZWQgSlNYIGNvbnRlbnRzLlwiLFxuICBVbndyYXBwZWRBZGphY2VudEpTWEVsZW1lbnRzOiBcIkFkamFjZW50IEpTWCBlbGVtZW50cyBtdXN0IGJlIHdyYXBwZWQgaW4gYW4gZW5jbG9zaW5nIHRhZy4gRGlkIHlvdSB3YW50IGEgSlNYIGZyYWdtZW50IDw+Li4uPC8+P1wiXG59KTtcbmZ1bmN0aW9uIGlzRnJhZ21lbnQob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgPyBvYmplY3QudHlwZSA9PT0gXCJKU1hPcGVuaW5nRnJhZ21lbnRcIiB8fCBvYmplY3QudHlwZSA9PT0gXCJKU1hDbG9zaW5nRnJhZ21lbnRcIiA6IGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0UXVhbGlmaWVkSlNYTmFtZShvYmplY3QpIHtcbiAgaWYgKG9iamVjdC50eXBlID09PSBcIkpTWElkZW50aWZpZXJcIikge1xuICAgIHJldHVybiBvYmplY3QubmFtZTtcbiAgfVxuICBpZiAob2JqZWN0LnR5cGUgPT09IFwiSlNYTmFtZXNwYWNlZE5hbWVcIikge1xuICAgIHJldHVybiBvYmplY3QubmFtZXNwYWNlLm5hbWUgKyBcIjpcIiArIG9iamVjdC5uYW1lLm5hbWU7XG4gIH1cbiAgaWYgKG9iamVjdC50eXBlID09PSBcIkpTWE1lbWJlckV4cHJlc3Npb25cIikge1xuICAgIHJldHVybiBnZXRRdWFsaWZpZWRKU1hOYW1lKG9iamVjdC5vYmplY3QpICsgXCIuXCIgKyBnZXRRdWFsaWZpZWRKU1hOYW1lKG9iamVjdC5wcm9wZXJ0eSk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiTm9kZSBoYWQgdW5leHBlY3RlZCB0eXBlOiBcIiArIG9iamVjdC50eXBlKTtcbn1cbnZhciBqc3ggPSBzdXBlckNsYXNzID0+IGNsYXNzIEpTWFBhcnNlck1peGluIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG4gIGpzeFJlYWRUb2tlbigpIHtcbiAgICBsZXQgb3V0ID0gXCJcIjtcbiAgICBsZXQgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLnBvcyA+PSB0aGlzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEpzeEVycm9ycy5VbnRlcm1pbmF0ZWRKc3hDb250ZW50LCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcbiAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgY2FzZSA2MDpcbiAgICAgICAgY2FzZSAxMjM6XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdGUucG9zID09PSB0aGlzLnN0YXRlLnN0YXJ0KSB7XG4gICAgICAgICAgICBpZiAoY2ggPT09IDYwICYmIHRoaXMuc3RhdGUuY2FuU3RhcnRKU1hFbGVtZW50KSB7XG4gICAgICAgICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTQzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN1cGVyLmdldFRva2VuRnJvbUNvZGUoY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnN0YXRlLnBvcyk7XG4gICAgICAgICAgdGhpcy5maW5pc2hUb2tlbigxNDIsIG91dCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMuc3RhdGUucG9zKTtcbiAgICAgICAgICBvdXQgKz0gdGhpcy5qc3hSZWFkRW50aXR5KCk7XG4gICAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDYyOlxuICAgICAgICBjYXNlIDEyNTpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoaXNOZXdMaW5lKGNoKSkge1xuICAgICAgICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgICAgICAgb3V0ICs9IHRoaXMuanN4UmVhZE5ld0xpbmUodHJ1ZSk7XG4gICAgICAgICAgICBjaHVua1N0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBqc3hSZWFkTmV3TGluZShub3JtYWxpemVDUkxGKSB7XG4gICAgY29uc3QgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MpO1xuICAgIGxldCBvdXQ7XG4gICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICBpZiAoY2ggPT09IDEzICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcykgPT09IDEwKSB7XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgb3V0ID0gbm9ybWFsaXplQ1JMRiA/IFwiXFxuXCIgOiBcIlxcclxcblwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcbiAgICB9XG4gICAgKyt0aGlzLnN0YXRlLmN1ckxpbmU7XG4gICAgdGhpcy5zdGF0ZS5saW5lU3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIGpzeFJlYWRTdHJpbmcocXVvdGUpIHtcbiAgICBsZXQgb3V0ID0gXCJcIjtcbiAgICBsZXQgY2h1bmtTdGFydCA9ICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKHRoaXMuc3RhdGUucG9zID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVudGVybWluYXRlZFN0cmluZywgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICB9XG4gICAgICBjb25zdCBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgICBpZiAoY2ggPT09IHF1b3RlKSBicmVhaztcbiAgICAgIGlmIChjaCA9PT0gMzgpIHtcbiAgICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgICBvdXQgKz0gdGhpcy5qc3hSZWFkRW50aXR5KCk7XG4gICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICAgIH0gZWxzZSBpZiAoaXNOZXdMaW5lKGNoKSkge1xuICAgICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnN0YXRlLnBvcyk7XG4gICAgICAgIG91dCArPSB0aGlzLmpzeFJlYWROZXdMaW5lKGZhbHNlKTtcbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIH1cbiAgICB9XG4gICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5zdGF0ZS5wb3MrKyk7XG4gICAgdGhpcy5maW5pc2hUb2tlbigxMzQsIG91dCk7XG4gIH1cbiAganN4UmVhZEVudGl0eSgpIHtcbiAgICBjb25zdCBzdGFydFBvcyA9ICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgaWYgKHRoaXMuY29kZVBvaW50QXRQb3ModGhpcy5zdGF0ZS5wb3MpID09PSAzNSkge1xuICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIGxldCByYWRpeCA9IDEwO1xuICAgICAgaWYgKHRoaXMuY29kZVBvaW50QXRQb3ModGhpcy5zdGF0ZS5wb3MpID09PSAxMjApIHtcbiAgICAgICAgcmFkaXggPSAxNjtcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvZGVQb2ludCA9IHRoaXMucmVhZEludChyYWRpeCwgdW5kZWZpbmVkLCBmYWxzZSwgXCJiYWlsXCIpO1xuICAgICAgaWYgKGNvZGVQb2ludCAhPT0gbnVsbCAmJiB0aGlzLmNvZGVQb2ludEF0UG9zKHRoaXMuc3RhdGUucG9zKSA9PT0gNTkpIHtcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGVQb2ludCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICBsZXQgc2VtaSA9IGZhbHNlO1xuICAgICAgd2hpbGUgKGNvdW50KysgPCAxMCAmJiB0aGlzLnN0YXRlLnBvcyA8IHRoaXMubGVuZ3RoICYmICEoc2VtaSA9IHRoaXMuY29kZVBvaW50QXRQb3ModGhpcy5zdGF0ZS5wb3MpID09PSA1OSkpIHtcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIH1cbiAgICAgIGlmIChzZW1pKSB7XG4gICAgICAgIGNvbnN0IGRlc2MgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0UG9zLCB0aGlzLnN0YXRlLnBvcyk7XG4gICAgICAgIGNvbnN0IGVudGl0eSA9IGVudGl0aWVzW2Rlc2NdO1xuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICBpZiAoZW50aXR5KSB7XG4gICAgICAgICAgcmV0dXJuIGVudGl0eTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnN0YXRlLnBvcyA9IHN0YXJ0UG9zO1xuICAgIHJldHVybiBcIiZcIjtcbiAgfVxuICBqc3hSZWFkV29yZCgpIHtcbiAgICBsZXQgY2g7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICBkbyB7XG4gICAgICBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMuc3RhdGUucG9zKTtcbiAgICB9IHdoaWxlIChpc0lkZW50aWZpZXJDaGFyKGNoKSB8fCBjaCA9PT0gNDUpO1xuICAgIHRoaXMuZmluaXNoVG9rZW4oMTQxLCB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnN0YXRlLnBvcykpO1xuICB9XG4gIGpzeFBhcnNlSWRlbnRpZmllcigpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBpZiAodGhpcy5tYXRjaCgxNDEpKSB7XG4gICAgICBub2RlLm5hbWUgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgIH0gZWxzZSBpZiAodG9rZW5Jc0tleXdvcmQodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgbm9kZS5uYW1lID0gdG9rZW5MYWJlbE5hbWUodGhpcy5zdGF0ZS50eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJKU1hJZGVudGlmaWVyXCIpO1xuICB9XG4gIGpzeFBhcnNlTmFtZXNwYWNlZE5hbWUoKSB7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLmpzeFBhcnNlSWRlbnRpZmllcigpO1xuICAgIGlmICghdGhpcy5lYXQoMTQpKSByZXR1cm4gbmFtZTtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgbm9kZS5uYW1lc3BhY2UgPSBuYW1lO1xuICAgIG5vZGUubmFtZSA9IHRoaXMuanN4UGFyc2VJZGVudGlmaWVyKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWE5hbWVzcGFjZWROYW1lXCIpO1xuICB9XG4gIGpzeFBhcnNlRWxlbWVudE5hbWUoKSB7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGxldCBub2RlID0gdGhpcy5qc3hQYXJzZU5hbWVzcGFjZWROYW1lKCk7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJKU1hOYW1lc3BhY2VkTmFtZVwiKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgd2hpbGUgKHRoaXMuZWF0KDE2KSkge1xuICAgICAgY29uc3QgbmV3Tm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgbmV3Tm9kZS5vYmplY3QgPSBub2RlO1xuICAgICAgbmV3Tm9kZS5wcm9wZXJ0eSA9IHRoaXMuanN4UGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICBub2RlID0gdGhpcy5maW5pc2hOb2RlKG5ld05vZGUsIFwiSlNYTWVtYmVyRXhwcmVzc2lvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAganN4UGFyc2VBdHRyaWJ1dGVWYWx1ZSgpIHtcbiAgICBsZXQgbm9kZTtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUudHlwZSkge1xuICAgICAgY2FzZSA1OlxuICAgICAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgdGhpcy5zZXRDb250ZXh0KHR5cGVzLmJyYWNlKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIG5vZGUgPSB0aGlzLmpzeFBhcnNlRXhwcmVzc2lvbkNvbnRhaW5lcihub2RlLCB0eXBlcy5qX29UYWcpO1xuICAgICAgICBpZiAobm9kZS5leHByZXNzaW9uLnR5cGUgPT09IFwiSlNYRW1wdHlFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEpzeEVycm9ycy5BdHRyaWJ1dGVJc0VtcHR5LCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIGNhc2UgMTQzOlxuICAgICAgY2FzZSAxMzQ6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXhwckF0b20oKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoSnN4RXJyb3JzLlVuc3VwcG9ydGVkSnN4VmFsdWUsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgIH1cbiAgfVxuICBqc3hQYXJzZUVtcHR5RXhwcmVzc2lvbigpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdCh0aGlzLnN0YXRlLmxhc3RUb2tFbmRMb2MpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGVBdChub2RlLCBcIkpTWEVtcHR5RXhwcmVzc2lvblwiLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgfVxuICBqc3hQYXJzZVNwcmVhZENoaWxkKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmV4cHJlc3Npb24gPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuc2V0Q29udGV4dCh0eXBlcy5qX2V4cHIpO1xuICAgIHRoaXMuc3RhdGUuY2FuU3RhcnRKU1hFbGVtZW50ID0gdHJ1ZTtcbiAgICB0aGlzLmV4cGVjdCg4KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSlNYU3ByZWFkQ2hpbGRcIik7XG4gIH1cbiAganN4UGFyc2VFeHByZXNzaW9uQ29udGFpbmVyKG5vZGUsIHByZXZpb3VzQ29udGV4dCkge1xuICAgIGlmICh0aGlzLm1hdGNoKDgpKSB7XG4gICAgICBub2RlLmV4cHJlc3Npb24gPSB0aGlzLmpzeFBhcnNlRW1wdHlFeHByZXNzaW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgbm9kZS5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICB9XG4gICAgdGhpcy5zZXRDb250ZXh0KHByZXZpb3VzQ29udGV4dCk7XG4gICAgdGhpcy5zdGF0ZS5jYW5TdGFydEpTWEVsZW1lbnQgPSB0cnVlO1xuICAgIHRoaXMuZXhwZWN0KDgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCIpO1xuICB9XG4gIGpzeFBhcnNlQXR0cmlidXRlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGlmICh0aGlzLm1hdGNoKDUpKSB7XG4gICAgICB0aGlzLnNldENvbnRleHQodHlwZXMuYnJhY2UpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLmV4cGVjdCgyMSk7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduQWxsb3dJbigpO1xuICAgICAgdGhpcy5zZXRDb250ZXh0KHR5cGVzLmpfb1RhZyk7XG4gICAgICB0aGlzLnN0YXRlLmNhblN0YXJ0SlNYRWxlbWVudCA9IHRydWU7XG4gICAgICB0aGlzLmV4cGVjdCg4KTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJKU1hTcHJlYWRBdHRyaWJ1dGVcIik7XG4gICAgfVxuICAgIG5vZGUubmFtZSA9IHRoaXMuanN4UGFyc2VOYW1lc3BhY2VkTmFtZSgpO1xuICAgIG5vZGUudmFsdWUgPSB0aGlzLmVhdCgyOSkgPyB0aGlzLmpzeFBhcnNlQXR0cmlidXRlVmFsdWUoKSA6IG51bGw7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWEF0dHJpYnV0ZVwiKTtcbiAgfVxuICBqc3hQYXJzZU9wZW5pbmdFbGVtZW50QXQoc3RhcnRMb2MpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgaWYgKHRoaXMuZWF0KDE0NCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJKU1hPcGVuaW5nRnJhZ21lbnRcIik7XG4gICAgfVxuICAgIG5vZGUubmFtZSA9IHRoaXMuanN4UGFyc2VFbGVtZW50TmFtZSgpO1xuICAgIHJldHVybiB0aGlzLmpzeFBhcnNlT3BlbmluZ0VsZW1lbnRBZnRlck5hbWUobm9kZSk7XG4gIH1cbiAganN4UGFyc2VPcGVuaW5nRWxlbWVudEFmdGVyTmFtZShub2RlKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IFtdO1xuICAgIHdoaWxlICghdGhpcy5tYXRjaCg1NikgJiYgIXRoaXMubWF0Y2goMTQ0KSkge1xuICAgICAgYXR0cmlidXRlcy5wdXNoKHRoaXMuanN4UGFyc2VBdHRyaWJ1dGUoKSk7XG4gICAgfVxuICAgIG5vZGUuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgbm9kZS5zZWxmQ2xvc2luZyA9IHRoaXMuZWF0KDU2KTtcbiAgICB0aGlzLmV4cGVjdCgxNDQpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJKU1hPcGVuaW5nRWxlbWVudFwiKTtcbiAgfVxuICBqc3hQYXJzZUNsb3NpbmdFbGVtZW50QXQoc3RhcnRMb2MpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgaWYgKHRoaXMuZWF0KDE0NCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJKU1hDbG9zaW5nRnJhZ21lbnRcIik7XG4gICAgfVxuICAgIG5vZGUubmFtZSA9IHRoaXMuanN4UGFyc2VFbGVtZW50TmFtZSgpO1xuICAgIHRoaXMuZXhwZWN0KDE0NCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWENsb3NpbmdFbGVtZW50XCIpO1xuICB9XG4gIGpzeFBhcnNlRWxlbWVudEF0KHN0YXJ0TG9jKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gW107XG4gICAgY29uc3Qgb3BlbmluZ0VsZW1lbnQgPSB0aGlzLmpzeFBhcnNlT3BlbmluZ0VsZW1lbnRBdChzdGFydExvYyk7XG4gICAgbGV0IGNsb3NpbmdFbGVtZW50ID0gbnVsbDtcbiAgICBpZiAoIW9wZW5pbmdFbGVtZW50LnNlbGZDbG9zaW5nKSB7XG4gICAgICBjb250ZW50czogZm9yICg7Oykge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUudHlwZSkge1xuICAgICAgICAgIGNhc2UgMTQzOlxuICAgICAgICAgICAgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5lYXQoNTYpKSB7XG4gICAgICAgICAgICAgIGNsb3NpbmdFbGVtZW50ID0gdGhpcy5qc3hQYXJzZUNsb3NpbmdFbGVtZW50QXQoc3RhcnRMb2MpO1xuICAgICAgICAgICAgICBicmVhayBjb250ZW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5qc3hQYXJzZUVsZW1lbnRBdChzdGFydExvYykpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxNDI6XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMucGFyc2VMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUsIFwiSlNYVGV4dFwiKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICAgICAgICB0aGlzLnNldENvbnRleHQodHlwZXMuYnJhY2UpO1xuICAgICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goMjEpKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmpzeFBhcnNlU3ByZWFkQ2hpbGQobm9kZSkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5qc3hQYXJzZUV4cHJlc3Npb25Db250YWluZXIobm9kZSwgdHlwZXMual9leHByKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNGcmFnbWVudChvcGVuaW5nRWxlbWVudCkgJiYgIWlzRnJhZ21lbnQoY2xvc2luZ0VsZW1lbnQpICYmIGNsb3NpbmdFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMucmFpc2UoSnN4RXJyb3JzLk1pc3NpbmdDbG9zaW5nVGFnRnJhZ21lbnQsIGNsb3NpbmdFbGVtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRnJhZ21lbnQob3BlbmluZ0VsZW1lbnQpICYmIGlzRnJhZ21lbnQoY2xvc2luZ0VsZW1lbnQpKSB7XG4gICAgICAgIHRoaXMucmFpc2UoSnN4RXJyb3JzLk1pc3NpbmdDbG9zaW5nVGFnRWxlbWVudCwgY2xvc2luZ0VsZW1lbnQsIHtcbiAgICAgICAgICBvcGVuaW5nVGFnTmFtZTogZ2V0UXVhbGlmaWVkSlNYTmFtZShvcGVuaW5nRWxlbWVudC5uYW1lKVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRnJhZ21lbnQob3BlbmluZ0VsZW1lbnQpICYmICFpc0ZyYWdtZW50KGNsb3NpbmdFbGVtZW50KSkge1xuICAgICAgICBpZiAoZ2V0UXVhbGlmaWVkSlNYTmFtZShjbG9zaW5nRWxlbWVudC5uYW1lKSAhPT0gZ2V0UXVhbGlmaWVkSlNYTmFtZShvcGVuaW5nRWxlbWVudC5uYW1lKSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoSnN4RXJyb3JzLk1pc3NpbmdDbG9zaW5nVGFnRWxlbWVudCwgY2xvc2luZ0VsZW1lbnQsIHtcbiAgICAgICAgICAgIG9wZW5pbmdUYWdOYW1lOiBnZXRRdWFsaWZpZWRKU1hOYW1lKG9wZW5pbmdFbGVtZW50Lm5hbWUpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRnJhZ21lbnQob3BlbmluZ0VsZW1lbnQpKSB7XG4gICAgICBub2RlLm9wZW5pbmdGcmFnbWVudCA9IG9wZW5pbmdFbGVtZW50O1xuICAgICAgbm9kZS5jbG9zaW5nRnJhZ21lbnQgPSBjbG9zaW5nRWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5vcGVuaW5nRWxlbWVudCA9IG9wZW5pbmdFbGVtZW50O1xuICAgICAgbm9kZS5jbG9zaW5nRWxlbWVudCA9IGNsb3NpbmdFbGVtZW50O1xuICAgIH1cbiAgICBub2RlLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEpzeEVycm9ycy5VbndyYXBwZWRBZGphY2VudEpTWEVsZW1lbnRzLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRnJhZ21lbnQob3BlbmluZ0VsZW1lbnQpID8gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSlNYRnJhZ21lbnRcIikgOiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJKU1hFbGVtZW50XCIpO1xuICB9XG4gIGpzeFBhcnNlRWxlbWVudCgpIHtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuanN4UGFyc2VFbGVtZW50QXQoc3RhcnRMb2MpO1xuICB9XG4gIHNldENvbnRleHQobmV3Q29udGV4dCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRleHRcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb250ZXh0W2NvbnRleHQubGVuZ3RoIC0gMV0gPSBuZXdDb250ZXh0O1xuICB9XG4gIHBhcnNlRXhwckF0b20ocmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGlmICh0aGlzLm1hdGNoKDE0MykpIHtcbiAgICAgIHJldHVybiB0aGlzLmpzeFBhcnNlRWxlbWVudCgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tYXRjaCg0NykgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKSAhPT0gMzMpIHtcbiAgICAgIHRoaXMucmVwbGFjZVRva2VuKDE0Myk7XG4gICAgICByZXR1cm4gdGhpcy5qc3hQYXJzZUVsZW1lbnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN1cGVyLnBhcnNlRXhwckF0b20ocmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgfVxuICB9XG4gIHNraXBTcGFjZSgpIHtcbiAgICBjb25zdCBjdXJDb250ZXh0ID0gdGhpcy5jdXJDb250ZXh0KCk7XG4gICAgaWYgKCFjdXJDb250ZXh0LnByZXNlcnZlU3BhY2UpIHN1cGVyLnNraXBTcGFjZSgpO1xuICB9XG4gIGdldFRva2VuRnJvbUNvZGUoY29kZSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmN1ckNvbnRleHQoKTtcbiAgICBpZiAoY29udGV4dCA9PT0gdHlwZXMual9leHByKSB7XG4gICAgICB0aGlzLmpzeFJlYWRUb2tlbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY29udGV4dCA9PT0gdHlwZXMual9vVGFnIHx8IGNvbnRleHQgPT09IHR5cGVzLmpfY1RhZykge1xuICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGNvZGUpKSB7XG4gICAgICAgIHRoaXMuanN4UmVhZFdvcmQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGNvZGUgPT09IDYyKSB7XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTQ0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKChjb2RlID09PSAzNCB8fCBjb2RlID09PSAzOSkgJiYgY29udGV4dCA9PT0gdHlwZXMual9vVGFnKSB7XG4gICAgICAgIHRoaXMuanN4UmVhZFN0cmluZyhjb2RlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29kZSA9PT0gNjAgJiYgdGhpcy5zdGF0ZS5jYW5TdGFydEpTWEVsZW1lbnQgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSkgIT09IDMzKSB7XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigxNDMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5nZXRUb2tlbkZyb21Db2RlKGNvZGUpO1xuICB9XG4gIHVwZGF0ZUNvbnRleHQocHJldlR5cGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250ZXh0LFxuICAgICAgdHlwZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICh0eXBlID09PSA1NiAmJiBwcmV2VHlwZSA9PT0gMTQzKSB7XG4gICAgICBjb250ZXh0LnNwbGljZSgtMiwgMiwgdHlwZXMual9jVGFnKTtcbiAgICAgIHRoaXMuc3RhdGUuY2FuU3RhcnRKU1hFbGVtZW50ID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAxNDMpIHtcbiAgICAgIGNvbnRleHQucHVzaCh0eXBlcy5qX29UYWcpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gMTQ0KSB7XG4gICAgICBjb25zdCBvdXQgPSBjb250ZXh0W2NvbnRleHQubGVuZ3RoIC0gMV07XG4gICAgICBpZiAob3V0ID09PSB0eXBlcy5qX29UYWcgJiYgcHJldlR5cGUgPT09IDU2IHx8IG91dCA9PT0gdHlwZXMual9jVGFnKSB7XG4gICAgICAgIGNvbnRleHQucG9wKCk7XG4gICAgICAgIHRoaXMuc3RhdGUuY2FuU3RhcnRKU1hFbGVtZW50ID0gY29udGV4dFtjb250ZXh0Lmxlbmd0aCAtIDFdID09PSB0eXBlcy5qX2V4cHI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldENvbnRleHQodHlwZXMual9leHByKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5jYW5TdGFydEpTWEVsZW1lbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlLmNhblN0YXJ0SlNYRWxlbWVudCA9IHRva2VuQ29tZXNCZWZvcmVFeHByZXNzaW9uKHR5cGUpO1xuICAgIH1cbiAgfVxufTtcbmNsYXNzIFR5cGVTY3JpcHRTY29wZSBleHRlbmRzIFNjb3BlIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIHRoaXMudHNOYW1lcyA9IG5ldyBNYXAoKTtcbiAgfVxufVxuY2xhc3MgVHlwZVNjcmlwdFNjb3BlSGFuZGxlciBleHRlbmRzIFNjb3BlSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICB0aGlzLmltcG9ydHNTdGFjayA9IFtdO1xuICB9XG4gIGNyZWF0ZVNjb3BlKGZsYWdzKSB7XG4gICAgdGhpcy5pbXBvcnRzU3RhY2sucHVzaChuZXcgU2V0KCkpO1xuICAgIHJldHVybiBuZXcgVHlwZVNjcmlwdFNjb3BlKGZsYWdzKTtcbiAgfVxuICBlbnRlcihmbGFncykge1xuICAgIGlmIChmbGFncyA9PT0gMTAyNCkge1xuICAgICAgdGhpcy5pbXBvcnRzU3RhY2sucHVzaChuZXcgU2V0KCkpO1xuICAgIH1cbiAgICBzdXBlci5lbnRlcihmbGFncyk7XG4gIH1cbiAgZXhpdCgpIHtcbiAgICBjb25zdCBmbGFncyA9IHN1cGVyLmV4aXQoKTtcbiAgICBpZiAoZmxhZ3MgPT09IDEwMjQpIHtcbiAgICAgIHRoaXMuaW1wb3J0c1N0YWNrLnBvcCgpO1xuICAgIH1cbiAgICByZXR1cm4gZmxhZ3M7XG4gIH1cbiAgaGFzSW1wb3J0KG5hbWUsIGFsbG93U2hhZG93KSB7XG4gICAgY29uc3QgbGVuID0gdGhpcy5pbXBvcnRzU3RhY2subGVuZ3RoO1xuICAgIGlmICh0aGlzLmltcG9ydHNTdGFja1tsZW4gLSAxXS5oYXMobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWFsbG93U2hhZG93ICYmIGxlbiA+IDEpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLmltcG9ydHNTdGFja1tpXS5oYXMobmFtZSkpIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZGVjbGFyZU5hbWUobmFtZSwgYmluZGluZ1R5cGUsIGxvYykge1xuICAgIGlmIChiaW5kaW5nVHlwZSAmIDQwOTYpIHtcbiAgICAgIGlmICh0aGlzLmhhc0ltcG9ydChuYW1lLCB0cnVlKSkge1xuICAgICAgICB0aGlzLnBhcnNlci5yYWlzZShFcnJvcnMuVmFyUmVkZWNsYXJhdGlvbiwgbG9jLCB7XG4gICAgICAgICAgaWRlbnRpZmllck5hbWU6IG5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLmltcG9ydHNTdGFja1t0aGlzLmltcG9ydHNTdGFjay5sZW5ndGggLSAxXS5hZGQobmFtZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNjb3BlID0gdGhpcy5jdXJyZW50U2NvcGUoKTtcbiAgICBsZXQgdHlwZSA9IHNjb3BlLnRzTmFtZXMuZ2V0KG5hbWUpIHx8IDA7XG4gICAgaWYgKGJpbmRpbmdUeXBlICYgMTAyNCkge1xuICAgICAgdGhpcy5tYXliZUV4cG9ydERlZmluZWQoc2NvcGUsIG5hbWUpO1xuICAgICAgc2NvcGUudHNOYW1lcy5zZXQobmFtZSwgdHlwZSB8IDE2KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIuZGVjbGFyZU5hbWUobmFtZSwgYmluZGluZ1R5cGUsIGxvYyk7XG4gICAgaWYgKGJpbmRpbmdUeXBlICYgMikge1xuICAgICAgaWYgKCEoYmluZGluZ1R5cGUgJiAxKSkge1xuICAgICAgICB0aGlzLmNoZWNrUmVkZWNsYXJhdGlvbkluU2NvcGUoc2NvcGUsIG5hbWUsIGJpbmRpbmdUeXBlLCBsb2MpO1xuICAgICAgICB0aGlzLm1heWJlRXhwb3J0RGVmaW5lZChzY29wZSwgbmFtZSk7XG4gICAgICB9XG4gICAgICB0eXBlID0gdHlwZSB8IDE7XG4gICAgfVxuICAgIGlmIChiaW5kaW5nVHlwZSAmIDI1Nikge1xuICAgICAgdHlwZSA9IHR5cGUgfCAyO1xuICAgIH1cbiAgICBpZiAoYmluZGluZ1R5cGUgJiA1MTIpIHtcbiAgICAgIHR5cGUgPSB0eXBlIHwgNDtcbiAgICB9XG4gICAgaWYgKGJpbmRpbmdUeXBlICYgMTI4KSB7XG4gICAgICB0eXBlID0gdHlwZSB8IDg7XG4gICAgfVxuICAgIGlmICh0eXBlKSBzY29wZS50c05hbWVzLnNldChuYW1lLCB0eXBlKTtcbiAgfVxuICBpc1JlZGVjbGFyZWRJblNjb3BlKHNjb3BlLCBuYW1lLCBiaW5kaW5nVHlwZSkge1xuICAgIGNvbnN0IHR5cGUgPSBzY29wZS50c05hbWVzLmdldChuYW1lKTtcbiAgICBpZiAoKHR5cGUgJiAyKSA+IDApIHtcbiAgICAgIGlmIChiaW5kaW5nVHlwZSAmIDI1Nikge1xuICAgICAgICBjb25zdCBpc0NvbnN0ID0gISEoYmluZGluZ1R5cGUgJiA1MTIpO1xuICAgICAgICBjb25zdCB3YXNDb25zdCA9ICh0eXBlICYgNCkgPiAwO1xuICAgICAgICByZXR1cm4gaXNDb25zdCAhPT0gd2FzQ29uc3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGJpbmRpbmdUeXBlICYgMTI4ICYmICh0eXBlICYgOCkgPiAwKSB7XG4gICAgICBpZiAoc2NvcGUubmFtZXMuZ2V0KG5hbWUpICYgMikge1xuICAgICAgICByZXR1cm4gISEoYmluZGluZ1R5cGUgJiAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJpbmRpbmdUeXBlICYgMiAmJiAodHlwZSAmIDEpID4gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5pc1JlZGVjbGFyZWRJblNjb3BlKHNjb3BlLCBuYW1lLCBiaW5kaW5nVHlwZSk7XG4gIH1cbiAgY2hlY2tMb2NhbEV4cG9ydChpZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG5hbWVcbiAgICB9ID0gaWQ7XG4gICAgaWYgKHRoaXMuaGFzSW1wb3J0KG5hbWUpKSByZXR1cm47XG4gICAgY29uc3QgbGVuID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZVN0YWNrW2ldO1xuICAgICAgY29uc3QgdHlwZSA9IHNjb3BlLnRzTmFtZXMuZ2V0KG5hbWUpO1xuICAgICAgaWYgKCh0eXBlICYgMSkgPiAwIHx8ICh0eXBlICYgMTYpID4gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHN1cGVyLmNoZWNrTG9jYWxFeHBvcnQoaWQpO1xuICB9XG59XG5jbGFzcyBQcm9kdWN0aW9uUGFyYW1ldGVySGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3RhY2tzID0gW107XG4gIH1cbiAgZW50ZXIoZmxhZ3MpIHtcbiAgICB0aGlzLnN0YWNrcy5wdXNoKGZsYWdzKTtcbiAgfVxuICBleGl0KCkge1xuICAgIHRoaXMuc3RhY2tzLnBvcCgpO1xuICB9XG4gIGN1cnJlbnRGbGFncygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFja3NbdGhpcy5zdGFja3MubGVuZ3RoIC0gMV07XG4gIH1cbiAgZ2V0IGhhc0F3YWl0KCkge1xuICAgIHJldHVybiAodGhpcy5jdXJyZW50RmxhZ3MoKSAmIDIpID4gMDtcbiAgfVxuICBnZXQgaGFzWWllbGQoKSB7XG4gICAgcmV0dXJuICh0aGlzLmN1cnJlbnRGbGFncygpICYgMSkgPiAwO1xuICB9XG4gIGdldCBoYXNSZXR1cm4oKSB7XG4gICAgcmV0dXJuICh0aGlzLmN1cnJlbnRGbGFncygpICYgNCkgPiAwO1xuICB9XG4gIGdldCBoYXNJbigpIHtcbiAgICByZXR1cm4gKHRoaXMuY3VycmVudEZsYWdzKCkgJiA4KSA+IDA7XG4gIH1cbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uRmxhZ3MoaXNBc3luYywgaXNHZW5lcmF0b3IpIHtcbiAgcmV0dXJuIChpc0FzeW5jID8gMiA6IDApIHwgKGlzR2VuZXJhdG9yID8gMSA6IDApO1xufVxuY2xhc3MgQmFzZVBhcnNlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc2F3VW5hbWJpZ3VvdXNFU00gPSBmYWxzZTtcbiAgICB0aGlzLmFtYmlndW91c1NjcmlwdERpZmZlcmVudEFzdCA9IGZhbHNlO1xuICB9XG4gIHNvdXJjZVRvT2Zmc2V0UG9zKHNvdXJjZVBvcykge1xuICAgIHJldHVybiBzb3VyY2VQb3MgKyB0aGlzLnN0YXJ0SW5kZXg7XG4gIH1cbiAgb2Zmc2V0VG9Tb3VyY2VQb3Mob2Zmc2V0UG9zKSB7XG4gICAgcmV0dXJuIG9mZnNldFBvcyAtIHRoaXMuc3RhcnRJbmRleDtcbiAgfVxuICBoYXNQbHVnaW4ocGx1Z2luQ29uZmlnKSB7XG4gICAgaWYgKHR5cGVvZiBwbHVnaW5Db25maWcgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLnBsdWdpbnMuaGFzKHBsdWdpbkNvbmZpZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IFtwbHVnaW5OYW1lLCBwbHVnaW5PcHRpb25zXSA9IHBsdWdpbkNvbmZpZztcbiAgICAgIGlmICghdGhpcy5oYXNQbHVnaW4ocGx1Z2luTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgYWN0dWFsT3B0aW9ucyA9IHRoaXMucGx1Z2lucy5nZXQocGx1Z2luTmFtZSk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhwbHVnaW5PcHRpb25zKSkge1xuICAgICAgICBpZiAoKGFjdHVhbE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGFjdHVhbE9wdGlvbnNba2V5XSkgIT09IHBsdWdpbk9wdGlvbnNba2V5XSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIGdldFBsdWdpbk9wdGlvbihwbHVnaW4sIG5hbWUpIHtcbiAgICB2YXIgX3RoaXMkcGx1Z2lucyRnZXQ7XG4gICAgcmV0dXJuIChfdGhpcyRwbHVnaW5zJGdldCA9IHRoaXMucGx1Z2lucy5nZXQocGx1Z2luKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHBsdWdpbnMkZ2V0W25hbWVdO1xuICB9XG59XG5mdW5jdGlvbiBzZXRUcmFpbGluZ0NvbW1lbnRzKG5vZGUsIGNvbW1lbnRzKSB7XG4gIGlmIChub2RlLnRyYWlsaW5nQ29tbWVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIG5vZGUudHJhaWxpbmdDb21tZW50cyA9IGNvbW1lbnRzO1xuICB9IGVsc2Uge1xuICAgIG5vZGUudHJhaWxpbmdDb21tZW50cy51bnNoaWZ0KC4uLmNvbW1lbnRzKTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0TGVhZGluZ0NvbW1lbnRzKG5vZGUsIGNvbW1lbnRzKSB7XG4gIGlmIChub2RlLmxlYWRpbmdDb21tZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbm9kZS5sZWFkaW5nQ29tbWVudHMgPSBjb21tZW50cztcbiAgfSBlbHNlIHtcbiAgICBub2RlLmxlYWRpbmdDb21tZW50cy51bnNoaWZ0KC4uLmNvbW1lbnRzKTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0SW5uZXJDb21tZW50cyhub2RlLCBjb21tZW50cykge1xuICBpZiAobm9kZS5pbm5lckNvbW1lbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBub2RlLmlubmVyQ29tbWVudHMgPSBjb21tZW50cztcbiAgfSBlbHNlIHtcbiAgICBub2RlLmlubmVyQ29tbWVudHMudW5zaGlmdCguLi5jb21tZW50cyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFkanVzdElubmVyQ29tbWVudHMobm9kZSwgZWxlbWVudHMsIGNvbW1lbnRXUykge1xuICBsZXQgbGFzdEVsZW1lbnQgPSBudWxsO1xuICBsZXQgaSA9IGVsZW1lbnRzLmxlbmd0aDtcbiAgd2hpbGUgKGxhc3RFbGVtZW50ID09PSBudWxsICYmIGkgPiAwKSB7XG4gICAgbGFzdEVsZW1lbnQgPSBlbGVtZW50c1stLWldO1xuICB9XG4gIGlmIChsYXN0RWxlbWVudCA9PT0gbnVsbCB8fCBsYXN0RWxlbWVudC5zdGFydCA+IGNvbW1lbnRXUy5zdGFydCkge1xuICAgIHNldElubmVyQ29tbWVudHMobm9kZSwgY29tbWVudFdTLmNvbW1lbnRzKTtcbiAgfSBlbHNlIHtcbiAgICBzZXRUcmFpbGluZ0NvbW1lbnRzKGxhc3RFbGVtZW50LCBjb21tZW50V1MuY29tbWVudHMpO1xuICB9XG59XG5jbGFzcyBDb21tZW50c1BhcnNlciBleHRlbmRzIEJhc2VQYXJzZXIge1xuICBhZGRDb21tZW50KGNvbW1lbnQpIHtcbiAgICBpZiAodGhpcy5maWxlbmFtZSkgY29tbWVudC5sb2MuZmlsZW5hbWUgPSB0aGlzLmZpbGVuYW1lO1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1lbnRzTGVuXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHRoaXMuY29tbWVudHMubGVuZ3RoICE9PSBjb21tZW50c0xlbikge1xuICAgICAgdGhpcy5jb21tZW50cy5sZW5ndGggPSBjb21tZW50c0xlbjtcbiAgICB9XG4gICAgdGhpcy5jb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgIHRoaXMuc3RhdGUuY29tbWVudHNMZW4rKztcbiAgfVxuICBwcm9jZXNzQ29tbWVudChub2RlKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWVudFN0YWNrXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgY29tbWVudFN0YWNrTGVuZ3RoID0gY29tbWVudFN0YWNrLmxlbmd0aDtcbiAgICBpZiAoY29tbWVudFN0YWNrTGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgbGV0IGkgPSBjb21tZW50U3RhY2tMZW5ndGggLSAxO1xuICAgIGNvbnN0IGxhc3RDb21tZW50V1MgPSBjb21tZW50U3RhY2tbaV07XG4gICAgaWYgKGxhc3RDb21tZW50V1Muc3RhcnQgPT09IG5vZGUuZW5kKSB7XG4gICAgICBsYXN0Q29tbWVudFdTLmxlYWRpbmdOb2RlID0gbm9kZTtcbiAgICAgIGktLTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc3RhcnQ6IG5vZGVTdGFydFxuICAgIH0gPSBub2RlO1xuICAgIGZvciAoOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgY29tbWVudFdTID0gY29tbWVudFN0YWNrW2ldO1xuICAgICAgY29uc3QgY29tbWVudEVuZCA9IGNvbW1lbnRXUy5lbmQ7XG4gICAgICBpZiAoY29tbWVudEVuZCA+IG5vZGVTdGFydCkge1xuICAgICAgICBjb21tZW50V1MuY29udGFpbmluZ05vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLmZpbmFsaXplQ29tbWVudChjb21tZW50V1MpO1xuICAgICAgICBjb21tZW50U3RhY2suc3BsaWNlKGksIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNvbW1lbnRFbmQgPT09IG5vZGVTdGFydCkge1xuICAgICAgICAgIGNvbW1lbnRXUy50cmFpbGluZ05vZGUgPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmaW5hbGl6ZUNvbW1lbnQoY29tbWVudFdTKSB7XG4gICAgdmFyIF9ub2RlJG9wdGlvbnM7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWVudHNcbiAgICB9ID0gY29tbWVudFdTO1xuICAgIGlmIChjb21tZW50V1MubGVhZGluZ05vZGUgIT09IG51bGwgfHwgY29tbWVudFdTLnRyYWlsaW5nTm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKGNvbW1lbnRXUy5sZWFkaW5nTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBzZXRUcmFpbGluZ0NvbW1lbnRzKGNvbW1lbnRXUy5sZWFkaW5nTm9kZSwgY29tbWVudHMpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbW1lbnRXUy50cmFpbGluZ05vZGUgIT09IG51bGwpIHtcbiAgICAgICAgc2V0TGVhZGluZ0NvbW1lbnRzKGNvbW1lbnRXUy50cmFpbGluZ05vZGUsIGNvbW1lbnRzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb250YWluaW5nTm9kZTogbm9kZSxcbiAgICAgICAgc3RhcnQ6IGNvbW1lbnRTdGFydFxuICAgICAgfSA9IGNvbW1lbnRXUztcbiAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5vZmZzZXRUb1NvdXJjZVBvcyhjb21tZW50U3RhcnQpIC0gMSkgPT09IDQ0KSB7XG4gICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIk9iamVjdEV4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgICAgICAgIGNhc2UgXCJSZWNvcmRFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICBhZGp1c3RJbm5lckNvbW1lbnRzKG5vZGUsIG5vZGUucHJvcGVydGllcywgY29tbWVudFdTKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJDYWxsRXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICBhZGp1c3RJbm5lckNvbW1lbnRzKG5vZGUsIG5vZGUuYXJndW1lbnRzLCBjb21tZW50V1MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIkltcG9ydEV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgIGFkanVzdElubmVyQ29tbWVudHMobm9kZSwgW25vZGUuc291cmNlLCAoX25vZGUkb3B0aW9ucyA9IG5vZGUub3B0aW9ucykgIT0gbnVsbCA/IF9ub2RlJG9wdGlvbnMgOiBudWxsXSwgY29tbWVudFdTKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCI6XG4gICAgICAgICAgY2FzZSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJPYmplY3RNZXRob2RcIjpcbiAgICAgICAgICBjYXNlIFwiQ2xhc3NNZXRob2RcIjpcbiAgICAgICAgICBjYXNlIFwiQ2xhc3NQcml2YXRlTWV0aG9kXCI6XG4gICAgICAgICAgICBhZGp1c3RJbm5lckNvbW1lbnRzKG5vZGUsIG5vZGUucGFyYW1zLCBjb21tZW50V1MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIkFycmF5RXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICAgICAgICBjYXNlIFwiVHVwbGVFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICBhZGp1c3RJbm5lckNvbW1lbnRzKG5vZGUsIG5vZGUuZWxlbWVudHMsIGNvbW1lbnRXUyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiOlxuICAgICAgICAgIGNhc2UgXCJJbXBvcnREZWNsYXJhdGlvblwiOlxuICAgICAgICAgICAgYWRqdXN0SW5uZXJDb21tZW50cyhub2RlLCBub2RlLnNwZWNpZmllcnMsIGNvbW1lbnRXUyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiVFNFbnVtRGVjbGFyYXRpb25cIjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgYWRqdXN0SW5uZXJDb21tZW50cyhub2RlLCBub2RlLm1lbWJlcnMsIGNvbW1lbnRXUyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiVFNFbnVtQm9keVwiOlxuICAgICAgICAgICAgYWRqdXN0SW5uZXJDb21tZW50cyhub2RlLCBub2RlLm1lbWJlcnMsIGNvbW1lbnRXUyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzZXRJbm5lckNvbW1lbnRzKG5vZGUsIGNvbW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0SW5uZXJDb21tZW50cyhub2RlLCBjb21tZW50cyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZpbmFsaXplUmVtYWluaW5nQ29tbWVudHMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWVudFN0YWNrXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgZm9yIChsZXQgaSA9IGNvbW1lbnRTdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdGhpcy5maW5hbGl6ZUNvbW1lbnQoY29tbWVudFN0YWNrW2ldKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZS5jb21tZW50U3RhY2sgPSBbXTtcbiAgfVxuICByZXNldFByZXZpb3VzTm9kZVRyYWlsaW5nQ29tbWVudHMobm9kZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1lbnRTdGFja1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHtcbiAgICAgIGxlbmd0aFxuICAgIH0gPSBjb21tZW50U3RhY2s7XG4gICAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIGNvbnN0IGNvbW1lbnRXUyA9IGNvbW1lbnRTdGFja1tsZW5ndGggLSAxXTtcbiAgICBpZiAoY29tbWVudFdTLmxlYWRpbmdOb2RlID09PSBub2RlKSB7XG4gICAgICBjb21tZW50V1MubGVhZGluZ05vZGUgPSBudWxsO1xuICAgIH1cbiAgfVxuICB0YWtlU3Vycm91bmRpbmdDb21tZW50cyhub2RlLCBzdGFydCwgZW5kKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWVudFN0YWNrXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgY29tbWVudFN0YWNrTGVuZ3RoID0gY29tbWVudFN0YWNrLmxlbmd0aDtcbiAgICBpZiAoY29tbWVudFN0YWNrTGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgbGV0IGkgPSBjb21tZW50U3RhY2tMZW5ndGggLSAxO1xuICAgIGZvciAoOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgY29tbWVudFdTID0gY29tbWVudFN0YWNrW2ldO1xuICAgICAgY29uc3QgY29tbWVudEVuZCA9IGNvbW1lbnRXUy5lbmQ7XG4gICAgICBjb25zdCBjb21tZW50U3RhcnQgPSBjb21tZW50V1Muc3RhcnQ7XG4gICAgICBpZiAoY29tbWVudFN0YXJ0ID09PSBlbmQpIHtcbiAgICAgICAgY29tbWVudFdTLmxlYWRpbmdOb2RlID0gbm9kZTtcbiAgICAgIH0gZWxzZSBpZiAoY29tbWVudEVuZCA9PT0gc3RhcnQpIHtcbiAgICAgICAgY29tbWVudFdTLnRyYWlsaW5nTm9kZSA9IG5vZGU7XG4gICAgICB9IGVsc2UgaWYgKGNvbW1lbnRFbmQgPCBzdGFydCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmNsYXNzIFN0YXRlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5mbGFncyA9IDEwMjQ7XG4gICAgdGhpcy5zdGFydEluZGV4ID0gdm9pZCAwO1xuICAgIHRoaXMuY3VyTGluZSA9IHZvaWQgMDtcbiAgICB0aGlzLmxpbmVTdGFydCA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YXJ0TG9jID0gdm9pZCAwO1xuICAgIHRoaXMuZW5kTG9jID0gdm9pZCAwO1xuICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID0gLTE7XG4gICAgdGhpcy5ub0Fycm93QXQgPSBbXTtcbiAgICB0aGlzLm5vQXJyb3dQYXJhbXNDb252ZXJzaW9uQXQgPSBbXTtcbiAgICB0aGlzLnRvcGljQ29udGV4dCA9IHtcbiAgICAgIG1heE51bU9mUmVzb2x2YWJsZVRvcGljczogMCxcbiAgICAgIG1heFRvcGljSW5kZXg6IG51bGxcbiAgICB9O1xuICAgIHRoaXMubGFiZWxzID0gW107XG4gICAgdGhpcy5jb21tZW50c0xlbiA9IDA7XG4gICAgdGhpcy5jb21tZW50U3RhY2sgPSBbXTtcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy50eXBlID0gMTQwO1xuICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgIHRoaXMuc3RhcnQgPSAwO1xuICAgIHRoaXMuZW5kID0gMDtcbiAgICB0aGlzLmxhc3RUb2tFbmRMb2MgPSBudWxsO1xuICAgIHRoaXMubGFzdFRva1N0YXJ0TG9jID0gbnVsbDtcbiAgICB0aGlzLmNvbnRleHQgPSBbdHlwZXMuYnJhY2VdO1xuICAgIHRoaXMuZmlyc3RJbnZhbGlkVGVtcGxhdGVFc2NhcGVQb3MgPSBudWxsO1xuICAgIHRoaXMuc3RyaWN0RXJyb3JzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudG9rZW5zTGVuZ3RoID0gMDtcbiAgfVxuICBnZXQgc3RyaWN0KCkge1xuICAgIHJldHVybiAodGhpcy5mbGFncyAmIDEpID4gMDtcbiAgfVxuICBzZXQgc3RyaWN0KHYpIHtcbiAgICBpZiAodikgdGhpcy5mbGFncyB8PSAxO2Vsc2UgdGhpcy5mbGFncyAmPSAtMjtcbiAgfVxuICBpbml0KHtcbiAgICBzdHJpY3RNb2RlLFxuICAgIHNvdXJjZVR5cGUsXG4gICAgc3RhcnRJbmRleCxcbiAgICBzdGFydExpbmUsXG4gICAgc3RhcnRDb2x1bW5cbiAgfSkge1xuICAgIHRoaXMuc3RyaWN0ID0gc3RyaWN0TW9kZSA9PT0gZmFsc2UgPyBmYWxzZSA6IHN0cmljdE1vZGUgPT09IHRydWUgPyB0cnVlIDogc291cmNlVHlwZSA9PT0gXCJtb2R1bGVcIjtcbiAgICB0aGlzLnN0YXJ0SW5kZXggPSBzdGFydEluZGV4O1xuICAgIHRoaXMuY3VyTGluZSA9IHN0YXJ0TGluZTtcbiAgICB0aGlzLmxpbmVTdGFydCA9IC1zdGFydENvbHVtbjtcbiAgICB0aGlzLnN0YXJ0TG9jID0gdGhpcy5lbmRMb2MgPSBuZXcgUG9zaXRpb24oc3RhcnRMaW5lLCBzdGFydENvbHVtbiwgc3RhcnRJbmRleCk7XG4gIH1cbiAgZ2V0IG1heWJlSW5BcnJvd1BhcmFtZXRlcnMoKSB7XG4gICAgcmV0dXJuICh0aGlzLmZsYWdzICYgMikgPiAwO1xuICB9XG4gIHNldCBtYXliZUluQXJyb3dQYXJhbWV0ZXJzKHYpIHtcbiAgICBpZiAodikgdGhpcy5mbGFncyB8PSAyO2Vsc2UgdGhpcy5mbGFncyAmPSAtMztcbiAgfVxuICBnZXQgaW5UeXBlKCkge1xuICAgIHJldHVybiAodGhpcy5mbGFncyAmIDQpID4gMDtcbiAgfVxuICBzZXQgaW5UeXBlKHYpIHtcbiAgICBpZiAodikgdGhpcy5mbGFncyB8PSA0O2Vsc2UgdGhpcy5mbGFncyAmPSAtNTtcbiAgfVxuICBnZXQgbm9Bbm9uRnVuY3Rpb25UeXBlKCkge1xuICAgIHJldHVybiAodGhpcy5mbGFncyAmIDgpID4gMDtcbiAgfVxuICBzZXQgbm9Bbm9uRnVuY3Rpb25UeXBlKHYpIHtcbiAgICBpZiAodikgdGhpcy5mbGFncyB8PSA4O2Vsc2UgdGhpcy5mbGFncyAmPSAtOTtcbiAgfVxuICBnZXQgaGFzRmxvd0NvbW1lbnQoKSB7XG4gICAgcmV0dXJuICh0aGlzLmZsYWdzICYgMTYpID4gMDtcbiAgfVxuICBzZXQgaGFzRmxvd0NvbW1lbnQodikge1xuICAgIGlmICh2KSB0aGlzLmZsYWdzIHw9IDE2O2Vsc2UgdGhpcy5mbGFncyAmPSAtMTc7XG4gIH1cbiAgZ2V0IGlzQW1iaWVudENvbnRleHQoKSB7XG4gICAgcmV0dXJuICh0aGlzLmZsYWdzICYgMzIpID4gMDtcbiAgfVxuICBzZXQgaXNBbWJpZW50Q29udGV4dCh2KSB7XG4gICAgaWYgKHYpIHRoaXMuZmxhZ3MgfD0gMzI7ZWxzZSB0aGlzLmZsYWdzICY9IC0zMztcbiAgfVxuICBnZXQgaW5BYnN0cmFjdENsYXNzKCkge1xuICAgIHJldHVybiAodGhpcy5mbGFncyAmIDY0KSA+IDA7XG4gIH1cbiAgc2V0IGluQWJzdHJhY3RDbGFzcyh2KSB7XG4gICAgaWYgKHYpIHRoaXMuZmxhZ3MgfD0gNjQ7ZWxzZSB0aGlzLmZsYWdzICY9IC02NTtcbiAgfVxuICBnZXQgaW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0KCkge1xuICAgIHJldHVybiAodGhpcy5mbGFncyAmIDEyOCkgPiAwO1xuICB9XG4gIHNldCBpbkRpc2FsbG93Q29uZGl0aW9uYWxUeXBlc0NvbnRleHQodikge1xuICAgIGlmICh2KSB0aGlzLmZsYWdzIHw9IDEyODtlbHNlIHRoaXMuZmxhZ3MgJj0gLTEyOTtcbiAgfVxuICBnZXQgc29sb0F3YWl0KCkge1xuICAgIHJldHVybiAodGhpcy5mbGFncyAmIDI1NikgPiAwO1xuICB9XG4gIHNldCBzb2xvQXdhaXQodikge1xuICAgIGlmICh2KSB0aGlzLmZsYWdzIHw9IDI1NjtlbHNlIHRoaXMuZmxhZ3MgJj0gLTI1NztcbiAgfVxuICBnZXQgaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkoKSB7XG4gICAgcmV0dXJuICh0aGlzLmZsYWdzICYgNTEyKSA+IDA7XG4gIH1cbiAgc2V0IGluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5KHYpIHtcbiAgICBpZiAodikgdGhpcy5mbGFncyB8PSA1MTI7ZWxzZSB0aGlzLmZsYWdzICY9IC01MTM7XG4gIH1cbiAgZ2V0IGNhblN0YXJ0SlNYRWxlbWVudCgpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiAxMDI0KSA+IDA7XG4gIH1cbiAgc2V0IGNhblN0YXJ0SlNYRWxlbWVudCh2KSB7XG4gICAgaWYgKHYpIHRoaXMuZmxhZ3MgfD0gMTAyNDtlbHNlIHRoaXMuZmxhZ3MgJj0gLTEwMjU7XG4gIH1cbiAgZ2V0IGNvbnRhaW5zRXNjKCkge1xuICAgIHJldHVybiAodGhpcy5mbGFncyAmIDIwNDgpID4gMDtcbiAgfVxuICBzZXQgY29udGFpbnNFc2Modikge1xuICAgIGlmICh2KSB0aGlzLmZsYWdzIHw9IDIwNDg7ZWxzZSB0aGlzLmZsYWdzICY9IC0yMDQ5O1xuICB9XG4gIGdldCBoYXNUb3BMZXZlbEF3YWl0KCkge1xuICAgIHJldHVybiAodGhpcy5mbGFncyAmIDQwOTYpID4gMDtcbiAgfVxuICBzZXQgaGFzVG9wTGV2ZWxBd2FpdCh2KSB7XG4gICAgaWYgKHYpIHRoaXMuZmxhZ3MgfD0gNDA5NjtlbHNlIHRoaXMuZmxhZ3MgJj0gLTQwOTc7XG4gIH1cbiAgY3VyUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBQb3NpdGlvbih0aGlzLmN1ckxpbmUsIHRoaXMucG9zIC0gdGhpcy5saW5lU3RhcnQsIHRoaXMucG9zICsgdGhpcy5zdGFydEluZGV4KTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBzdGF0ZSA9IG5ldyBTdGF0ZSgpO1xuICAgIHN0YXRlLmZsYWdzID0gdGhpcy5mbGFncztcbiAgICBzdGF0ZS5zdGFydEluZGV4ID0gdGhpcy5zdGFydEluZGV4O1xuICAgIHN0YXRlLmN1ckxpbmUgPSB0aGlzLmN1ckxpbmU7XG4gICAgc3RhdGUubGluZVN0YXJ0ID0gdGhpcy5saW5lU3RhcnQ7XG4gICAgc3RhdGUuc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgIHN0YXRlLmVuZExvYyA9IHRoaXMuZW5kTG9jO1xuICAgIHN0YXRlLmVycm9ycyA9IHRoaXMuZXJyb3JzLnNsaWNlKCk7XG4gICAgc3RhdGUucG90ZW50aWFsQXJyb3dBdCA9IHRoaXMucG90ZW50aWFsQXJyb3dBdDtcbiAgICBzdGF0ZS5ub0Fycm93QXQgPSB0aGlzLm5vQXJyb3dBdC5zbGljZSgpO1xuICAgIHN0YXRlLm5vQXJyb3dQYXJhbXNDb252ZXJzaW9uQXQgPSB0aGlzLm5vQXJyb3dQYXJhbXNDb252ZXJzaW9uQXQuc2xpY2UoKTtcbiAgICBzdGF0ZS50b3BpY0NvbnRleHQgPSB0aGlzLnRvcGljQ29udGV4dDtcbiAgICBzdGF0ZS5sYWJlbHMgPSB0aGlzLmxhYmVscy5zbGljZSgpO1xuICAgIHN0YXRlLmNvbW1lbnRzTGVuID0gdGhpcy5jb21tZW50c0xlbjtcbiAgICBzdGF0ZS5jb21tZW50U3RhY2sgPSB0aGlzLmNvbW1lbnRTdGFjay5zbGljZSgpO1xuICAgIHN0YXRlLnBvcyA9IHRoaXMucG9zO1xuICAgIHN0YXRlLnR5cGUgPSB0aGlzLnR5cGU7XG4gICAgc3RhdGUudmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgIHN0YXRlLnN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICBzdGF0ZS5lbmQgPSB0aGlzLmVuZDtcbiAgICBzdGF0ZS5sYXN0VG9rRW5kTG9jID0gdGhpcy5sYXN0VG9rRW5kTG9jO1xuICAgIHN0YXRlLmxhc3RUb2tTdGFydExvYyA9IHRoaXMubGFzdFRva1N0YXJ0TG9jO1xuICAgIHN0YXRlLmNvbnRleHQgPSB0aGlzLmNvbnRleHQuc2xpY2UoKTtcbiAgICBzdGF0ZS5maXJzdEludmFsaWRUZW1wbGF0ZUVzY2FwZVBvcyA9IHRoaXMuZmlyc3RJbnZhbGlkVGVtcGxhdGVFc2NhcGVQb3M7XG4gICAgc3RhdGUuc3RyaWN0RXJyb3JzID0gdGhpcy5zdHJpY3RFcnJvcnM7XG4gICAgc3RhdGUudG9rZW5zTGVuZ3RoID0gdGhpcy50b2tlbnNMZW5ndGg7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG52YXIgX2lzRGlnaXQgPSBmdW5jdGlvbiBpc0RpZ2l0KGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPj0gNDggJiYgY29kZSA8PSA1Nztcbn07XG5jb25zdCBmb3JiaWRkZW5OdW1lcmljU2VwYXJhdG9yU2libGluZ3MgPSB7XG4gIGRlY0Jpbk9jdDogbmV3IFNldChbNDYsIDY2LCA2OSwgNzksIDk1LCA5OCwgMTAxLCAxMTFdKSxcbiAgaGV4OiBuZXcgU2V0KFs0NiwgODgsIDk1LCAxMjBdKVxufTtcbmNvbnN0IGlzQWxsb3dlZE51bWVyaWNTZXBhcmF0b3JTaWJsaW5nID0ge1xuICBiaW46IGNoID0+IGNoID09PSA0OCB8fCBjaCA9PT0gNDksXG4gIG9jdDogY2ggPT4gY2ggPj0gNDggJiYgY2ggPD0gNTUsXG4gIGRlYzogY2ggPT4gY2ggPj0gNDggJiYgY2ggPD0gNTcsXG4gIGhleDogY2ggPT4gY2ggPj0gNDggJiYgY2ggPD0gNTcgfHwgY2ggPj0gNjUgJiYgY2ggPD0gNzAgfHwgY2ggPj0gOTcgJiYgY2ggPD0gMTAyXG59O1xuZnVuY3Rpb24gcmVhZFN0cmluZ0NvbnRlbnRzKHR5cGUsIGlucHV0LCBwb3MsIGxpbmVTdGFydCwgY3VyTGluZSwgZXJyb3JzKSB7XG4gIGNvbnN0IGluaXRpYWxQb3MgPSBwb3M7XG4gIGNvbnN0IGluaXRpYWxMaW5lU3RhcnQgPSBsaW5lU3RhcnQ7XG4gIGNvbnN0IGluaXRpYWxDdXJMaW5lID0gY3VyTGluZTtcbiAgbGV0IG91dCA9IFwiXCI7XG4gIGxldCBmaXJzdEludmFsaWRMb2MgPSBudWxsO1xuICBsZXQgY2h1bmtTdGFydCA9IHBvcztcbiAgY29uc3Qge1xuICAgIGxlbmd0aFxuICB9ID0gaW5wdXQ7XG4gIGZvciAoOzspIHtcbiAgICBpZiAocG9zID49IGxlbmd0aCkge1xuICAgICAgZXJyb3JzLnVudGVybWluYXRlZChpbml0aWFsUG9zLCBpbml0aWFsTGluZVN0YXJ0LCBpbml0aWFsQ3VyTGluZSk7XG4gICAgICBvdXQgKz0gaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgcG9zKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBjaCA9IGlucHV0LmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoaXNTdHJpbmdFbmQodHlwZSwgY2gsIGlucHV0LCBwb3MpKSB7XG4gICAgICBvdXQgKz0gaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgcG9zKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoY2ggPT09IDkyKSB7XG4gICAgICBvdXQgKz0gaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgcG9zKTtcbiAgICAgIGNvbnN0IHJlcyA9IHJlYWRFc2NhcGVkQ2hhcihpbnB1dCwgcG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIHR5cGUgPT09IFwidGVtcGxhdGVcIiwgZXJyb3JzKTtcbiAgICAgIGlmIChyZXMuY2ggPT09IG51bGwgJiYgIWZpcnN0SW52YWxpZExvYykge1xuICAgICAgICBmaXJzdEludmFsaWRMb2MgPSB7XG4gICAgICAgICAgcG9zLFxuICAgICAgICAgIGxpbmVTdGFydCxcbiAgICAgICAgICBjdXJMaW5lXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gcmVzLmNoO1xuICAgICAgfVxuICAgICAgKHtcbiAgICAgICAgcG9zLFxuICAgICAgICBsaW5lU3RhcnQsXG4gICAgICAgIGN1ckxpbmVcbiAgICAgIH0gPSByZXMpO1xuICAgICAgY2h1bmtTdGFydCA9IHBvcztcbiAgICB9IGVsc2UgaWYgKGNoID09PSA4MjMyIHx8IGNoID09PSA4MjMzKSB7XG4gICAgICArK3BvcztcbiAgICAgICsrY3VyTGluZTtcbiAgICAgIGxpbmVTdGFydCA9IHBvcztcbiAgICB9IGVsc2UgaWYgKGNoID09PSAxMCB8fCBjaCA9PT0gMTMpIHtcbiAgICAgIGlmICh0eXBlID09PSBcInRlbXBsYXRlXCIpIHtcbiAgICAgICAgb3V0ICs9IGlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHBvcykgKyBcIlxcblwiO1xuICAgICAgICArK3BvcztcbiAgICAgICAgaWYgKGNoID09PSAxMyAmJiBpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDEwKSB7XG4gICAgICAgICAgKytwb3M7XG4gICAgICAgIH1cbiAgICAgICAgKytjdXJMaW5lO1xuICAgICAgICBjaHVua1N0YXJ0ID0gbGluZVN0YXJ0ID0gcG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3JzLnVudGVybWluYXRlZChpbml0aWFsUG9zLCBpbml0aWFsTGluZVN0YXJ0LCBpbml0aWFsQ3VyTGluZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICsrcG9zO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHBvcyxcbiAgICBzdHI6IG91dCxcbiAgICBmaXJzdEludmFsaWRMb2MsXG4gICAgbGluZVN0YXJ0LFxuICAgIGN1ckxpbmUsXG4gICAgY29udGFpbnNJbnZhbGlkOiAhIWZpcnN0SW52YWxpZExvY1xuICB9O1xufVxuZnVuY3Rpb24gaXNTdHJpbmdFbmQodHlwZSwgY2gsIGlucHV0LCBwb3MpIHtcbiAgaWYgKHR5cGUgPT09IFwidGVtcGxhdGVcIikge1xuICAgIHJldHVybiBjaCA9PT0gOTYgfHwgY2ggPT09IDM2ICYmIGlucHV0LmNoYXJDb2RlQXQocG9zICsgMSkgPT09IDEyMztcbiAgfVxuICByZXR1cm4gY2ggPT09ICh0eXBlID09PSBcImRvdWJsZVwiID8gMzQgOiAzOSk7XG59XG5mdW5jdGlvbiByZWFkRXNjYXBlZENoYXIoaW5wdXQsIHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lLCBpblRlbXBsYXRlLCBlcnJvcnMpIHtcbiAgY29uc3QgdGhyb3dPbkludmFsaWQgPSAhaW5UZW1wbGF0ZTtcbiAgcG9zKys7XG4gIGNvbnN0IHJlcyA9IGNoID0+ICh7XG4gICAgcG9zLFxuICAgIGNoLFxuICAgIGxpbmVTdGFydCxcbiAgICBjdXJMaW5lXG4gIH0pO1xuICBjb25zdCBjaCA9IGlucHV0LmNoYXJDb2RlQXQocG9zKyspO1xuICBzd2l0Y2ggKGNoKSB7XG4gICAgY2FzZSAxMTA6XG4gICAgICByZXR1cm4gcmVzKFwiXFxuXCIpO1xuICAgIGNhc2UgMTE0OlxuICAgICAgcmV0dXJuIHJlcyhcIlxcclwiKTtcbiAgICBjYXNlIDEyMDpcbiAgICAgIHtcbiAgICAgICAgbGV0IGNvZGU7XG4gICAgICAgICh7XG4gICAgICAgICAgY29kZSxcbiAgICAgICAgICBwb3NcbiAgICAgICAgfSA9IHJlYWRIZXhDaGFyKGlucHV0LCBwb3MsIGxpbmVTdGFydCwgY3VyTGluZSwgMiwgZmFsc2UsIHRocm93T25JbnZhbGlkLCBlcnJvcnMpKTtcbiAgICAgICAgcmV0dXJuIHJlcyhjb2RlID09PSBudWxsID8gbnVsbCA6IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpO1xuICAgICAgfVxuICAgIGNhc2UgMTE3OlxuICAgICAge1xuICAgICAgICBsZXQgY29kZTtcbiAgICAgICAgKHtcbiAgICAgICAgICBjb2RlLFxuICAgICAgICAgIHBvc1xuICAgICAgICB9ID0gcmVhZENvZGVQb2ludChpbnB1dCwgcG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIHRocm93T25JbnZhbGlkLCBlcnJvcnMpKTtcbiAgICAgICAgcmV0dXJuIHJlcyhjb2RlID09PSBudWxsID8gbnVsbCA6IFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGUpKTtcbiAgICAgIH1cbiAgICBjYXNlIDExNjpcbiAgICAgIHJldHVybiByZXMoXCJcXHRcIik7XG4gICAgY2FzZSA5ODpcbiAgICAgIHJldHVybiByZXMoXCJcXGJcIik7XG4gICAgY2FzZSAxMTg6XG4gICAgICByZXR1cm4gcmVzKFwiXFx1MDAwYlwiKTtcbiAgICBjYXNlIDEwMjpcbiAgICAgIHJldHVybiByZXMoXCJcXGZcIik7XG4gICAgY2FzZSAxMzpcbiAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDEwKSB7XG4gICAgICAgICsrcG9zO1xuICAgICAgfVxuICAgIGNhc2UgMTA6XG4gICAgICBsaW5lU3RhcnQgPSBwb3M7XG4gICAgICArK2N1ckxpbmU7XG4gICAgY2FzZSA4MjMyOlxuICAgIGNhc2UgODIzMzpcbiAgICAgIHJldHVybiByZXMoXCJcIik7XG4gICAgY2FzZSA1NjpcbiAgICBjYXNlIDU3OlxuICAgICAgaWYgKGluVGVtcGxhdGUpIHtcbiAgICAgICAgcmV0dXJuIHJlcyhudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9ycy5zdHJpY3ROdW1lcmljRXNjYXBlKHBvcyAtIDEsIGxpbmVTdGFydCwgY3VyTGluZSk7XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChjaCA+PSA0OCAmJiBjaCA8PSA1NSkge1xuICAgICAgICBjb25zdCBzdGFydFBvcyA9IHBvcyAtIDE7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gL15bMC03XSsvLmV4ZWMoaW5wdXQuc2xpY2Uoc3RhcnRQb3MsIHBvcyArIDIpKTtcbiAgICAgICAgbGV0IG9jdGFsU3RyID0gbWF0Y2hbMF07XG4gICAgICAgIGxldCBvY3RhbCA9IHBhcnNlSW50KG9jdGFsU3RyLCA4KTtcbiAgICAgICAgaWYgKG9jdGFsID4gMjU1KSB7XG4gICAgICAgICAgb2N0YWxTdHIgPSBvY3RhbFN0ci5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgb2N0YWwgPSBwYXJzZUludChvY3RhbFN0ciwgOCk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IG9jdGFsU3RyLmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmIChvY3RhbFN0ciAhPT0gXCIwXCIgfHwgbmV4dCA9PT0gNTYgfHwgbmV4dCA9PT0gNTcpIHtcbiAgICAgICAgICBpZiAoaW5UZW1wbGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcyhudWxsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3JzLnN0cmljdE51bWVyaWNFc2NhcGUoc3RhcnRQb3MsIGxpbmVTdGFydCwgY3VyTGluZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXMoU3RyaW5nLmZyb21DaGFyQ29kZShvY3RhbCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcyhTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlYWRIZXhDaGFyKGlucHV0LCBwb3MsIGxpbmVTdGFydCwgY3VyTGluZSwgbGVuLCBmb3JjZUxlbiwgdGhyb3dPbkludmFsaWQsIGVycm9ycykge1xuICBjb25zdCBpbml0aWFsUG9zID0gcG9zO1xuICBsZXQgbjtcbiAgKHtcbiAgICBuLFxuICAgIHBvc1xuICB9ID0gcmVhZEludChpbnB1dCwgcG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIDE2LCBsZW4sIGZvcmNlTGVuLCBmYWxzZSwgZXJyb3JzLCAhdGhyb3dPbkludmFsaWQpKTtcbiAgaWYgKG4gPT09IG51bGwpIHtcbiAgICBpZiAodGhyb3dPbkludmFsaWQpIHtcbiAgICAgIGVycm9ycy5pbnZhbGlkRXNjYXBlU2VxdWVuY2UoaW5pdGlhbFBvcywgbGluZVN0YXJ0LCBjdXJMaW5lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9zID0gaW5pdGlhbFBvcyAtIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgY29kZTogbixcbiAgICBwb3NcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlYWRJbnQoaW5wdXQsIHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lLCByYWRpeCwgbGVuLCBmb3JjZUxlbiwgYWxsb3dOdW1TZXBhcmF0b3IsIGVycm9ycywgYmFpbE9uRXJyb3IpIHtcbiAgY29uc3Qgc3RhcnQgPSBwb3M7XG4gIGNvbnN0IGZvcmJpZGRlblNpYmxpbmdzID0gcmFkaXggPT09IDE2ID8gZm9yYmlkZGVuTnVtZXJpY1NlcGFyYXRvclNpYmxpbmdzLmhleCA6IGZvcmJpZGRlbk51bWVyaWNTZXBhcmF0b3JTaWJsaW5ncy5kZWNCaW5PY3Q7XG4gIGNvbnN0IGlzQWxsb3dlZFNpYmxpbmcgPSByYWRpeCA9PT0gMTYgPyBpc0FsbG93ZWROdW1lcmljU2VwYXJhdG9yU2libGluZy5oZXggOiByYWRpeCA9PT0gMTAgPyBpc0FsbG93ZWROdW1lcmljU2VwYXJhdG9yU2libGluZy5kZWMgOiByYWRpeCA9PT0gOCA/IGlzQWxsb3dlZE51bWVyaWNTZXBhcmF0b3JTaWJsaW5nLm9jdCA6IGlzQWxsb3dlZE51bWVyaWNTZXBhcmF0b3JTaWJsaW5nLmJpbjtcbiAgbGV0IGludmFsaWQgPSBmYWxzZTtcbiAgbGV0IHRvdGFsID0gMDtcbiAgZm9yIChsZXQgaSA9IDAsIGUgPSBsZW4gPT0gbnVsbCA/IEluZmluaXR5IDogbGVuOyBpIDwgZTsgKytpKSB7XG4gICAgY29uc3QgY29kZSA9IGlucHV0LmNoYXJDb2RlQXQocG9zKTtcbiAgICBsZXQgdmFsO1xuICAgIGlmIChjb2RlID09PSA5NSAmJiBhbGxvd051bVNlcGFyYXRvciAhPT0gXCJiYWlsXCIpIHtcbiAgICAgIGNvbnN0IHByZXYgPSBpbnB1dC5jaGFyQ29kZUF0KHBvcyAtIDEpO1xuICAgICAgY29uc3QgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQocG9zICsgMSk7XG4gICAgICBpZiAoIWFsbG93TnVtU2VwYXJhdG9yKSB7XG4gICAgICAgIGlmIChiYWlsT25FcnJvcikgcmV0dXJuIHtcbiAgICAgICAgICBuOiBudWxsLFxuICAgICAgICAgIHBvc1xuICAgICAgICB9O1xuICAgICAgICBlcnJvcnMubnVtZXJpY1NlcGFyYXRvckluRXNjYXBlU2VxdWVuY2UocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpO1xuICAgICAgfSBlbHNlIGlmIChOdW1iZXIuaXNOYU4obmV4dCkgfHwgIWlzQWxsb3dlZFNpYmxpbmcobmV4dCkgfHwgZm9yYmlkZGVuU2libGluZ3MuaGFzKHByZXYpIHx8IGZvcmJpZGRlblNpYmxpbmdzLmhhcyhuZXh0KSkge1xuICAgICAgICBpZiAoYmFpbE9uRXJyb3IpIHJldHVybiB7XG4gICAgICAgICAgbjogbnVsbCxcbiAgICAgICAgICBwb3NcbiAgICAgICAgfTtcbiAgICAgICAgZXJyb3JzLnVuZXhwZWN0ZWROdW1lcmljU2VwYXJhdG9yKHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lKTtcbiAgICAgIH1cbiAgICAgICsrcG9zO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjb2RlID49IDk3KSB7XG4gICAgICB2YWwgPSBjb2RlIC0gOTcgKyAxMDtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPj0gNjUpIHtcbiAgICAgIHZhbCA9IGNvZGUgLSA2NSArIDEwO1xuICAgIH0gZWxzZSBpZiAoX2lzRGlnaXQoY29kZSkpIHtcbiAgICAgIHZhbCA9IGNvZGUgLSA0ODtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsID0gSW5maW5pdHk7XG4gICAgfVxuICAgIGlmICh2YWwgPj0gcmFkaXgpIHtcbiAgICAgIGlmICh2YWwgPD0gOSAmJiBiYWlsT25FcnJvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG46IG51bGwsXG4gICAgICAgICAgcG9zXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHZhbCA8PSA5ICYmIGVycm9ycy5pbnZhbGlkRGlnaXQocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIHJhZGl4KSkge1xuICAgICAgICB2YWwgPSAwO1xuICAgICAgfSBlbHNlIGlmIChmb3JjZUxlbikge1xuICAgICAgICB2YWwgPSAwO1xuICAgICAgICBpbnZhbGlkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICArK3BvcztcbiAgICB0b3RhbCA9IHRvdGFsICogcmFkaXggKyB2YWw7XG4gIH1cbiAgaWYgKHBvcyA9PT0gc3RhcnQgfHwgbGVuICE9IG51bGwgJiYgcG9zIC0gc3RhcnQgIT09IGxlbiB8fCBpbnZhbGlkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG46IG51bGwsXG4gICAgICBwb3NcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbjogdG90YWwsXG4gICAgcG9zXG4gIH07XG59XG5mdW5jdGlvbiByZWFkQ29kZVBvaW50KGlucHV0LCBwb3MsIGxpbmVTdGFydCwgY3VyTGluZSwgdGhyb3dPbkludmFsaWQsIGVycm9ycykge1xuICBjb25zdCBjaCA9IGlucHV0LmNoYXJDb2RlQXQocG9zKTtcbiAgbGV0IGNvZGU7XG4gIGlmIChjaCA9PT0gMTIzKSB7XG4gICAgKytwb3M7XG4gICAgKHtcbiAgICAgIGNvZGUsXG4gICAgICBwb3NcbiAgICB9ID0gcmVhZEhleENoYXIoaW5wdXQsIHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lLCBpbnB1dC5pbmRleE9mKFwifVwiLCBwb3MpIC0gcG9zLCB0cnVlLCB0aHJvd09uSW52YWxpZCwgZXJyb3JzKSk7XG4gICAgKytwb3M7XG4gICAgaWYgKGNvZGUgIT09IG51bGwgJiYgY29kZSA+IDB4MTBmZmZmKSB7XG4gICAgICBpZiAodGhyb3dPbkludmFsaWQpIHtcbiAgICAgICAgZXJyb3JzLmludmFsaWRDb2RlUG9pbnQocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb2RlOiBudWxsLFxuICAgICAgICAgIHBvc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAoe1xuICAgICAgY29kZSxcbiAgICAgIHBvc1xuICAgIH0gPSByZWFkSGV4Q2hhcihpbnB1dCwgcG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIDQsIGZhbHNlLCB0aHJvd09uSW52YWxpZCwgZXJyb3JzKSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb2RlLFxuICAgIHBvc1xuICB9O1xufVxuZnVuY3Rpb24gYnVpbGRQb3NpdGlvbihwb3MsIGxpbmVTdGFydCwgY3VyTGluZSkge1xuICByZXR1cm4gbmV3IFBvc2l0aW9uKGN1ckxpbmUsIHBvcyAtIGxpbmVTdGFydCwgcG9zKTtcbn1cbmNvbnN0IFZBTElEX1JFR0VYX0ZMQUdTID0gbmV3IFNldChbMTAzLCAxMDksIDExNSwgMTA1LCAxMjEsIDExNywgMTAwLCAxMThdKTtcbmNsYXNzIFRva2VuIHtcbiAgY29uc3RydWN0b3Ioc3RhdGUpIHtcbiAgICBjb25zdCBzdGFydEluZGV4ID0gc3RhdGUuc3RhcnRJbmRleCB8fCAwO1xuICAgIHRoaXMudHlwZSA9IHN0YXRlLnR5cGU7XG4gICAgdGhpcy52YWx1ZSA9IHN0YXRlLnZhbHVlO1xuICAgIHRoaXMuc3RhcnQgPSBzdGFydEluZGV4ICsgc3RhdGUuc3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBzdGFydEluZGV4ICsgc3RhdGUuZW5kO1xuICAgIHRoaXMubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKHN0YXRlLnN0YXJ0TG9jLCBzdGF0ZS5lbmRMb2MpO1xuICB9XG59XG5jbGFzcyBUb2tlbml6ZXIgZXh0ZW5kcyBDb21tZW50c1BhcnNlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGlucHV0KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmlzTG9va2FoZWFkID0gdm9pZCAwO1xuICAgIHRoaXMudG9rZW5zID0gW107XG4gICAgdGhpcy5lcnJvckhhbmRsZXJzX3JlYWRJbnQgPSB7XG4gICAgICBpbnZhbGlkRGlnaXQ6IChwb3MsIGxpbmVTdGFydCwgY3VyTGluZSwgcmFkaXgpID0+IHtcbiAgICAgICAgaWYgKCEodGhpcy5vcHRpb25GbGFncyAmIDIwNDgpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWREaWdpdCwgYnVpbGRQb3NpdGlvbihwb3MsIGxpbmVTdGFydCwgY3VyTGluZSksIHtcbiAgICAgICAgICByYWRpeFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuICAgICAgbnVtZXJpY1NlcGFyYXRvckluRXNjYXBlU2VxdWVuY2U6IHRoaXMuZXJyb3JCdWlsZGVyKEVycm9ycy5OdW1lcmljU2VwYXJhdG9ySW5Fc2NhcGVTZXF1ZW5jZSksXG4gICAgICB1bmV4cGVjdGVkTnVtZXJpY1NlcGFyYXRvcjogdGhpcy5lcnJvckJ1aWxkZXIoRXJyb3JzLlVuZXhwZWN0ZWROdW1lcmljU2VwYXJhdG9yKVxuICAgIH07XG4gICAgdGhpcy5lcnJvckhhbmRsZXJzX3JlYWRDb2RlUG9pbnQgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmVycm9ySGFuZGxlcnNfcmVhZEludCwge1xuICAgICAgaW52YWxpZEVzY2FwZVNlcXVlbmNlOiB0aGlzLmVycm9yQnVpbGRlcihFcnJvcnMuSW52YWxpZEVzY2FwZVNlcXVlbmNlKSxcbiAgICAgIGludmFsaWRDb2RlUG9pbnQ6IHRoaXMuZXJyb3JCdWlsZGVyKEVycm9ycy5JbnZhbGlkQ29kZVBvaW50KVxuICAgIH0pO1xuICAgIHRoaXMuZXJyb3JIYW5kbGVyc19yZWFkU3RyaW5nQ29udGVudHNfc3RyaW5nID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5lcnJvckhhbmRsZXJzX3JlYWRDb2RlUG9pbnQsIHtcbiAgICAgIHN0cmljdE51bWVyaWNFc2NhcGU6IChwb3MsIGxpbmVTdGFydCwgY3VyTGluZSkgPT4ge1xuICAgICAgICB0aGlzLnJlY29yZFN0cmljdE1vZGVFcnJvcnMoRXJyb3JzLlN0cmljdE51bWVyaWNFc2NhcGUsIGJ1aWxkUG9zaXRpb24ocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpKTtcbiAgICAgIH0sXG4gICAgICB1bnRlcm1pbmF0ZWQ6IChwb3MsIGxpbmVTdGFydCwgY3VyTGluZSkgPT4ge1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5VbnRlcm1pbmF0ZWRTdHJpbmcsIGJ1aWxkUG9zaXRpb24ocG9zIC0gMSwgbGluZVN0YXJ0LCBjdXJMaW5lKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5lcnJvckhhbmRsZXJzX3JlYWRTdHJpbmdDb250ZW50c190ZW1wbGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZXJyb3JIYW5kbGVyc19yZWFkQ29kZVBvaW50LCB7XG4gICAgICBzdHJpY3ROdW1lcmljRXNjYXBlOiB0aGlzLmVycm9yQnVpbGRlcihFcnJvcnMuU3RyaWN0TnVtZXJpY0VzY2FwZSksXG4gICAgICB1bnRlcm1pbmF0ZWQ6IChwb3MsIGxpbmVTdGFydCwgY3VyTGluZSkgPT4ge1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5VbnRlcm1pbmF0ZWRUZW1wbGF0ZSwgYnVpbGRQb3NpdGlvbihwb3MsIGxpbmVTdGFydCwgY3VyTGluZSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc3RhdGUgPSBuZXcgU3RhdGUoKTtcbiAgICB0aGlzLnN0YXRlLmluaXQob3B0aW9ucyk7XG4gICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgIHRoaXMubGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgIHRoaXMuY29tbWVudHMgPSBbXTtcbiAgICB0aGlzLmlzTG9va2FoZWFkID0gZmFsc2U7XG4gIH1cbiAgcHVzaFRva2VuKHRva2VuKSB7XG4gICAgdGhpcy50b2tlbnMubGVuZ3RoID0gdGhpcy5zdGF0ZS50b2tlbnNMZW5ndGg7XG4gICAgdGhpcy50b2tlbnMucHVzaCh0b2tlbik7XG4gICAgKyt0aGlzLnN0YXRlLnRva2Vuc0xlbmd0aDtcbiAgfVxuICBuZXh0KCkge1xuICAgIHRoaXMuY2hlY2tLZXl3b3JkRXNjYXBlcygpO1xuICAgIGlmICh0aGlzLm9wdGlvbkZsYWdzICYgMjU2KSB7XG4gICAgICB0aGlzLnB1c2hUb2tlbihuZXcgVG9rZW4odGhpcy5zdGF0ZSkpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLmxhc3RUb2tFbmRMb2MgPSB0aGlzLnN0YXRlLmVuZExvYztcbiAgICB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgdGhpcy5uZXh0VG9rZW4oKTtcbiAgfVxuICBlYXQodHlwZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKHR5cGUpKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIG1hdGNoKHR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS50eXBlID09PSB0eXBlO1xuICB9XG4gIGNyZWF0ZUxvb2thaGVhZFN0YXRlKHN0YXRlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvczogc3RhdGUucG9zLFxuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICB0eXBlOiBzdGF0ZS50eXBlLFxuICAgICAgc3RhcnQ6IHN0YXRlLnN0YXJ0LFxuICAgICAgZW5kOiBzdGF0ZS5lbmQsXG4gICAgICBjb250ZXh0OiBbdGhpcy5jdXJDb250ZXh0KCldLFxuICAgICAgaW5UeXBlOiBzdGF0ZS5pblR5cGUsXG4gICAgICBzdGFydExvYzogc3RhdGUuc3RhcnRMb2MsXG4gICAgICBsYXN0VG9rRW5kTG9jOiBzdGF0ZS5sYXN0VG9rRW5kTG9jLFxuICAgICAgY3VyTGluZTogc3RhdGUuY3VyTGluZSxcbiAgICAgIGxpbmVTdGFydDogc3RhdGUubGluZVN0YXJ0LFxuICAgICAgY3VyUG9zaXRpb246IHN0YXRlLmN1clBvc2l0aW9uXG4gICAgfTtcbiAgfVxuICBsb29rYWhlYWQoKSB7XG4gICAgY29uc3Qgb2xkID0gdGhpcy5zdGF0ZTtcbiAgICB0aGlzLnN0YXRlID0gdGhpcy5jcmVhdGVMb29rYWhlYWRTdGF0ZShvbGQpO1xuICAgIHRoaXMuaXNMb29rYWhlYWQgPSB0cnVlO1xuICAgIHRoaXMubmV4dFRva2VuKCk7XG4gICAgdGhpcy5pc0xvb2thaGVhZCA9IGZhbHNlO1xuICAgIGNvbnN0IGN1cnIgPSB0aGlzLnN0YXRlO1xuICAgIHRoaXMuc3RhdGUgPSBvbGQ7XG4gICAgcmV0dXJuIGN1cnI7XG4gIH1cbiAgbmV4dFRva2VuU3RhcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubmV4dFRva2VuU3RhcnRTaW5jZSh0aGlzLnN0YXRlLnBvcyk7XG4gIH1cbiAgbmV4dFRva2VuU3RhcnRTaW5jZShwb3MpIHtcbiAgICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSBwb3M7XG4gICAgcmV0dXJuIHNraXBXaGl0ZVNwYWNlLnRlc3QodGhpcy5pbnB1dCkgPyBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggOiBwb3M7XG4gIH1cbiAgbG9va2FoZWFkQ2hhckNvZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubG9va2FoZWFkQ2hhckNvZGVTaW5jZSh0aGlzLnN0YXRlLnBvcyk7XG4gIH1cbiAgbG9va2FoZWFkQ2hhckNvZGVTaW5jZShwb3MpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMubmV4dFRva2VuU3RhcnRTaW5jZShwb3MpKTtcbiAgfVxuICBuZXh0VG9rZW5JbkxpbmVTdGFydCgpIHtcbiAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW5JbkxpbmVTdGFydFNpbmNlKHRoaXMuc3RhdGUucG9zKTtcbiAgfVxuICBuZXh0VG9rZW5JbkxpbmVTdGFydFNpbmNlKHBvcykge1xuICAgIHNraXBXaGl0ZVNwYWNlSW5MaW5lLmxhc3RJbmRleCA9IHBvcztcbiAgICByZXR1cm4gc2tpcFdoaXRlU3BhY2VJbkxpbmUudGVzdCh0aGlzLmlucHV0KSA/IHNraXBXaGl0ZVNwYWNlSW5MaW5lLmxhc3RJbmRleCA6IHBvcztcbiAgfVxuICBsb29rYWhlYWRJbkxpbmVDaGFyQ29kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMubmV4dFRva2VuSW5MaW5lU3RhcnQoKSk7XG4gIH1cbiAgY29kZVBvaW50QXRQb3MocG9zKSB7XG4gICAgbGV0IGNwID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKChjcCAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiArK3BvcyA8IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgICBjb25zdCB0cmFpbCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKCh0cmFpbCAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICBjcCA9IDB4MTAwMDAgKyAoKGNwICYgMHgzZmYpIDw8IDEwKSArICh0cmFpbCAmIDB4M2ZmKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNwO1xuICB9XG4gIHNldFN0cmljdChzdHJpY3QpIHtcbiAgICB0aGlzLnN0YXRlLnN0cmljdCA9IHN0cmljdDtcbiAgICBpZiAoc3RyaWN0KSB7XG4gICAgICB0aGlzLnN0YXRlLnN0cmljdEVycm9ycy5mb3JFYWNoKChbdG9QYXJzZUVycm9yLCBhdF0pID0+IHRoaXMucmFpc2UodG9QYXJzZUVycm9yLCBhdCkpO1xuICAgICAgdGhpcy5zdGF0ZS5zdHJpY3RFcnJvcnMuY2xlYXIoKTtcbiAgICB9XG4gIH1cbiAgY3VyQ29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5jb250ZXh0W3RoaXMuc3RhdGUuY29udGV4dC5sZW5ndGggLSAxXTtcbiAgfVxuICBuZXh0VG9rZW4oKSB7XG4gICAgdGhpcy5za2lwU3BhY2UoKTtcbiAgICB0aGlzLnN0YXRlLnN0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgaWYgKCF0aGlzLmlzTG9va2FoZWFkKSB0aGlzLnN0YXRlLnN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpO1xuICAgIGlmICh0aGlzLnN0YXRlLnBvcyA+PSB0aGlzLmxlbmd0aCkge1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigxNDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmdldFRva2VuRnJvbUNvZGUodGhpcy5jb2RlUG9pbnRBdFBvcyh0aGlzLnN0YXRlLnBvcykpO1xuICB9XG4gIHNraXBCbG9ja0NvbW1lbnQoY29tbWVudEVuZCkge1xuICAgIGxldCBzdGFydExvYztcbiAgICBpZiAoIXRoaXMuaXNMb29rYWhlYWQpIHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpO1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgY29uc3QgZW5kID0gdGhpcy5pbnB1dC5pbmRleE9mKGNvbW1lbnRFbmQsIHN0YXJ0ICsgMik7XG4gICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVudGVybWluYXRlZENvbW1lbnQsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUucG9zID0gZW5kICsgY29tbWVudEVuZC5sZW5ndGg7XG4gICAgbGluZUJyZWFrRy5sYXN0SW5kZXggPSBzdGFydCArIDI7XG4gICAgd2hpbGUgKGxpbmVCcmVha0cudGVzdCh0aGlzLmlucHV0KSAmJiBsaW5lQnJlYWtHLmxhc3RJbmRleCA8PSBlbmQpIHtcbiAgICAgICsrdGhpcy5zdGF0ZS5jdXJMaW5lO1xuICAgICAgdGhpcy5zdGF0ZS5saW5lU3RhcnQgPSBsaW5lQnJlYWtHLmxhc3RJbmRleDtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNMb29rYWhlYWQpIHJldHVybjtcbiAgICBjb25zdCBjb21tZW50ID0ge1xuICAgICAgdHlwZTogXCJDb21tZW50QmxvY2tcIixcbiAgICAgIHZhbHVlOiB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0ICsgMiwgZW5kKSxcbiAgICAgIHN0YXJ0OiB0aGlzLnNvdXJjZVRvT2Zmc2V0UG9zKHN0YXJ0KSxcbiAgICAgIGVuZDogdGhpcy5zb3VyY2VUb09mZnNldFBvcyhlbmQgKyBjb21tZW50RW5kLmxlbmd0aCksXG4gICAgICBsb2M6IG5ldyBTb3VyY2VMb2NhdGlvbihzdGFydExvYywgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKVxuICAgIH07XG4gICAgaWYgKHRoaXMub3B0aW9uRmxhZ3MgJiAyNTYpIHRoaXMucHVzaFRva2VuKGNvbW1lbnQpO1xuICAgIHJldHVybiBjb21tZW50O1xuICB9XG4gIHNraXBMaW5lQ29tbWVudChzdGFydFNraXApIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIGxldCBzdGFydExvYztcbiAgICBpZiAoIXRoaXMuaXNMb29rYWhlYWQpIHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpO1xuICAgIGxldCBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArPSBzdGFydFNraXApO1xuICAgIGlmICh0aGlzLnN0YXRlLnBvcyA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICB3aGlsZSAoIWlzTmV3TGluZShjaCkgJiYgKyt0aGlzLnN0YXRlLnBvcyA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuaXNMb29rYWhlYWQpIHJldHVybjtcbiAgICBjb25zdCBlbmQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQgKyBzdGFydFNraXAsIGVuZCk7XG4gICAgY29uc3QgY29tbWVudCA9IHtcbiAgICAgIHR5cGU6IFwiQ29tbWVudExpbmVcIixcbiAgICAgIHZhbHVlLFxuICAgICAgc3RhcnQ6IHRoaXMuc291cmNlVG9PZmZzZXRQb3Moc3RhcnQpLFxuICAgICAgZW5kOiB0aGlzLnNvdXJjZVRvT2Zmc2V0UG9zKGVuZCksXG4gICAgICBsb2M6IG5ldyBTb3VyY2VMb2NhdGlvbihzdGFydExvYywgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKVxuICAgIH07XG4gICAgaWYgKHRoaXMub3B0aW9uRmxhZ3MgJiAyNTYpIHRoaXMucHVzaFRva2VuKGNvbW1lbnQpO1xuICAgIHJldHVybiBjb21tZW50O1xuICB9XG4gIHNraXBTcGFjZSgpIHtcbiAgICBjb25zdCBzcGFjZVN0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgY29uc3QgY29tbWVudHMgPSB0aGlzLm9wdGlvbkZsYWdzICYgNDA5NiA/IFtdIDogbnVsbDtcbiAgICBsb29wOiB3aGlsZSAodGhpcy5zdGF0ZS5wb3MgPCB0aGlzLmxlbmd0aCkge1xuICAgICAgY29uc3QgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICBjYXNlIDMyOlxuICAgICAgICBjYXNlIDE2MDpcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpID09PSAxMCkge1xuICAgICAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgIGNhc2UgODIzMjpcbiAgICAgICAgY2FzZSA4MjMzOlxuICAgICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgKyt0aGlzLnN0YXRlLmN1ckxpbmU7XG4gICAgICAgICAgdGhpcy5zdGF0ZS5saW5lU3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0NzpcbiAgICAgICAgICBzd2l0Y2ggKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpKSB7XG4gICAgICAgICAgICBjYXNlIDQyOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tbWVudCA9IHRoaXMuc2tpcEJsb2NrQ29tbWVudChcIiovXCIpO1xuICAgICAgICAgICAgICAgIGlmIChjb21tZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29tbWVudChjb21tZW50KTtcbiAgICAgICAgICAgICAgICAgIGNvbW1lbnRzID09IG51bGwgfHwgY29tbWVudHMucHVzaChjb21tZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgNDc6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21tZW50ID0gdGhpcy5za2lwTGluZUNvbW1lbnQoMik7XG4gICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5hZGRDb21tZW50KGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgICAgY29tbWVudHMgPT0gbnVsbCB8fCBjb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKGlzV2hpdGVzcGFjZShjaCkpIHtcbiAgICAgICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gNDUgJiYgIXRoaXMuaW5Nb2R1bGUgJiYgdGhpcy5vcHRpb25GbGFncyAmIDgxOTIpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IHRoaXMuc3RhdGUucG9zO1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MgKyAxKSA9PT0gNDUgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHBvcyArIDIpID09PSA2MiAmJiAoc3BhY2VTdGFydCA9PT0gMCB8fCB0aGlzLnN0YXRlLmxpbmVTdGFydCA+IHNwYWNlU3RhcnQpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbW1lbnQgPSB0aGlzLnNraXBMaW5lQ29tbWVudCgzKTtcbiAgICAgICAgICAgICAgaWYgKGNvbW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29tbWVudChjb21tZW50KTtcbiAgICAgICAgICAgICAgICBjb21tZW50cyA9PSBudWxsIHx8IGNvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gNjAgJiYgIXRoaXMuaW5Nb2R1bGUgJiYgdGhpcy5vcHRpb25GbGFncyAmIDgxOTIpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IHRoaXMuc3RhdGUucG9zO1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MgKyAxKSA9PT0gMzMgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHBvcyArIDIpID09PSA0NSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zICsgMykgPT09IDQ1KSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbW1lbnQgPSB0aGlzLnNraXBMaW5lQ29tbWVudCg0KTtcbiAgICAgICAgICAgICAgaWYgKGNvbW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29tbWVudChjb21tZW50KTtcbiAgICAgICAgICAgICAgICBjb21tZW50cyA9PSBudWxsIHx8IGNvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoKGNvbW1lbnRzID09IG51bGwgPyB2b2lkIDAgOiBjb21tZW50cy5sZW5ndGgpID4gMCkge1xuICAgICAgY29uc3QgZW5kID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgICBjb25zdCBjb21tZW50V2hpdGVzcGFjZSA9IHtcbiAgICAgICAgc3RhcnQ6IHRoaXMuc291cmNlVG9PZmZzZXRQb3Moc3BhY2VTdGFydCksXG4gICAgICAgIGVuZDogdGhpcy5zb3VyY2VUb09mZnNldFBvcyhlbmQpLFxuICAgICAgICBjb21tZW50cyxcbiAgICAgICAgbGVhZGluZ05vZGU6IG51bGwsXG4gICAgICAgIHRyYWlsaW5nTm9kZTogbnVsbCxcbiAgICAgICAgY29udGFpbmluZ05vZGU6IG51bGxcbiAgICAgIH07XG4gICAgICB0aGlzLnN0YXRlLmNvbW1lbnRTdGFjay5wdXNoKGNvbW1lbnRXaGl0ZXNwYWNlKTtcbiAgICB9XG4gIH1cbiAgZmluaXNoVG9rZW4odHlwZSwgdmFsKSB7XG4gICAgdGhpcy5zdGF0ZS5lbmQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICB0aGlzLnN0YXRlLmVuZExvYyA9IHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKTtcbiAgICBjb25zdCBwcmV2VHlwZSA9IHRoaXMuc3RhdGUudHlwZTtcbiAgICB0aGlzLnN0YXRlLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuc3RhdGUudmFsdWUgPSB2YWw7XG4gICAgaWYgKCF0aGlzLmlzTG9va2FoZWFkKSB7XG4gICAgICB0aGlzLnVwZGF0ZUNvbnRleHQocHJldlR5cGUpO1xuICAgIH1cbiAgfVxuICByZXBsYWNlVG9rZW4odHlwZSkge1xuICAgIHRoaXMuc3RhdGUudHlwZSA9IHR5cGU7XG4gICAgdGhpcy51cGRhdGVDb250ZXh0KCk7XG4gIH1cbiAgcmVhZFRva2VuX251bWJlclNpZ24oKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUucG9zID09PSAwICYmIHRoaXMucmVhZFRva2VuX2ludGVycHJldGVyKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmV4dFBvcyA9IHRoaXMuc3RhdGUucG9zICsgMTtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5jb2RlUG9pbnRBdFBvcyhuZXh0UG9zKTtcbiAgICBpZiAobmV4dCA+PSA0OCAmJiBuZXh0IDw9IDU3KSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkRGlnaXRBZnRlckhhc2gsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgfVxuICAgIGlmIChuZXh0ID09PSAxMjMgfHwgbmV4dCA9PT0gOTEgJiYgdGhpcy5oYXNQbHVnaW4oXCJyZWNvcmRBbmRUdXBsZVwiKSkge1xuICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJyZWNvcmRBbmRUdXBsZVwiKTtcbiAgICAgIGlmICh0aGlzLmdldFBsdWdpbk9wdGlvbihcInJlY29yZEFuZFR1cGxlXCIsIFwic3ludGF4VHlwZVwiKSA9PT0gXCJiYXJcIikge1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKG5leHQgPT09IDEyMyA/IEVycm9ycy5SZWNvcmRFeHByZXNzaW9uSGFzaEluY29ycmVjdFN0YXJ0U3ludGF4VHlwZSA6IEVycm9ycy5UdXBsZUV4cHJlc3Npb25IYXNoSW5jb3JyZWN0U3RhcnRTeW50YXhUeXBlLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZS5wb3MgKz0gMjtcbiAgICAgIGlmIChuZXh0ID09PSAxMjMpIHtcbiAgICAgICAgdGhpcy5maW5pc2hUb2tlbig3KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZmluaXNoVG9rZW4oMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0lkZW50aWZpZXJTdGFydChuZXh0KSkge1xuICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTM5LCB0aGlzLnJlYWRXb3JkMShuZXh0KSk7XG4gICAgfSBlbHNlIGlmIChuZXh0ID09PSA5Mikge1xuICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTM5LCB0aGlzLnJlYWRXb3JkMSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5maW5pc2hPcCgyNywgMSk7XG4gICAgfVxuICB9XG4gIHJlYWRUb2tlbl9kb3QoKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpO1xuICAgIGlmIChuZXh0ID49IDQ4ICYmIG5leHQgPD0gNTcpIHtcbiAgICAgIHRoaXMucmVhZE51bWJlcih0cnVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5leHQgPT09IDQ2ICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDIpID09PSA0Nikge1xuICAgICAgdGhpcy5zdGF0ZS5wb3MgKz0gMztcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4oMjEpO1xuICAgIH0gZWxzZSB7XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigxNik7XG4gICAgfVxuICB9XG4gIHJlYWRUb2tlbl9zbGFzaCgpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IDYxKSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKDMxLCAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5maW5pc2hPcCg1NiwgMSk7XG4gICAgfVxuICB9XG4gIHJlYWRUb2tlbl9pbnRlcnByZXRlcigpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5wb3MgIT09IDAgfHwgdGhpcy5sZW5ndGggPCAyKSByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG4gICAgaWYgKGNoICE9PSAzMykgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgdGhpcy5zdGF0ZS5wb3MgKz0gMTtcbiAgICB3aGlsZSAoIWlzTmV3TGluZShjaCkgJiYgKyt0aGlzLnN0YXRlLnBvcyA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pbnB1dC5zbGljZShzdGFydCArIDIsIHRoaXMuc3RhdGUucG9zKTtcbiAgICB0aGlzLmZpbmlzaFRva2VuKDI4LCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmVhZFRva2VuX211bHRfbW9kdWxvKGNvZGUpIHtcbiAgICBsZXQgdHlwZSA9IGNvZGUgPT09IDQyID8gNTUgOiA1NDtcbiAgICBsZXQgd2lkdGggPSAxO1xuICAgIGxldCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG4gICAgaWYgKGNvZGUgPT09IDQyICYmIG5leHQgPT09IDQyKSB7XG4gICAgICB3aWR0aCsrO1xuICAgICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDIpO1xuICAgICAgdHlwZSA9IDU3O1xuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gNjEgJiYgIXRoaXMuc3RhdGUuaW5UeXBlKSB7XG4gICAgICB3aWR0aCsrO1xuICAgICAgdHlwZSA9IGNvZGUgPT09IDM3ID8gMzMgOiAzMDtcbiAgICB9XG4gICAgdGhpcy5maW5pc2hPcCh0eXBlLCB3aWR0aCk7XG4gIH1cbiAgcmVhZFRva2VuX3BpcGVfYW1wKGNvZGUpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IGNvZGUpIHtcbiAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAyKSA9PT0gNjEpIHtcbiAgICAgICAgdGhpcy5maW5pc2hPcCgzMCwgMyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDEyNCA/IDQxIDogNDIsIDIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY29kZSA9PT0gMTI0KSB7XG4gICAgICBpZiAobmV4dCA9PT0gNjIpIHtcbiAgICAgICAgdGhpcy5maW5pc2hPcCgzOSwgMik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmhhc1BsdWdpbihcInJlY29yZEFuZFR1cGxlXCIpICYmIG5leHQgPT09IDEyNSkge1xuICAgICAgICBpZiAodGhpcy5nZXRQbHVnaW5PcHRpb24oXCJyZWNvcmRBbmRUdXBsZVwiLCBcInN5bnRheFR5cGVcIikgIT09IFwiYmFyXCIpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5SZWNvcmRFeHByZXNzaW9uQmFySW5jb3JyZWN0RW5kU3ludGF4VHlwZSwgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlLnBvcyArPSAyO1xuICAgICAgICB0aGlzLmZpbmlzaFRva2VuKDkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJyZWNvcmRBbmRUdXBsZVwiKSAmJiBuZXh0ID09PSA5Mykge1xuICAgICAgICBpZiAodGhpcy5nZXRQbHVnaW5PcHRpb24oXCJyZWNvcmRBbmRUdXBsZVwiLCBcInN5bnRheFR5cGVcIikgIT09IFwiYmFyXCIpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5UdXBsZUV4cHJlc3Npb25CYXJJbmNvcnJlY3RFbmRTeW50YXhUeXBlLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUucG9zICs9IDI7XG4gICAgICAgIHRoaXMuZmluaXNoVG9rZW4oNCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5leHQgPT09IDYxKSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKDMwLCAyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5maW5pc2hPcChjb2RlID09PSAxMjQgPyA0MyA6IDQ1LCAxKTtcbiAgfVxuICByZWFkVG9rZW5fY2FyZXQoKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpO1xuICAgIGlmIChuZXh0ID09PSA2MSAmJiAhdGhpcy5zdGF0ZS5pblR5cGUpIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoMzIsIDIpO1xuICAgIH0gZWxzZSBpZiAobmV4dCA9PT0gOTQgJiYgdGhpcy5oYXNQbHVnaW4oW1wicGlwZWxpbmVPcGVyYXRvclwiLCB7XG4gICAgICBwcm9wb3NhbDogXCJoYWNrXCIsXG4gICAgICB0b3BpY1Rva2VuOiBcIl5eXCJcbiAgICB9XSkpIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoMzcsIDIpO1xuICAgICAgY29uc3QgbG9va2FoZWFkQ2ggPSB0aGlzLmlucHV0LmNvZGVQb2ludEF0KHRoaXMuc3RhdGUucG9zKTtcbiAgICAgIGlmIChsb29rYWhlYWRDaCA9PT0gOTQpIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoNDQsIDEpO1xuICAgIH1cbiAgfVxuICByZWFkVG9rZW5fYXRTaWduKCkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gNjQgJiYgdGhpcy5oYXNQbHVnaW4oW1wicGlwZWxpbmVPcGVyYXRvclwiLCB7XG4gICAgICBwcm9wb3NhbDogXCJoYWNrXCIsXG4gICAgICB0b3BpY1Rva2VuOiBcIkBAXCJcbiAgICB9XSkpIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoMzgsIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKDI2LCAxKTtcbiAgICB9XG4gIH1cbiAgcmVhZFRva2VuX3BsdXNfbWluKGNvZGUpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IGNvZGUpIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoMzQsIDIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gNjEpIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoMzAsIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKDUzLCAxKTtcbiAgICB9XG4gIH1cbiAgcmVhZFRva2VuX2x0KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBvc1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IDYwKSB7XG4gICAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHBvcyArIDIpID09PSA2MSkge1xuICAgICAgICB0aGlzLmZpbmlzaE9wKDMwLCAzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5maW5pc2hPcCg1MSwgMik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuZXh0ID09PSA2MSkge1xuICAgICAgdGhpcy5maW5pc2hPcCg0OSwgMik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZmluaXNoT3AoNDcsIDEpO1xuICB9XG4gIHJlYWRUb2tlbl9ndCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBwb3NcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHBvcyArIDEpO1xuICAgIGlmIChuZXh0ID09PSA2Mikge1xuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MgKyAyKSA9PT0gNjIgPyAzIDogMjtcbiAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zICsgc2l6ZSkgPT09IDYxKSB7XG4gICAgICAgIHRoaXMuZmluaXNoT3AoMzAsIHNpemUgKyAxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5maW5pc2hPcCg1Miwgc2l6ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuZXh0ID09PSA2MSkge1xuICAgICAgdGhpcy5maW5pc2hPcCg0OSwgMik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZmluaXNoT3AoNDgsIDEpO1xuICB9XG4gIHJlYWRUb2tlbl9lcV9leGNsKGNvZGUpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IDYxKSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKDQ2LCB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAyKSA9PT0gNjEgPyAzIDogMik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjb2RlID09PSA2MSAmJiBuZXh0ID09PSA2Mikge1xuICAgICAgdGhpcy5zdGF0ZS5wb3MgKz0gMjtcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDYxID8gMjkgOiAzNSwgMSk7XG4gIH1cbiAgcmVhZFRva2VuX3F1ZXN0aW9uKCkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICBjb25zdCBuZXh0MiA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDIpO1xuICAgIGlmIChuZXh0ID09PSA2Mykge1xuICAgICAgaWYgKG5leHQyID09PSA2MSkge1xuICAgICAgICB0aGlzLmZpbmlzaE9wKDMwLCAzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZmluaXNoT3AoNDAsIDIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dCA9PT0gNDYgJiYgIShuZXh0MiA+PSA0OCAmJiBuZXh0MiA8PSA1NykpIHtcbiAgICAgIHRoaXMuc3RhdGUucG9zICs9IDI7XG4gICAgICB0aGlzLmZpbmlzaFRva2VuKDE4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTcpO1xuICAgIH1cbiAgfVxuICBnZXRUb2tlbkZyb21Db2RlKGNvZGUpIHtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgIGNhc2UgNDY6XG4gICAgICAgIHRoaXMucmVhZFRva2VuX2RvdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDQwOlxuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICB0aGlzLmZpbmlzaFRva2VuKDEwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSA0MTpcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgdGhpcy5maW5pc2hUb2tlbigxMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgNTk6XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTMpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDQ0OlxuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICB0aGlzLmZpbmlzaFRva2VuKDEyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSA5MTpcbiAgICAgICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwicmVjb3JkQW5kVHVwbGVcIikgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSkgPT09IDEyNCkge1xuICAgICAgICAgIGlmICh0aGlzLmdldFBsdWdpbk9wdGlvbihcInJlY29yZEFuZFR1cGxlXCIsIFwic3ludGF4VHlwZVwiKSAhPT0gXCJiYXJcIikge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuVHVwbGVFeHByZXNzaW9uQmFySW5jb3JyZWN0U3RhcnRTeW50YXhUeXBlLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnN0YXRlLnBvcyArPSAyO1xuICAgICAgICAgIHRoaXMuZmluaXNoVG9rZW4oMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgICB0aGlzLmZpbmlzaFRva2VuKDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgOTM6XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgIHRoaXMuZmluaXNoVG9rZW4oMyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgMTIzOlxuICAgICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJyZWNvcmRBbmRUdXBsZVwiKSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKSA9PT0gMTI0KSB7XG4gICAgICAgICAgaWYgKHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwicmVjb3JkQW5kVHVwbGVcIiwgXCJzeW50YXhUeXBlXCIpICE9PSBcImJhclwiKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5SZWNvcmRFeHByZXNzaW9uQmFySW5jb3JyZWN0U3RhcnRTeW50YXhUeXBlLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnN0YXRlLnBvcyArPSAyO1xuICAgICAgICAgIHRoaXMuZmluaXNoVG9rZW4oNik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgICB0aGlzLmZpbmlzaFRva2VuKDUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgMTI1OlxuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICB0aGlzLmZpbmlzaFRva2VuKDgpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDU4OlxuICAgICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJmdW5jdGlvbkJpbmRcIikgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSkgPT09IDU4KSB7XG4gICAgICAgICAgdGhpcy5maW5pc2hPcCgxNSwgMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgICB0aGlzLmZpbmlzaFRva2VuKDE0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDYzOlxuICAgICAgICB0aGlzLnJlYWRUb2tlbl9xdWVzdGlvbigpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDk2OlxuICAgICAgICB0aGlzLnJlYWRUZW1wbGF0ZVRva2VuKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgNDg6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG4gICAgICAgICAgaWYgKG5leHQgPT09IDEyMCB8fCBuZXh0ID09PSA4OCkge1xuICAgICAgICAgICAgdGhpcy5yZWFkUmFkaXhOdW1iZXIoMTYpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmV4dCA9PT0gMTExIHx8IG5leHQgPT09IDc5KSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRSYWRpeE51bWJlcig4KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5leHQgPT09IDk4IHx8IG5leHQgPT09IDY2KSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRSYWRpeE51bWJlcigyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGNhc2UgNDk6XG4gICAgICBjYXNlIDUwOlxuICAgICAgY2FzZSA1MTpcbiAgICAgIGNhc2UgNTI6XG4gICAgICBjYXNlIDUzOlxuICAgICAgY2FzZSA1NDpcbiAgICAgIGNhc2UgNTU6XG4gICAgICBjYXNlIDU2OlxuICAgICAgY2FzZSA1NzpcbiAgICAgICAgdGhpcy5yZWFkTnVtYmVyKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSAzNDpcbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIHRoaXMucmVhZFN0cmluZyhjb2RlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSA0NzpcbiAgICAgICAgdGhpcy5yZWFkVG9rZW5fc2xhc2goKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSAzNzpcbiAgICAgIGNhc2UgNDI6XG4gICAgICAgIHRoaXMucmVhZFRva2VuX211bHRfbW9kdWxvKGNvZGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDEyNDpcbiAgICAgIGNhc2UgMzg6XG4gICAgICAgIHRoaXMucmVhZFRva2VuX3BpcGVfYW1wKGNvZGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDk0OlxuICAgICAgICB0aGlzLnJlYWRUb2tlbl9jYXJldCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDQzOlxuICAgICAgY2FzZSA0NTpcbiAgICAgICAgdGhpcy5yZWFkVG9rZW5fcGx1c19taW4oY29kZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgNjA6XG4gICAgICAgIHRoaXMucmVhZFRva2VuX2x0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgNjI6XG4gICAgICAgIHRoaXMucmVhZFRva2VuX2d0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgNjE6XG4gICAgICBjYXNlIDMzOlxuICAgICAgICB0aGlzLnJlYWRUb2tlbl9lcV9leGNsKGNvZGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDEyNjpcbiAgICAgICAgdGhpcy5maW5pc2hPcCgzNiwgMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgNjQ6XG4gICAgICAgIHRoaXMucmVhZFRva2VuX2F0U2lnbigpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDM1OlxuICAgICAgICB0aGlzLnJlYWRUb2tlbl9udW1iZXJTaWduKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgOTI6XG4gICAgICAgIHRoaXMucmVhZFdvcmQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGNvZGUpKSB7XG4gICAgICAgICAgdGhpcy5yZWFkV29yZChjb2RlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuSW52YWxpZE9yVW5leHBlY3RlZFRva2VuLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCksIHtcbiAgICAgIHVuZXhwZWN0ZWQ6IFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGUpXG4gICAgfSk7XG4gIH1cbiAgZmluaXNoT3AodHlwZSwgc2l6ZSkge1xuICAgIGNvbnN0IHN0ciA9IHRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGF0ZS5wb3MsIHRoaXMuc3RhdGUucG9zICsgc2l6ZSk7XG4gICAgdGhpcy5zdGF0ZS5wb3MgKz0gc2l6ZTtcbiAgICB0aGlzLmZpbmlzaFRva2VuKHR5cGUsIHN0cik7XG4gIH1cbiAgcmVhZFJlZ2V4cCgpIHtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLnN0YXRlLnN0YXJ0ICsgMTtcbiAgICBsZXQgZXNjYXBlZCwgaW5DbGFzcztcbiAgICBsZXQge1xuICAgICAgcG9zXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgZm9yICg7OyArK3Bvcykge1xuICAgICAgaWYgKHBvcyA+PSB0aGlzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5VbnRlcm1pbmF0ZWRSZWdFeHAsIGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldChzdGFydExvYywgMSkpO1xuICAgICAgfVxuICAgICAgY29uc3QgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIGlmIChpc05ld0xpbmUoY2gpKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVudGVybWluYXRlZFJlZ0V4cCwgY3JlYXRlUG9zaXRpb25XaXRoQ29sdW1uT2Zmc2V0KHN0YXJ0TG9jLCAxKSk7XG4gICAgICB9XG4gICAgICBpZiAoZXNjYXBlZCkge1xuICAgICAgICBlc2NhcGVkID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY2ggPT09IDkxKSB7XG4gICAgICAgICAgaW5DbGFzcyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDkzICYmIGluQ2xhc3MpIHtcbiAgICAgICAgICBpbkNsYXNzID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDQ3ICYmICFpbkNsYXNzKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZXNjYXBlZCA9IGNoID09PSA5MjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY29udGVudCA9IHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHBvcyk7XG4gICAgKytwb3M7XG4gICAgbGV0IG1vZHMgPSBcIlwiO1xuICAgIGNvbnN0IG5leHRQb3MgPSAoKSA9PiBjcmVhdGVQb3NpdGlvbldpdGhDb2x1bW5PZmZzZXQoc3RhcnRMb2MsIHBvcyArIDIgLSBzdGFydCk7XG4gICAgd2hpbGUgKHBvcyA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBjcCA9IHRoaXMuY29kZVBvaW50QXRQb3MocG9zKTtcbiAgICAgIGNvbnN0IGNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNwKTtcbiAgICAgIGlmIChWQUxJRF9SRUdFWF9GTEFHUy5oYXMoY3ApKSB7XG4gICAgICAgIGlmIChjcCA9PT0gMTE4KSB7XG4gICAgICAgICAgaWYgKG1vZHMuaW5jbHVkZXMoXCJ1XCIpKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbmNvbXBhdGlibGVSZWdFeHBVVkZsYWdzLCBuZXh0UG9zKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjcCA9PT0gMTE3KSB7XG4gICAgICAgICAgaWYgKG1vZHMuaW5jbHVkZXMoXCJ2XCIpKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbmNvbXBhdGlibGVSZWdFeHBVVkZsYWdzLCBuZXh0UG9zKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobW9kcy5pbmNsdWRlcyhjaGFyKSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkR1cGxpY2F0ZVJlZ0V4cEZsYWdzLCBuZXh0UG9zKCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzSWRlbnRpZmllckNoYXIoY3ApIHx8IGNwID09PSA5Mikge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5NYWxmb3JtZWRSZWdFeHBGbGFncywgbmV4dFBvcygpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgKytwb3M7XG4gICAgICBtb2RzICs9IGNoYXI7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUucG9zID0gcG9zO1xuICAgIHRoaXMuZmluaXNoVG9rZW4oMTM4LCB7XG4gICAgICBwYXR0ZXJuOiBjb250ZW50LFxuICAgICAgZmxhZ3M6IG1vZHNcbiAgICB9KTtcbiAgfVxuICByZWFkSW50KHJhZGl4LCBsZW4sIGZvcmNlTGVuID0gZmFsc2UsIGFsbG93TnVtU2VwYXJhdG9yID0gdHJ1ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG4sXG4gICAgICBwb3NcbiAgICB9ID0gcmVhZEludCh0aGlzLmlucHV0LCB0aGlzLnN0YXRlLnBvcywgdGhpcy5zdGF0ZS5saW5lU3RhcnQsIHRoaXMuc3RhdGUuY3VyTGluZSwgcmFkaXgsIGxlbiwgZm9yY2VMZW4sIGFsbG93TnVtU2VwYXJhdG9yLCB0aGlzLmVycm9ySGFuZGxlcnNfcmVhZEludCwgZmFsc2UpO1xuICAgIHRoaXMuc3RhdGUucG9zID0gcG9zO1xuICAgIHJldHVybiBuO1xuICB9XG4gIHJlYWRSYWRpeE51bWJlcihyYWRpeCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCk7XG4gICAgbGV0IGlzQmlnSW50ID0gZmFsc2U7XG4gICAgdGhpcy5zdGF0ZS5wb3MgKz0gMjtcbiAgICBjb25zdCB2YWwgPSB0aGlzLnJlYWRJbnQocmFkaXgpO1xuICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW52YWxpZERpZ2l0LCBjcmVhdGVQb3NpdGlvbldpdGhDb2x1bW5PZmZzZXQoc3RhcnRMb2MsIDIpLCB7XG4gICAgICAgIHJhZGl4XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgaWYgKG5leHQgPT09IDExMCkge1xuICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIGlzQmlnSW50ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKG5leHQgPT09IDEwOSkge1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuSW52YWxpZERlY2ltYWwsIHN0YXJ0TG9jKTtcbiAgICB9XG4gICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHRoaXMuY29kZVBvaW50QXRQb3ModGhpcy5zdGF0ZS5wb3MpKSkge1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuTnVtYmVySWRlbnRpZmllciwgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKTtcbiAgICB9XG4gICAgaWYgKGlzQmlnSW50KSB7XG4gICAgICBjb25zdCBzdHIgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnN0YXRlLnBvcykucmVwbGFjZSgvW19uXS9nLCBcIlwiKTtcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTM2LCBzdHIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmZpbmlzaFRva2VuKDEzNSwgdmFsKTtcbiAgfVxuICByZWFkTnVtYmVyKHN0YXJ0c1dpdGhEb3QpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpO1xuICAgIGxldCBpc0Zsb2F0ID0gZmFsc2U7XG4gICAgbGV0IGlzQmlnSW50ID0gZmFsc2U7XG4gICAgbGV0IGhhc0V4cG9uZW50ID0gZmFsc2U7XG4gICAgbGV0IGlzT2N0YWwgPSBmYWxzZTtcbiAgICBpZiAoIXN0YXJ0c1dpdGhEb3QgJiYgdGhpcy5yZWFkSW50KDEwKSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW52YWxpZE51bWJlciwgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKTtcbiAgICB9XG4gICAgY29uc3QgaGFzTGVhZGluZ1plcm8gPSB0aGlzLnN0YXRlLnBvcyAtIHN0YXJ0ID49IDIgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHN0YXJ0KSA9PT0gNDg7XG4gICAgaWYgKGhhc0xlYWRpbmdaZXJvKSB7XG4gICAgICBjb25zdCBpbnRlZ2VyID0gdGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgdGhpcy5yZWNvcmRTdHJpY3RNb2RlRXJyb3JzKEVycm9ycy5TdHJpY3RPY3RhbExpdGVyYWwsIHN0YXJ0TG9jKTtcbiAgICAgIGlmICghdGhpcy5zdGF0ZS5zdHJpY3QpIHtcbiAgICAgICAgY29uc3QgdW5kZXJzY29yZVBvcyA9IGludGVnZXIuaW5kZXhPZihcIl9cIik7XG4gICAgICAgIGlmICh1bmRlcnNjb3JlUG9zID4gMCkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlplcm9EaWdpdE51bWVyaWNTZXBhcmF0b3IsIGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldChzdGFydExvYywgdW5kZXJzY29yZVBvcykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpc09jdGFsID0gaGFzTGVhZGluZ1plcm8gJiYgIS9bODldLy50ZXN0KGludGVnZXIpO1xuICAgIH1cbiAgICBsZXQgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgaWYgKG5leHQgPT09IDQ2ICYmICFpc09jdGFsKSB7XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgdGhpcy5yZWFkSW50KDEwKTtcbiAgICAgIGlzRmxvYXQgPSB0cnVlO1xuICAgICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgfVxuICAgIGlmICgobmV4dCA9PT0gNjkgfHwgbmV4dCA9PT0gMTAxKSAmJiAhaXNPY3RhbCkge1xuICAgICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMuc3RhdGUucG9zKTtcbiAgICAgIGlmIChuZXh0ID09PSA0MyB8fCBuZXh0ID09PSA0NSkge1xuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucmVhZEludCgxMCkgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW52YWxpZE9yTWlzc2luZ0V4cG9uZW50LCBzdGFydExvYyk7XG4gICAgICB9XG4gICAgICBpc0Zsb2F0ID0gdHJ1ZTtcbiAgICAgIGhhc0V4cG9uZW50ID0gdHJ1ZTtcbiAgICAgIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MpO1xuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gMTEwKSB7XG4gICAgICBpZiAoaXNGbG9hdCB8fCBoYXNMZWFkaW5nWmVybykge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkQmlnSW50TGl0ZXJhbCwgc3RhcnRMb2MpO1xuICAgICAgfVxuICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIGlzQmlnSW50ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG5leHQgPT09IDEwOSkge1xuICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJkZWNpbWFsXCIsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgICBpZiAoaGFzRXhwb25lbnQgfHwgaGFzTGVhZGluZ1plcm8pIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW52YWxpZERlY2ltYWwsIHN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICB2YXIgaXNEZWNpbWFsID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHRoaXMuY29kZVBvaW50QXRQb3ModGhpcy5zdGF0ZS5wb3MpKSkge1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuTnVtYmVySWRlbnRpZmllciwgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKTtcbiAgICB9XG4gICAgY29uc3Qgc3RyID0gdGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5zdGF0ZS5wb3MpLnJlcGxhY2UoL1tfbW5dL2csIFwiXCIpO1xuICAgIGlmIChpc0JpZ0ludCkge1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigxMzYsIHN0cik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc0RlY2ltYWwpIHtcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTM3LCBzdHIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB2YWwgPSBpc09jdGFsID8gcGFyc2VJbnQoc3RyLCA4KSA6IHBhcnNlRmxvYXQoc3RyKTtcbiAgICB0aGlzLmZpbmlzaFRva2VuKDEzNSwgdmFsKTtcbiAgfVxuICByZWFkQ29kZVBvaW50KHRocm93T25JbnZhbGlkKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29kZSxcbiAgICAgIHBvc1xuICAgIH0gPSByZWFkQ29kZVBvaW50KHRoaXMuaW5wdXQsIHRoaXMuc3RhdGUucG9zLCB0aGlzLnN0YXRlLmxpbmVTdGFydCwgdGhpcy5zdGF0ZS5jdXJMaW5lLCB0aHJvd09uSW52YWxpZCwgdGhpcy5lcnJvckhhbmRsZXJzX3JlYWRDb2RlUG9pbnQpO1xuICAgIHRoaXMuc3RhdGUucG9zID0gcG9zO1xuICAgIHJldHVybiBjb2RlO1xuICB9XG4gIHJlYWRTdHJpbmcocXVvdGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdHIsXG4gICAgICBwb3MsXG4gICAgICBjdXJMaW5lLFxuICAgICAgbGluZVN0YXJ0XG4gICAgfSA9IHJlYWRTdHJpbmdDb250ZW50cyhxdW90ZSA9PT0gMzQgPyBcImRvdWJsZVwiIDogXCJzaW5nbGVcIiwgdGhpcy5pbnB1dCwgdGhpcy5zdGF0ZS5wb3MgKyAxLCB0aGlzLnN0YXRlLmxpbmVTdGFydCwgdGhpcy5zdGF0ZS5jdXJMaW5lLCB0aGlzLmVycm9ySGFuZGxlcnNfcmVhZFN0cmluZ0NvbnRlbnRzX3N0cmluZyk7XG4gICAgdGhpcy5zdGF0ZS5wb3MgPSBwb3MgKyAxO1xuICAgIHRoaXMuc3RhdGUubGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgIHRoaXMuc3RhdGUuY3VyTGluZSA9IGN1ckxpbmU7XG4gICAgdGhpcy5maW5pc2hUb2tlbigxMzQsIHN0cik7XG4gIH1cbiAgcmVhZFRlbXBsYXRlQ29udGludWF0aW9uKCkge1xuICAgIGlmICghdGhpcy5tYXRjaCg4KSkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKG51bGwsIDgpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLnBvcy0tO1xuICAgIHRoaXMucmVhZFRlbXBsYXRlVG9rZW4oKTtcbiAgfVxuICByZWFkVGVtcGxhdGVUb2tlbigpIHtcbiAgICBjb25zdCBvcGVuaW5nID0gdGhpcy5pbnB1dFt0aGlzLnN0YXRlLnBvc107XG4gICAgY29uc3Qge1xuICAgICAgc3RyLFxuICAgICAgZmlyc3RJbnZhbGlkTG9jLFxuICAgICAgcG9zLFxuICAgICAgY3VyTGluZSxcbiAgICAgIGxpbmVTdGFydFxuICAgIH0gPSByZWFkU3RyaW5nQ29udGVudHMoXCJ0ZW1wbGF0ZVwiLCB0aGlzLmlucHV0LCB0aGlzLnN0YXRlLnBvcyArIDEsIHRoaXMuc3RhdGUubGluZVN0YXJ0LCB0aGlzLnN0YXRlLmN1ckxpbmUsIHRoaXMuZXJyb3JIYW5kbGVyc19yZWFkU3RyaW5nQ29udGVudHNfdGVtcGxhdGUpO1xuICAgIHRoaXMuc3RhdGUucG9zID0gcG9zICsgMTtcbiAgICB0aGlzLnN0YXRlLmxpbmVTdGFydCA9IGxpbmVTdGFydDtcbiAgICB0aGlzLnN0YXRlLmN1ckxpbmUgPSBjdXJMaW5lO1xuICAgIGlmIChmaXJzdEludmFsaWRMb2MpIHtcbiAgICAgIHRoaXMuc3RhdGUuZmlyc3RJbnZhbGlkVGVtcGxhdGVFc2NhcGVQb3MgPSBuZXcgUG9zaXRpb24oZmlyc3RJbnZhbGlkTG9jLmN1ckxpbmUsIGZpcnN0SW52YWxpZExvYy5wb3MgLSBmaXJzdEludmFsaWRMb2MubGluZVN0YXJ0LCB0aGlzLnNvdXJjZVRvT2Zmc2V0UG9zKGZpcnN0SW52YWxpZExvYy5wb3MpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaW5wdXQuY29kZVBvaW50QXQocG9zKSA9PT0gOTYpIHtcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4oMjQsIGZpcnN0SW52YWxpZExvYyA/IG51bGwgOiBvcGVuaW5nICsgc3RyICsgXCJgXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlLnBvcysrO1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigyNSwgZmlyc3RJbnZhbGlkTG9jID8gbnVsbCA6IG9wZW5pbmcgKyBzdHIgKyBcIiR7XCIpO1xuICAgIH1cbiAgfVxuICByZWNvcmRTdHJpY3RNb2RlRXJyb3JzKHRvUGFyc2VFcnJvciwgYXQpIHtcbiAgICBjb25zdCBpbmRleCA9IGF0LmluZGV4O1xuICAgIGlmICh0aGlzLnN0YXRlLnN0cmljdCAmJiAhdGhpcy5zdGF0ZS5zdHJpY3RFcnJvcnMuaGFzKGluZGV4KSkge1xuICAgICAgdGhpcy5yYWlzZSh0b1BhcnNlRXJyb3IsIGF0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGF0ZS5zdHJpY3RFcnJvcnMuc2V0KGluZGV4LCBbdG9QYXJzZUVycm9yLCBhdF0pO1xuICAgIH1cbiAgfVxuICByZWFkV29yZDEoZmlyc3RDb2RlKSB7XG4gICAgdGhpcy5zdGF0ZS5jb250YWluc0VzYyA9IGZhbHNlO1xuICAgIGxldCB3b3JkID0gXCJcIjtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIGxldCBjaHVua1N0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgaWYgKGZpcnN0Q29kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnN0YXRlLnBvcyArPSBmaXJzdENvZGUgPD0gMHhmZmZmID8gMSA6IDI7XG4gICAgfVxuICAgIHdoaWxlICh0aGlzLnN0YXRlLnBvcyA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBjaCA9IHRoaXMuY29kZVBvaW50QXRQb3ModGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgaWYgKGlzSWRlbnRpZmllckNoYXIoY2gpKSB7XG4gICAgICAgIHRoaXMuc3RhdGUucG9zICs9IGNoIDw9IDB4ZmZmZiA/IDEgOiAyO1xuICAgICAgfSBlbHNlIGlmIChjaCA9PT0gOTIpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5jb250YWluc0VzYyA9IHRydWU7XG4gICAgICAgIHdvcmQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnN0YXRlLnBvcyk7XG4gICAgICAgIGNvbnN0IGVzY1N0YXJ0ID0gdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpO1xuICAgICAgICBjb25zdCBpZGVudGlmaWVyQ2hlY2sgPSB0aGlzLnN0YXRlLnBvcyA9PT0gc3RhcnQgPyBpc0lkZW50aWZpZXJTdGFydCA6IGlzSWRlbnRpZmllckNoYXI7XG4gICAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnN0YXRlLnBvcykgIT09IDExNykge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLk1pc3NpbmdVbmljb2RlRXNjYXBlLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnN0YXRlLnBvcyAtIDE7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgY29uc3QgZXNjID0gdGhpcy5yZWFkQ29kZVBvaW50KHRydWUpO1xuICAgICAgICBpZiAoZXNjICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKCFpZGVudGlmaWVyQ2hlY2soZXNjKSkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRXNjYXBlZENoYXJOb3RBbklkZW50aWZpZXIsIGVzY1N0YXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd29yZCArPSBTdHJpbmcuZnJvbUNvZGVQb2ludChlc2MpO1xuICAgICAgICB9XG4gICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gd29yZCArIHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5zdGF0ZS5wb3MpO1xuICB9XG4gIHJlYWRXb3JkKGZpcnN0Q29kZSkge1xuICAgIGNvbnN0IHdvcmQgPSB0aGlzLnJlYWRXb3JkMShmaXJzdENvZGUpO1xuICAgIGNvbnN0IHR5cGUgPSBrZXl3b3JkcyQxLmdldCh3b3JkKTtcbiAgICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmZpbmlzaFRva2VuKHR5cGUsIHRva2VuTGFiZWxOYW1lKHR5cGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigxMzIsIHdvcmQpO1xuICAgIH1cbiAgfVxuICBjaGVja0tleXdvcmRFc2NhcGVzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodG9rZW5Jc0tleXdvcmQodHlwZSkgJiYgdGhpcy5zdGF0ZS5jb250YWluc0VzYykge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW52YWxpZEVzY2FwZWRSZXNlcnZlZFdvcmQsIHRoaXMuc3RhdGUuc3RhcnRMb2MsIHtcbiAgICAgICAgcmVzZXJ2ZWRXb3JkOiB0b2tlbkxhYmVsTmFtZSh0eXBlKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJhaXNlKHRvUGFyc2VFcnJvciwgYXQsIGRldGFpbHMgPSB7fSkge1xuICAgIGNvbnN0IGxvYyA9IGF0IGluc3RhbmNlb2YgUG9zaXRpb24gPyBhdCA6IGF0LmxvYy5zdGFydDtcbiAgICBjb25zdCBlcnJvciA9IHRvUGFyc2VFcnJvcihsb2MsIGRldGFpbHMpO1xuICAgIGlmICghKHRoaXMub3B0aW9uRmxhZ3MgJiAyMDQ4KSkgdGhyb3cgZXJyb3I7XG4gICAgaWYgKCF0aGlzLmlzTG9va2FoZWFkKSB0aGlzLnN0YXRlLmVycm9ycy5wdXNoKGVycm9yKTtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbiAgcmFpc2VPdmVyd3JpdGUodG9QYXJzZUVycm9yLCBhdCwgZGV0YWlscyA9IHt9KSB7XG4gICAgY29uc3QgbG9jID0gYXQgaW5zdGFuY2VvZiBQb3NpdGlvbiA/IGF0IDogYXQubG9jLnN0YXJ0O1xuICAgIGNvbnN0IHBvcyA9IGxvYy5pbmRleDtcbiAgICBjb25zdCBlcnJvcnMgPSB0aGlzLnN0YXRlLmVycm9ycztcbiAgICBmb3IgKGxldCBpID0gZXJyb3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBlcnJvciA9IGVycm9yc1tpXTtcbiAgICAgIGlmIChlcnJvci5sb2MuaW5kZXggPT09IHBvcykge1xuICAgICAgICByZXR1cm4gZXJyb3JzW2ldID0gdG9QYXJzZUVycm9yKGxvYywgZGV0YWlscyk7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IubG9jLmluZGV4IDwgcG9zKSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmFpc2UodG9QYXJzZUVycm9yLCBhdCwgZGV0YWlscyk7XG4gIH1cbiAgdXBkYXRlQ29udGV4dChwcmV2VHlwZSkge31cbiAgdW5leHBlY3RlZChsb2MsIHR5cGUpIHtcbiAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkVG9rZW4sIGxvYyAhPSBudWxsID8gbG9jIDogdGhpcy5zdGF0ZS5zdGFydExvYywge1xuICAgICAgZXhwZWN0ZWQ6IHR5cGUgPyB0b2tlbkxhYmVsTmFtZSh0eXBlKSA6IG51bGxcbiAgICB9KTtcbiAgfVxuICBleHBlY3RQbHVnaW4ocGx1Z2luTmFtZSwgbG9jKSB7XG4gICAgaWYgKHRoaXMuaGFzUGx1Z2luKHBsdWdpbk5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuTWlzc2luZ1BsdWdpbiwgbG9jICE9IG51bGwgPyBsb2MgOiB0aGlzLnN0YXRlLnN0YXJ0TG9jLCB7XG4gICAgICBtaXNzaW5nUGx1Z2luOiBbcGx1Z2luTmFtZV1cbiAgICB9KTtcbiAgfVxuICBleHBlY3RPbmVQbHVnaW4ocGx1Z2luTmFtZXMpIHtcbiAgICBpZiAoIXBsdWdpbk5hbWVzLnNvbWUobmFtZSA9PiB0aGlzLmhhc1BsdWdpbihuYW1lKSkpIHtcbiAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLk1pc3NpbmdPbmVPZlBsdWdpbnMsIHRoaXMuc3RhdGUuc3RhcnRMb2MsIHtcbiAgICAgICAgbWlzc2luZ1BsdWdpbjogcGx1Z2luTmFtZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBlcnJvckJ1aWxkZXIoZXJyb3IpIHtcbiAgICByZXR1cm4gKHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lKSA9PiB7XG4gICAgICB0aGlzLnJhaXNlKGVycm9yLCBidWlsZFBvc2l0aW9uKHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lKSk7XG4gICAgfTtcbiAgfVxufVxuY2xhc3MgQ2xhc3NTY29wZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucHJpdmF0ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgIHRoaXMubG9uZUFjY2Vzc29ycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnVuZGVmaW5lZFByaXZhdGVOYW1lcyA9IG5ldyBNYXAoKTtcbiAgfVxufVxuY2xhc3MgQ2xhc3NTY29wZUhhbmRsZXIge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YWNrID0gW107XG4gICAgdGhpcy51bmRlZmluZWRQcml2YXRlTmFtZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gIH1cbiAgY3VycmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICB9XG4gIGVudGVyKCkge1xuICAgIHRoaXMuc3RhY2sucHVzaChuZXcgQ2xhc3NTY29wZSgpKTtcbiAgfVxuICBleGl0KCkge1xuICAgIGNvbnN0IG9sZENsYXNzU2NvcGUgPSB0aGlzLnN0YWNrLnBvcCgpO1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQoKTtcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBsb2NdIG9mIEFycmF5LmZyb20ob2xkQ2xhc3NTY29wZS51bmRlZmluZWRQcml2YXRlTmFtZXMpKSB7XG4gICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICBpZiAoIWN1cnJlbnQudW5kZWZpbmVkUHJpdmF0ZU5hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICAgIGN1cnJlbnQudW5kZWZpbmVkUHJpdmF0ZU5hbWVzLnNldChuYW1lLCBsb2MpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhcnNlci5yYWlzZShFcnJvcnMuSW52YWxpZFByaXZhdGVGaWVsZFJlc29sdXRpb24sIGxvYywge1xuICAgICAgICAgIGlkZW50aWZpZXJOYW1lOiBuYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkZWNsYXJlUHJpdmF0ZU5hbWUobmFtZSwgZWxlbWVudFR5cGUsIGxvYykge1xuICAgIGNvbnN0IHtcbiAgICAgIHByaXZhdGVOYW1lcyxcbiAgICAgIGxvbmVBY2Nlc3NvcnMsXG4gICAgICB1bmRlZmluZWRQcml2YXRlTmFtZXNcbiAgICB9ID0gdGhpcy5jdXJyZW50KCk7XG4gICAgbGV0IHJlZGVmaW5lZCA9IHByaXZhdGVOYW1lcy5oYXMobmFtZSk7XG4gICAgaWYgKGVsZW1lbnRUeXBlICYgMykge1xuICAgICAgY29uc3QgYWNjZXNzb3IgPSByZWRlZmluZWQgJiYgbG9uZUFjY2Vzc29ycy5nZXQobmFtZSk7XG4gICAgICBpZiAoYWNjZXNzb3IpIHtcbiAgICAgICAgY29uc3Qgb2xkU3RhdGljID0gYWNjZXNzb3IgJiA0O1xuICAgICAgICBjb25zdCBuZXdTdGF0aWMgPSBlbGVtZW50VHlwZSAmIDQ7XG4gICAgICAgIGNvbnN0IG9sZEtpbmQgPSBhY2Nlc3NvciAmIDM7XG4gICAgICAgIGNvbnN0IG5ld0tpbmQgPSBlbGVtZW50VHlwZSAmIDM7XG4gICAgICAgIHJlZGVmaW5lZCA9IG9sZEtpbmQgPT09IG5ld0tpbmQgfHwgb2xkU3RhdGljICE9PSBuZXdTdGF0aWM7XG4gICAgICAgIGlmICghcmVkZWZpbmVkKSBsb25lQWNjZXNzb3JzLmRlbGV0ZShuYW1lKTtcbiAgICAgIH0gZWxzZSBpZiAoIXJlZGVmaW5lZCkge1xuICAgICAgICBsb25lQWNjZXNzb3JzLnNldChuYW1lLCBlbGVtZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZWRlZmluZWQpIHtcbiAgICAgIHRoaXMucGFyc2VyLnJhaXNlKEVycm9ycy5Qcml2YXRlTmFtZVJlZGVjbGFyYXRpb24sIGxvYywge1xuICAgICAgICBpZGVudGlmaWVyTmFtZTogbmFtZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHByaXZhdGVOYW1lcy5hZGQobmFtZSk7XG4gICAgdW5kZWZpbmVkUHJpdmF0ZU5hbWVzLmRlbGV0ZShuYW1lKTtcbiAgfVxuICB1c2VQcml2YXRlTmFtZShuYW1lLCBsb2MpIHtcbiAgICBsZXQgY2xhc3NTY29wZTtcbiAgICBmb3IgKGNsYXNzU2NvcGUgb2YgdGhpcy5zdGFjaykge1xuICAgICAgaWYgKGNsYXNzU2NvcGUucHJpdmF0ZU5hbWVzLmhhcyhuYW1lKSkgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2xhc3NTY29wZSkge1xuICAgICAgY2xhc3NTY29wZS51bmRlZmluZWRQcml2YXRlTmFtZXMuc2V0KG5hbWUsIGxvYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFyc2VyLnJhaXNlKEVycm9ycy5JbnZhbGlkUHJpdmF0ZUZpZWxkUmVzb2x1dGlvbiwgbG9jLCB7XG4gICAgICAgIGlkZW50aWZpZXJOYW1lOiBuYW1lXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEV4cHJlc3Npb25TY29wZSB7XG4gIGNvbnN0cnVjdG9yKHR5cGUgPSAwKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgfVxuICBjYW5CZUFycm93UGFyYW1ldGVyRGVjbGFyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gMiB8fCB0aGlzLnR5cGUgPT09IDE7XG4gIH1cbiAgaXNDZXJ0YWlubHlQYXJhbWV0ZXJEZWNsYXJhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSAzO1xuICB9XG59XG5jbGFzcyBBcnJvd0hlYWRQYXJzaW5nU2NvcGUgZXh0ZW5kcyBFeHByZXNzaW9uU2NvcGUge1xuICBjb25zdHJ1Y3Rvcih0eXBlKSB7XG4gICAgc3VwZXIodHlwZSk7XG4gICAgdGhpcy5kZWNsYXJhdGlvbkVycm9ycyA9IG5ldyBNYXAoKTtcbiAgfVxuICByZWNvcmREZWNsYXJhdGlvbkVycm9yKFBhcnNpbmdFcnJvckNsYXNzLCBhdCkge1xuICAgIGNvbnN0IGluZGV4ID0gYXQuaW5kZXg7XG4gICAgdGhpcy5kZWNsYXJhdGlvbkVycm9ycy5zZXQoaW5kZXgsIFtQYXJzaW5nRXJyb3JDbGFzcywgYXRdKTtcbiAgfVxuICBjbGVhckRlY2xhcmF0aW9uRXJyb3IoaW5kZXgpIHtcbiAgICB0aGlzLmRlY2xhcmF0aW9uRXJyb3JzLmRlbGV0ZShpbmRleCk7XG4gIH1cbiAgaXRlcmF0ZUVycm9ycyhpdGVyYXRvcikge1xuICAgIHRoaXMuZGVjbGFyYXRpb25FcnJvcnMuZm9yRWFjaChpdGVyYXRvcik7XG4gIH1cbn1cbmNsYXNzIEV4cHJlc3Npb25TY29wZUhhbmRsZXIge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YWNrID0gW25ldyBFeHByZXNzaW9uU2NvcGUoKV07XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gIH1cbiAgZW50ZXIoc2NvcGUpIHtcbiAgICB0aGlzLnN0YWNrLnB1c2goc2NvcGUpO1xuICB9XG4gIGV4aXQoKSB7XG4gICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgfVxuICByZWNvcmRQYXJhbWV0ZXJJbml0aWFsaXplckVycm9yKHRvUGFyc2VFcnJvciwgbm9kZSkge1xuICAgIGNvbnN0IG9yaWdpbiA9IG5vZGUubG9jLnN0YXJ0O1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWNrXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IGkgPSBzdGFjay5sZW5ndGggLSAxO1xuICAgIGxldCBzY29wZSA9IHN0YWNrW2ldO1xuICAgIHdoaWxlICghc2NvcGUuaXNDZXJ0YWlubHlQYXJhbWV0ZXJEZWNsYXJhdGlvbigpKSB7XG4gICAgICBpZiAoc2NvcGUuY2FuQmVBcnJvd1BhcmFtZXRlckRlY2xhcmF0aW9uKCkpIHtcbiAgICAgICAgc2NvcGUucmVjb3JkRGVjbGFyYXRpb25FcnJvcih0b1BhcnNlRXJyb3IsIG9yaWdpbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzY29wZSA9IHN0YWNrWy0taV07XG4gICAgfVxuICAgIHRoaXMucGFyc2VyLnJhaXNlKHRvUGFyc2VFcnJvciwgb3JpZ2luKTtcbiAgfVxuICByZWNvcmRBcnJvd1BhcmFtZXRlckJpbmRpbmdFcnJvcihlcnJvciwgbm9kZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWNrXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc2NvcGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBvcmlnaW4gPSBub2RlLmxvYy5zdGFydDtcbiAgICBpZiAoc2NvcGUuaXNDZXJ0YWlubHlQYXJhbWV0ZXJEZWNsYXJhdGlvbigpKSB7XG4gICAgICB0aGlzLnBhcnNlci5yYWlzZShlcnJvciwgb3JpZ2luKTtcbiAgICB9IGVsc2UgaWYgKHNjb3BlLmNhbkJlQXJyb3dQYXJhbWV0ZXJEZWNsYXJhdGlvbigpKSB7XG4gICAgICBzY29wZS5yZWNvcmREZWNsYXJhdGlvbkVycm9yKGVycm9yLCBvcmlnaW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIHJlY29yZEFzeW5jQXJyb3dQYXJhbWV0ZXJzRXJyb3IoYXQpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFja1xuICAgIH0gPSB0aGlzO1xuICAgIGxldCBpID0gc3RhY2subGVuZ3RoIC0gMTtcbiAgICBsZXQgc2NvcGUgPSBzdGFja1tpXTtcbiAgICB3aGlsZSAoc2NvcGUuY2FuQmVBcnJvd1BhcmFtZXRlckRlY2xhcmF0aW9uKCkpIHtcbiAgICAgIGlmIChzY29wZS50eXBlID09PSAyKSB7XG4gICAgICAgIHNjb3BlLnJlY29yZERlY2xhcmF0aW9uRXJyb3IoRXJyb3JzLkF3YWl0QmluZGluZ0lkZW50aWZpZXIsIGF0KTtcbiAgICAgIH1cbiAgICAgIHNjb3BlID0gc3RhY2tbLS1pXTtcbiAgICB9XG4gIH1cbiAgdmFsaWRhdGVBc1BhdHRlcm4oKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3RhY2tcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBjdXJyZW50U2NvcGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICBpZiAoIWN1cnJlbnRTY29wZS5jYW5CZUFycm93UGFyYW1ldGVyRGVjbGFyYXRpb24oKSkgcmV0dXJuO1xuICAgIGN1cnJlbnRTY29wZS5pdGVyYXRlRXJyb3JzKChbdG9QYXJzZUVycm9yLCBsb2NdKSA9PiB7XG4gICAgICB0aGlzLnBhcnNlci5yYWlzZSh0b1BhcnNlRXJyb3IsIGxvYyk7XG4gICAgICBsZXQgaSA9IHN0YWNrLmxlbmd0aCAtIDI7XG4gICAgICBsZXQgc2NvcGUgPSBzdGFja1tpXTtcbiAgICAgIHdoaWxlIChzY29wZS5jYW5CZUFycm93UGFyYW1ldGVyRGVjbGFyYXRpb24oKSkge1xuICAgICAgICBzY29wZS5jbGVhckRlY2xhcmF0aW9uRXJyb3IobG9jLmluZGV4KTtcbiAgICAgICAgc2NvcGUgPSBzdGFja1stLWldO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBuZXdQYXJhbWV0ZXJEZWNsYXJhdGlvblNjb3BlKCkge1xuICByZXR1cm4gbmV3IEV4cHJlc3Npb25TY29wZSgzKTtcbn1cbmZ1bmN0aW9uIG5ld0Fycm93SGVhZFNjb3BlKCkge1xuICByZXR1cm4gbmV3IEFycm93SGVhZFBhcnNpbmdTY29wZSgxKTtcbn1cbmZ1bmN0aW9uIG5ld0FzeW5jQXJyb3dTY29wZSgpIHtcbiAgcmV0dXJuIG5ldyBBcnJvd0hlYWRQYXJzaW5nU2NvcGUoMik7XG59XG5mdW5jdGlvbiBuZXdFeHByZXNzaW9uU2NvcGUoKSB7XG4gIHJldHVybiBuZXcgRXhwcmVzc2lvblNjb3BlKCk7XG59XG5jbGFzcyBVdGlsUGFyc2VyIGV4dGVuZHMgVG9rZW5pemVyIHtcbiAgYWRkRXh0cmEobm9kZSwga2V5LCB2YWx1ZSwgZW51bWVyYWJsZSA9IHRydWUpIHtcbiAgICBpZiAoIW5vZGUpIHJldHVybjtcbiAgICBsZXQge1xuICAgICAgZXh0cmFcbiAgICB9ID0gbm9kZTtcbiAgICBpZiAoZXh0cmEgPT0gbnVsbCkge1xuICAgICAgZXh0cmEgPSB7fTtcbiAgICAgIG5vZGUuZXh0cmEgPSBleHRyYTtcbiAgICB9XG4gICAgaWYgKGVudW1lcmFibGUpIHtcbiAgICAgIGV4dHJhW2tleV0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4dHJhLCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZSxcbiAgICAgICAgdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpc0NvbnRleHR1YWwodG9rZW4pIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS50eXBlID09PSB0b2tlbiAmJiAhdGhpcy5zdGF0ZS5jb250YWluc0VzYztcbiAgfVxuICBpc1VucGFyc2VkQ29udGV4dHVhbChuYW1lU3RhcnQsIG5hbWUpIHtcbiAgICBpZiAodGhpcy5pbnB1dC5zdGFydHNXaXRoKG5hbWUsIG5hbWVTdGFydCkpIHtcbiAgICAgIGNvbnN0IG5leHRDaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChuYW1lU3RhcnQgKyBuYW1lLmxlbmd0aCk7XG4gICAgICByZXR1cm4gIShpc0lkZW50aWZpZXJDaGFyKG5leHRDaCkgfHwgKG5leHRDaCAmIDB4ZmMwMCkgPT09IDB4ZDgwMCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpc0xvb2thaGVhZENvbnRleHR1YWwobmFtZSkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLm5leHRUb2tlblN0YXJ0KCk7XG4gICAgcmV0dXJuIHRoaXMuaXNVbnBhcnNlZENvbnRleHR1YWwobmV4dCwgbmFtZSk7XG4gIH1cbiAgZWF0Q29udGV4dHVhbCh0b2tlbikge1xuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCh0b2tlbikpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBleHBlY3RDb250ZXh0dWFsKHRva2VuLCB0b1BhcnNlRXJyb3IpIHtcbiAgICBpZiAoIXRoaXMuZWF0Q29udGV4dHVhbCh0b2tlbikpIHtcbiAgICAgIGlmICh0b1BhcnNlRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKHRvUGFyc2VFcnJvciwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICB9XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQobnVsbCwgdG9rZW4pO1xuICAgIH1cbiAgfVxuICBjYW5JbnNlcnRTZW1pY29sb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goMTQwKSB8fCB0aGlzLm1hdGNoKDgpIHx8IHRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCk7XG4gIH1cbiAgaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkge1xuICAgIHJldHVybiBoYXNOZXdMaW5lKHRoaXMuaW5wdXQsIHRoaXMub2Zmc2V0VG9Tb3VyY2VQb3ModGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jLmluZGV4KSwgdGhpcy5zdGF0ZS5zdGFydCk7XG4gIH1cbiAgaGFzRm9sbG93aW5nTGluZUJyZWFrKCkge1xuICAgIHJldHVybiBoYXNOZXdMaW5lKHRoaXMuaW5wdXQsIHRoaXMuc3RhdGUuZW5kLCB0aGlzLm5leHRUb2tlblN0YXJ0KCkpO1xuICB9XG4gIGlzTGluZVRlcm1pbmF0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWF0KDEzKSB8fCB0aGlzLmNhbkluc2VydFNlbWljb2xvbigpO1xuICB9XG4gIHNlbWljb2xvbihhbGxvd0FzaSA9IHRydWUpIHtcbiAgICBpZiAoYWxsb3dBc2kgPyB0aGlzLmlzTGluZVRlcm1pbmF0b3IoKSA6IHRoaXMuZWF0KDEzKSkgcmV0dXJuO1xuICAgIHRoaXMucmFpc2UoRXJyb3JzLk1pc3NpbmdTZW1pY29sb24sIHRoaXMuc3RhdGUubGFzdFRva0VuZExvYyk7XG4gIH1cbiAgZXhwZWN0KHR5cGUsIGxvYykge1xuICAgIGlmICghdGhpcy5lYXQodHlwZSkpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZChsb2MsIHR5cGUpO1xuICAgIH1cbiAgfVxuICB0cnlQYXJzZShmbiwgb2xkU3RhdGUgPSB0aGlzLnN0YXRlLmNsb25lKCkpIHtcbiAgICBjb25zdCBhYm9ydFNpZ25hbCA9IHtcbiAgICAgIG5vZGU6IG51bGxcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBub2RlID0gZm4oKG5vZGUgPSBudWxsKSA9PiB7XG4gICAgICAgIGFib3J0U2lnbmFsLm5vZGUgPSBub2RlO1xuICAgICAgICB0aHJvdyBhYm9ydFNpZ25hbDtcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMuc3RhdGUuZXJyb3JzLmxlbmd0aCA+IG9sZFN0YXRlLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZmFpbFN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IG9sZFN0YXRlO1xuICAgICAgICB0aGlzLnN0YXRlLnRva2Vuc0xlbmd0aCA9IGZhaWxTdGF0ZS50b2tlbnNMZW5ndGg7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBlcnJvcjogZmFpbFN0YXRlLmVycm9yc1tvbGRTdGF0ZS5lcnJvcnMubGVuZ3RoXSxcbiAgICAgICAgICB0aHJvd246IGZhbHNlLFxuICAgICAgICAgIGFib3J0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGZhaWxTdGF0ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIHRocm93bjogZmFsc2UsXG4gICAgICAgIGFib3J0ZWQ6IGZhbHNlLFxuICAgICAgICBmYWlsU3RhdGU6IG51bGxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IGZhaWxTdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICB0aGlzLnN0YXRlID0gb2xkU3RhdGU7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBTeW50YXhFcnJvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5vZGU6IG51bGwsXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgdGhyb3duOiB0cnVlLFxuICAgICAgICAgIGFib3J0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGZhaWxTdGF0ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yID09PSBhYm9ydFNpZ25hbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5vZGU6IGFib3J0U2lnbmFsLm5vZGUsXG4gICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgdGhyb3duOiBmYWxzZSxcbiAgICAgICAgICBhYm9ydGVkOiB0cnVlLFxuICAgICAgICAgIGZhaWxTdGF0ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIGNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZFeHByZXNzaW9uRXJyb3JzLCBhbmRUaHJvdykge1xuICAgIGlmICghcmVmRXhwcmVzc2lvbkVycm9ycykgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHtcbiAgICAgIHNob3J0aGFuZEFzc2lnbkxvYyxcbiAgICAgIGRvdWJsZVByb3RvTG9jLFxuICAgICAgcHJpdmF0ZUtleUxvYyxcbiAgICAgIG9wdGlvbmFsUGFyYW1ldGVyc0xvYyxcbiAgICAgIHZvaWRQYXR0ZXJuTG9jXG4gICAgfSA9IHJlZkV4cHJlc3Npb25FcnJvcnM7XG4gICAgY29uc3QgaGFzRXJyb3JzID0gISFzaG9ydGhhbmRBc3NpZ25Mb2MgfHwgISFkb3VibGVQcm90b0xvYyB8fCAhIW9wdGlvbmFsUGFyYW1ldGVyc0xvYyB8fCAhIXByaXZhdGVLZXlMb2MgfHwgISF2b2lkUGF0dGVybkxvYztcbiAgICBpZiAoIWFuZFRocm93KSB7XG4gICAgICByZXR1cm4gaGFzRXJyb3JzO1xuICAgIH1cbiAgICBpZiAoc2hvcnRoYW5kQXNzaWduTG9jICE9IG51bGwpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWRDb3ZlckluaXRpYWxpemVkTmFtZSwgc2hvcnRoYW5kQXNzaWduTG9jKTtcbiAgICB9XG4gICAgaWYgKGRvdWJsZVByb3RvTG9jICE9IG51bGwpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkR1cGxpY2F0ZVByb3RvLCBkb3VibGVQcm90b0xvYyk7XG4gICAgfVxuICAgIGlmIChwcml2YXRlS2V5TG9jICE9IG51bGwpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWRQcml2YXRlRmllbGQsIHByaXZhdGVLZXlMb2MpO1xuICAgIH1cbiAgICBpZiAob3B0aW9uYWxQYXJhbWV0ZXJzTG9jICE9IG51bGwpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZChvcHRpb25hbFBhcmFtZXRlcnNMb2MpO1xuICAgIH1cbiAgICBpZiAodm9pZFBhdHRlcm5Mb2MgIT0gbnVsbCkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW52YWxpZENvdmVyRGlzY2FyZEVsZW1lbnQsIHZvaWRQYXR0ZXJuTG9jKTtcbiAgICB9XG4gIH1cbiAgaXNMaXRlcmFsUHJvcGVydHlOYW1lKCkge1xuICAgIHJldHVybiB0b2tlbklzTGl0ZXJhbFByb3BlcnR5TmFtZSh0aGlzLnN0YXRlLnR5cGUpO1xuICB9XG4gIGlzUHJpdmF0ZU5hbWUobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiUHJpdmF0ZU5hbWVcIjtcbiAgfVxuICBnZXRQcml2YXRlTmFtZVNWKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5pZC5uYW1lO1xuICB9XG4gIGhhc1Byb3BlcnR5QXNQcml2YXRlTmFtZShub2RlKSB7XG4gICAgcmV0dXJuIChub2RlLnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIikgJiYgdGhpcy5pc1ByaXZhdGVOYW1lKG5vZGUucHJvcGVydHkpO1xuICB9XG4gIGlzT2JqZWN0UHJvcGVydHkobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiT2JqZWN0UHJvcGVydHlcIjtcbiAgfVxuICBpc09iamVjdE1ldGhvZChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJPYmplY3RNZXRob2RcIjtcbiAgfVxuICBpbml0aWFsaXplU2NvcGVzKGluTW9kdWxlID0gdGhpcy5vcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCIpIHtcbiAgICBjb25zdCBvbGRMYWJlbHMgPSB0aGlzLnN0YXRlLmxhYmVscztcbiAgICB0aGlzLnN0YXRlLmxhYmVscyA9IFtdO1xuICAgIGNvbnN0IG9sZEV4cG9ydGVkSWRlbnRpZmllcnMgPSB0aGlzLmV4cG9ydGVkSWRlbnRpZmllcnM7XG4gICAgdGhpcy5leHBvcnRlZElkZW50aWZpZXJzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IG9sZEluTW9kdWxlID0gdGhpcy5pbk1vZHVsZTtcbiAgICB0aGlzLmluTW9kdWxlID0gaW5Nb2R1bGU7XG4gICAgY29uc3Qgb2xkU2NvcGUgPSB0aGlzLnNjb3BlO1xuICAgIGNvbnN0IFNjb3BlSGFuZGxlciA9IHRoaXMuZ2V0U2NvcGVIYW5kbGVyKCk7XG4gICAgdGhpcy5zY29wZSA9IG5ldyBTY29wZUhhbmRsZXIodGhpcywgaW5Nb2R1bGUpO1xuICAgIGNvbnN0IG9sZFByb2RQYXJhbSA9IHRoaXMucHJvZFBhcmFtO1xuICAgIHRoaXMucHJvZFBhcmFtID0gbmV3IFByb2R1Y3Rpb25QYXJhbWV0ZXJIYW5kbGVyKCk7XG4gICAgY29uc3Qgb2xkQ2xhc3NTY29wZSA9IHRoaXMuY2xhc3NTY29wZTtcbiAgICB0aGlzLmNsYXNzU2NvcGUgPSBuZXcgQ2xhc3NTY29wZUhhbmRsZXIodGhpcyk7XG4gICAgY29uc3Qgb2xkRXhwcmVzc2lvblNjb3BlID0gdGhpcy5leHByZXNzaW9uU2NvcGU7XG4gICAgdGhpcy5leHByZXNzaW9uU2NvcGUgPSBuZXcgRXhwcmVzc2lvblNjb3BlSGFuZGxlcih0aGlzKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdGhpcy5zdGF0ZS5sYWJlbHMgPSBvbGRMYWJlbHM7XG4gICAgICB0aGlzLmV4cG9ydGVkSWRlbnRpZmllcnMgPSBvbGRFeHBvcnRlZElkZW50aWZpZXJzO1xuICAgICAgdGhpcy5pbk1vZHVsZSA9IG9sZEluTW9kdWxlO1xuICAgICAgdGhpcy5zY29wZSA9IG9sZFNjb3BlO1xuICAgICAgdGhpcy5wcm9kUGFyYW0gPSBvbGRQcm9kUGFyYW07XG4gICAgICB0aGlzLmNsYXNzU2NvcGUgPSBvbGRDbGFzc1Njb3BlO1xuICAgICAgdGhpcy5leHByZXNzaW9uU2NvcGUgPSBvbGRFeHByZXNzaW9uU2NvcGU7XG4gICAgfTtcbiAgfVxuICBlbnRlckluaXRpYWxTY29wZXMoKSB7XG4gICAgbGV0IHBhcmFtRmxhZ3MgPSAwO1xuICAgIGlmICh0aGlzLmluTW9kdWxlIHx8IHRoaXMub3B0aW9uRmxhZ3MgJiAxKSB7XG4gICAgICBwYXJhbUZsYWdzIHw9IDI7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbkZsYWdzICYgMzIpIHtcbiAgICAgIHBhcmFtRmxhZ3MgfD0gMTtcbiAgICB9XG4gICAgY29uc3QgaXNDb21tb25KUyA9ICF0aGlzLmluTW9kdWxlICYmIHRoaXMub3B0aW9ucy5zb3VyY2VUeXBlID09PSBcImNvbW1vbmpzXCI7XG4gICAgaWYgKGlzQ29tbW9uSlMgfHwgdGhpcy5vcHRpb25GbGFncyAmIDIpIHtcbiAgICAgIHBhcmFtRmxhZ3MgfD0gNDtcbiAgICB9XG4gICAgdGhpcy5wcm9kUGFyYW0uZW50ZXIocGFyYW1GbGFncyk7XG4gICAgbGV0IHNjb3BlRmxhZ3MgPSBpc0NvbW1vbkpTID8gNTE0IDogMTtcbiAgICBpZiAodGhpcy5vcHRpb25GbGFncyAmIDQpIHtcbiAgICAgIHNjb3BlRmxhZ3MgfD0gNTEyO1xuICAgIH1cbiAgICB0aGlzLnNjb3BlLmVudGVyKHNjb3BlRmxhZ3MpO1xuICB9XG4gIGNoZWNrRGVzdHJ1Y3R1cmluZ1ByaXZhdGUocmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGNvbnN0IHtcbiAgICAgIHByaXZhdGVLZXlMb2NcbiAgICB9ID0gcmVmRXhwcmVzc2lvbkVycm9ycztcbiAgICBpZiAocHJpdmF0ZUtleUxvYyAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJkZXN0cnVjdHVyaW5nUHJpdmF0ZVwiLCBwcml2YXRlS2V5TG9jKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEV4cHJlc3Npb25FcnJvcnMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnNob3J0aGFuZEFzc2lnbkxvYyA9IG51bGw7XG4gICAgdGhpcy5kb3VibGVQcm90b0xvYyA9IG51bGw7XG4gICAgdGhpcy5wcml2YXRlS2V5TG9jID0gbnVsbDtcbiAgICB0aGlzLm9wdGlvbmFsUGFyYW1ldGVyc0xvYyA9IG51bGw7XG4gICAgdGhpcy52b2lkUGF0dGVybkxvYyA9IG51bGw7XG4gIH1cbn1cbmNsYXNzIE5vZGUge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIsIHBvcywgbG9jKSB7XG4gICAgdGhpcy50eXBlID0gXCJcIjtcbiAgICB0aGlzLnN0YXJ0ID0gcG9zO1xuICAgIHRoaXMuZW5kID0gMDtcbiAgICB0aGlzLmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbihsb2MpO1xuICAgIGlmICgocGFyc2VyID09IG51bGwgPyB2b2lkIDAgOiBwYXJzZXIub3B0aW9uRmxhZ3MpICYgMTI4KSB0aGlzLnJhbmdlID0gW3BvcywgMF07XG4gICAgaWYgKHBhcnNlciAhPSBudWxsICYmIHBhcnNlci5maWxlbmFtZSkgdGhpcy5sb2MuZmlsZW5hbWUgPSBwYXJzZXIuZmlsZW5hbWU7XG4gIH1cbn1cbmNvbnN0IE5vZGVQcm90b3R5cGUgPSBOb2RlLnByb3RvdHlwZTtcbntcbiAgTm9kZVByb3RvdHlwZS5fX2Nsb25lID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IG5ld05vZGUgPSBuZXcgTm9kZSh1bmRlZmluZWQsIHRoaXMuc3RhcnQsIHRoaXMubG9jLnN0YXJ0KTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoa2V5ICE9PSBcImxlYWRpbmdDb21tZW50c1wiICYmIGtleSAhPT0gXCJ0cmFpbGluZ0NvbW1lbnRzXCIgJiYga2V5ICE9PSBcImlubmVyQ29tbWVudHNcIikge1xuICAgICAgICBuZXdOb2RlW2tleV0gPSB0aGlzW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdOb2RlO1xuICB9O1xufVxuY2xhc3MgTm9kZVV0aWxzIGV4dGVuZHMgVXRpbFBhcnNlciB7XG4gIHN0YXJ0Tm9kZSgpIHtcbiAgICBjb25zdCBsb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLCBsb2MuaW5kZXgsIGxvYyk7XG4gIH1cbiAgc3RhcnROb2RlQXQobG9jKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIGxvYy5pbmRleCwgbG9jKTtcbiAgfVxuICBzdGFydE5vZGVBdE5vZGUodHlwZSkge1xuICAgIHJldHVybiB0aGlzLnN0YXJ0Tm9kZUF0KHR5cGUubG9jLnN0YXJ0KTtcbiAgfVxuICBmaW5pc2hOb2RlKG5vZGUsIHR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlQXQobm9kZSwgdHlwZSwgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jKTtcbiAgfVxuICBmaW5pc2hOb2RlQXQobm9kZSwgdHlwZSwgZW5kTG9jKSB7XG4gICAgbm9kZS50eXBlID0gdHlwZTtcbiAgICBub2RlLmVuZCA9IGVuZExvYy5pbmRleDtcbiAgICBub2RlLmxvYy5lbmQgPSBlbmRMb2M7XG4gICAgaWYgKHRoaXMub3B0aW9uRmxhZ3MgJiAxMjgpIG5vZGUucmFuZ2VbMV0gPSBlbmRMb2MuaW5kZXg7XG4gICAgaWYgKHRoaXMub3B0aW9uRmxhZ3MgJiA0MDk2KSB7XG4gICAgICB0aGlzLnByb2Nlc3NDb21tZW50KG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICByZXNldFN0YXJ0TG9jYXRpb24obm9kZSwgc3RhcnRMb2MpIHtcbiAgICBub2RlLnN0YXJ0ID0gc3RhcnRMb2MuaW5kZXg7XG4gICAgbm9kZS5sb2Muc3RhcnQgPSBzdGFydExvYztcbiAgICBpZiAodGhpcy5vcHRpb25GbGFncyAmIDEyOCkgbm9kZS5yYW5nZVswXSA9IHN0YXJ0TG9jLmluZGV4O1xuICB9XG4gIHJlc2V0RW5kTG9jYXRpb24obm9kZSwgZW5kTG9jID0gdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jKSB7XG4gICAgbm9kZS5lbmQgPSBlbmRMb2MuaW5kZXg7XG4gICAgbm9kZS5sb2MuZW5kID0gZW5kTG9jO1xuICAgIGlmICh0aGlzLm9wdGlvbkZsYWdzICYgMTI4KSBub2RlLnJhbmdlWzFdID0gZW5kTG9jLmluZGV4O1xuICB9XG4gIHJlc2V0U3RhcnRMb2NhdGlvbkZyb21Ob2RlKG5vZGUsIGxvY2F0aW9uTm9kZSkge1xuICAgIHRoaXMucmVzZXRTdGFydExvY2F0aW9uKG5vZGUsIGxvY2F0aW9uTm9kZS5sb2Muc3RhcnQpO1xuICB9XG4gIGNhc3ROb2RlVG8obm9kZSwgdHlwZSkge1xuICAgIG5vZGUudHlwZSA9IHR5cGU7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgY2xvbmVJZGVudGlmaWVyKG5vZGUpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlLFxuICAgICAgc3RhcnQsXG4gICAgICBlbmQsXG4gICAgICBsb2MsXG4gICAgICByYW5nZSxcbiAgICAgIG5hbWVcbiAgICB9ID0gbm9kZTtcbiAgICBjb25zdCBjbG9uZWQgPSBPYmplY3QuY3JlYXRlKE5vZGVQcm90b3R5cGUpO1xuICAgIGNsb25lZC50eXBlID0gdHlwZTtcbiAgICBjbG9uZWQuc3RhcnQgPSBzdGFydDtcbiAgICBjbG9uZWQuZW5kID0gZW5kO1xuICAgIGNsb25lZC5sb2MgPSBsb2M7XG4gICAgY2xvbmVkLnJhbmdlID0gcmFuZ2U7XG4gICAgY2xvbmVkLm5hbWUgPSBuYW1lO1xuICAgIGlmIChub2RlLmV4dHJhKSBjbG9uZWQuZXh0cmEgPSBub2RlLmV4dHJhO1xuICAgIHJldHVybiBjbG9uZWQ7XG4gIH1cbiAgY2xvbmVTdHJpbmdMaXRlcmFsKG5vZGUpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlLFxuICAgICAgc3RhcnQsXG4gICAgICBlbmQsXG4gICAgICBsb2MsXG4gICAgICByYW5nZSxcbiAgICAgIGV4dHJhXG4gICAgfSA9IG5vZGU7XG4gICAgY29uc3QgY2xvbmVkID0gT2JqZWN0LmNyZWF0ZShOb2RlUHJvdG90eXBlKTtcbiAgICBjbG9uZWQudHlwZSA9IHR5cGU7XG4gICAgY2xvbmVkLnN0YXJ0ID0gc3RhcnQ7XG4gICAgY2xvbmVkLmVuZCA9IGVuZDtcbiAgICBjbG9uZWQubG9jID0gbG9jO1xuICAgIGNsb25lZC5yYW5nZSA9IHJhbmdlO1xuICAgIGNsb25lZC5leHRyYSA9IGV4dHJhO1xuICAgIGNsb25lZC52YWx1ZSA9IG5vZGUudmFsdWU7XG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfVxufVxuY29uc3QgdW53cmFwUGFyZW50aGVzaXplZEV4cHJlc3Npb24gPSBub2RlID0+IHtcbiAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiID8gdW53cmFwUGFyZW50aGVzaXplZEV4cHJlc3Npb24obm9kZS5leHByZXNzaW9uKSA6IG5vZGU7XG59O1xuY2xhc3MgTFZhbFBhcnNlciBleHRlbmRzIE5vZGVVdGlscyB7XG4gIHRvQXNzaWduYWJsZShub2RlLCBpc0xIUyA9IGZhbHNlKSB7XG4gICAgdmFyIF9ub2RlJGV4dHJhLCBfbm9kZSRleHRyYTM7XG4gICAgbGV0IHBhcmVudGhlc2l6ZWQgPSB1bmRlZmluZWQ7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiIHx8IChfbm9kZSRleHRyYSA9IG5vZGUuZXh0cmEpICE9IG51bGwgJiYgX25vZGUkZXh0cmEucGFyZW50aGVzaXplZCkge1xuICAgICAgcGFyZW50aGVzaXplZCA9IHVud3JhcFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uKG5vZGUpO1xuICAgICAgaWYgKGlzTEhTKSB7XG4gICAgICAgIGlmIChwYXJlbnRoZXNpemVkLnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICAgICAgdGhpcy5leHByZXNzaW9uU2NvcGUucmVjb3JkQXJyb3dQYXJhbWV0ZXJCaW5kaW5nRXJyb3IoRXJyb3JzLkludmFsaWRQYXJlbnRoZXNpemVkQXNzaWdubWVudCwgbm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyZW50aGVzaXplZC50eXBlICE9PSBcIk1lbWJlckV4cHJlc3Npb25cIiAmJiAhdGhpcy5pc09wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbihwYXJlbnRoZXNpemVkKSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWRQYXJlbnRoZXNpemVkQXNzaWdubWVudCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWRQYXJlbnRoZXNpemVkQXNzaWdubWVudCwgbm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcbiAgICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgICAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgICBjYXNlIFwiVm9pZFBhdHRlcm5cIjpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiT2JqZWN0RXhwcmVzc2lvblwiOlxuICAgICAgICB0aGlzLmNhc3ROb2RlVG8obm9kZSwgXCJPYmplY3RQYXR0ZXJuXCIpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gbm9kZS5wcm9wZXJ0aWVzLmxlbmd0aCwgbGFzdCA9IGxlbmd0aCAtIDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBfbm9kZSRleHRyYTI7XG4gICAgICAgICAgY29uc3QgcHJvcCA9IG5vZGUucHJvcGVydGllc1tpXTtcbiAgICAgICAgICBjb25zdCBpc0xhc3QgPSBpID09PSBsYXN0O1xuICAgICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlT2JqZWN0RXhwcmVzc2lvblByb3AocHJvcCwgaXNMYXN0LCBpc0xIUyk7XG4gICAgICAgICAgaWYgKGlzTGFzdCAmJiBwcm9wLnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIiAmJiAoX25vZGUkZXh0cmEyID0gbm9kZS5leHRyYSkgIT0gbnVsbCAmJiBfbm9kZSRleHRyYTIudHJhaWxpbmdDb21tYUxvYykge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuUmVzdFRyYWlsaW5nQ29tbWEsIG5vZGUuZXh0cmEudHJhaWxpbmdDb21tYUxvYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIk9iamVjdFByb3BlcnR5XCI6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0gPSBub2RlO1xuICAgICAgICAgIGlmICh0aGlzLmlzUHJpdmF0ZU5hbWUoa2V5KSkge1xuICAgICAgICAgICAgdGhpcy5jbGFzc1Njb3BlLnVzZVByaXZhdGVOYW1lKHRoaXMuZ2V0UHJpdmF0ZU5hbWVTVihrZXkpLCBrZXkubG9jLnN0YXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy50b0Fzc2lnbmFibGUodmFsdWUsIGlzTEhTKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBcIlNwcmVhZEVsZW1lbnRcIjpcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludGVybmFsIEBiYWJlbC9wYXJzZXIgZXJyb3IgKHRoaXMgaXMgYSBidWcsIHBsZWFzZSByZXBvcnQgaXQpLlwiICsgXCIgU3ByZWFkRWxlbWVudCBzaG91bGQgYmUgY29udmVydGVkIGJ5IC50b0Fzc2lnbmFibGUncyBjYWxsZXIuXCIpO1xuICAgICAgICB9XG4gICAgICBjYXNlIFwiQXJyYXlFeHByZXNzaW9uXCI6XG4gICAgICAgIHRoaXMuY2FzdE5vZGVUbyhub2RlLCBcIkFycmF5UGF0dGVyblwiKTtcbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGVMaXN0KG5vZGUuZWxlbWVudHMsIChfbm9kZSRleHRyYTMgPSBub2RlLmV4dHJhKSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkZXh0cmEzLnRyYWlsaW5nQ29tbWFMb2MsIGlzTEhTKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKG5vZGUub3BlcmF0b3IgIT09IFwiPVwiKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuTWlzc2luZ0VxSW5Bc3NpZ25tZW50LCBub2RlLmxlZnQubG9jLmVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYXN0Tm9kZVRvKG5vZGUsIFwiQXNzaWdubWVudFBhdHRlcm5cIik7XG4gICAgICAgIGRlbGV0ZSBub2RlLm9wZXJhdG9yO1xuICAgICAgICBpZiAobm9kZS5sZWZ0LnR5cGUgPT09IFwiVm9pZFBhdHRlcm5cIikge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlZvaWRQYXR0ZXJuSW5pdGlhbGl6ZXIsIG5vZGUubGVmdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS5sZWZ0LCBpc0xIUyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI6XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKHBhcmVudGhlc2l6ZWQsIGlzTEhTKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRvQXNzaWduYWJsZU9iamVjdEV4cHJlc3Npb25Qcm9wKHByb3AsIGlzTGFzdCwgaXNMSFMpIHtcbiAgICBpZiAocHJvcC50eXBlID09PSBcIk9iamVjdE1ldGhvZFwiKSB7XG4gICAgICB0aGlzLnJhaXNlKHByb3Aua2luZCA9PT0gXCJnZXRcIiB8fCBwcm9wLmtpbmQgPT09IFwic2V0XCIgPyBFcnJvcnMuUGF0dGVybkhhc0FjY2Vzc29yIDogRXJyb3JzLlBhdHRlcm5IYXNNZXRob2QsIHByb3Aua2V5KTtcbiAgICB9IGVsc2UgaWYgKHByb3AudHlwZSA9PT0gXCJTcHJlYWRFbGVtZW50XCIpIHtcbiAgICAgIHRoaXMuY2FzdE5vZGVUbyhwcm9wLCBcIlJlc3RFbGVtZW50XCIpO1xuICAgICAgY29uc3QgYXJnID0gcHJvcC5hcmd1bWVudDtcbiAgICAgIHRoaXMuY2hlY2tUb1Jlc3RDb252ZXJzaW9uKGFyZywgZmFsc2UpO1xuICAgICAgdGhpcy50b0Fzc2lnbmFibGUoYXJnLCBpc0xIUyk7XG4gICAgICBpZiAoIWlzTGFzdCkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5SZXN0VHJhaWxpbmdDb21tYSwgcHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKHByb3AsIGlzTEhTKTtcbiAgICB9XG4gIH1cbiAgdG9Bc3NpZ25hYmxlTGlzdChleHByTGlzdCwgdHJhaWxpbmdDb21tYUxvYywgaXNMSFMpIHtcbiAgICBjb25zdCBlbmQgPSBleHByTGlzdC5sZW5ndGggLSAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICBjb25zdCBlbHQgPSBleHByTGlzdFtpXTtcbiAgICAgIGlmICghZWx0KSBjb250aW51ZTtcbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlTGlzdEl0ZW0oZXhwckxpc3QsIGksIGlzTEhTKTtcbiAgICAgIGlmIChlbHQudHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiKSB7XG4gICAgICAgIGlmIChpIDwgZW5kKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuUmVzdFRyYWlsaW5nQ29tbWEsIGVsdCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHJhaWxpbmdDb21tYUxvYykge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlJlc3RUcmFpbGluZ0NvbW1hLCB0cmFpbGluZ0NvbW1hTG9jKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB0b0Fzc2lnbmFibGVMaXN0SXRlbShleHByTGlzdCwgaW5kZXgsIGlzTEhTKSB7XG4gICAgY29uc3Qgbm9kZSA9IGV4cHJMaXN0W2luZGV4XTtcbiAgICBpZiAobm9kZS50eXBlID09PSBcIlNwcmVhZEVsZW1lbnRcIikge1xuICAgICAgdGhpcy5jYXN0Tm9kZVRvKG5vZGUsIFwiUmVzdEVsZW1lbnRcIik7XG4gICAgICBjb25zdCBhcmcgPSBub2RlLmFyZ3VtZW50O1xuICAgICAgdGhpcy5jaGVja1RvUmVzdENvbnZlcnNpb24oYXJnLCB0cnVlKTtcbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKGFyZywgaXNMSFMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLCBpc0xIUyk7XG4gICAgfVxuICB9XG4gIGlzQXNzaWduYWJsZShub2RlLCBpc0JpbmRpbmcpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICAgIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgICBjYXNlIFwiQXNzaWdubWVudFBhdHRlcm5cIjpcbiAgICAgIGNhc2UgXCJSZXN0RWxlbWVudFwiOlxuICAgICAgY2FzZSBcIlZvaWRQYXR0ZXJuXCI6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSBcIk9iamVjdEV4cHJlc3Npb25cIjpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGxhc3QgPSBub2RlLnByb3BlcnRpZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICByZXR1cm4gbm9kZS5wcm9wZXJ0aWVzLmV2ZXJ5KChwcm9wLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcC50eXBlICE9PSBcIk9iamVjdE1ldGhvZFwiICYmIChpID09PSBsYXN0IHx8IHByb3AudHlwZSAhPT0gXCJTcHJlYWRFbGVtZW50XCIpICYmIHRoaXMuaXNBc3NpZ25hYmxlKHByb3ApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICBjYXNlIFwiT2JqZWN0UHJvcGVydHlcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNBc3NpZ25hYmxlKG5vZGUudmFsdWUpO1xuICAgICAgY2FzZSBcIlNwcmVhZEVsZW1lbnRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNBc3NpZ25hYmxlKG5vZGUuYXJndW1lbnQpO1xuICAgICAgY2FzZSBcIkFycmF5RXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gbm9kZS5lbGVtZW50cy5ldmVyeShlbGVtZW50ID0+IGVsZW1lbnQgPT09IG51bGwgfHwgdGhpcy5pc0Fzc2lnbmFibGUoZWxlbWVudCkpO1xuICAgICAgY2FzZSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiBub2RlLm9wZXJhdG9yID09PSBcIj1cIjtcbiAgICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gdGhpcy5pc0Fzc2lnbmFibGUobm9kZS5leHByZXNzaW9uKTtcbiAgICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiAhaXNCaW5kaW5nO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB0b1JlZmVyZW5jZWRMaXN0KGV4cHJMaXN0LCBpc1BhcmVudGhlc2l6ZWRFeHByKSB7XG4gICAgcmV0dXJuIGV4cHJMaXN0O1xuICB9XG4gIHRvUmVmZXJlbmNlZExpc3REZWVwKGV4cHJMaXN0LCBpc1BhcmVudGhlc2l6ZWRFeHByKSB7XG4gICAgdGhpcy50b1JlZmVyZW5jZWRMaXN0KGV4cHJMaXN0LCBpc1BhcmVudGhlc2l6ZWRFeHByKTtcbiAgICBmb3IgKGNvbnN0IGV4cHIgb2YgZXhwckxpc3QpIHtcbiAgICAgIGlmICgoZXhwciA9PSBudWxsID8gdm9pZCAwIDogZXhwci50eXBlKSA9PT0gXCJBcnJheUV4cHJlc3Npb25cIikge1xuICAgICAgICB0aGlzLnRvUmVmZXJlbmNlZExpc3REZWVwKGV4cHIuZWxlbWVudHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwYXJzZVNwcmVhZChyZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbkFsbG93SW4ocmVmRXhwcmVzc2lvbkVycm9ycywgdW5kZWZpbmVkKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3ByZWFkRWxlbWVudFwiKTtcbiAgfVxuICBwYXJzZVJlc3RCaW5kaW5nKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGNvbnN0IGFyZ3VtZW50ID0gdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gICAgaWYgKGFyZ3VtZW50LnR5cGUgPT09IFwiVm9pZFBhdHRlcm5cIikge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZFZvaWRQYXR0ZXJuLCBhcmd1bWVudCk7XG4gICAgfVxuICAgIG5vZGUuYXJndW1lbnQgPSBhcmd1bWVudDtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUmVzdEVsZW1lbnRcIik7XG4gIH1cbiAgcGFyc2VCaW5kaW5nQXRvbSgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUudHlwZSkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgbm9kZS5lbGVtZW50cyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdCgzLCA5MywgMSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycmF5UGF0dGVyblwiKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSA1OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9iamVjdExpa2UoOCwgdHJ1ZSk7XG4gICAgICBjYXNlIDg4OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVZvaWRQYXR0ZXJuKG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgfVxuICBwYXJzZUJpbmRpbmdMaXN0KGNsb3NlLCBjbG9zZUNoYXJDb2RlLCBmbGFncykge1xuICAgIGNvbnN0IGFsbG93RW1wdHkgPSBmbGFncyAmIDE7XG4gICAgY29uc3QgZWx0cyA9IFtdO1xuICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgd2hpbGUgKCF0aGlzLmVhdChjbG9zZSkpIHtcbiAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leHBlY3QoMTIpO1xuICAgICAgfVxuICAgICAgaWYgKGFsbG93RW1wdHkgJiYgdGhpcy5tYXRjaCgxMikpIHtcbiAgICAgICAgZWx0cy5wdXNoKG51bGwpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmVhdChjbG9zZSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2goMjEpKSB7XG4gICAgICAgIGxldCByZXN0ID0gdGhpcy5wYXJzZVJlc3RCaW5kaW5nKCk7XG4gICAgICAgIGlmICh0aGlzLmhhc1BsdWdpbihcImZsb3dcIikgfHwgZmxhZ3MgJiAyKSB7XG4gICAgICAgICAgcmVzdCA9IHRoaXMucGFyc2VGdW5jdGlvblBhcmFtVHlwZShyZXN0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHRzLnB1c2gocmVzdCk7XG4gICAgICAgIGlmICghdGhpcy5jaGVja0NvbW1hQWZ0ZXJSZXN0KGNsb3NlQ2hhckNvZGUpKSB7XG4gICAgICAgICAgdGhpcy5leHBlY3QoY2xvc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBkZWNvcmF0b3JzID0gW107XG4gICAgICAgIGlmIChmbGFncyAmIDIpIHtcbiAgICAgICAgICBpZiAodGhpcy5tYXRjaCgyNikgJiYgdGhpcy5oYXNQbHVnaW4oXCJkZWNvcmF0b3JzXCIpKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbnN1cHBvcnRlZFBhcmFtZXRlckRlY29yYXRvciwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlICh0aGlzLm1hdGNoKDI2KSkge1xuICAgICAgICAgICAgZGVjb3JhdG9ycy5wdXNoKHRoaXMucGFyc2VEZWNvcmF0b3IoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsdHMucHVzaCh0aGlzLnBhcnNlQmluZGluZ0VsZW1lbnQoZmxhZ3MsIGRlY29yYXRvcnMpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsdHM7XG4gIH1cbiAgcGFyc2VCaW5kaW5nUmVzdFByb3BlcnR5KHByb3ApIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJkaXNjYXJkQmluZGluZ1wiKSAmJiB0aGlzLm1hdGNoKDg4KSkge1xuICAgICAgcHJvcC5hcmd1bWVudCA9IHRoaXMucGFyc2VWb2lkUGF0dGVybihudWxsKTtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWRWb2lkUGF0dGVybiwgcHJvcC5hcmd1bWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3AuYXJndW1lbnQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgIH1cbiAgICB0aGlzLmNoZWNrQ29tbWFBZnRlclJlc3QoMTI1KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHByb3AsIFwiUmVzdEVsZW1lbnRcIik7XG4gIH1cbiAgcGFyc2VCaW5kaW5nUHJvcGVydHkoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZSxcbiAgICAgIHN0YXJ0TG9jXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHR5cGUgPT09IDIxKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUJpbmRpbmdSZXN0UHJvcGVydHkodGhpcy5zdGFydE5vZGUoKSk7XG4gICAgfVxuICAgIGNvbnN0IHByb3AgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGlmICh0eXBlID09PSAxMzkpIHtcbiAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwiZGVzdHJ1Y3R1cmluZ1ByaXZhdGVcIiwgc3RhcnRMb2MpO1xuICAgICAgdGhpcy5jbGFzc1Njb3BlLnVzZVByaXZhdGVOYW1lKHRoaXMuc3RhdGUudmFsdWUsIHN0YXJ0TG9jKTtcbiAgICAgIHByb3Aua2V5ID0gdGhpcy5wYXJzZVByaXZhdGVOYW1lKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCk7XG4gICAgfVxuICAgIHByb3AubWV0aG9kID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VPYmpQcm9wVmFsdWUocHJvcCwgc3RhcnRMb2MsIGZhbHNlLCBmYWxzZSwgdHJ1ZSwgZmFsc2UpO1xuICB9XG4gIHBhcnNlQmluZGluZ0VsZW1lbnQoZmxhZ3MsIGRlY29yYXRvcnMpIHtcbiAgICBjb25zdCBsZWZ0ID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdCgpO1xuICAgIGlmICh0aGlzLmhhc1BsdWdpbihcImZsb3dcIikgfHwgZmxhZ3MgJiAyKSB7XG4gICAgICB0aGlzLnBhcnNlRnVuY3Rpb25QYXJhbVR5cGUobGVmdCk7XG4gICAgfVxuICAgIGlmIChkZWNvcmF0b3JzLmxlbmd0aCkge1xuICAgICAgbGVmdC5kZWNvcmF0b3JzID0gZGVjb3JhdG9ycztcbiAgICAgIHRoaXMucmVzZXRTdGFydExvY2F0aW9uRnJvbU5vZGUobGVmdCwgZGVjb3JhdG9yc1swXSk7XG4gICAgfVxuICAgIGNvbnN0IGVsdCA9IHRoaXMucGFyc2VNYXliZURlZmF1bHQobGVmdC5sb2Muc3RhcnQsIGxlZnQpO1xuICAgIHJldHVybiBlbHQ7XG4gIH1cbiAgcGFyc2VGdW5jdGlvblBhcmFtVHlwZShwYXJhbSkge1xuICAgIHJldHVybiBwYXJhbTtcbiAgfVxuICBwYXJzZU1heWJlRGVmYXVsdChzdGFydExvYywgbGVmdCkge1xuICAgIHN0YXJ0TG9jICE9IG51bGwgPyBzdGFydExvYyA6IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBsZWZ0ID0gbGVmdCAhPSBudWxsID8gbGVmdCA6IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICAgIGlmICghdGhpcy5lYXQoMjkpKSByZXR1cm4gbGVmdDtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJWb2lkUGF0dGVyblwiKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5Wb2lkUGF0dGVybkluaXRpYWxpemVyLCBsZWZ0KTtcbiAgICB9XG4gICAgbm9kZS5sZWZ0ID0gbGVmdDtcbiAgICBub2RlLnJpZ2h0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduQWxsb3dJbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50UGF0dGVyblwiKTtcbiAgfVxuICBpc1ZhbGlkTFZhbCh0eXBlLCBpc1VucGFyZW50aGVzaXplZEluQXNzaWduLCBiaW5kaW5nKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiQXNzaWdubWVudFBhdHRlcm5cIjpcbiAgICAgICAgcmV0dXJuIFwibGVmdFwiO1xuICAgICAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgICAgIHJldHVybiBcImFyZ3VtZW50XCI7XG4gICAgICBjYXNlIFwiT2JqZWN0UHJvcGVydHlcIjpcbiAgICAgICAgcmV0dXJuIFwidmFsdWVcIjtcbiAgICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gXCJleHByZXNzaW9uXCI7XG4gICAgICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgICAgIHJldHVybiBcImVsZW1lbnRzXCI7XG4gICAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgICAgICByZXR1cm4gXCJwcm9wZXJ0aWVzXCI7XG4gICAgICBjYXNlIFwiVm9pZFBhdHRlcm5cIjpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpc09wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbihleHByZXNzaW9uKSB7XG4gICAgcmV0dXJuIGV4cHJlc3Npb24udHlwZSA9PT0gXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIjtcbiAgfVxuICBjaGVja0xWYWwoZXhwcmVzc2lvbiwgYW5jZXN0b3IsIGJpbmRpbmcgPSA2NCwgY2hlY2tDbGFzaGVzID0gZmFsc2UsIHN0cmljdE1vZGVDaGFuZ2VkID0gZmFsc2UsIGhhc1BhcmVudGhlc2l6ZWRBbmNlc3RvciA9IGZhbHNlKSB7XG4gICAgdmFyIF9leHByZXNzaW9uJGV4dHJhO1xuICAgIGNvbnN0IHR5cGUgPSBleHByZXNzaW9uLnR5cGU7XG4gICAgaWYgKHRoaXMuaXNPYmplY3RNZXRob2QoZXhwcmVzc2lvbikpIHJldHVybjtcbiAgICBjb25zdCBpc09wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbiA9IHRoaXMuaXNPcHRpb25hbE1lbWJlckV4cHJlc3Npb24oZXhwcmVzc2lvbik7XG4gICAgaWYgKGlzT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uIHx8IHR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgICBpZiAoaXNPcHRpb25hbE1lbWJlckV4cHJlc3Npb24pIHtcbiAgICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJvcHRpb25hbENoYWluaW5nQXNzaWduXCIsIGV4cHJlc3Npb24ubG9jLnN0YXJ0KTtcbiAgICAgICAgaWYgKGFuY2VzdG9yLnR5cGUgIT09IFwiQXNzaWdubWVudEV4cHJlc3Npb25cIikge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWRMaHNPcHRpb25hbENoYWluaW5nLCBleHByZXNzaW9uLCB7XG4gICAgICAgICAgICBhbmNlc3RvclxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYmluZGluZyAhPT0gNjQpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW52YWxpZFByb3BlcnR5QmluZGluZ1BhdHRlcm4sIGV4cHJlc3Npb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICAgIHRoaXMuY2hlY2tJZGVudGlmaWVyKGV4cHJlc3Npb24sIGJpbmRpbmcsIHN0cmljdE1vZGVDaGFuZ2VkKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmFtZVxuICAgICAgfSA9IGV4cHJlc3Npb247XG4gICAgICBpZiAoY2hlY2tDbGFzaGVzKSB7XG4gICAgICAgIGlmIChjaGVja0NsYXNoZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuUGFyYW1EdXBlLCBleHByZXNzaW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGVja0NsYXNoZXMuYWRkKG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcIlZvaWRQYXR0ZXJuXCIgJiYgYW5jZXN0b3IudHlwZSA9PT0gXCJDYXRjaENsYXVzZVwiKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5Wb2lkUGF0dGVybkNhdGNoQ2xhdXNlUGFyYW0sIGV4cHJlc3Npb24pO1xuICAgIH1cbiAgICBjb25zdCB2YWxpZGl0eSA9IHRoaXMuaXNWYWxpZExWYWwodHlwZSwgIShoYXNQYXJlbnRoZXNpemVkQW5jZXN0b3IgfHwgKF9leHByZXNzaW9uJGV4dHJhID0gZXhwcmVzc2lvbi5leHRyYSkgIT0gbnVsbCAmJiBfZXhwcmVzc2lvbiRleHRyYS5wYXJlbnRoZXNpemVkKSAmJiBhbmNlc3Rvci50eXBlID09PSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIsIGJpbmRpbmcpO1xuICAgIGlmICh2YWxpZGl0eSA9PT0gdHJ1ZSkgcmV0dXJuO1xuICAgIGlmICh2YWxpZGl0eSA9PT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IFBhcnNlRXJyb3JDbGFzcyA9IGJpbmRpbmcgPT09IDY0ID8gRXJyb3JzLkludmFsaWRMaHMgOiBFcnJvcnMuSW52YWxpZExoc0JpbmRpbmc7XG4gICAgICB0aGlzLnJhaXNlKFBhcnNlRXJyb3JDbGFzcywgZXhwcmVzc2lvbiwge1xuICAgICAgICBhbmNlc3RvclxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBrZXksIGlzUGFyZW50aGVzaXplZEV4cHJlc3Npb247XG4gICAgaWYgKHR5cGVvZiB2YWxpZGl0eSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAga2V5ID0gdmFsaWRpdHk7XG4gICAgICBpc1BhcmVudGhlc2l6ZWRFeHByZXNzaW9uID0gdHlwZSA9PT0gXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBba2V5LCBpc1BhcmVudGhlc2l6ZWRFeHByZXNzaW9uXSA9IHZhbGlkaXR5O1xuICAgIH1cbiAgICBjb25zdCBuZXh0QW5jZXN0b3IgPSB0eXBlID09PSBcIkFycmF5UGF0dGVyblwiIHx8IHR5cGUgPT09IFwiT2JqZWN0UGF0dGVyblwiID8ge1xuICAgICAgdHlwZVxuICAgIH0gOiBhbmNlc3RvcjtcbiAgICBjb25zdCB2YWwgPSBleHByZXNzaW9uW2tleV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiB2YWwpIHtcbiAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgdGhpcy5jaGVja0xWYWwoY2hpbGQsIG5leHRBbmNlc3RvciwgYmluZGluZywgY2hlY2tDbGFzaGVzLCBzdHJpY3RNb2RlQ2hhbmdlZCwgaXNQYXJlbnRoZXNpemVkRXhwcmVzc2lvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZhbCkge1xuICAgICAgdGhpcy5jaGVja0xWYWwodmFsLCBuZXh0QW5jZXN0b3IsIGJpbmRpbmcsIGNoZWNrQ2xhc2hlcywgc3RyaWN0TW9kZUNoYW5nZWQsIGlzUGFyZW50aGVzaXplZEV4cHJlc3Npb24pO1xuICAgIH1cbiAgfVxuICBjaGVja0lkZW50aWZpZXIoYXQsIGJpbmRpbmdUeXBlLCBzdHJpY3RNb2RlQ2hhbmdlZCA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuc3RyaWN0ICYmIChzdHJpY3RNb2RlQ2hhbmdlZCA/IGlzU3RyaWN0QmluZFJlc2VydmVkV29yZChhdC5uYW1lLCB0aGlzLmluTW9kdWxlKSA6IGlzU3RyaWN0QmluZE9ubHlSZXNlcnZlZFdvcmQoYXQubmFtZSkpKSB7XG4gICAgICBpZiAoYmluZGluZ1R5cGUgPT09IDY0KSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlN0cmljdEV2YWxBcmd1bWVudHMsIGF0LCB7XG4gICAgICAgICAgcmVmZXJlbmNlTmFtZTogYXQubmFtZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlN0cmljdEV2YWxBcmd1bWVudHNCaW5kaW5nLCBhdCwge1xuICAgICAgICAgIGJpbmRpbmdOYW1lOiBhdC5uYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmluZGluZ1R5cGUgJiA4MTkyICYmIGF0Lm5hbWUgPT09IFwibGV0XCIpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkxldEluTGV4aWNhbEJpbmRpbmcsIGF0KTtcbiAgICB9XG4gICAgaWYgKCEoYmluZGluZ1R5cGUgJiA2NCkpIHtcbiAgICAgIHRoaXMuZGVjbGFyZU5hbWVGcm9tSWRlbnRpZmllcihhdCwgYmluZGluZ1R5cGUpO1xuICAgIH1cbiAgfVxuICBkZWNsYXJlTmFtZUZyb21JZGVudGlmaWVyKGlkZW50aWZpZXIsIGJpbmRpbmcpIHtcbiAgICB0aGlzLnNjb3BlLmRlY2xhcmVOYW1lKGlkZW50aWZpZXIubmFtZSwgYmluZGluZywgaWRlbnRpZmllci5sb2Muc3RhcnQpO1xuICB9XG4gIGNoZWNrVG9SZXN0Q29udmVyc2lvbihub2RlLCBhbGxvd1BhdHRlcm4pIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI6XG4gICAgICAgIHRoaXMuY2hlY2tUb1Jlc3RDb252ZXJzaW9uKG5vZGUuZXhwcmVzc2lvbiwgYWxsb3dQYXR0ZXJuKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiQXJyYXlFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiT2JqZWN0RXhwcmVzc2lvblwiOlxuICAgICAgICBpZiAoYWxsb3dQYXR0ZXJuKSBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWRSZXN0QXNzaWdubWVudFBhdHRlcm4sIG5vZGUpO1xuICAgIH1cbiAgfVxuICBjaGVja0NvbW1hQWZ0ZXJSZXN0KGNsb3NlKSB7XG4gICAgaWYgKCF0aGlzLm1hdGNoKDEyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLnJhaXNlKHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKSA9PT0gY2xvc2UgPyBFcnJvcnMuUmVzdFRyYWlsaW5nQ29tbWEgOiBFcnJvcnMuRWxlbWVudEFmdGVyUmVzdCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmZ1bmN0aW9uIG5vbk51bGwoeCkge1xuICBpZiAoeCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkICR7eH0gdmFsdWUuYCk7XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5mdW5jdGlvbiBhc3NlcnQoeCkge1xuICBpZiAoIXgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3NlcnQgZmFpbFwiKTtcbiAgfVxufVxuY29uc3QgVFNFcnJvcnMgPSBQYXJzZUVycm9yRW51bWB0eXBlc2NyaXB0YCh7XG4gIEFic3RyYWN0TWV0aG9kSGFzSW1wbGVtZW50YXRpb246ICh7XG4gICAgbWV0aG9kTmFtZVxuICB9KSA9PiBgTWV0aG9kICcke21ldGhvZE5hbWV9JyBjYW5ub3QgaGF2ZSBhbiBpbXBsZW1lbnRhdGlvbiBiZWNhdXNlIGl0IGlzIG1hcmtlZCBhYnN0cmFjdC5gLFxuICBBYnN0cmFjdFByb3BlcnR5SGFzSW5pdGlhbGl6ZXI6ICh7XG4gICAgcHJvcGVydHlOYW1lXG4gIH0pID0+IGBQcm9wZXJ0eSAnJHtwcm9wZXJ0eU5hbWV9JyBjYW5ub3QgaGF2ZSBhbiBpbml0aWFsaXplciBiZWNhdXNlIGl0IGlzIG1hcmtlZCBhYnN0cmFjdC5gLFxuICBBY2Nlc3NvckNhbm5vdEJlT3B0aW9uYWw6IFwiQW4gJ2FjY2Vzc29yJyBwcm9wZXJ0eSBjYW5ub3QgYmUgZGVjbGFyZWQgb3B0aW9uYWwuXCIsXG4gIEFjY2Vzc29yQ2Fubm90RGVjbGFyZVRoaXNQYXJhbWV0ZXI6IFwiJ2dldCcgYW5kICdzZXQnIGFjY2Vzc29ycyBjYW5ub3QgZGVjbGFyZSAndGhpcycgcGFyYW1ldGVycy5cIixcbiAgQWNjZXNzb3JDYW5ub3RIYXZlVHlwZVBhcmFtZXRlcnM6IFwiQW4gYWNjZXNzb3IgY2Fubm90IGhhdmUgdHlwZSBwYXJhbWV0ZXJzLlwiLFxuICBDbGFzc01ldGhvZEhhc0RlY2xhcmU6IFwiQ2xhc3MgbWV0aG9kcyBjYW5ub3QgaGF2ZSB0aGUgJ2RlY2xhcmUnIG1vZGlmaWVyLlwiLFxuICBDbGFzc01ldGhvZEhhc1JlYWRvbmx5OiBcIkNsYXNzIG1ldGhvZHMgY2Fubm90IGhhdmUgdGhlICdyZWFkb25seScgbW9kaWZpZXIuXCIsXG4gIENvbnN0SW5pdGlhbGl6ZXJNdXN0QmVTdHJpbmdPck51bWVyaWNMaXRlcmFsT3JMaXRlcmFsRW51bVJlZmVyZW5jZTogXCJBICdjb25zdCcgaW5pdGlhbGl6ZXIgaW4gYW4gYW1iaWVudCBjb250ZXh0IG11c3QgYmUgYSBzdHJpbmcgb3IgbnVtZXJpYyBsaXRlcmFsIG9yIGxpdGVyYWwgZW51bSByZWZlcmVuY2UuXCIsXG4gIENvbnN0cnVjdG9ySGFzVHlwZVBhcmFtZXRlcnM6IFwiVHlwZSBwYXJhbWV0ZXJzIGNhbm5vdCBhcHBlYXIgb24gYSBjb25zdHJ1Y3RvciBkZWNsYXJhdGlvbi5cIixcbiAgRGVjbGFyZUFjY2Vzc29yOiAoe1xuICAgIGtpbmRcbiAgfSkgPT4gYCdkZWNsYXJlJyBpcyBub3QgYWxsb3dlZCBpbiAke2tpbmR9dGVycy5gLFxuICBEZWNsYXJlQ2xhc3NGaWVsZEhhc0luaXRpYWxpemVyOiBcIkluaXRpYWxpemVycyBhcmUgbm90IGFsbG93ZWQgaW4gYW1iaWVudCBjb250ZXh0cy5cIixcbiAgRGVjbGFyZUZ1bmN0aW9uSGFzSW1wbGVtZW50YXRpb246IFwiQW4gaW1wbGVtZW50YXRpb24gY2Fubm90IGJlIGRlY2xhcmVkIGluIGFtYmllbnQgY29udGV4dHMuXCIsXG4gIER1cGxpY2F0ZUFjY2Vzc2liaWxpdHlNb2RpZmllcjogKHtcbiAgICBtb2RpZmllclxuICB9KSA9PiBgQWNjZXNzaWJpbGl0eSBtb2RpZmllciBhbHJlYWR5IHNlZW46ICcke21vZGlmaWVyfScuYCxcbiAgRHVwbGljYXRlTW9kaWZpZXI6ICh7XG4gICAgbW9kaWZpZXJcbiAgfSkgPT4gYER1cGxpY2F0ZSBtb2RpZmllcjogJyR7bW9kaWZpZXJ9Jy5gLFxuICBFbXB0eUhlcml0YWdlQ2xhdXNlVHlwZTogKHtcbiAgICB0b2tlblxuICB9KSA9PiBgJyR7dG9rZW59JyBsaXN0IGNhbm5vdCBiZSBlbXB0eS5gLFxuICBFbXB0eVR5cGVBcmd1bWVudHM6IFwiVHlwZSBhcmd1bWVudCBsaXN0IGNhbm5vdCBiZSBlbXB0eS5cIixcbiAgRW1wdHlUeXBlUGFyYW1ldGVyczogXCJUeXBlIHBhcmFtZXRlciBsaXN0IGNhbm5vdCBiZSBlbXB0eS5cIixcbiAgRXhwZWN0ZWRBbWJpZW50QWZ0ZXJFeHBvcnREZWNsYXJlOiBcIidleHBvcnQgZGVjbGFyZScgbXVzdCBiZSBmb2xsb3dlZCBieSBhbiBhbWJpZW50IGRlY2xhcmF0aW9uLlwiLFxuICBJbXBvcnRBbGlhc0hhc0ltcG9ydFR5cGU6IFwiQW4gaW1wb3J0IGFsaWFzIGNhbiBub3QgdXNlICdpbXBvcnQgdHlwZScuXCIsXG4gIEltcG9ydFJlZmxlY3Rpb25IYXNJbXBvcnRUeXBlOiBcIkFuIGBpbXBvcnQgbW9kdWxlYCBkZWNsYXJhdGlvbiBjYW4gbm90IHVzZSBgdHlwZWAgbW9kaWZpZXJcIixcbiAgSW5jb21wYXRpYmxlTW9kaWZpZXJzOiAoe1xuICAgIG1vZGlmaWVyc1xuICB9KSA9PiBgJyR7bW9kaWZpZXJzWzBdfScgbW9kaWZpZXIgY2Fubm90IGJlIHVzZWQgd2l0aCAnJHttb2RpZmllcnNbMV19JyBtb2RpZmllci5gLFxuICBJbmRleFNpZ25hdHVyZUhhc0Fic3RyYWN0OiBcIkluZGV4IHNpZ25hdHVyZXMgY2Fubm90IGhhdmUgdGhlICdhYnN0cmFjdCcgbW9kaWZpZXIuXCIsXG4gIEluZGV4U2lnbmF0dXJlSGFzQWNjZXNzaWJpbGl0eTogKHtcbiAgICBtb2RpZmllclxuICB9KSA9PiBgSW5kZXggc2lnbmF0dXJlcyBjYW5ub3QgaGF2ZSBhbiBhY2Nlc3NpYmlsaXR5IG1vZGlmaWVyICgnJHttb2RpZmllcn0nKS5gLFxuICBJbmRleFNpZ25hdHVyZUhhc0RlY2xhcmU6IFwiSW5kZXggc2lnbmF0dXJlcyBjYW5ub3QgaGF2ZSB0aGUgJ2RlY2xhcmUnIG1vZGlmaWVyLlwiLFxuICBJbmRleFNpZ25hdHVyZUhhc092ZXJyaWRlOiBcIidvdmVycmlkZScgbW9kaWZpZXIgY2Fubm90IGFwcGVhciBvbiBhbiBpbmRleCBzaWduYXR1cmUuXCIsXG4gIEluZGV4U2lnbmF0dXJlSGFzU3RhdGljOiBcIkluZGV4IHNpZ25hdHVyZXMgY2Fubm90IGhhdmUgdGhlICdzdGF0aWMnIG1vZGlmaWVyLlwiLFxuICBJbml0aWFsaXplck5vdEFsbG93ZWRJbkFtYmllbnRDb250ZXh0OiBcIkluaXRpYWxpemVycyBhcmUgbm90IGFsbG93ZWQgaW4gYW1iaWVudCBjb250ZXh0cy5cIixcbiAgSW52YWxpZEhlcml0YWdlQ2xhdXNlVHlwZTogKHtcbiAgICB0b2tlblxuICB9KSA9PiBgJyR7dG9rZW59JyBsaXN0IGNhbiBvbmx5IGluY2x1ZGUgaWRlbnRpZmllcnMgb3IgcXVhbGlmaWVkLW5hbWVzIHdpdGggb3B0aW9uYWwgdHlwZSBhcmd1bWVudHMuYCxcbiAgSW52YWxpZE1vZGlmaWVyT25Bd2FpdFVzaW5nRGVjbGFyYXRpb246IG1vZGlmaWVyID0+IGAnJHttb2RpZmllcn0nIG1vZGlmaWVyIGNhbm5vdCBhcHBlYXIgb24gYW4gYXdhaXQgdXNpbmcgZGVjbGFyYXRpb24uYCxcbiAgSW52YWxpZE1vZGlmaWVyT25UeXBlTWVtYmVyOiAoe1xuICAgIG1vZGlmaWVyXG4gIH0pID0+IGAnJHttb2RpZmllcn0nIG1vZGlmaWVyIGNhbm5vdCBhcHBlYXIgb24gYSB0eXBlIG1lbWJlci5gLFxuICBJbnZhbGlkTW9kaWZpZXJPblR5cGVQYXJhbWV0ZXI6ICh7XG4gICAgbW9kaWZpZXJcbiAgfSkgPT4gYCcke21vZGlmaWVyfScgbW9kaWZpZXIgY2Fubm90IGFwcGVhciBvbiBhIHR5cGUgcGFyYW1ldGVyLmAsXG4gIEludmFsaWRNb2RpZmllck9uVHlwZVBhcmFtZXRlclBvc2l0aW9uczogKHtcbiAgICBtb2RpZmllclxuICB9KSA9PiBgJyR7bW9kaWZpZXJ9JyBtb2RpZmllciBjYW4gb25seSBhcHBlYXIgb24gYSB0eXBlIHBhcmFtZXRlciBvZiBhIGNsYXNzLCBpbnRlcmZhY2Ugb3IgdHlwZSBhbGlhcy5gLFxuICBJbnZhbGlkTW9kaWZpZXJPblVzaW5nRGVjbGFyYXRpb246IG1vZGlmaWVyID0+IGAnJHttb2RpZmllcn0nIG1vZGlmaWVyIGNhbm5vdCBhcHBlYXIgb24gYSB1c2luZyBkZWNsYXJhdGlvbi5gLFxuICBJbnZhbGlkTW9kaWZpZXJzT3JkZXI6ICh7XG4gICAgb3JkZXJlZE1vZGlmaWVyc1xuICB9KSA9PiBgJyR7b3JkZXJlZE1vZGlmaWVyc1swXX0nIG1vZGlmaWVyIG11c3QgcHJlY2VkZSAnJHtvcmRlcmVkTW9kaWZpZXJzWzFdfScgbW9kaWZpZXIuYCxcbiAgSW52YWxpZFByb3BlcnR5QWNjZXNzQWZ0ZXJJbnN0YW50aWF0aW9uRXhwcmVzc2lvbjogXCJJbnZhbGlkIHByb3BlcnR5IGFjY2VzcyBhZnRlciBhbiBpbnN0YW50aWF0aW9uIGV4cHJlc3Npb24uIFwiICsgXCJZb3UgY2FuIGVpdGhlciB3cmFwIHRoZSBpbnN0YW50aWF0aW9uIGV4cHJlc3Npb24gaW4gcGFyZW50aGVzZXMsIG9yIGRlbGV0ZSB0aGUgdHlwZSBhcmd1bWVudHMuXCIsXG4gIEludmFsaWRUdXBsZU1lbWJlckxhYmVsOiBcIlR1cGxlIG1lbWJlcnMgbXVzdCBiZSBsYWJlbGVkIHdpdGggYSBzaW1wbGUgaWRlbnRpZmllci5cIixcbiAgTWlzc2luZ0ludGVyZmFjZU5hbWU6IFwiJ2ludGVyZmFjZScgZGVjbGFyYXRpb25zIG11c3QgYmUgZm9sbG93ZWQgYnkgYW4gaWRlbnRpZmllci5cIixcbiAgTm9uQWJzdHJhY3RDbGFzc0hhc0Fic3RyYWN0TWV0aG9kOiBcIkFic3RyYWN0IG1ldGhvZHMgY2FuIG9ubHkgYXBwZWFyIHdpdGhpbiBhbiBhYnN0cmFjdCBjbGFzcy5cIixcbiAgTm9uQ2xhc3NNZXRob2RQcm9wZXJ0eUhhc0Fic3RyYWN0TW9kaWZpZXI6IFwiJ2Fic3RyYWN0JyBtb2RpZmllciBjYW4gb25seSBhcHBlYXIgb24gYSBjbGFzcywgbWV0aG9kLCBvciBwcm9wZXJ0eSBkZWNsYXJhdGlvbi5cIixcbiAgT3B0aW9uYWxUeXBlQmVmb3JlUmVxdWlyZWQ6IFwiQSByZXF1aXJlZCBlbGVtZW50IGNhbm5vdCBmb2xsb3cgYW4gb3B0aW9uYWwgZWxlbWVudC5cIixcbiAgT3ZlcnJpZGVOb3RJblN1YkNsYXNzOiBcIlRoaXMgbWVtYmVyIGNhbm5vdCBoYXZlIGFuICdvdmVycmlkZScgbW9kaWZpZXIgYmVjYXVzZSBpdHMgY29udGFpbmluZyBjbGFzcyBkb2VzIG5vdCBleHRlbmQgYW5vdGhlciBjbGFzcy5cIixcbiAgUGF0dGVybklzT3B0aW9uYWw6IFwiQSBiaW5kaW5nIHBhdHRlcm4gcGFyYW1ldGVyIGNhbm5vdCBiZSBvcHRpb25hbCBpbiBhbiBpbXBsZW1lbnRhdGlvbiBzaWduYXR1cmUuXCIsXG4gIFByaXZhdGVFbGVtZW50SGFzQWJzdHJhY3Q6IFwiUHJpdmF0ZSBlbGVtZW50cyBjYW5ub3QgaGF2ZSB0aGUgJ2Fic3RyYWN0JyBtb2RpZmllci5cIixcbiAgUHJpdmF0ZUVsZW1lbnRIYXNBY2Nlc3NpYmlsaXR5OiAoe1xuICAgIG1vZGlmaWVyXG4gIH0pID0+IGBQcml2YXRlIGVsZW1lbnRzIGNhbm5vdCBoYXZlIGFuIGFjY2Vzc2liaWxpdHkgbW9kaWZpZXIgKCcke21vZGlmaWVyfScpLmAsXG4gIFJlYWRvbmx5Rm9yTWV0aG9kU2lnbmF0dXJlOiBcIidyZWFkb25seScgbW9kaWZpZXIgY2FuIG9ubHkgYXBwZWFyIG9uIGEgcHJvcGVydHkgZGVjbGFyYXRpb24gb3IgaW5kZXggc2lnbmF0dXJlLlwiLFxuICBSZXNlcnZlZEFycm93VHlwZVBhcmFtOiBcIlRoaXMgc3ludGF4IGlzIHJlc2VydmVkIGluIGZpbGVzIHdpdGggdGhlIC5tdHMgb3IgLmN0cyBleHRlbnNpb24uIEFkZCBhIHRyYWlsaW5nIGNvbW1hLCBhcyBpbiBgPFQsPigpID0+IC4uLmAuXCIsXG4gIFJlc2VydmVkVHlwZUFzc2VydGlvbjogXCJUaGlzIHN5bnRheCBpcyByZXNlcnZlZCBpbiBmaWxlcyB3aXRoIHRoZSAubXRzIG9yIC5jdHMgZXh0ZW5zaW9uLiBVc2UgYW4gYGFzYCBleHByZXNzaW9uIGluc3RlYWQuXCIsXG4gIFNldEFjY2Vzc29yQ2Fubm90SGF2ZU9wdGlvbmFsUGFyYW1ldGVyOiBcIkEgJ3NldCcgYWNjZXNzb3IgY2Fubm90IGhhdmUgYW4gb3B0aW9uYWwgcGFyYW1ldGVyLlwiLFxuICBTZXRBY2Nlc3NvckNhbm5vdEhhdmVSZXN0UGFyYW1ldGVyOiBcIkEgJ3NldCcgYWNjZXNzb3IgY2Fubm90IGhhdmUgcmVzdCBwYXJhbWV0ZXIuXCIsXG4gIFNldEFjY2Vzc29yQ2Fubm90SGF2ZVJldHVyblR5cGU6IFwiQSAnc2V0JyBhY2Nlc3NvciBjYW5ub3QgaGF2ZSBhIHJldHVybiB0eXBlIGFubm90YXRpb24uXCIsXG4gIFNpbmdsZVR5cGVQYXJhbWV0ZXJXaXRob3V0VHJhaWxpbmdDb21tYTogKHtcbiAgICB0eXBlUGFyYW1ldGVyTmFtZVxuICB9KSA9PiBgU2luZ2xlIHR5cGUgcGFyYW1ldGVyICR7dHlwZVBhcmFtZXRlck5hbWV9IHNob3VsZCBoYXZlIGEgdHJhaWxpbmcgY29tbWEuIEV4YW1wbGUgdXNhZ2U6IDwke3R5cGVQYXJhbWV0ZXJOYW1lfSw+LmAsXG4gIFN0YXRpY0Jsb2NrQ2Fubm90SGF2ZU1vZGlmaWVyOiBcIlN0YXRpYyBjbGFzcyBibG9ja3MgY2Fubm90IGhhdmUgYW55IG1vZGlmaWVyLlwiLFxuICBUdXBsZU9wdGlvbmFsQWZ0ZXJUeXBlOiBcIkEgbGFiZWxlZCB0dXBsZSBvcHRpb25hbCBlbGVtZW50IG11c3QgYmUgZGVjbGFyZWQgdXNpbmcgYSBxdWVzdGlvbiBtYXJrIGFmdGVyIHRoZSBuYW1lIGFuZCBiZWZvcmUgdGhlIGNvbG9uIChgbmFtZT86IHR5cGVgKSwgcmF0aGVyIHRoYW4gYWZ0ZXIgdGhlIHR5cGUgKGBuYW1lOiB0eXBlP2ApLlwiLFxuICBUeXBlQW5ub3RhdGlvbkFmdGVyQXNzaWduOiBcIlR5cGUgYW5ub3RhdGlvbnMgbXVzdCBjb21lIGJlZm9yZSBkZWZhdWx0IGFzc2lnbm1lbnRzLCBlLmcuIGluc3RlYWQgb2YgYGFnZSA9IDI1OiBudW1iZXJgIHVzZSBgYWdlOiBudW1iZXIgPSAyNWAuXCIsXG4gIFR5cGVJbXBvcnRDYW5ub3RTcGVjaWZ5RGVmYXVsdEFuZE5hbWVkOiBcIkEgdHlwZS1vbmx5IGltcG9ydCBjYW4gc3BlY2lmeSBhIGRlZmF1bHQgaW1wb3J0IG9yIG5hbWVkIGJpbmRpbmdzLCBidXQgbm90IGJvdGguXCIsXG4gIFR5cGVNb2RpZmllcklzVXNlZEluVHlwZUV4cG9ydHM6IFwiVGhlICd0eXBlJyBtb2RpZmllciBjYW5ub3QgYmUgdXNlZCBvbiBhIG5hbWVkIGV4cG9ydCB3aGVuICdleHBvcnQgdHlwZScgaXMgdXNlZCBvbiBpdHMgZXhwb3J0IHN0YXRlbWVudC5cIixcbiAgVHlwZU1vZGlmaWVySXNVc2VkSW5UeXBlSW1wb3J0czogXCJUaGUgJ3R5cGUnIG1vZGlmaWVyIGNhbm5vdCBiZSB1c2VkIG9uIGEgbmFtZWQgaW1wb3J0IHdoZW4gJ2ltcG9ydCB0eXBlJyBpcyB1c2VkIG9uIGl0cyBpbXBvcnQgc3RhdGVtZW50LlwiLFxuICBVbmV4cGVjdGVkUGFyYW1ldGVyTW9kaWZpZXI6IFwiQSBwYXJhbWV0ZXIgcHJvcGVydHkgaXMgb25seSBhbGxvd2VkIGluIGEgY29uc3RydWN0b3IgaW1wbGVtZW50YXRpb24uXCIsXG4gIFVuZXhwZWN0ZWRSZWFkb25seTogXCIncmVhZG9ubHknIHR5cGUgbW9kaWZpZXIgaXMgb25seSBwZXJtaXR0ZWQgb24gYXJyYXkgYW5kIHR1cGxlIGxpdGVyYWwgdHlwZXMuXCIsXG4gIFVuZXhwZWN0ZWRUeXBlQW5ub3RhdGlvbjogXCJEaWQgbm90IGV4cGVjdCBhIHR5cGUgYW5ub3RhdGlvbiBoZXJlLlwiLFxuICBVbmV4cGVjdGVkVHlwZUNhc3RJblBhcmFtZXRlcjogXCJVbmV4cGVjdGVkIHR5cGUgY2FzdCBpbiBwYXJhbWV0ZXIgcG9zaXRpb24uXCIsXG4gIFVuc3VwcG9ydGVkSW1wb3J0VHlwZUFyZ3VtZW50OiBcIkFyZ3VtZW50IGluIGEgdHlwZSBpbXBvcnQgbXVzdCBiZSBhIHN0cmluZyBsaXRlcmFsLlwiLFxuICBVbnN1cHBvcnRlZFBhcmFtZXRlclByb3BlcnR5S2luZDogXCJBIHBhcmFtZXRlciBwcm9wZXJ0eSBtYXkgbm90IGJlIGRlY2xhcmVkIHVzaW5nIGEgYmluZGluZyBwYXR0ZXJuLlwiLFxuICBVbnN1cHBvcnRlZFNpZ25hdHVyZVBhcmFtZXRlcktpbmQ6ICh7XG4gICAgdHlwZVxuICB9KSA9PiBgTmFtZSBpbiBhIHNpZ25hdHVyZSBtdXN0IGJlIGFuIElkZW50aWZpZXIsIE9iamVjdFBhdHRlcm4gb3IgQXJyYXlQYXR0ZXJuLCBpbnN0ZWFkIGdvdCAke3R5cGV9LmAsXG4gIFVzaW5nRGVjbGFyYXRpb25JbkFtYmllbnRDb250ZXh0OiBraW5kID0+IGAnJHtraW5kfScgZGVjbGFyYXRpb25zIGFyZSBub3QgYWxsb3dlZCBpbiBhbWJpZW50IGNvbnRleHRzLmBcbn0pO1xuZnVuY3Rpb24ga2V5d29yZFR5cGVGcm9tTmFtZSh2YWx1ZSkge1xuICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgY2FzZSBcImFueVwiOlxuICAgICAgcmV0dXJuIFwiVFNBbnlLZXl3b3JkXCI7XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIHJldHVybiBcIlRTQm9vbGVhbktleXdvcmRcIjtcbiAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICByZXR1cm4gXCJUU0JpZ0ludEtleXdvcmRcIjtcbiAgICBjYXNlIFwibmV2ZXJcIjpcbiAgICAgIHJldHVybiBcIlRTTmV2ZXJLZXl3b3JkXCI7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgcmV0dXJuIFwiVFNOdW1iZXJLZXl3b3JkXCI7XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgcmV0dXJuIFwiVFNPYmplY3RLZXl3b3JkXCI7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgcmV0dXJuIFwiVFNTdHJpbmdLZXl3b3JkXCI7XG4gICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgcmV0dXJuIFwiVFNTeW1ib2xLZXl3b3JkXCI7XG4gICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgcmV0dXJuIFwiVFNVbmRlZmluZWRLZXl3b3JkXCI7XG4gICAgY2FzZSBcInVua25vd25cIjpcbiAgICAgIHJldHVybiBcIlRTVW5rbm93bktleXdvcmRcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuZnVuY3Rpb24gdHNJc0FjY2Vzc01vZGlmaWVyKG1vZGlmaWVyKSB7XG4gIHJldHVybiBtb2RpZmllciA9PT0gXCJwcml2YXRlXCIgfHwgbW9kaWZpZXIgPT09IFwicHVibGljXCIgfHwgbW9kaWZpZXIgPT09IFwicHJvdGVjdGVkXCI7XG59XG5mdW5jdGlvbiB0c0lzVmFyaWFuY2VBbm5vdGF0aW9ucyhtb2RpZmllcikge1xuICByZXR1cm4gbW9kaWZpZXIgPT09IFwiaW5cIiB8fCBtb2RpZmllciA9PT0gXCJvdXRcIjtcbn1cbnZhciB0eXBlc2NyaXB0ID0gc3VwZXJDbGFzcyA9PiBjbGFzcyBUeXBlU2NyaXB0UGFyc2VyTWl4aW4gZXh0ZW5kcyBzdXBlckNsYXNzIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIHRoaXMudHNQYXJzZUluT3V0TW9kaWZpZXJzID0gdGhpcy50c1BhcnNlTW9kaWZpZXJzLmJpbmQodGhpcywge1xuICAgICAgYWxsb3dlZE1vZGlmaWVyczogW1wiaW5cIiwgXCJvdXRcIl0sXG4gICAgICBkaXNhbGxvd2VkTW9kaWZpZXJzOiBbXCJjb25zdFwiLCBcInB1YmxpY1wiLCBcInByaXZhdGVcIiwgXCJwcm90ZWN0ZWRcIiwgXCJyZWFkb25seVwiLCBcImRlY2xhcmVcIiwgXCJhYnN0cmFjdFwiLCBcIm92ZXJyaWRlXCJdLFxuICAgICAgZXJyb3JUZW1wbGF0ZTogVFNFcnJvcnMuSW52YWxpZE1vZGlmaWVyT25UeXBlUGFyYW1ldGVyXG4gICAgfSk7XG4gICAgdGhpcy50c1BhcnNlQ29uc3RNb2RpZmllciA9IHRoaXMudHNQYXJzZU1vZGlmaWVycy5iaW5kKHRoaXMsIHtcbiAgICAgIGFsbG93ZWRNb2RpZmllcnM6IFtcImNvbnN0XCJdLFxuICAgICAgZGlzYWxsb3dlZE1vZGlmaWVyczogW1wiaW5cIiwgXCJvdXRcIl0sXG4gICAgICBlcnJvclRlbXBsYXRlOiBUU0Vycm9ycy5JbnZhbGlkTW9kaWZpZXJPblR5cGVQYXJhbWV0ZXJQb3NpdGlvbnNcbiAgICB9KTtcbiAgICB0aGlzLnRzUGFyc2VJbk91dENvbnN0TW9kaWZpZXJzID0gdGhpcy50c1BhcnNlTW9kaWZpZXJzLmJpbmQodGhpcywge1xuICAgICAgYWxsb3dlZE1vZGlmaWVyczogW1wiaW5cIiwgXCJvdXRcIiwgXCJjb25zdFwiXSxcbiAgICAgIGRpc2FsbG93ZWRNb2RpZmllcnM6IFtcInB1YmxpY1wiLCBcInByaXZhdGVcIiwgXCJwcm90ZWN0ZWRcIiwgXCJyZWFkb25seVwiLCBcImRlY2xhcmVcIiwgXCJhYnN0cmFjdFwiLCBcIm92ZXJyaWRlXCJdLFxuICAgICAgZXJyb3JUZW1wbGF0ZTogVFNFcnJvcnMuSW52YWxpZE1vZGlmaWVyT25UeXBlUGFyYW1ldGVyXG4gICAgfSk7XG4gIH1cbiAgZ2V0U2NvcGVIYW5kbGVyKCkge1xuICAgIHJldHVybiBUeXBlU2NyaXB0U2NvcGVIYW5kbGVyO1xuICB9XG4gIHRzSXNJZGVudGlmaWVyKCkge1xuICAgIHJldHVybiB0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpO1xuICB9XG4gIHRzVG9rZW5DYW5Gb2xsb3dNb2RpZmllcigpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgwKSB8fCB0aGlzLm1hdGNoKDUpIHx8IHRoaXMubWF0Y2goNTUpIHx8IHRoaXMubWF0Y2goMjEpIHx8IHRoaXMubWF0Y2goMTM5KSB8fCB0aGlzLmlzTGl0ZXJhbFByb3BlcnR5TmFtZSgpO1xuICB9XG4gIHRzTmV4dFRva2VuT25TYW1lTGluZUFuZENhbkZvbGxvd01vZGlmaWVyKCkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRzVG9rZW5DYW5Gb2xsb3dNb2RpZmllcigpO1xuICB9XG4gIHRzTmV4dFRva2VuQ2FuRm9sbG93TW9kaWZpZXIoKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTA2KSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy50c1Rva2VuQ2FuRm9sbG93TW9kaWZpZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudHNOZXh0VG9rZW5PblNhbWVMaW5lQW5kQ2FuRm9sbG93TW9kaWZpZXIoKTtcbiAgfVxuICB0c1BhcnNlTW9kaWZpZXIoYWxsb3dlZE1vZGlmaWVycywgc3RvcE9uU3RhcnRPZkNsYXNzU3RhdGljQmxvY2ssIGhhc1NlZW5TdGF0aWNNb2RpZmllcikge1xuICAgIGlmICghdG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSAmJiB0aGlzLnN0YXRlLnR5cGUgIT09IDU4ICYmIHRoaXMuc3RhdGUudHlwZSAhPT0gNzUpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IG1vZGlmaWVyID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICBpZiAoYWxsb3dlZE1vZGlmaWVycy5pbmNsdWRlcyhtb2RpZmllcikpIHtcbiAgICAgIGlmIChoYXNTZWVuU3RhdGljTW9kaWZpZXIgJiYgdGhpcy5tYXRjaCgxMDYpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoc3RvcE9uU3RhcnRPZkNsYXNzU3RhdGljQmxvY2sgJiYgdGhpcy50c0lzU3RhcnRPZlN0YXRpY0Jsb2NrcygpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50c1RyeVBhcnNlKHRoaXMudHNOZXh0VG9rZW5DYW5Gb2xsb3dNb2RpZmllci5iaW5kKHRoaXMpKSkge1xuICAgICAgICByZXR1cm4gbW9kaWZpZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgdHNQYXJzZU1vZGlmaWVycyh7XG4gICAgYWxsb3dlZE1vZGlmaWVycyxcbiAgICBkaXNhbGxvd2VkTW9kaWZpZXJzLFxuICAgIHN0b3BPblN0YXJ0T2ZDbGFzc1N0YXRpY0Jsb2NrLFxuICAgIGVycm9yVGVtcGxhdGUgPSBUU0Vycm9ycy5JbnZhbGlkTW9kaWZpZXJPblR5cGVNZW1iZXJcbiAgfSwgbW9kaWZpZWQpIHtcbiAgICBjb25zdCBlbmZvcmNlT3JkZXIgPSAobG9jLCBtb2RpZmllciwgYmVmb3JlLCBhZnRlcikgPT4ge1xuICAgICAgaWYgKG1vZGlmaWVyID09PSBiZWZvcmUgJiYgbW9kaWZpZWRbYWZ0ZXJdKSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuSW52YWxpZE1vZGlmaWVyc09yZGVyLCBsb2MsIHtcbiAgICAgICAgICBvcmRlcmVkTW9kaWZpZXJzOiBbYmVmb3JlLCBhZnRlcl1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpbmNvbXBhdGlibGUgPSAobG9jLCBtb2RpZmllciwgbW9kMSwgbW9kMikgPT4ge1xuICAgICAgaWYgKG1vZGlmaWVkW21vZDFdICYmIG1vZGlmaWVyID09PSBtb2QyIHx8IG1vZGlmaWVkW21vZDJdICYmIG1vZGlmaWVyID09PSBtb2QxKSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuSW5jb21wYXRpYmxlTW9kaWZpZXJzLCBsb2MsIHtcbiAgICAgICAgICBtb2RpZmllcnM6IFttb2QxLCBtb2QyXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoOzspIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3RhcnRMb2NcbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3QgbW9kaWZpZXIgPSB0aGlzLnRzUGFyc2VNb2RpZmllcihhbGxvd2VkTW9kaWZpZXJzLmNvbmNhdChkaXNhbGxvd2VkTW9kaWZpZXJzICE9IG51bGwgPyBkaXNhbGxvd2VkTW9kaWZpZXJzIDogW10pLCBzdG9wT25TdGFydE9mQ2xhc3NTdGF0aWNCbG9jaywgbW9kaWZpZWQuc3RhdGljKTtcbiAgICAgIGlmICghbW9kaWZpZXIpIGJyZWFrO1xuICAgICAgaWYgKHRzSXNBY2Nlc3NNb2RpZmllcihtb2RpZmllcikpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVkLmFjY2Vzc2liaWxpdHkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkR1cGxpY2F0ZUFjY2Vzc2liaWxpdHlNb2RpZmllciwgc3RhcnRMb2MsIHtcbiAgICAgICAgICAgIG1vZGlmaWVyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5mb3JjZU9yZGVyKHN0YXJ0TG9jLCBtb2RpZmllciwgbW9kaWZpZXIsIFwib3ZlcnJpZGVcIik7XG4gICAgICAgICAgZW5mb3JjZU9yZGVyKHN0YXJ0TG9jLCBtb2RpZmllciwgbW9kaWZpZXIsIFwic3RhdGljXCIpO1xuICAgICAgICAgIGVuZm9yY2VPcmRlcihzdGFydExvYywgbW9kaWZpZXIsIG1vZGlmaWVyLCBcInJlYWRvbmx5XCIpO1xuICAgICAgICAgIG1vZGlmaWVkLmFjY2Vzc2liaWxpdHkgPSBtb2RpZmllcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0c0lzVmFyaWFuY2VBbm5vdGF0aW9ucyhtb2RpZmllcikpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVkW21vZGlmaWVyXSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuRHVwbGljYXRlTW9kaWZpZXIsIHN0YXJ0TG9jLCB7XG4gICAgICAgICAgICBtb2RpZmllclxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIG1vZGlmaWVkW21vZGlmaWVyXSA9IHRydWU7XG4gICAgICAgIGVuZm9yY2VPcmRlcihzdGFydExvYywgbW9kaWZpZXIsIFwiaW5cIiwgXCJvdXRcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChtb2RpZmllZCwgbW9kaWZpZXIpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5EdXBsaWNhdGVNb2RpZmllciwgc3RhcnRMb2MsIHtcbiAgICAgICAgICAgIG1vZGlmaWVyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5mb3JjZU9yZGVyKHN0YXJ0TG9jLCBtb2RpZmllciwgXCJzdGF0aWNcIiwgXCJyZWFkb25seVwiKTtcbiAgICAgICAgICBlbmZvcmNlT3JkZXIoc3RhcnRMb2MsIG1vZGlmaWVyLCBcInN0YXRpY1wiLCBcIm92ZXJyaWRlXCIpO1xuICAgICAgICAgIGVuZm9yY2VPcmRlcihzdGFydExvYywgbW9kaWZpZXIsIFwib3ZlcnJpZGVcIiwgXCJyZWFkb25seVwiKTtcbiAgICAgICAgICBlbmZvcmNlT3JkZXIoc3RhcnRMb2MsIG1vZGlmaWVyLCBcImFic3RyYWN0XCIsIFwib3ZlcnJpZGVcIik7XG4gICAgICAgICAgaW5jb21wYXRpYmxlKHN0YXJ0TG9jLCBtb2RpZmllciwgXCJkZWNsYXJlXCIsIFwib3ZlcnJpZGVcIik7XG4gICAgICAgICAgaW5jb21wYXRpYmxlKHN0YXJ0TG9jLCBtb2RpZmllciwgXCJzdGF0aWNcIiwgXCJhYnN0cmFjdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBtb2RpZmllZFttb2RpZmllcl0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGRpc2FsbG93ZWRNb2RpZmllcnMgIT0gbnVsbCAmJiBkaXNhbGxvd2VkTW9kaWZpZXJzLmluY2x1ZGVzKG1vZGlmaWVyKSkge1xuICAgICAgICB0aGlzLnJhaXNlKGVycm9yVGVtcGxhdGUsIHN0YXJ0TG9jLCB7XG4gICAgICAgICAgbW9kaWZpZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRzSXNMaXN0VGVybWluYXRvcihraW5kKSB7XG4gICAgc3dpdGNoIChraW5kKSB7XG4gICAgICBjYXNlIFwiRW51bU1lbWJlcnNcIjpcbiAgICAgIGNhc2UgXCJUeXBlTWVtYmVyc1wiOlxuICAgICAgICByZXR1cm4gdGhpcy5tYXRjaCg4KTtcbiAgICAgIGNhc2UgXCJIZXJpdGFnZUNsYXVzZUVsZW1lbnRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2goNSk7XG4gICAgICBjYXNlIFwiVHVwbGVFbGVtZW50VHlwZXNcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2goMyk7XG4gICAgICBjYXNlIFwiVHlwZVBhcmFtZXRlcnNPckFyZ3VtZW50c1wiOlxuICAgICAgICByZXR1cm4gdGhpcy5tYXRjaCg0OCk7XG4gICAgfVxuICB9XG4gIHRzUGFyc2VMaXN0KGtpbmQsIHBhcnNlRWxlbWVudCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHdoaWxlICghdGhpcy50c0lzTGlzdFRlcm1pbmF0b3Ioa2luZCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHBhcnNlRWxlbWVudCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB0c1BhcnNlRGVsaW1pdGVkTGlzdChraW5kLCBwYXJzZUVsZW1lbnQsIHJlZlRyYWlsaW5nQ29tbWFQb3MpIHtcbiAgICByZXR1cm4gbm9uTnVsbCh0aGlzLnRzUGFyc2VEZWxpbWl0ZWRMaXN0V29ya2VyKGtpbmQsIHBhcnNlRWxlbWVudCwgdHJ1ZSwgcmVmVHJhaWxpbmdDb21tYVBvcykpO1xuICB9XG4gIHRzUGFyc2VEZWxpbWl0ZWRMaXN0V29ya2VyKGtpbmQsIHBhcnNlRWxlbWVudCwgZXhwZWN0U3VjY2VzcywgcmVmVHJhaWxpbmdDb21tYVBvcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCB0cmFpbGluZ0NvbW1hUG9zID0gLTE7XG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKHRoaXMudHNJc0xpc3RUZXJtaW5hdG9yKGtpbmQpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdHJhaWxpbmdDb21tYVBvcyA9IC0xO1xuICAgICAgY29uc3QgZWxlbWVudCA9IHBhcnNlRWxlbWVudCgpO1xuICAgICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2goZWxlbWVudCk7XG4gICAgICBpZiAodGhpcy5lYXQoMTIpKSB7XG4gICAgICAgIHRyYWlsaW5nQ29tbWFQb3MgPSB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYy5pbmRleDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50c0lzTGlzdFRlcm1pbmF0b3Ioa2luZCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoZXhwZWN0U3VjY2Vzcykge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAocmVmVHJhaWxpbmdDb21tYVBvcykge1xuICAgICAgcmVmVHJhaWxpbmdDb21tYVBvcy52YWx1ZSA9IHRyYWlsaW5nQ29tbWFQb3M7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdHNQYXJzZUJyYWNrZXRlZExpc3Qoa2luZCwgcGFyc2VFbGVtZW50LCBicmFja2V0LCBza2lwRmlyc3RUb2tlbiwgcmVmVHJhaWxpbmdDb21tYVBvcykge1xuICAgIGlmICghc2tpcEZpcnN0VG9rZW4pIHtcbiAgICAgIGlmIChicmFja2V0KSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leHBlY3QoNDcpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnRzUGFyc2VEZWxpbWl0ZWRMaXN0KGtpbmQsIHBhcnNlRWxlbWVudCwgcmVmVHJhaWxpbmdDb21tYVBvcyk7XG4gICAgaWYgKGJyYWNrZXQpIHtcbiAgICAgIHRoaXMuZXhwZWN0KDMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV4cGVjdCg0OCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdHNQYXJzZUltcG9ydFR5cGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5leHBlY3QoODMpO1xuICAgIHRoaXMuZXhwZWN0KDEwKTtcbiAgICBpZiAoIXRoaXMubWF0Y2goMTM0KSkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5VbnN1cHBvcnRlZEltcG9ydFR5cGVBcmd1bWVudCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICB7XG4gICAgICAgIG5vZGUuYXJndW1lbnQgPSBzdXBlci5wYXJzZUV4cHJBdG9tKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VTdHJpbmdMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5lYXQoMTIpKSB7XG4gICAgICBub2RlLm9wdGlvbnMgPSB0aGlzLnRzUGFyc2VJbXBvcnRUeXBlT3B0aW9ucygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLm9wdGlvbnMgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmV4cGVjdCgxMSk7XG4gICAgaWYgKHRoaXMuZWF0KDE2KSkge1xuICAgICAgbm9kZS5xdWFsaWZpZXIgPSB0aGlzLnRzUGFyc2VFbnRpdHlOYW1lKDEgfCAyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICB7XG4gICAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLnRzUGFyc2VUeXBlQXJndW1lbnRzKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0ltcG9ydFR5cGVcIik7XG4gIH1cbiAgdHNQYXJzZUltcG9ydFR5cGVPcHRpb25zKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMuZXhwZWN0KDUpO1xuICAgIGNvbnN0IHdpdGhQcm9wZXJ0eSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDc2KSkge1xuICAgICAgd2l0aFByb3BlcnR5Lm1ldGhvZCA9IGZhbHNlO1xuICAgICAgd2l0aFByb3BlcnR5LmtleSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgICAgd2l0aFByb3BlcnR5LmNvbXB1dGVkID0gZmFsc2U7XG4gICAgICB3aXRoUHJvcGVydHkuc2hvcnRoYW5kID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZChudWxsLCA3Nik7XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0KDE0KTtcbiAgICB3aXRoUHJvcGVydHkudmFsdWUgPSB0aGlzLnRzUGFyc2VJbXBvcnRUeXBlV2l0aFByb3BlcnR5VmFsdWUoKTtcbiAgICBub2RlLnByb3BlcnRpZXMgPSBbdGhpcy5maW5pc2hPYmplY3RQcm9wZXJ0eSh3aXRoUHJvcGVydHkpXTtcbiAgICB0aGlzLmV4cGVjdCg4KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiT2JqZWN0RXhwcmVzc2lvblwiKTtcbiAgfVxuICB0c1BhcnNlSW1wb3J0VHlwZVdpdGhQcm9wZXJ0eVZhbHVlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBbXTtcbiAgICB0aGlzLmV4cGVjdCg1KTtcbiAgICB3aGlsZSAoIXRoaXMubWF0Y2goOCkpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLnN0YXRlLnR5cGU7XG4gICAgICBpZiAodG9rZW5Jc0lkZW50aWZpZXIodHlwZSkgfHwgdHlwZSA9PT0gMTM0KSB7XG4gICAgICAgIHByb3BlcnRpZXMucHVzaChzdXBlci5wYXJzZVByb3BlcnR5RGVmaW5pdGlvbihudWxsKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZWF0KDEyKTtcbiAgICB9XG4gICAgbm9kZS5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiT2JqZWN0RXhwcmVzc2lvblwiKTtcbiAgfVxuICB0c1BhcnNlRW50aXR5TmFtZShmbGFncykge1xuICAgIGxldCBlbnRpdHk7XG4gICAgaWYgKGZsYWdzICYgMSAmJiB0aGlzLm1hdGNoKDc4KSkge1xuICAgICAgaWYgKGZsYWdzICYgMikge1xuICAgICAgICBlbnRpdHkgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgZW50aXR5ID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGhpc0V4cHJlc3Npb25cIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudGl0eSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCEhKGZsYWdzICYgMSkpO1xuICAgIH1cbiAgICB3aGlsZSAodGhpcy5lYXQoMTYpKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdE5vZGUoZW50aXR5KTtcbiAgICAgIG5vZGUubGVmdCA9IGVudGl0eTtcbiAgICAgIG5vZGUucmlnaHQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcighIShmbGFncyAmIDEpKTtcbiAgICAgIGVudGl0eSA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTUXVhbGlmaWVkTmFtZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGVudGl0eTtcbiAgfVxuICB0c1BhcnNlVHlwZVJlZmVyZW5jZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLnR5cGVOYW1lID0gdGhpcy50c1BhcnNlRW50aXR5TmFtZSgxKTtcbiAgICBpZiAoIXRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkgJiYgdGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIHtcbiAgICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMudHNQYXJzZVR5cGVBcmd1bWVudHMoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHlwZVJlZmVyZW5jZVwiKTtcbiAgfVxuICB0c1BhcnNlVGhpc1R5cGVQcmVkaWNhdGUobGhzKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXROb2RlKGxocyk7XG4gICAgbm9kZS5wYXJhbWV0ZXJOYW1lID0gbGhzO1xuICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLnRzUGFyc2VUeXBlQW5ub3RhdGlvbihmYWxzZSk7XG4gICAgbm9kZS5hc3NlcnRzID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHlwZVByZWRpY2F0ZVwiKTtcbiAgfVxuICB0c1BhcnNlVGhpc1R5cGVOb2RlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU1RoaXNUeXBlXCIpO1xuICB9XG4gIHRzUGFyc2VUeXBlUXVlcnkoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5leHBlY3QoODcpO1xuICAgIGlmICh0aGlzLm1hdGNoKDgzKSkge1xuICAgICAgbm9kZS5leHByTmFtZSA9IHRoaXMudHNQYXJzZUltcG9ydFR5cGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAge1xuICAgICAgICBub2RlLmV4cHJOYW1lID0gdGhpcy50c1BhcnNlRW50aXR5TmFtZSgxIHwgMik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSAmJiB0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAge1xuICAgICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1BhcnNlVHlwZUFyZ3VtZW50cygpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUeXBlUXVlcnlcIik7XG4gIH1cbiAgdHNQYXJzZVR5cGVQYXJhbWV0ZXIocGFyc2VNb2RpZmllcnMpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBwYXJzZU1vZGlmaWVycyhub2RlKTtcbiAgICBub2RlLm5hbWUgPSB0aGlzLnRzUGFyc2VUeXBlUGFyYW1ldGVyTmFtZSgpO1xuICAgIG5vZGUuY29uc3RyYWludCA9IHRoaXMudHNFYXRUaGVuUGFyc2VUeXBlKDgxKTtcbiAgICBub2RlLmRlZmF1bHQgPSB0aGlzLnRzRWF0VGhlblBhcnNlVHlwZSgyOSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHlwZVBhcmFtZXRlclwiKTtcbiAgfVxuICB0c1RyeVBhcnNlVHlwZVBhcmFtZXRlcnMocGFyc2VNb2RpZmllcnMpIHtcbiAgICBpZiAodGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUeXBlUGFyYW1ldGVycyhwYXJzZU1vZGlmaWVycyk7XG4gICAgfVxuICB9XG4gIHRzUGFyc2VUeXBlUGFyYW1ldGVycyhwYXJzZU1vZGlmaWVycykge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGlmICh0aGlzLm1hdGNoKDQ3KSB8fCB0aGlzLm1hdGNoKDE0MykpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gICAgY29uc3QgcmVmVHJhaWxpbmdDb21tYVBvcyA9IHtcbiAgICAgIHZhbHVlOiAtMVxuICAgIH07XG4gICAgbm9kZS5wYXJhbXMgPSB0aGlzLnRzUGFyc2VCcmFja2V0ZWRMaXN0KFwiVHlwZVBhcmFtZXRlcnNPckFyZ3VtZW50c1wiLCB0aGlzLnRzUGFyc2VUeXBlUGFyYW1ldGVyLmJpbmQodGhpcywgcGFyc2VNb2RpZmllcnMpLCBmYWxzZSwgdHJ1ZSwgcmVmVHJhaWxpbmdDb21tYVBvcyk7XG4gICAgaWYgKG5vZGUucGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5FbXB0eVR5cGVQYXJhbWV0ZXJzLCBub2RlKTtcbiAgICB9XG4gICAgaWYgKHJlZlRyYWlsaW5nQ29tbWFQb3MudmFsdWUgIT09IC0xKSB7XG4gICAgICB0aGlzLmFkZEV4dHJhKG5vZGUsIFwidHJhaWxpbmdDb21tYVwiLCByZWZUcmFpbGluZ0NvbW1hUG9zLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIpO1xuICB9XG4gIHRzRmlsbFNpZ25hdHVyZShyZXR1cm5Ub2tlbiwgc2lnbmF0dXJlKSB7XG4gICAgY29uc3QgcmV0dXJuVG9rZW5SZXF1aXJlZCA9IHJldHVyblRva2VuID09PSAxOTtcbiAgICBjb25zdCBwYXJhbXNLZXkgPSBcInBhcmFtZXRlcnNcIjtcbiAgICBjb25zdCByZXR1cm5UeXBlS2V5ID0gXCJ0eXBlQW5ub3RhdGlvblwiO1xuICAgIHNpZ25hdHVyZS50eXBlUGFyYW1ldGVycyA9IHRoaXMudHNUcnlQYXJzZVR5cGVQYXJhbWV0ZXJzKHRoaXMudHNQYXJzZUNvbnN0TW9kaWZpZXIpO1xuICAgIHRoaXMuZXhwZWN0KDEwKTtcbiAgICBzaWduYXR1cmVbcGFyYW1zS2V5XSA9IHRoaXMudHNQYXJzZUJpbmRpbmdMaXN0Rm9yU2lnbmF0dXJlKCk7XG4gICAgaWYgKHJldHVyblRva2VuUmVxdWlyZWQpIHtcbiAgICAgIHNpZ25hdHVyZVtyZXR1cm5UeXBlS2V5XSA9IHRoaXMudHNQYXJzZVR5cGVPclR5cGVQcmVkaWNhdGVBbm5vdGF0aW9uKHJldHVyblRva2VuKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2gocmV0dXJuVG9rZW4pKSB7XG4gICAgICBzaWduYXR1cmVbcmV0dXJuVHlwZUtleV0gPSB0aGlzLnRzUGFyc2VUeXBlT3JUeXBlUHJlZGljYXRlQW5ub3RhdGlvbihyZXR1cm5Ub2tlbik7XG4gICAgfVxuICB9XG4gIHRzUGFyc2VCaW5kaW5nTGlzdEZvclNpZ25hdHVyZSgpIHtcbiAgICBjb25zdCBsaXN0ID0gc3VwZXIucGFyc2VCaW5kaW5nTGlzdCgxMSwgNDEsIDIpO1xuICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiBsaXN0KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHR5cGVcbiAgICAgIH0gPSBwYXR0ZXJuO1xuICAgICAgaWYgKHR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIiB8fCB0eXBlID09PSBcIlRTUGFyYW1ldGVyUHJvcGVydHlcIikge1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlVuc3VwcG9ydGVkU2lnbmF0dXJlUGFyYW1ldGVyS2luZCwgcGF0dGVybiwge1xuICAgICAgICAgIHR5cGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xuICB9XG4gIHRzUGFyc2VUeXBlTWVtYmVyU2VtaWNvbG9uKCkge1xuICAgIGlmICghdGhpcy5lYXQoMTIpICYmICF0aGlzLmlzTGluZVRlcm1pbmF0b3IoKSkge1xuICAgICAgdGhpcy5leHBlY3QoMTMpO1xuICAgIH1cbiAgfVxuICB0c1BhcnNlU2lnbmF0dXJlTWVtYmVyKGtpbmQsIG5vZGUpIHtcbiAgICB0aGlzLnRzRmlsbFNpZ25hdHVyZSgxNCwgbm9kZSk7XG4gICAgdGhpcy50c1BhcnNlVHlwZU1lbWJlclNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwga2luZCk7XG4gIH1cbiAgdHNJc1VuYW1iaWd1b3VzbHlJbmRleFNpZ25hdHVyZSgpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5tYXRjaCgxNCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0c1RyeVBhcnNlSW5kZXhTaWduYXR1cmUobm9kZSkge1xuICAgIGlmICghKHRoaXMubWF0Y2goMCkgJiYgdGhpcy50c0xvb2tBaGVhZCh0aGlzLnRzSXNVbmFtYmlndW91c2x5SW5kZXhTaWduYXR1cmUuYmluZCh0aGlzKSkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0KDApO1xuICAgIGNvbnN0IGlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICBpZC50eXBlQW5ub3RhdGlvbiA9IHRoaXMudHNQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgdGhpcy5yZXNldEVuZExvY2F0aW9uKGlkKTtcbiAgICB0aGlzLmV4cGVjdCgzKTtcbiAgICBub2RlLnBhcmFtZXRlcnMgPSBbaWRdO1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLnRzVHJ5UGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgIGlmICh0eXBlKSBub2RlLnR5cGVBbm5vdGF0aW9uID0gdHlwZTtcbiAgICB0aGlzLnRzUGFyc2VUeXBlTWVtYmVyU2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTSW5kZXhTaWduYXR1cmVcIik7XG4gIH1cbiAgdHNQYXJzZVByb3BlcnR5T3JNZXRob2RTaWduYXR1cmUobm9kZSwgcmVhZG9ubHkpIHtcbiAgICBpZiAodGhpcy5lYXQoMTcpKSBub2RlLm9wdGlvbmFsID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5tYXRjaCgxMCkgfHwgdGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIGlmIChyZWFkb25seSkge1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlJlYWRvbmx5Rm9yTWV0aG9kU2lnbmF0dXJlLCBub2RlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1ldGhvZCA9IG5vZGU7XG4gICAgICBpZiAobWV0aG9kLmtpbmQgJiYgdGhpcy5tYXRjaCg0NykpIHtcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5BY2Nlc3NvckNhbm5vdEhhdmVUeXBlUGFyYW1ldGVycywgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudHNGaWxsU2lnbmF0dXJlKDE0LCBtZXRob2QpO1xuICAgICAgdGhpcy50c1BhcnNlVHlwZU1lbWJlclNlbWljb2xvbigpO1xuICAgICAgY29uc3QgcGFyYW1zS2V5ID0gXCJwYXJhbWV0ZXJzXCI7XG4gICAgICBjb25zdCByZXR1cm5UeXBlS2V5ID0gXCJ0eXBlQW5ub3RhdGlvblwiO1xuICAgICAgaWYgKG1ldGhvZC5raW5kID09PSBcImdldFwiKSB7XG4gICAgICAgIGlmIChtZXRob2RbcGFyYW1zS2V5XS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQmFkR2V0dGVyQXJpdHksIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgICAgICAgaWYgKHRoaXMuaXNUaGlzUGFyYW0obWV0aG9kW3BhcmFtc0tleV1bMF0pKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkFjY2Vzc29yQ2Fubm90RGVjbGFyZVRoaXNQYXJhbWV0ZXIsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG1ldGhvZC5raW5kID09PSBcInNldFwiKSB7XG4gICAgICAgIGlmIChtZXRob2RbcGFyYW1zS2V5XS5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5CYWRTZXR0ZXJBcml0eSwgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBmaXJzdFBhcmFtZXRlciA9IG1ldGhvZFtwYXJhbXNLZXldWzBdO1xuICAgICAgICAgIGlmICh0aGlzLmlzVGhpc1BhcmFtKGZpcnN0UGFyYW1ldGVyKSkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5BY2Nlc3NvckNhbm5vdERlY2xhcmVUaGlzUGFyYW1ldGVyLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZmlyc3RQYXJhbWV0ZXIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgZmlyc3RQYXJhbWV0ZXIub3B0aW9uYWwpIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuU2V0QWNjZXNzb3JDYW5ub3RIYXZlT3B0aW9uYWxQYXJhbWV0ZXIsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmaXJzdFBhcmFtZXRlci50eXBlID09PSBcIlJlc3RFbGVtZW50XCIpIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuU2V0QWNjZXNzb3JDYW5ub3RIYXZlUmVzdFBhcmFtZXRlciwgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGhvZFtyZXR1cm5UeXBlS2V5XSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuU2V0QWNjZXNzb3JDYW5ub3RIYXZlUmV0dXJuVHlwZSwgbWV0aG9kW3JldHVyblR5cGVLZXldKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWV0aG9kLmtpbmQgPSBcIm1ldGhvZFwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShtZXRob2QsIFwiVFNNZXRob2RTaWduYXR1cmVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHByb3BlcnR5ID0gbm9kZTtcbiAgICAgIGlmIChyZWFkb25seSkgcHJvcGVydHkucmVhZG9ubHkgPSB0cnVlO1xuICAgICAgY29uc3QgdHlwZSA9IHRoaXMudHNUcnlQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgICBpZiAodHlwZSkgcHJvcGVydHkudHlwZUFubm90YXRpb24gPSB0eXBlO1xuICAgICAgdGhpcy50c1BhcnNlVHlwZU1lbWJlclNlbWljb2xvbigpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcm9wZXJ0eSwgXCJUU1Byb3BlcnR5U2lnbmF0dXJlXCIpO1xuICAgIH1cbiAgfVxuICB0c1BhcnNlVHlwZU1lbWJlcigpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBpZiAodGhpcy5tYXRjaCgxMCkgfHwgdGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VTaWduYXR1cmVNZW1iZXIoXCJUU0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvblwiLCBub2RlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF0Y2goNzcpKSB7XG4gICAgICBjb25zdCBpZCA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDEwKSB8fCB0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlU2lnbmF0dXJlTWVtYmVyKFwiVFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvblwiLCBub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUua2V5ID0gdGhpcy5jcmVhdGVJZGVudGlmaWVyKGlkLCBcIm5ld1wiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVByb3BlcnR5T3JNZXRob2RTaWduYXR1cmUobm9kZSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnRzUGFyc2VNb2RpZmllcnMoe1xuICAgICAgYWxsb3dlZE1vZGlmaWVyczogW1wicmVhZG9ubHlcIl0sXG4gICAgICBkaXNhbGxvd2VkTW9kaWZpZXJzOiBbXCJkZWNsYXJlXCIsIFwiYWJzdHJhY3RcIiwgXCJwcml2YXRlXCIsIFwicHJvdGVjdGVkXCIsIFwicHVibGljXCIsIFwic3RhdGljXCIsIFwib3ZlcnJpZGVcIl1cbiAgICB9LCBub2RlKTtcbiAgICBjb25zdCBpZHggPSB0aGlzLnRzVHJ5UGFyc2VJbmRleFNpZ25hdHVyZShub2RlKTtcbiAgICBpZiAoaWR4KSB7XG4gICAgICByZXR1cm4gaWR4O1xuICAgIH1cbiAgICBzdXBlci5wYXJzZVByb3BlcnR5TmFtZShub2RlKTtcbiAgICBpZiAoIW5vZGUuY29tcHV0ZWQgJiYgbm9kZS5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgKG5vZGUua2V5Lm5hbWUgPT09IFwiZ2V0XCIgfHwgbm9kZS5rZXkubmFtZSA9PT0gXCJzZXRcIikgJiYgdGhpcy50c1Rva2VuQ2FuRm9sbG93TW9kaWZpZXIoKSkge1xuICAgICAgbm9kZS5raW5kID0gbm9kZS5rZXkubmFtZTtcbiAgICAgIHN1cGVyLnBhcnNlUHJvcGVydHlOYW1lKG5vZGUpO1xuICAgICAgaWYgKCF0aGlzLm1hdGNoKDEwKSAmJiAhdGhpcy5tYXRjaCg0NykpIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKG51bGwsIDEwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudHNQYXJzZVByb3BlcnR5T3JNZXRob2RTaWduYXR1cmUobm9kZSwgISFub2RlLnJlYWRvbmx5KTtcbiAgfVxuICB0c1BhcnNlVHlwZUxpdGVyYWwoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS5tZW1iZXJzID0gdGhpcy50c1BhcnNlT2JqZWN0VHlwZU1lbWJlcnMoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUeXBlTGl0ZXJhbFwiKTtcbiAgfVxuICB0c1BhcnNlT2JqZWN0VHlwZU1lbWJlcnMoKSB7XG4gICAgdGhpcy5leHBlY3QoNSk7XG4gICAgY29uc3QgbWVtYmVycyA9IHRoaXMudHNQYXJzZUxpc3QoXCJUeXBlTWVtYmVyc1wiLCB0aGlzLnRzUGFyc2VUeXBlTWVtYmVyLmJpbmQodGhpcykpO1xuICAgIHRoaXMuZXhwZWN0KDgpO1xuICAgIHJldHVybiBtZW1iZXJzO1xuICB9XG4gIHRzSXNTdGFydE9mTWFwcGVkVHlwZSgpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy5lYXQoNTMpKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc0NvbnRleHR1YWwoMTIyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEyMikpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMubWF0Y2goMCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKCF0aGlzLnRzSXNJZGVudGlmaWVyKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goNTgpO1xuICB9XG4gIHRzUGFyc2VNYXBwZWRUeXBlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMuZXhwZWN0KDUpO1xuICAgIGlmICh0aGlzLm1hdGNoKDUzKSkge1xuICAgICAgbm9kZS5yZWFkb25seSA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbCgxMjIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5lYXRDb250ZXh0dWFsKDEyMikpIHtcbiAgICAgIG5vZGUucmVhZG9ubHkgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmV4cGVjdCgwKTtcbiAgICB7XG4gICAgICBjb25zdCB0eXBlUGFyYW1ldGVyID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHR5cGVQYXJhbWV0ZXIubmFtZSA9IHRoaXMudHNQYXJzZVR5cGVQYXJhbWV0ZXJOYW1lKCk7XG4gICAgICB0eXBlUGFyYW1ldGVyLmNvbnN0cmFpbnQgPSB0aGlzLnRzRXhwZWN0VGhlblBhcnNlVHlwZSg1OCk7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXIgPSB0aGlzLmZpbmlzaE5vZGUodHlwZVBhcmFtZXRlciwgXCJUU1R5cGVQYXJhbWV0ZXJcIik7XG4gICAgfVxuICAgIG5vZGUubmFtZVR5cGUgPSB0aGlzLmVhdENvbnRleHR1YWwoOTMpID8gdGhpcy50c1BhcnNlVHlwZSgpIDogbnVsbDtcbiAgICB0aGlzLmV4cGVjdCgzKTtcbiAgICBpZiAodGhpcy5tYXRjaCg1MykpIHtcbiAgICAgIG5vZGUub3B0aW9uYWwgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLmV4cGVjdCgxNyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmVhdCgxNykpIHtcbiAgICAgIG5vZGUub3B0aW9uYWwgPSB0cnVlO1xuICAgIH1cbiAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy50c1RyeVBhcnNlVHlwZSgpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgdGhpcy5leHBlY3QoOCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTTWFwcGVkVHlwZVwiKTtcbiAgfVxuICB0c1BhcnNlVHVwbGVUeXBlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUuZWxlbWVudFR5cGVzID0gdGhpcy50c1BhcnNlQnJhY2tldGVkTGlzdChcIlR1cGxlRWxlbWVudFR5cGVzXCIsIHRoaXMudHNQYXJzZVR1cGxlRWxlbWVudFR5cGUuYmluZCh0aGlzKSwgdHJ1ZSwgZmFsc2UpO1xuICAgIGxldCBzZWVuT3B0aW9uYWxFbGVtZW50ID0gZmFsc2U7XG4gICAgbm9kZS5lbGVtZW50VHlwZXMuZm9yRWFjaChlbGVtZW50Tm9kZSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHR5cGVcbiAgICAgIH0gPSBlbGVtZW50Tm9kZTtcbiAgICAgIGlmIChzZWVuT3B0aW9uYWxFbGVtZW50ICYmIHR5cGUgIT09IFwiVFNSZXN0VHlwZVwiICYmIHR5cGUgIT09IFwiVFNPcHRpb25hbFR5cGVcIiAmJiAhKHR5cGUgPT09IFwiVFNOYW1lZFR1cGxlTWVtYmVyXCIgJiYgZWxlbWVudE5vZGUub3B0aW9uYWwpKSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuT3B0aW9uYWxUeXBlQmVmb3JlUmVxdWlyZWQsIGVsZW1lbnROb2RlKTtcbiAgICAgIH1cbiAgICAgIHNlZW5PcHRpb25hbEVsZW1lbnQgfHwgKHNlZW5PcHRpb25hbEVsZW1lbnQgPSB0eXBlID09PSBcIlRTTmFtZWRUdXBsZU1lbWJlclwiICYmIGVsZW1lbnROb2RlLm9wdGlvbmFsIHx8IHR5cGUgPT09IFwiVFNPcHRpb25hbFR5cGVcIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHVwbGVUeXBlXCIpO1xuICB9XG4gIHRzUGFyc2VUdXBsZUVsZW1lbnRUeXBlKCkge1xuICAgIGNvbnN0IHJlc3RTdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgcmVzdCA9IHRoaXMuZWF0KDIxKTtcbiAgICBjb25zdCB7XG4gICAgICBzdGFydExvY1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCBsYWJlbGVkO1xuICAgIGxldCBsYWJlbDtcbiAgICBsZXQgb3B0aW9uYWw7XG4gICAgbGV0IHR5cGU7XG4gICAgY29uc3QgaXNXb3JkID0gdG9rZW5Jc0tleXdvcmRPcklkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKTtcbiAgICBjb25zdCBjaEFmdGVyV29yZCA9IGlzV29yZCA/IHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKSA6IG51bGw7XG4gICAgaWYgKGNoQWZ0ZXJXb3JkID09PSA1OCkge1xuICAgICAgbGFiZWxlZCA9IHRydWU7XG4gICAgICBvcHRpb25hbCA9IGZhbHNlO1xuICAgICAgbGFiZWwgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICAgIHRoaXMuZXhwZWN0KDE0KTtcbiAgICAgIHR5cGUgPSB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgfSBlbHNlIGlmIChjaEFmdGVyV29yZCA9PT0gNjMpIHtcbiAgICAgIG9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHdvcmROYW1lID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICAgIGNvbnN0IHR5cGVPckxhYmVsID0gdGhpcy50c1BhcnNlTm9uQXJyYXlUeXBlKCk7XG4gICAgICBpZiAodGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpID09PSA1OCkge1xuICAgICAgICBsYWJlbGVkID0gdHJ1ZTtcbiAgICAgICAgbGFiZWwgPSB0aGlzLmNyZWF0ZUlkZW50aWZpZXIodGhpcy5zdGFydE5vZGVBdChzdGFydExvYyksIHdvcmROYW1lKTtcbiAgICAgICAgdGhpcy5leHBlY3QoMTcpO1xuICAgICAgICB0aGlzLmV4cGVjdCgxNCk7XG4gICAgICAgIHR5cGUgPSB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYWJlbGVkID0gZmFsc2U7XG4gICAgICAgIHR5cGUgPSB0eXBlT3JMYWJlbDtcbiAgICAgICAgdGhpcy5leHBlY3QoMTcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlID0gdGhpcy50c1BhcnNlVHlwZSgpO1xuICAgICAgb3B0aW9uYWwgPSB0aGlzLmVhdCgxNyk7XG4gICAgICBsYWJlbGVkID0gdGhpcy5lYXQoMTQpO1xuICAgIH1cbiAgICBpZiAobGFiZWxlZCkge1xuICAgICAgbGV0IGxhYmVsZWROb2RlO1xuICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgIGxhYmVsZWROb2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICAgIGxhYmVsZWROb2RlLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgICAgIGxhYmVsZWROb2RlLmxhYmVsID0gbGFiZWw7XG4gICAgICAgIGxhYmVsZWROb2RlLmVsZW1lbnRUeXBlID0gdHlwZTtcbiAgICAgICAgaWYgKHRoaXMuZWF0KDE3KSkge1xuICAgICAgICAgIGxhYmVsZWROb2RlLm9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlR1cGxlT3B0aW9uYWxBZnRlclR5cGUsIHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0TG9jKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFiZWxlZE5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgICAgbGFiZWxlZE5vZGUub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5JbnZhbGlkVHVwbGVNZW1iZXJMYWJlbCwgdHlwZSk7XG4gICAgICAgIGxhYmVsZWROb2RlLmxhYmVsID0gdHlwZTtcbiAgICAgICAgbGFiZWxlZE5vZGUuZWxlbWVudFR5cGUgPSB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgICB9XG4gICAgICB0eXBlID0gdGhpcy5maW5pc2hOb2RlKGxhYmVsZWROb2RlLCBcIlRTTmFtZWRUdXBsZU1lbWJlclwiKTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbmFsKSB7XG4gICAgICBjb25zdCBvcHRpb25hbFR5cGVOb2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICBvcHRpb25hbFR5cGVOb2RlLnR5cGVBbm5vdGF0aW9uID0gdHlwZTtcbiAgICAgIHR5cGUgPSB0aGlzLmZpbmlzaE5vZGUob3B0aW9uYWxUeXBlTm9kZSwgXCJUU09wdGlvbmFsVHlwZVwiKTtcbiAgICB9XG4gICAgaWYgKHJlc3QpIHtcbiAgICAgIGNvbnN0IHJlc3ROb2RlID0gdGhpcy5zdGFydE5vZGVBdChyZXN0U3RhcnRMb2MpO1xuICAgICAgcmVzdE5vZGUudHlwZUFubm90YXRpb24gPSB0eXBlO1xuICAgICAgdHlwZSA9IHRoaXMuZmluaXNoTm9kZShyZXN0Tm9kZSwgXCJUU1Jlc3RUeXBlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICB0c1BhcnNlUGFyZW50aGVzaXplZFR5cGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5leHBlY3QoMTApO1xuICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgdGhpcy5leHBlY3QoMTEpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU1BhcmVudGhlc2l6ZWRUeXBlXCIpO1xuICB9XG4gIHRzUGFyc2VGdW5jdGlvbk9yQ29uc3RydWN0b3JUeXBlKHR5cGUsIGFic3RyYWN0KSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKHR5cGUgPT09IFwiVFNDb25zdHJ1Y3RvclR5cGVcIikge1xuICAgICAgbm9kZS5hYnN0cmFjdCA9ICEhYWJzdHJhY3Q7XG4gICAgICBpZiAoYWJzdHJhY3QpIHRoaXMubmV4dCgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIHRoaXMudHNJbkFsbG93Q29uZGl0aW9uYWxUeXBlc0NvbnRleHQoKCkgPT4gdGhpcy50c0ZpbGxTaWduYXR1cmUoMTksIG5vZGUpKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIHR5cGUpO1xuICB9XG4gIHRzUGFyc2VMaXRlcmFsVHlwZU5vZGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlLnR5cGUpIHtcbiAgICAgIGNhc2UgMTM1OlxuICAgICAgY2FzZSAxMzY6XG4gICAgICBjYXNlIDEzNDpcbiAgICAgIGNhc2UgODU6XG4gICAgICBjYXNlIDg2OlxuICAgICAgICBub2RlLmxpdGVyYWwgPSBzdXBlci5wYXJzZUV4cHJBdG9tKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0xpdGVyYWxUeXBlXCIpO1xuICB9XG4gIHRzUGFyc2VUZW1wbGF0ZUxpdGVyYWxUeXBlKCkge1xuICAgIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgbm9kZS5saXRlcmFsID0gc3VwZXIucGFyc2VUZW1wbGF0ZShmYWxzZSk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNMaXRlcmFsVHlwZVwiKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VUZW1wbGF0ZVN1YnN0aXR1dGlvbigpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5pblR5cGUpIHJldHVybiB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlVGVtcGxhdGVTdWJzdGl0dXRpb24oKTtcbiAgfVxuICB0c1BhcnNlVGhpc1R5cGVPclRoaXNUeXBlUHJlZGljYXRlKCkge1xuICAgIGNvbnN0IHRoaXNLZXl3b3JkID0gdGhpcy50c1BhcnNlVGhpc1R5cGVOb2RlKCk7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDExNikgJiYgIXRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUaGlzVHlwZVByZWRpY2F0ZSh0aGlzS2V5d29yZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzS2V5d29yZDtcbiAgICB9XG4gIH1cbiAgdHNQYXJzZU5vbkFycmF5VHlwZSgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUudHlwZSkge1xuICAgICAgY2FzZSAxMzQ6XG4gICAgICBjYXNlIDEzNTpcbiAgICAgIGNhc2UgMTM2OlxuICAgICAgY2FzZSA4NTpcbiAgICAgIGNhc2UgODY6XG4gICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VMaXRlcmFsVHlwZU5vZGUoKTtcbiAgICAgIGNhc2UgNTM6XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnZhbHVlID09PSBcIi1cIikge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICAgIGNvbnN0IG5leHRUb2tlbiA9IHRoaXMubG9va2FoZWFkKCk7XG4gICAgICAgICAgaWYgKG5leHRUb2tlbi50eXBlICE9PSAxMzUgJiYgbmV4dFRva2VuLnR5cGUgIT09IDEzNikge1xuICAgICAgICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUubGl0ZXJhbCA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTTGl0ZXJhbFR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDc4OlxuICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlVGhpc1R5cGVPclRoaXNUeXBlUHJlZGljYXRlKCk7XG4gICAgICBjYXNlIDg3OlxuICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlVHlwZVF1ZXJ5KCk7XG4gICAgICBjYXNlIDgzOlxuICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlSW1wb3J0VHlwZSgpO1xuICAgICAgY2FzZSA1OlxuICAgICAgICByZXR1cm4gdGhpcy50c0xvb2tBaGVhZCh0aGlzLnRzSXNTdGFydE9mTWFwcGVkVHlwZS5iaW5kKHRoaXMpKSA/IHRoaXMudHNQYXJzZU1hcHBlZFR5cGUoKSA6IHRoaXMudHNQYXJzZVR5cGVMaXRlcmFsKCk7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUdXBsZVR5cGUoKTtcbiAgICAgIGNhc2UgMTA6XG4gICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VQYXJlbnRoZXNpemVkVHlwZSgpO1xuICAgICAgY2FzZSAyNTpcbiAgICAgIGNhc2UgMjQ6XG4gICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUZW1wbGF0ZUxpdGVyYWxUeXBlKCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdHlwZVxuICAgICAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgIGlmICh0b2tlbklzSWRlbnRpZmllcih0eXBlKSB8fCB0eXBlID09PSA4OCB8fCB0eXBlID09PSA4NCkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZVR5cGUgPSB0eXBlID09PSA4OCA/IFwiVFNWb2lkS2V5d29yZFwiIDogdHlwZSA9PT0gODQgPyBcIlRTTnVsbEtleXdvcmRcIiA6IGtleXdvcmRUeXBlRnJvbU5hbWUodGhpcy5zdGF0ZS52YWx1ZSk7XG4gICAgICAgICAgICBpZiAobm9kZVR5cGUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgIT09IDQ2KSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBub2RlVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlVHlwZVJlZmVyZW5jZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxuICB0c1BhcnNlQXJyYXlUeXBlT3JIaWdoZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3RhcnRMb2NcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBsZXQgdHlwZSA9IHRoaXMudHNQYXJzZU5vbkFycmF5VHlwZSgpO1xuICAgIHdoaWxlICghdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSAmJiB0aGlzLmVhdCgwKSkge1xuICAgICAgaWYgKHRoaXMubWF0Y2goMykpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgICBub2RlLmVsZW1lbnRUeXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5leHBlY3QoMyk7XG4gICAgICAgIHR5cGUgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0FycmF5VHlwZVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgICAgbm9kZS5vYmplY3RUeXBlID0gdHlwZTtcbiAgICAgICAgbm9kZS5pbmRleFR5cGUgPSB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgICAgIHRoaXMuZXhwZWN0KDMpO1xuICAgICAgICB0eXBlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNJbmRleGVkQWNjZXNzVHlwZVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgdHNQYXJzZVR5cGVPcGVyYXRvcigpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCBvcGVyYXRvciA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLnRzUGFyc2VUeXBlT3BlcmF0b3JPckhpZ2hlcigpO1xuICAgIGlmIChvcGVyYXRvciA9PT0gXCJyZWFkb25seVwiKSB7XG4gICAgICB0aGlzLnRzQ2hlY2tUeXBlQW5ub3RhdGlvbkZvclJlYWRPbmx5KG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUeXBlT3BlcmF0b3JcIik7XG4gIH1cbiAgdHNDaGVja1R5cGVBbm5vdGF0aW9uRm9yUmVhZE9ubHkobm9kZSkge1xuICAgIHN3aXRjaCAobm9kZS50eXBlQW5ub3RhdGlvbi50eXBlKSB7XG4gICAgICBjYXNlIFwiVFNUdXBsZVR5cGVcIjpcbiAgICAgIGNhc2UgXCJUU0FycmF5VHlwZVwiOlxuICAgICAgICByZXR1cm47XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlVuZXhwZWN0ZWRSZWFkb25seSwgbm9kZSk7XG4gICAgfVxuICB9XG4gIHRzUGFyc2VJbmZlclR5cGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKDExNSk7XG4gICAgY29uc3QgdHlwZVBhcmFtZXRlciA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdHlwZVBhcmFtZXRlci5uYW1lID0gdGhpcy50c1BhcnNlVHlwZVBhcmFtZXRlck5hbWUoKTtcbiAgICB0eXBlUGFyYW1ldGVyLmNvbnN0cmFpbnQgPSB0aGlzLnRzVHJ5UGFyc2UoKCkgPT4gdGhpcy50c1BhcnNlQ29uc3RyYWludEZvckluZmVyVHlwZSgpKTtcbiAgICBub2RlLnR5cGVQYXJhbWV0ZXIgPSB0aGlzLmZpbmlzaE5vZGUodHlwZVBhcmFtZXRlciwgXCJUU1R5cGVQYXJhbWV0ZXJcIik7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTSW5mZXJUeXBlXCIpO1xuICB9XG4gIHRzUGFyc2VDb25zdHJhaW50Rm9ySW5mZXJUeXBlKCkge1xuICAgIGlmICh0aGlzLmVhdCg4MSkpIHtcbiAgICAgIGNvbnN0IGNvbnN0cmFpbnQgPSB0aGlzLnRzSW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0KCgpID0+IHRoaXMudHNQYXJzZVR5cGUoKSk7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5pbkRpc2FsbG93Q29uZGl0aW9uYWxUeXBlc0NvbnRleHQgfHwgIXRoaXMubWF0Y2goMTcpKSB7XG4gICAgICAgIHJldHVybiBjb25zdHJhaW50O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0c1BhcnNlVHlwZU9wZXJhdG9yT3JIaWdoZXIoKSB7XG4gICAgY29uc3QgaXNUeXBlT3BlcmF0b3IgPSB0b2tlbklzVFNUeXBlT3BlcmF0b3IodGhpcy5zdGF0ZS50eXBlKSAmJiAhdGhpcy5zdGF0ZS5jb250YWluc0VzYztcbiAgICByZXR1cm4gaXNUeXBlT3BlcmF0b3IgPyB0aGlzLnRzUGFyc2VUeXBlT3BlcmF0b3IoKSA6IHRoaXMuaXNDb250ZXh0dWFsKDExNSkgPyB0aGlzLnRzUGFyc2VJbmZlclR5cGUoKSA6IHRoaXMudHNJbkFsbG93Q29uZGl0aW9uYWxUeXBlc0NvbnRleHQoKCkgPT4gdGhpcy50c1BhcnNlQXJyYXlUeXBlT3JIaWdoZXIoKSk7XG4gIH1cbiAgdHNQYXJzZVVuaW9uT3JJbnRlcnNlY3Rpb25UeXBlKGtpbmQsIHBhcnNlQ29uc3RpdHVlbnRUeXBlLCBvcGVyYXRvcikge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGNvbnN0IGhhc0xlYWRpbmdPcGVyYXRvciA9IHRoaXMuZWF0KG9wZXJhdG9yKTtcbiAgICBjb25zdCB0eXBlcyA9IFtdO1xuICAgIGRvIHtcbiAgICAgIHR5cGVzLnB1c2gocGFyc2VDb25zdGl0dWVudFR5cGUoKSk7XG4gICAgfSB3aGlsZSAodGhpcy5lYXQob3BlcmF0b3IpKTtcbiAgICBpZiAodHlwZXMubGVuZ3RoID09PSAxICYmICFoYXNMZWFkaW5nT3BlcmF0b3IpIHtcbiAgICAgIHJldHVybiB0eXBlc1swXTtcbiAgICB9XG4gICAgbm9kZS50eXBlcyA9IHR5cGVzO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwga2luZCk7XG4gIH1cbiAgdHNQYXJzZUludGVyc2VjdGlvblR5cGVPckhpZ2hlcigpIHtcbiAgICByZXR1cm4gdGhpcy50c1BhcnNlVW5pb25PckludGVyc2VjdGlvblR5cGUoXCJUU0ludGVyc2VjdGlvblR5cGVcIiwgdGhpcy50c1BhcnNlVHlwZU9wZXJhdG9yT3JIaWdoZXIuYmluZCh0aGlzKSwgNDUpO1xuICB9XG4gIHRzUGFyc2VVbmlvblR5cGVPckhpZ2hlcigpIHtcbiAgICByZXR1cm4gdGhpcy50c1BhcnNlVW5pb25PckludGVyc2VjdGlvblR5cGUoXCJUU1VuaW9uVHlwZVwiLCB0aGlzLnRzUGFyc2VJbnRlcnNlY3Rpb25UeXBlT3JIaWdoZXIuYmluZCh0aGlzKSwgNDMpO1xuICB9XG4gIHRzSXNTdGFydE9mRnVuY3Rpb25UeXBlKCkge1xuICAgIGlmICh0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1hdGNoKDEwKSAmJiB0aGlzLnRzTG9va0FoZWFkKHRoaXMudHNJc1VuYW1iaWd1b3VzbHlTdGFydE9mRnVuY3Rpb25UeXBlLmJpbmQodGhpcykpO1xuICB9XG4gIHRzU2tpcFBhcmFtZXRlclN0YXJ0KCkge1xuICAgIGlmICh0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpIHx8IHRoaXMubWF0Y2goNzgpKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXRjaCg1KSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBlcnJvcnNcbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3QgcHJldmlvdXNFcnJvckNvdW50ID0gZXJyb3JzLmxlbmd0aDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMucGFyc2VPYmplY3RMaWtlKDgsIHRydWUpO1xuICAgICAgICByZXR1cm4gZXJyb3JzLmxlbmd0aCA9PT0gcHJldmlvdXNFcnJvckNvdW50O1xuICAgICAgfSBjYXRjaCAoX3VudXNlZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLm1hdGNoKDApKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZXJyb3JzXG4gICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGNvbnN0IHByZXZpb3VzRXJyb3JDb3VudCA9IGVycm9ycy5sZW5ndGg7XG4gICAgICB0cnkge1xuICAgICAgICBzdXBlci5wYXJzZUJpbmRpbmdMaXN0KDMsIDkzLCAxKTtcbiAgICAgICAgcmV0dXJuIGVycm9ycy5sZW5ndGggPT09IHByZXZpb3VzRXJyb3JDb3VudDtcbiAgICAgIH0gY2F0Y2ggKF91bnVzZWQyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRzSXNVbmFtYmlndW91c2x5U3RhcnRPZkZ1bmN0aW9uVHlwZSgpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy5tYXRjaCgxMSkgfHwgdGhpcy5tYXRjaCgyMSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy50c1NraXBQYXJhbWV0ZXJTdGFydCgpKSB7XG4gICAgICBpZiAodGhpcy5tYXRjaCgxNCkgfHwgdGhpcy5tYXRjaCgxMikgfHwgdGhpcy5tYXRjaCgxNykgfHwgdGhpcy5tYXRjaCgyOSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tYXRjaCgxMSkpIHtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIGlmICh0aGlzLm1hdGNoKDE5KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0c1BhcnNlVHlwZU9yVHlwZVByZWRpY2F0ZUFubm90YXRpb24ocmV0dXJuVG9rZW4pIHtcbiAgICByZXR1cm4gdGhpcy50c0luVHlwZSgoKSA9PiB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMuZXhwZWN0KHJldHVyblRva2VuKTtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgY29uc3QgYXNzZXJ0cyA9ICEhdGhpcy50c1RyeVBhcnNlKHRoaXMudHNQYXJzZVR5cGVQcmVkaWNhdGVBc3NlcnRzLmJpbmQodGhpcykpO1xuICAgICAgaWYgKGFzc2VydHMgJiYgdGhpcy5tYXRjaCg3OCkpIHtcbiAgICAgICAgbGV0IHRoaXNUeXBlUHJlZGljYXRlID0gdGhpcy50c1BhcnNlVGhpc1R5cGVPclRoaXNUeXBlUHJlZGljYXRlKCk7XG4gICAgICAgIGlmICh0aGlzVHlwZVByZWRpY2F0ZS50eXBlID09PSBcIlRTVGhpc1R5cGVcIikge1xuICAgICAgICAgIG5vZGUucGFyYW1ldGVyTmFtZSA9IHRoaXNUeXBlUHJlZGljYXRlO1xuICAgICAgICAgIG5vZGUuYXNzZXJ0cyA9IHRydWU7XG4gICAgICAgICAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IG51bGw7XG4gICAgICAgICAgdGhpc1R5cGVQcmVkaWNhdGUgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU1R5cGVQcmVkaWNhdGVcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZXNldFN0YXJ0TG9jYXRpb25Gcm9tTm9kZSh0aGlzVHlwZVByZWRpY2F0ZSwgbm9kZSk7XG4gICAgICAgICAgdGhpc1R5cGVQcmVkaWNhdGUuYXNzZXJ0cyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdC50eXBlQW5ub3RhdGlvbiA9IHRoaXNUeXBlUHJlZGljYXRlO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHQsIFwiVFNUeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHR5cGVQcmVkaWNhdGVWYXJpYWJsZSA9IHRoaXMudHNJc0lkZW50aWZpZXIoKSAmJiB0aGlzLnRzVHJ5UGFyc2UodGhpcy50c1BhcnNlVHlwZVByZWRpY2F0ZVByZWZpeC5iaW5kKHRoaXMpKTtcbiAgICAgIGlmICghdHlwZVByZWRpY2F0ZVZhcmlhYmxlKSB7XG4gICAgICAgIGlmICghYXNzZXJ0cykge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUeXBlQW5ub3RhdGlvbihmYWxzZSwgdCk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5wYXJhbWV0ZXJOYW1lID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgICAgbm9kZS5hc3NlcnRzID0gYXNzZXJ0cztcbiAgICAgICAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IG51bGw7XG4gICAgICAgIHQudHlwZUFubm90YXRpb24gPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU1R5cGVQcmVkaWNhdGVcIik7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUodCwgXCJUU1R5cGVBbm5vdGF0aW9uXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgdHlwZSA9IHRoaXMudHNQYXJzZVR5cGVBbm5vdGF0aW9uKGZhbHNlKTtcbiAgICAgIG5vZGUucGFyYW1ldGVyTmFtZSA9IHR5cGVQcmVkaWNhdGVWYXJpYWJsZTtcbiAgICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0eXBlO1xuICAgICAgbm9kZS5hc3NlcnRzID0gYXNzZXJ0cztcbiAgICAgIHQudHlwZUFubm90YXRpb24gPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU1R5cGVQcmVkaWNhdGVcIik7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHQsIFwiVFNUeXBlQW5ub3RhdGlvblwiKTtcbiAgICB9KTtcbiAgfVxuICB0c1RyeVBhcnNlVHlwZU9yVHlwZVByZWRpY2F0ZUFubm90YXRpb24oKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICByZXR1cm4gdGhpcy50c1BhcnNlVHlwZU9yVHlwZVByZWRpY2F0ZUFubm90YXRpb24oMTQpO1xuICAgIH1cbiAgfVxuICB0c1RyeVBhcnNlVHlwZUFubm90YXRpb24oKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICByZXR1cm4gdGhpcy50c1BhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICB9XG4gIH1cbiAgdHNUcnlQYXJzZVR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHNFYXRUaGVuUGFyc2VUeXBlKDE0KTtcbiAgfVxuICB0c1BhcnNlVHlwZVByZWRpY2F0ZVByZWZpeCgpIHtcbiAgICBjb25zdCBpZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDExNikgJiYgIXRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgfVxuICB0c1BhcnNlVHlwZVByZWRpY2F0ZUFzc2VydHMoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUudHlwZSAhPT0gMTA5KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRhaW5zRXNjID0gdGhpcy5zdGF0ZS5jb250YWluc0VzYztcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAoIXRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkgJiYgIXRoaXMubWF0Y2goNzgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChjb250YWluc0VzYykge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW52YWxpZEVzY2FwZWRSZXNlcnZlZFdvcmQsIHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0TG9jLCB7XG4gICAgICAgIHJlc2VydmVkV29yZDogXCJhc3NlcnRzXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0c1BhcnNlVHlwZUFubm90YXRpb24oZWF0Q29sb24gPSB0cnVlLCB0ID0gdGhpcy5zdGFydE5vZGUoKSkge1xuICAgIHRoaXMudHNJblR5cGUoKCkgPT4ge1xuICAgICAgaWYgKGVhdENvbG9uKSB0aGlzLmV4cGVjdCgxNCk7XG4gICAgICB0LnR5cGVBbm5vdGF0aW9uID0gdGhpcy50c1BhcnNlVHlwZSgpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUodCwgXCJUU1R5cGVBbm5vdGF0aW9uXCIpO1xuICB9XG4gIHRzUGFyc2VUeXBlKCkge1xuICAgIGFzc2VydCh0aGlzLnN0YXRlLmluVHlwZSk7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMudHNQYXJzZU5vbkNvbmRpdGlvbmFsVHlwZSgpO1xuICAgIGlmICh0aGlzLnN0YXRlLmluRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dCB8fCB0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpIHx8ICF0aGlzLmVhdCg4MSkpIHtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdE5vZGUodHlwZSk7XG4gICAgbm9kZS5jaGVja1R5cGUgPSB0eXBlO1xuICAgIG5vZGUuZXh0ZW5kc1R5cGUgPSB0aGlzLnRzSW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0KCgpID0+IHRoaXMudHNQYXJzZU5vbkNvbmRpdGlvbmFsVHlwZSgpKTtcbiAgICB0aGlzLmV4cGVjdCgxNyk7XG4gICAgbm9kZS50cnVlVHlwZSA9IHRoaXMudHNJbkFsbG93Q29uZGl0aW9uYWxUeXBlc0NvbnRleHQoKCkgPT4gdGhpcy50c1BhcnNlVHlwZSgpKTtcbiAgICB0aGlzLmV4cGVjdCgxNCk7XG4gICAgbm9kZS5mYWxzZVR5cGUgPSB0aGlzLnRzSW5BbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0KCgpID0+IHRoaXMudHNQYXJzZVR5cGUoKSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTQ29uZGl0aW9uYWxUeXBlXCIpO1xuICB9XG4gIGlzQWJzdHJhY3RDb25zdHJ1Y3RvclNpZ25hdHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0NvbnRleHR1YWwoMTI0KSAmJiB0aGlzLmlzTG9va2FoZWFkQ29udGV4dHVhbChcIm5ld1wiKTtcbiAgfVxuICB0c1BhcnNlTm9uQ29uZGl0aW9uYWxUeXBlKCkge1xuICAgIGlmICh0aGlzLnRzSXNTdGFydE9mRnVuY3Rpb25UeXBlKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VGdW5jdGlvbk9yQ29uc3RydWN0b3JUeXBlKFwiVFNGdW5jdGlvblR5cGVcIik7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hdGNoKDc3KSkge1xuICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZUZ1bmN0aW9uT3JDb25zdHJ1Y3RvclR5cGUoXCJUU0NvbnN0cnVjdG9yVHlwZVwiKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNBYnN0cmFjdENvbnN0cnVjdG9yU2lnbmF0dXJlKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VGdW5jdGlvbk9yQ29uc3RydWN0b3JUeXBlKFwiVFNDb25zdHJ1Y3RvclR5cGVcIiwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRzUGFyc2VVbmlvblR5cGVPckhpZ2hlcigpO1xuICB9XG4gIHRzUGFyc2VUeXBlQXNzZXJ0aW9uKCkge1xuICAgIGlmICh0aGlzLmdldFBsdWdpbk9wdGlvbihcInR5cGVzY3JpcHRcIiwgXCJkaXNhbGxvd0FtYmlndW91c0pTWExpa2VcIikpIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuUmVzZXJ2ZWRUeXBlQXNzZXJ0aW9uLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHRoaXMudHNJblR5cGUoKCkgPT4ge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5tYXRjaCg3NSkgPyB0aGlzLnRzUGFyc2VUeXBlUmVmZXJlbmNlKCkgOiB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgfSk7XG4gICAgdGhpcy5leHBlY3QoNDgpO1xuICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHlwZUFzc2VydGlvblwiKTtcbiAgfVxuICB0c1BhcnNlSGVyaXRhZ2VDbGF1c2UodG9rZW4pIHtcbiAgICBjb25zdCBvcmlnaW5hbFN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBjb25zdCBkZWxpbWl0ZWRMaXN0ID0gdGhpcy50c1BhcnNlRGVsaW1pdGVkTGlzdChcIkhlcml0YWdlQ2xhdXNlRWxlbWVudFwiLCAoKSA9PiB7XG4gICAgICB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICBub2RlLmV4cHJlc3Npb24gPSB0aGlzLnRzUGFyc2VFbnRpdHlOYW1lKDEgfCAyKTtcbiAgICAgICAgaWYgKHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMudHNQYXJzZVR5cGVBcmd1bWVudHMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHNcIik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFkZWxpbWl0ZWRMaXN0Lmxlbmd0aCkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5FbXB0eUhlcml0YWdlQ2xhdXNlVHlwZSwgb3JpZ2luYWxTdGFydExvYywge1xuICAgICAgICB0b2tlblxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBkZWxpbWl0ZWRMaXN0O1xuICB9XG4gIHRzUGFyc2VJbnRlcmZhY2VEZWNsYXJhdGlvbihub2RlLCBwcm9wZXJ0aWVzID0ge30pIHtcbiAgICBpZiAodGhpcy5oYXNGb2xsb3dpbmdMaW5lQnJlYWsoKSkgcmV0dXJuIG51bGw7XG4gICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKDEyOSk7XG4gICAgaWYgKHByb3BlcnRpZXMuZGVjbGFyZSkgbm9kZS5kZWNsYXJlID0gdHJ1ZTtcbiAgICBpZiAodG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgbm9kZS5pZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICB0aGlzLmNoZWNrSWRlbnRpZmllcihub2RlLmlkLCAxMzApO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmlkID0gbnVsbDtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuTWlzc2luZ0ludGVyZmFjZU5hbWUsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgIH1cbiAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1RyeVBhcnNlVHlwZVBhcmFtZXRlcnModGhpcy50c1BhcnNlSW5PdXRDb25zdE1vZGlmaWVycyk7XG4gICAgaWYgKHRoaXMuZWF0KDgxKSkge1xuICAgICAgbm9kZS5leHRlbmRzID0gdGhpcy50c1BhcnNlSGVyaXRhZ2VDbGF1c2UoXCJleHRlbmRzXCIpO1xuICAgIH1cbiAgICBjb25zdCBib2R5ID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBib2R5LmJvZHkgPSB0aGlzLnRzSW5UeXBlKHRoaXMudHNQYXJzZU9iamVjdFR5cGVNZW1iZXJzLmJpbmQodGhpcykpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMuZmluaXNoTm9kZShib2R5LCBcIlRTSW50ZXJmYWNlQm9keVwiKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNJbnRlcmZhY2VEZWNsYXJhdGlvblwiKTtcbiAgfVxuICB0c1BhcnNlVHlwZUFsaWFzRGVjbGFyYXRpb24obm9kZSkge1xuICAgIG5vZGUuaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgIHRoaXMuY2hlY2tJZGVudGlmaWVyKG5vZGUuaWQsIDIpO1xuICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLnRzSW5UeXBlKCgpID0+IHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLnRzVHJ5UGFyc2VUeXBlUGFyYW1ldGVycyh0aGlzLnRzUGFyc2VJbk91dE1vZGlmaWVycyk7XG4gICAgICB0aGlzLmV4cGVjdCgyOSk7XG4gICAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTE0KSAmJiB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgIT09IDQ2KSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTSW50cmluc2ljS2V5d29yZFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgfSk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUeXBlQWxpYXNEZWNsYXJhdGlvblwiKTtcbiAgfVxuICB0c0luVG9wTGV2ZWxDb250ZXh0KGNiKSB7XG4gICAgaWYgKHRoaXMuY3VyQ29udGV4dCgpICE9PSB0eXBlcy5icmFjZSkge1xuICAgICAgY29uc3Qgb2xkQ29udGV4dCA9IHRoaXMuc3RhdGUuY29udGV4dDtcbiAgICAgIHRoaXMuc3RhdGUuY29udGV4dCA9IFtvbGRDb250ZXh0WzBdXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjYigpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5zdGF0ZS5jb250ZXh0ID0gb2xkQ29udGV4dDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNiKCk7XG4gICAgfVxuICB9XG4gIHRzSW5UeXBlKGNiKSB7XG4gICAgY29uc3Qgb2xkSW5UeXBlID0gdGhpcy5zdGF0ZS5pblR5cGU7XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY2IoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5zdGF0ZS5pblR5cGUgPSBvbGRJblR5cGU7XG4gICAgfVxuICB9XG4gIHRzSW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0KGNiKSB7XG4gICAgY29uc3Qgb2xkSW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0ID0gdGhpcy5zdGF0ZS5pbkRpc2FsbG93Q29uZGl0aW9uYWxUeXBlc0NvbnRleHQ7XG4gICAgdGhpcy5zdGF0ZS5pbkRpc2FsbG93Q29uZGl0aW9uYWxUeXBlc0NvbnRleHQgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY2IoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5zdGF0ZS5pbkRpc2FsbG93Q29uZGl0aW9uYWxUeXBlc0NvbnRleHQgPSBvbGRJbkRpc2FsbG93Q29uZGl0aW9uYWxUeXBlc0NvbnRleHQ7XG4gICAgfVxuICB9XG4gIHRzSW5BbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0KGNiKSB7XG4gICAgY29uc3Qgb2xkSW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0ID0gdGhpcy5zdGF0ZS5pbkRpc2FsbG93Q29uZGl0aW9uYWxUeXBlc0NvbnRleHQ7XG4gICAgdGhpcy5zdGF0ZS5pbkRpc2FsbG93Q29uZGl0aW9uYWxUeXBlc0NvbnRleHQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNiKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuc3RhdGUuaW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0ID0gb2xkSW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0O1xuICAgIH1cbiAgfVxuICB0c0VhdFRoZW5QYXJzZVR5cGUodG9rZW4pIHtcbiAgICBpZiAodGhpcy5tYXRjaCh0b2tlbikpIHtcbiAgICAgIHJldHVybiB0aGlzLnRzTmV4dFRoZW5QYXJzZVR5cGUoKTtcbiAgICB9XG4gIH1cbiAgdHNFeHBlY3RUaGVuUGFyc2VUeXBlKHRva2VuKSB7XG4gICAgcmV0dXJuIHRoaXMudHNJblR5cGUoKCkgPT4ge1xuICAgICAgdGhpcy5leHBlY3QodG9rZW4pO1xuICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVR5cGUoKTtcbiAgICB9KTtcbiAgfVxuICB0c05leHRUaGVuUGFyc2VUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLnRzSW5UeXBlKCgpID0+IHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVR5cGUoKTtcbiAgICB9KTtcbiAgfVxuICB0c1BhcnNlRW51bU1lbWJlcigpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLmlkID0gdGhpcy5tYXRjaCgxMzQpID8gc3VwZXIucGFyc2VTdHJpbmdMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpIDogdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG4gICAgaWYgKHRoaXMuZWF0KDI5KSkge1xuICAgICAgbm9kZS5pbml0aWFsaXplciA9IHN1cGVyLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0VudW1NZW1iZXJcIik7XG4gIH1cbiAgdHNQYXJzZUVudW1EZWNsYXJhdGlvbihub2RlLCBwcm9wZXJ0aWVzID0ge30pIHtcbiAgICBpZiAocHJvcGVydGllcy5jb25zdCkgbm9kZS5jb25zdCA9IHRydWU7XG4gICAgaWYgKHByb3BlcnRpZXMuZGVjbGFyZSkgbm9kZS5kZWNsYXJlID0gdHJ1ZTtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoMTI2KTtcbiAgICBub2RlLmlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICB0aGlzLmNoZWNrSWRlbnRpZmllcihub2RlLmlkLCBub2RlLmNvbnN0ID8gODk3MSA6IDg0NTkpO1xuICAgIHtcbiAgICAgIHRoaXMuZXhwZWN0KDUpO1xuICAgICAgbm9kZS5tZW1iZXJzID0gdGhpcy50c1BhcnNlRGVsaW1pdGVkTGlzdChcIkVudW1NZW1iZXJzXCIsIHRoaXMudHNQYXJzZUVudW1NZW1iZXIuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmV4cGVjdCg4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTRW51bURlY2xhcmF0aW9uXCIpO1xuICB9XG4gIHRzUGFyc2VFbnVtQm9keSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLmV4cGVjdCg1KTtcbiAgICBub2RlLm1lbWJlcnMgPSB0aGlzLnRzUGFyc2VEZWxpbWl0ZWRMaXN0KFwiRW51bU1lbWJlcnNcIiwgdGhpcy50c1BhcnNlRW51bU1lbWJlci5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmV4cGVjdCg4KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNFbnVtQm9keVwiKTtcbiAgfVxuICB0c1BhcnNlTW9kdWxlQmxvY2soKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5zY29wZS5lbnRlcigwKTtcbiAgICB0aGlzLmV4cGVjdCg1KTtcbiAgICBzdXBlci5wYXJzZUJsb2NrT3JNb2R1bGVCbG9ja0JvZHkobm9kZS5ib2R5ID0gW10sIHVuZGVmaW5lZCwgdHJ1ZSwgOCk7XG4gICAgdGhpcy5zY29wZS5leGl0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTTW9kdWxlQmxvY2tcIik7XG4gIH1cbiAgdHNQYXJzZU1vZHVsZU9yTmFtZXNwYWNlRGVjbGFyYXRpb24obm9kZSwgbmVzdGVkID0gZmFsc2UpIHtcbiAgICBub2RlLmlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICBpZiAoIW5lc3RlZCkge1xuICAgICAgdGhpcy5jaGVja0lkZW50aWZpZXIobm9kZS5pZCwgMTAyNCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmVhdCgxNikpIHtcbiAgICAgIGNvbnN0IGlubmVyID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMudHNQYXJzZU1vZHVsZU9yTmFtZXNwYWNlRGVjbGFyYXRpb24oaW5uZXIsIHRydWUpO1xuICAgICAgbm9kZS5ib2R5ID0gaW5uZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2NvcGUuZW50ZXIoMTAyNCk7XG4gICAgICB0aGlzLnByb2RQYXJhbS5lbnRlcigwKTtcbiAgICAgIG5vZGUuYm9keSA9IHRoaXMudHNQYXJzZU1vZHVsZUJsb2NrKCk7XG4gICAgICB0aGlzLnByb2RQYXJhbS5leGl0KCk7XG4gICAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTTW9kdWxlRGVjbGFyYXRpb25cIik7XG4gIH1cbiAgdHNQYXJzZUFtYmllbnRFeHRlcm5hbE1vZHVsZURlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTEyKSkge1xuICAgICAgbm9kZS5raW5kID0gXCJnbG9iYWxcIjtcbiAgICAgIHtcbiAgICAgICAgbm9kZS5nbG9iYWwgPSB0cnVlO1xuICAgICAgfVxuICAgICAgbm9kZS5pZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKDEzNCkpIHtcbiAgICAgIG5vZGUua2luZCA9IFwibW9kdWxlXCI7XG4gICAgICBub2RlLmlkID0gc3VwZXIucGFyc2VTdHJpbmdMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF0Y2goNSkpIHtcbiAgICAgIHRoaXMuc2NvcGUuZW50ZXIoMTAyNCk7XG4gICAgICB0aGlzLnByb2RQYXJhbS5lbnRlcigwKTtcbiAgICAgIG5vZGUuYm9keSA9IHRoaXMudHNQYXJzZU1vZHVsZUJsb2NrKCk7XG4gICAgICB0aGlzLnByb2RQYXJhbS5leGl0KCk7XG4gICAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTTW9kdWxlRGVjbGFyYXRpb25cIik7XG4gIH1cbiAgdHNQYXJzZUltcG9ydEVxdWFsc0RlY2xhcmF0aW9uKG5vZGUsIG1heWJlRGVmYXVsdElkZW50aWZpZXIsIGlzRXhwb3J0KSB7XG4gICAge1xuICAgICAgbm9kZS5pc0V4cG9ydCA9IGlzRXhwb3J0IHx8IGZhbHNlO1xuICAgIH1cbiAgICBub2RlLmlkID0gbWF5YmVEZWZhdWx0SWRlbnRpZmllciB8fCB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgIHRoaXMuY2hlY2tJZGVudGlmaWVyKG5vZGUuaWQsIDQwOTYpO1xuICAgIHRoaXMuZXhwZWN0KDI5KTtcbiAgICBjb25zdCBtb2R1bGVSZWZlcmVuY2UgPSB0aGlzLnRzUGFyc2VNb2R1bGVSZWZlcmVuY2UoKTtcbiAgICBpZiAobm9kZS5pbXBvcnRLaW5kID09PSBcInR5cGVcIiAmJiBtb2R1bGVSZWZlcmVuY2UudHlwZSAhPT0gXCJUU0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlXCIpIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuSW1wb3J0QWxpYXNIYXNJbXBvcnRUeXBlLCBtb2R1bGVSZWZlcmVuY2UpO1xuICAgIH1cbiAgICBub2RlLm1vZHVsZVJlZmVyZW5jZSA9IG1vZHVsZVJlZmVyZW5jZTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uXCIpO1xuICB9XG4gIHRzSXNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0NvbnRleHR1YWwoMTE5KSAmJiB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgPT09IDQwO1xuICB9XG4gIHRzUGFyc2VNb2R1bGVSZWZlcmVuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMudHNJc0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlKCkgPyB0aGlzLnRzUGFyc2VFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZSgpIDogdGhpcy50c1BhcnNlRW50aXR5TmFtZSgwKTtcbiAgfVxuICB0c1BhcnNlRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2UoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKDExOSk7XG4gICAgdGhpcy5leHBlY3QoMTApO1xuICAgIGlmICghdGhpcy5tYXRjaCgxMzQpKSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gICAgbm9kZS5leHByZXNzaW9uID0gc3VwZXIucGFyc2VFeHByQXRvbSgpO1xuICAgIHRoaXMuZXhwZWN0KDExKTtcbiAgICB0aGlzLnNhd1VuYW1iaWd1b3VzRVNNID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZVwiKTtcbiAgfVxuICB0c0xvb2tBaGVhZChmKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlLmNsb25lKCk7XG4gICAgY29uc3QgcmVzID0gZigpO1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIHRzVHJ5UGFyc2VBbmRDYXRjaChmKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy50cnlQYXJzZShhYm9ydCA9PiBmKCkgfHwgYWJvcnQoKSk7XG4gICAgaWYgKHJlc3VsdC5hYm9ydGVkIHx8ICFyZXN1bHQubm9kZSkgcmV0dXJuO1xuICAgIGlmIChyZXN1bHQuZXJyb3IpIHRoaXMuc3RhdGUgPSByZXN1bHQuZmFpbFN0YXRlO1xuICAgIHJldHVybiByZXN1bHQubm9kZTtcbiAgfVxuICB0c1RyeVBhcnNlKGYpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGUuY2xvbmUoKTtcbiAgICBjb25zdCByZXN1bHQgPSBmKCk7XG4gICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIHJlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgfVxuICB0c1RyeVBhcnNlRGVjbGFyZShub2RlKSB7XG4gICAgaWYgKHRoaXMuaXNMaW5lVGVybWluYXRvcigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0VHlwZSA9IHRoaXMuc3RhdGUudHlwZTtcbiAgICByZXR1cm4gdGhpcy50c0luQW1iaWVudENvbnRleHQoKCkgPT4ge1xuICAgICAgc3dpdGNoIChzdGFydFR5cGUpIHtcbiAgICAgICAgY2FzZSA2ODpcbiAgICAgICAgICBub2RlLmRlY2xhcmUgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBzdXBlci5wYXJzZUZ1bmN0aW9uU3RhdGVtZW50KG5vZGUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgIGNhc2UgODA6XG4gICAgICAgICAgbm9kZS5kZWNsYXJlID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKG5vZGUsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgY2FzZSAxMjY6XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZUVudW1EZWNsYXJhdGlvbihub2RlLCB7XG4gICAgICAgICAgICBkZWNsYXJlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgMTEyOlxuICAgICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VBbWJpZW50RXh0ZXJuYWxNb2R1bGVEZWNsYXJhdGlvbihub2RlKTtcbiAgICAgICAgY2FzZSAxMDA6XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdGUuY29udGFpbnNFc2MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgNzU6XG4gICAgICAgIGNhc2UgNzQ6XG4gICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKDc1KSB8fCAhdGhpcy5pc0xvb2thaGVhZENvbnRleHR1YWwoXCJlbnVtXCIpKSB7XG4gICAgICAgICAgICBub2RlLmRlY2xhcmUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VWYXJTdGF0ZW1lbnQobm9kZSwgdGhpcy5zdGF0ZS52YWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZXhwZWN0KDc1KTtcbiAgICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlRW51bURlY2xhcmF0aW9uKG5vZGUsIHtcbiAgICAgICAgICAgIGNvbnN0OiB0cnVlLFxuICAgICAgICAgICAgZGVjbGFyZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlIDEwNzpcbiAgICAgICAgICBpZiAodGhpcy5pc1VzaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuSW52YWxpZE1vZGlmaWVyT25Vc2luZ0RlY2xhcmF0aW9uLCB0aGlzLnN0YXRlLnN0YXJ0TG9jLCBcImRlY2xhcmVcIik7XG4gICAgICAgICAgICBub2RlLmRlY2xhcmUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VWYXJTdGF0ZW1lbnQobm9kZSwgXCJ1c2luZ1wiLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgOTY6XG4gICAgICAgICAgaWYgKHRoaXMuaXNBd2FpdFVzaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuSW52YWxpZE1vZGlmaWVyT25Bd2FpdFVzaW5nRGVjbGFyYXRpb24sIHRoaXMuc3RhdGUuc3RhcnRMb2MsIFwiZGVjbGFyZVwiKTtcbiAgICAgICAgICAgIG5vZGUuZGVjbGFyZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVmFyU3RhdGVtZW50KG5vZGUsIFwiYXdhaXQgdXNpbmdcIiwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEyOTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnRzUGFyc2VJbnRlcmZhY2VEZWNsYXJhdGlvbihub2RlLCB7XG4gICAgICAgICAgICAgIGRlY2xhcmU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKHRva2VuSXNJZGVudGlmaWVyKHN0YXJ0VHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VEZWNsYXJhdGlvbihub2RlLCB0aGlzLnN0YXRlLnZhbHVlLCB0cnVlLCBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgdHNUcnlQYXJzZUV4cG9ydERlY2xhcmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRzUGFyc2VEZWNsYXJhdGlvbih0aGlzLnN0YXJ0Tm9kZSgpLCB0aGlzLnN0YXRlLnZhbHVlLCB0cnVlLCBudWxsKTtcbiAgfVxuICB0c1BhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCBleHByLCBkZWNvcmF0b3JzKSB7XG4gICAgc3dpdGNoIChleHByLm5hbWUpIHtcbiAgICAgIGNhc2UgXCJkZWNsYXJlXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBkZWNsYXJhdGlvbiA9IHRoaXMudHNUcnlQYXJzZURlY2xhcmUobm9kZSk7XG4gICAgICAgICAgaWYgKGRlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICBkZWNsYXJhdGlvbi5kZWNsYXJlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRlY2xhcmF0aW9uO1xuICAgICAgICB9XG4gICAgICBjYXNlIFwiZ2xvYmFsXCI6XG4gICAgICAgIGlmICh0aGlzLm1hdGNoKDUpKSB7XG4gICAgICAgICAgdGhpcy5zY29wZS5lbnRlcigxMDI0KTtcbiAgICAgICAgICB0aGlzLnByb2RQYXJhbS5lbnRlcigwKTtcbiAgICAgICAgICBjb25zdCBtb2QgPSBub2RlO1xuICAgICAgICAgIG1vZC5raW5kID0gXCJnbG9iYWxcIjtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBub2RlLmdsb2JhbCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1vZC5pZCA9IGV4cHI7XG4gICAgICAgICAgbW9kLmJvZHkgPSB0aGlzLnRzUGFyc2VNb2R1bGVCbG9jaygpO1xuICAgICAgICAgIHRoaXMuc2NvcGUuZXhpdCgpO1xuICAgICAgICAgIHRoaXMucHJvZFBhcmFtLmV4aXQoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG1vZCwgXCJUU01vZHVsZURlY2xhcmF0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZURlY2xhcmF0aW9uKG5vZGUsIGV4cHIubmFtZSwgZmFsc2UsIGRlY29yYXRvcnMpO1xuICAgIH1cbiAgfVxuICB0c1BhcnNlRGVjbGFyYXRpb24obm9kZSwgdmFsdWUsIG5leHQsIGRlY29yYXRvcnMpIHtcbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICBjYXNlIFwiYWJzdHJhY3RcIjpcbiAgICAgICAgaWYgKHRoaXMudHNDaGVja0xpbmVUZXJtaW5hdG9yKG5leHQpICYmICh0aGlzLm1hdGNoKDgwKSB8fCB0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VBYnN0cmFjdERlY2xhcmF0aW9uKG5vZGUsIGRlY29yYXRvcnMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1vZHVsZVwiOlxuICAgICAgICBpZiAodGhpcy50c0NoZWNrTGluZVRlcm1pbmF0b3IobmV4dCkpIHtcbiAgICAgICAgICBpZiAodGhpcy5tYXRjaCgxMzQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlQW1iaWVudEV4dGVybmFsTW9kdWxlRGVjbGFyYXRpb24obm9kZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICAgICAgICBub2RlLmtpbmQgPSBcIm1vZHVsZVwiO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZU1vZHVsZU9yTmFtZXNwYWNlRGVjbGFyYXRpb24obm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm5hbWVzcGFjZVwiOlxuICAgICAgICBpZiAodGhpcy50c0NoZWNrTGluZVRlcm1pbmF0b3IobmV4dCkgJiYgdG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgICAgIG5vZGUua2luZCA9IFwibmFtZXNwYWNlXCI7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZU1vZHVsZU9yTmFtZXNwYWNlRGVjbGFyYXRpb24obm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidHlwZVwiOlxuICAgICAgICBpZiAodGhpcy50c0NoZWNrTGluZVRlcm1pbmF0b3IobmV4dCkgJiYgdG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUeXBlQWxpYXNEZWNsYXJhdGlvbihub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdHNDaGVja0xpbmVUZXJtaW5hdG9yKG5leHQpIHtcbiAgICBpZiAobmV4dCkge1xuICAgICAgaWYgKHRoaXMuaGFzRm9sbG93aW5nTGluZUJyZWFrKCkpIHJldHVybiBmYWxzZTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiAhdGhpcy5pc0xpbmVUZXJtaW5hdG9yKCk7XG4gIH1cbiAgdHNUcnlQYXJzZUdlbmVyaWNBc3luY0Fycm93RnVuY3Rpb24oc3RhcnRMb2MpIHtcbiAgICBpZiAoIXRoaXMubWF0Y2goNDcpKSByZXR1cm47XG4gICAgY29uc3Qgb2xkTWF5YmVJbkFycm93UGFyYW1ldGVycyA9IHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycztcbiAgICB0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnMgPSB0cnVlO1xuICAgIGNvbnN0IHJlcyA9IHRoaXMudHNUcnlQYXJzZUFuZENhdGNoKCgpID0+IHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLnRzUGFyc2VUeXBlUGFyYW1ldGVycyh0aGlzLnRzUGFyc2VDb25zdE1vZGlmaWVyKTtcbiAgICAgIHN1cGVyLnBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSk7XG4gICAgICBub2RlLnJldHVyblR5cGUgPSB0aGlzLnRzVHJ5UGFyc2VUeXBlT3JUeXBlUHJlZGljYXRlQW5ub3RhdGlvbigpO1xuICAgICAgdGhpcy5leHBlY3QoMTkpO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSk7XG4gICAgdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gb2xkTWF5YmVJbkFycm93UGFyYW1ldGVycztcbiAgICBpZiAoIXJlcykgcmV0dXJuO1xuICAgIHJldHVybiBzdXBlci5wYXJzZUFycm93RXhwcmVzc2lvbihyZXMsIG51bGwsIHRydWUpO1xuICB9XG4gIHRzUGFyc2VUeXBlQXJndW1lbnRzSW5FeHByZXNzaW9uKCkge1xuICAgIGlmICh0aGlzLnJlU2Nhbl9sdCgpICE9PSA0NykgcmV0dXJuO1xuICAgIHJldHVybiB0aGlzLnRzUGFyc2VUeXBlQXJndW1lbnRzKCk7XG4gIH1cbiAgdHNQYXJzZVR5cGVBcmd1bWVudHMoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS5wYXJhbXMgPSB0aGlzLnRzSW5UeXBlKCgpID0+IHRoaXMudHNJblRvcExldmVsQ29udGV4dCgoKSA9PiB7XG4gICAgICB0aGlzLmV4cGVjdCg0Nyk7XG4gICAgICByZXR1cm4gdGhpcy50c1BhcnNlRGVsaW1pdGVkTGlzdChcIlR5cGVQYXJhbWV0ZXJzT3JBcmd1bWVudHNcIiwgdGhpcy50c1BhcnNlVHlwZS5iaW5kKHRoaXMpKTtcbiAgICB9KSk7XG4gICAgaWYgKG5vZGUucGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5FbXB0eVR5cGVBcmd1bWVudHMsIG5vZGUpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuc3RhdGUuaW5UeXBlICYmIHRoaXMuY3VyQ29udGV4dCgpID09PSB0eXBlcy5icmFjZSkge1xuICAgICAgdGhpcy5yZVNjYW5fbHRfZ3QoKTtcbiAgICB9XG4gICAgdGhpcy5leHBlY3QoNDgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpO1xuICB9XG4gIHRzSXNEZWNsYXJhdGlvblN0YXJ0KCkge1xuICAgIHJldHVybiB0b2tlbklzVFNEZWNsYXJhdGlvblN0YXJ0KHRoaXMuc3RhdGUudHlwZSk7XG4gIH1cbiAgaXNFeHBvcnREZWZhdWx0U3BlY2lmaWVyKCkge1xuICAgIGlmICh0aGlzLnRzSXNEZWNsYXJhdGlvblN0YXJ0KCkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gc3VwZXIuaXNFeHBvcnREZWZhdWx0U3BlY2lmaWVyKCk7XG4gIH1cbiAgcGFyc2VCaW5kaW5nRWxlbWVudChmbGFncywgZGVjb3JhdG9ycykge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gZGVjb3JhdG9ycy5sZW5ndGggPyBkZWNvcmF0b3JzWzBdLmxvYy5zdGFydCA6IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgbW9kaWZpZWQgPSB7fTtcbiAgICB0aGlzLnRzUGFyc2VNb2RpZmllcnMoe1xuICAgICAgYWxsb3dlZE1vZGlmaWVyczogW1wicHVibGljXCIsIFwicHJpdmF0ZVwiLCBcInByb3RlY3RlZFwiLCBcIm92ZXJyaWRlXCIsIFwicmVhZG9ubHlcIl1cbiAgICB9LCBtb2RpZmllZCk7XG4gICAgY29uc3QgYWNjZXNzaWJpbGl0eSA9IG1vZGlmaWVkLmFjY2Vzc2liaWxpdHk7XG4gICAgY29uc3Qgb3ZlcnJpZGUgPSBtb2RpZmllZC5vdmVycmlkZTtcbiAgICBjb25zdCByZWFkb25seSA9IG1vZGlmaWVkLnJlYWRvbmx5O1xuICAgIGlmICghKGZsYWdzICYgNCkgJiYgKGFjY2Vzc2liaWxpdHkgfHwgcmVhZG9ubHkgfHwgb3ZlcnJpZGUpKSB7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlVuZXhwZWN0ZWRQYXJhbWV0ZXJNb2RpZmllciwgc3RhcnRMb2MpO1xuICAgIH1cbiAgICBjb25zdCBsZWZ0ID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdCgpO1xuICAgIGlmIChmbGFncyAmIDIpIHtcbiAgICAgIHRoaXMucGFyc2VGdW5jdGlvblBhcmFtVHlwZShsZWZ0KTtcbiAgICB9XG4gICAgY29uc3QgZWx0ID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChsZWZ0LmxvYy5zdGFydCwgbGVmdCk7XG4gICAgaWYgKGFjY2Vzc2liaWxpdHkgfHwgcmVhZG9ubHkgfHwgb3ZlcnJpZGUpIHtcbiAgICAgIGNvbnN0IHBwID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICBpZiAoZGVjb3JhdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgcHAuZGVjb3JhdG9ycyA9IGRlY29yYXRvcnM7XG4gICAgICB9XG4gICAgICBpZiAoYWNjZXNzaWJpbGl0eSkgcHAuYWNjZXNzaWJpbGl0eSA9IGFjY2Vzc2liaWxpdHk7XG4gICAgICBpZiAocmVhZG9ubHkpIHBwLnJlYWRvbmx5ID0gcmVhZG9ubHk7XG4gICAgICBpZiAob3ZlcnJpZGUpIHBwLm92ZXJyaWRlID0gb3ZlcnJpZGU7XG4gICAgICBpZiAoZWx0LnR5cGUgIT09IFwiSWRlbnRpZmllclwiICYmIGVsdC50eXBlICE9PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5VbnN1cHBvcnRlZFBhcmFtZXRlclByb3BlcnR5S2luZCwgcHApO1xuICAgICAgfVxuICAgICAgcHAucGFyYW1ldGVyID0gZWx0O1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcCwgXCJUU1BhcmFtZXRlclByb3BlcnR5XCIpO1xuICAgIH1cbiAgICBpZiAoZGVjb3JhdG9ycy5sZW5ndGgpIHtcbiAgICAgIGxlZnQuZGVjb3JhdG9ycyA9IGRlY29yYXRvcnM7XG4gICAgfVxuICAgIHJldHVybiBlbHQ7XG4gIH1cbiAgaXNTaW1wbGVQYXJhbWV0ZXIobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiVFNQYXJhbWV0ZXJQcm9wZXJ0eVwiICYmIHN1cGVyLmlzU2ltcGxlUGFyYW1ldGVyKG5vZGUucGFyYW1ldGVyKSB8fCBzdXBlci5pc1NpbXBsZVBhcmFtZXRlcihub2RlKTtcbiAgfVxuICB0c0Rpc2FsbG93T3B0aW9uYWxQYXR0ZXJuKG5vZGUpIHtcbiAgICBmb3IgKGNvbnN0IHBhcmFtIG9mIG5vZGUucGFyYW1zKSB7XG4gICAgICBpZiAocGFyYW0udHlwZSAhPT0gXCJJZGVudGlmaWVyXCIgJiYgcGFyYW0ub3B0aW9uYWwgJiYgIXRoaXMuc3RhdGUuaXNBbWJpZW50Q29udGV4dCkge1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlBhdHRlcm5Jc09wdGlvbmFsLCBwYXJhbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNldEFycm93RnVuY3Rpb25QYXJhbWV0ZXJzKG5vZGUsIHBhcmFtcywgdHJhaWxpbmdDb21tYUxvYykge1xuICAgIHN1cGVyLnNldEFycm93RnVuY3Rpb25QYXJhbWV0ZXJzKG5vZGUsIHBhcmFtcywgdHJhaWxpbmdDb21tYUxvYyk7XG4gICAgdGhpcy50c0Rpc2FsbG93T3B0aW9uYWxQYXR0ZXJuKG5vZGUpO1xuICB9XG4gIHBhcnNlRnVuY3Rpb25Cb2R5QW5kRmluaXNoKG5vZGUsIHR5cGUsIGlzTWV0aG9kID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxNCkpIHtcbiAgICAgIG5vZGUucmV0dXJuVHlwZSA9IHRoaXMudHNQYXJzZVR5cGVPclR5cGVQcmVkaWNhdGVBbm5vdGF0aW9uKDE0KTtcbiAgICB9XG4gICAgY29uc3QgYm9kaWxlc3NUeXBlID0gdHlwZSA9PT0gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgPyBcIlRTRGVjbGFyZUZ1bmN0aW9uXCIgOiB0eXBlID09PSBcIkNsYXNzTWV0aG9kXCIgfHwgdHlwZSA9PT0gXCJDbGFzc1ByaXZhdGVNZXRob2RcIiA/IFwiVFNEZWNsYXJlTWV0aG9kXCIgOiB1bmRlZmluZWQ7XG4gICAgaWYgKGJvZGlsZXNzVHlwZSAmJiAhdGhpcy5tYXRjaCg1KSAmJiB0aGlzLmlzTGluZVRlcm1pbmF0b3IoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBib2RpbGVzc1R5cGUpO1xuICAgIH1cbiAgICBpZiAoYm9kaWxlc3NUeXBlID09PSBcIlRTRGVjbGFyZUZ1bmN0aW9uXCIgJiYgdGhpcy5zdGF0ZS5pc0FtYmllbnRDb250ZXh0KSB7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkRlY2xhcmVGdW5jdGlvbkhhc0ltcGxlbWVudGF0aW9uLCBub2RlKTtcbiAgICAgIGlmIChub2RlLmRlY2xhcmUpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnBhcnNlRnVuY3Rpb25Cb2R5QW5kRmluaXNoKG5vZGUsIGJvZGlsZXNzVHlwZSwgaXNNZXRob2QpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnRzRGlzYWxsb3dPcHRpb25hbFBhdHRlcm4obm9kZSk7XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlRnVuY3Rpb25Cb2R5QW5kRmluaXNoKG5vZGUsIHR5cGUsIGlzTWV0aG9kKTtcbiAgfVxuICByZWdpc3RlckZ1bmN0aW9uU3RhdGVtZW50SWQobm9kZSkge1xuICAgIGlmICghbm9kZS5ib2R5ICYmIG5vZGUuaWQpIHtcbiAgICAgIHRoaXMuY2hlY2tJZGVudGlmaWVyKG5vZGUuaWQsIDEwMjQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlci5yZWdpc3RlckZ1bmN0aW9uU3RhdGVtZW50SWQobm9kZSk7XG4gICAgfVxuICB9XG4gIHRzQ2hlY2tGb3JJbnZhbGlkVHlwZUNhc3RzKGl0ZW1zKSB7XG4gICAgaXRlbXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgIGlmICgobm9kZSA9PSBudWxsID8gdm9pZCAwIDogbm9kZS50eXBlKSA9PT0gXCJUU1R5cGVDYXN0RXhwcmVzc2lvblwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuVW5leHBlY3RlZFR5cGVBbm5vdGF0aW9uLCBub2RlLnR5cGVBbm5vdGF0aW9uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB0b1JlZmVyZW5jZWRMaXN0KGV4cHJMaXN0LCBpc0luUGFyZW5zKSB7XG4gICAgdGhpcy50c0NoZWNrRm9ySW52YWxpZFR5cGVDYXN0cyhleHByTGlzdCk7XG4gICAgcmV0dXJuIGV4cHJMaXN0O1xuICB9XG4gIHBhcnNlQXJyYXlMaWtlKGNsb3NlLCBjYW5CZVBhdHRlcm4sIGlzVHVwbGUsIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBjb25zdCBub2RlID0gc3VwZXIucGFyc2VBcnJheUxpa2UoY2xvc2UsIGNhbkJlUGF0dGVybiwgaXNUdXBsZSwgcmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJBcnJheUV4cHJlc3Npb25cIikge1xuICAgICAgdGhpcy50c0NoZWNrRm9ySW52YWxpZFR5cGVDYXN0cyhub2RlLmVsZW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhcnRMb2MsIG5vQ2FsbHMsIHN0YXRlKSB7XG4gICAgaWYgKCF0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpICYmIHRoaXMubWF0Y2goMzUpKSB7XG4gICAgICB0aGlzLnN0YXRlLmNhblN0YXJ0SlNYRWxlbWVudCA9IGZhbHNlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBjb25zdCBub25OdWxsRXhwcmVzc2lvbiA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgbm9uTnVsbEV4cHJlc3Npb24uZXhwcmVzc2lvbiA9IGJhc2U7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vbk51bGxFeHByZXNzaW9uLCBcIlRTTm9uTnVsbEV4cHJlc3Npb25cIik7XG4gICAgfVxuICAgIGxldCBpc09wdGlvbmFsQ2FsbCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLm1hdGNoKDE4KSAmJiB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgPT09IDYwKSB7XG4gICAgICBpZiAobm9DYWxscykge1xuICAgICAgICBzdGF0ZS5zdG9wID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICB9XG4gICAgICBzdGF0ZS5vcHRpb25hbENoYWluTWVtYmVyID0gaXNPcHRpb25hbENhbGwgPSB0cnVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hdGNoKDQ3KSB8fCB0aGlzLm1hdGNoKDUxKSkge1xuICAgICAgbGV0IG1pc3NpbmdQYXJlbkVycm9yTG9jO1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy50c1RyeVBhcnNlQW5kQ2F0Y2goKCkgPT4ge1xuICAgICAgICBpZiAoIW5vQ2FsbHMgJiYgdGhpcy5hdFBvc3NpYmxlQXN5bmNBcnJvdyhiYXNlKSkge1xuICAgICAgICAgIGNvbnN0IGFzeW5jQXJyb3dGbiA9IHRoaXMudHNUcnlQYXJzZUdlbmVyaWNBc3luY0Fycm93RnVuY3Rpb24oc3RhcnRMb2MpO1xuICAgICAgICAgIGlmIChhc3luY0Fycm93Rm4pIHtcbiAgICAgICAgICAgIHJldHVybiBhc3luY0Fycm93Rm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGVBcmd1bWVudHMgPSB0aGlzLnRzUGFyc2VUeXBlQXJndW1lbnRzSW5FeHByZXNzaW9uKCk7XG4gICAgICAgIGlmICghdHlwZUFyZ3VtZW50cykgcmV0dXJuO1xuICAgICAgICBpZiAoaXNPcHRpb25hbENhbGwgJiYgIXRoaXMubWF0Y2goMTApKSB7XG4gICAgICAgICAgbWlzc2luZ1BhcmVuRXJyb3JMb2MgPSB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbklzVGVtcGxhdGUodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLnBhcnNlVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKGJhc2UsIHN0YXJ0TG9jLCBzdGF0ZSk7XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmVzdWx0LnR5cGVQYXJhbWV0ZXJzID0gdHlwZUFyZ3VtZW50cztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vQ2FsbHMgJiYgdGhpcy5lYXQoMTApKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgICAgIG5vZGUuY2FsbGVlID0gYmFzZTtcbiAgICAgICAgICBub2RlLmFyZ3VtZW50cyA9IHRoaXMucGFyc2VDYWxsRXhwcmVzc2lvbkFyZ3VtZW50cygpO1xuICAgICAgICAgIHRoaXMudHNDaGVja0ZvckludmFsaWRUeXBlQ2FzdHMobm9kZS5hcmd1bWVudHMpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0eXBlQXJndW1lbnRzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUub3B0aW9uYWxDaGFpbk1lbWJlcikge1xuICAgICAgICAgICAgbm9kZS5vcHRpb25hbCA9IGlzT3B0aW9uYWxDYWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hDYWxsRXhwcmVzc2lvbihub2RlLCBzdGF0ZS5vcHRpb25hbENoYWluTWVtYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b2tlblR5cGUgPSB0aGlzLnN0YXRlLnR5cGU7XG4gICAgICAgIGlmICh0b2tlblR5cGUgPT09IDQ4IHx8IHRva2VuVHlwZSA9PT0gNTIgfHwgdG9rZW5UeXBlICE9PSAxMCAmJiB0b2tlbkNhblN0YXJ0RXhwcmVzc2lvbih0b2tlblR5cGUpICYmICF0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgICAgbm9kZS5leHByZXNzaW9uID0gYmFzZTtcbiAgICAgICAge1xuICAgICAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0eXBlQXJndW1lbnRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0luc3RhbnRpYXRpb25FeHByZXNzaW9uXCIpO1xuICAgICAgfSk7XG4gICAgICBpZiAobWlzc2luZ1BhcmVuRXJyb3JMb2MpIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKG1pc3NpbmdQYXJlbkVycm9yTG9jLCAxMCk7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJUU0luc3RhbnRpYXRpb25FeHByZXNzaW9uXCIpIHtcbiAgICAgICAgICBpZiAodGhpcy5tYXRjaCgxNikgfHwgdGhpcy5tYXRjaCgxOCkgJiYgdGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpICE9PSA0MCkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5JbnZhbGlkUHJvcGVydHlBY2Nlc3NBZnRlckluc3RhbnRpYXRpb25FeHByZXNzaW9uLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKDE2KSAmJiAhdGhpcy5tYXRjaCgxOCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5leHByZXNzaW9uID0gc3VwZXIuc3RvcFBhcnNlU3Vic2NyaXB0KGJhc2UsIHN0YXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlU3Vic2NyaXB0KGJhc2UsIHN0YXJ0TG9jLCBub0NhbGxzLCBzdGF0ZSk7XG4gIH1cbiAgcGFyc2VOZXdDYWxsZWUobm9kZSkge1xuICAgIHZhciBfY2FsbGVlJGV4dHJhO1xuICAgIHN1cGVyLnBhcnNlTmV3Q2FsbGVlKG5vZGUpO1xuICAgIGNvbnN0IHtcbiAgICAgIGNhbGxlZVxuICAgIH0gPSBub2RlO1xuICAgIGlmIChjYWxsZWUudHlwZSA9PT0gXCJUU0luc3RhbnRpYXRpb25FeHByZXNzaW9uXCIgJiYgISgoX2NhbGxlZSRleHRyYSA9IGNhbGxlZS5leHRyYSkgIT0gbnVsbCAmJiBfY2FsbGVlJGV4dHJhLnBhcmVudGhlc2l6ZWQpKSB7XG4gICAgICB7XG4gICAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBjYWxsZWUudHlwZVBhcmFtZXRlcnM7XG4gICAgICB9XG4gICAgICBub2RlLmNhbGxlZSA9IGNhbGxlZS5leHByZXNzaW9uO1xuICAgIH1cbiAgfVxuICBwYXJzZUV4cHJPcChsZWZ0LCBsZWZ0U3RhcnRMb2MsIG1pblByZWMpIHtcbiAgICBsZXQgaXNTYXRpc2ZpZXM7XG4gICAgaWYgKHRva2VuT3BlcmF0b3JQcmVjZWRlbmNlKDU4KSA+IG1pblByZWMgJiYgIXRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkgJiYgKHRoaXMuaXNDb250ZXh0dWFsKDkzKSB8fCAoaXNTYXRpc2ZpZXMgPSB0aGlzLmlzQ29udGV4dHVhbCgxMjApKSkpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KGxlZnRTdGFydExvYyk7XG4gICAgICBub2RlLmV4cHJlc3Npb24gPSBsZWZ0O1xuICAgICAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHRoaXMudHNJblR5cGUoKCkgPT4ge1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKHRoaXMubWF0Y2goNzUpKSB7XG4gICAgICAgICAgaWYgKGlzU2F0aXNmaWVzKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkS2V5d29yZCwgdGhpcy5zdGF0ZS5zdGFydExvYywge1xuICAgICAgICAgICAgICBrZXl3b3JkOiBcImNvbnN0XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlVHlwZVJlZmVyZW5jZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc1NhdGlzZmllcyA/IFwiVFNTYXRpc2ZpZXNFeHByZXNzaW9uXCIgOiBcIlRTQXNFeHByZXNzaW9uXCIpO1xuICAgICAgdGhpcy5yZVNjYW5fbHRfZ3QoKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRXhwck9wKG5vZGUsIGxlZnRTdGFydExvYywgbWluUHJlYyk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZUV4cHJPcChsZWZ0LCBsZWZ0U3RhcnRMb2MsIG1pblByZWMpO1xuICB9XG4gIGNoZWNrUmVzZXJ2ZWRXb3JkKHdvcmQsIHN0YXJ0TG9jLCBjaGVja0tleXdvcmRzLCBpc0JpbmRpbmcpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuaXNBbWJpZW50Q29udGV4dCkge1xuICAgICAgc3VwZXIuY2hlY2tSZXNlcnZlZFdvcmQod29yZCwgc3RhcnRMb2MsIGNoZWNrS2V5d29yZHMsIGlzQmluZGluZyk7XG4gICAgfVxuICB9XG4gIGNoZWNrSW1wb3J0UmVmbGVjdGlvbihub2RlKSB7XG4gICAgc3VwZXIuY2hlY2tJbXBvcnRSZWZsZWN0aW9uKG5vZGUpO1xuICAgIGlmIChub2RlLm1vZHVsZSAmJiBub2RlLmltcG9ydEtpbmQgIT09IFwidmFsdWVcIikge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5JbXBvcnRSZWZsZWN0aW9uSGFzSW1wb3J0VHlwZSwgbm9kZS5zcGVjaWZpZXJzWzBdLmxvYy5zdGFydCk7XG4gICAgfVxuICB9XG4gIGNoZWNrRHVwbGljYXRlRXhwb3J0cygpIHt9XG4gIGlzUG90ZW50aWFsSW1wb3J0UGhhc2UoaXNFeHBvcnQpIHtcbiAgICBpZiAoc3VwZXIuaXNQb3RlbnRpYWxJbXBvcnRQaGFzZShpc0V4cG9ydCkpIHJldHVybiB0cnVlO1xuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMzApKSB7XG4gICAgICBjb25zdCBjaCA9IHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKTtcbiAgICAgIHJldHVybiBpc0V4cG9ydCA/IGNoID09PSAxMjMgfHwgY2ggPT09IDQyIDogY2ggIT09IDYxO1xuICAgIH1cbiAgICByZXR1cm4gIWlzRXhwb3J0ICYmIHRoaXMuaXNDb250ZXh0dWFsKDg3KTtcbiAgfVxuICBhcHBseUltcG9ydFBoYXNlKG5vZGUsIGlzRXhwb3J0LCBwaGFzZSwgbG9jKSB7XG4gICAgc3VwZXIuYXBwbHlJbXBvcnRQaGFzZShub2RlLCBpc0V4cG9ydCwgcGhhc2UsIGxvYyk7XG4gICAgaWYgKGlzRXhwb3J0KSB7XG4gICAgICBub2RlLmV4cG9ydEtpbmQgPSBwaGFzZSA9PT0gXCJ0eXBlXCIgPyBcInR5cGVcIiA6IFwidmFsdWVcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5pbXBvcnRLaW5kID0gcGhhc2UgPT09IFwidHlwZVwiIHx8IHBoYXNlID09PSBcInR5cGVvZlwiID8gcGhhc2UgOiBcInZhbHVlXCI7XG4gICAgfVxuICB9XG4gIHBhcnNlSW1wb3J0KG5vZGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxMzQpKSB7XG4gICAgICBub2RlLmltcG9ydEtpbmQgPSBcInZhbHVlXCI7XG4gICAgICByZXR1cm4gc3VwZXIucGFyc2VJbXBvcnQobm9kZSk7XG4gICAgfVxuICAgIGxldCBpbXBvcnROb2RlO1xuICAgIGlmICh0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpICYmIHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKSA9PT0gNjEpIHtcbiAgICAgIG5vZGUuaW1wb3J0S2luZCA9IFwidmFsdWVcIjtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VJbXBvcnRFcXVhbHNEZWNsYXJhdGlvbihub2RlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEzMCkpIHtcbiAgICAgIGNvbnN0IG1heWJlRGVmYXVsdElkZW50aWZpZXIgPSB0aGlzLnBhcnNlTWF5YmVJbXBvcnRQaGFzZShub2RlLCBmYWxzZSk7XG4gICAgICBpZiAodGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpID09PSA2MSkge1xuICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlSW1wb3J0RXF1YWxzRGVjbGFyYXRpb24obm9kZSwgbWF5YmVEZWZhdWx0SWRlbnRpZmllcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbXBvcnROb2RlID0gc3VwZXIucGFyc2VJbXBvcnRTcGVjaWZpZXJzQW5kQWZ0ZXIobm9kZSwgbWF5YmVEZWZhdWx0SWRlbnRpZmllcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGltcG9ydE5vZGUgPSBzdXBlci5wYXJzZUltcG9ydChub2RlKTtcbiAgICB9XG4gICAgaWYgKGltcG9ydE5vZGUuaW1wb3J0S2luZCA9PT0gXCJ0eXBlXCIgJiYgaW1wb3J0Tm9kZS5zcGVjaWZpZXJzLmxlbmd0aCA+IDEgJiYgaW1wb3J0Tm9kZS5zcGVjaWZpZXJzWzBdLnR5cGUgPT09IFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiKSB7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlR5cGVJbXBvcnRDYW5ub3RTcGVjaWZ5RGVmYXVsdEFuZE5hbWVkLCBpbXBvcnROb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGltcG9ydE5vZGU7XG4gIH1cbiAgcGFyc2VFeHBvcnQobm9kZSwgZGVjb3JhdG9ycykge1xuICAgIGlmICh0aGlzLm1hdGNoKDgzKSkge1xuICAgICAgY29uc3Qgbm9kZUltcG9ydEVxdWFscyA9IG5vZGU7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGxldCBtYXliZURlZmF1bHRJZGVudGlmaWVyID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMzApICYmIHRoaXMuaXNQb3RlbnRpYWxJbXBvcnRQaGFzZShmYWxzZSkpIHtcbiAgICAgICAgbWF5YmVEZWZhdWx0SWRlbnRpZmllciA9IHRoaXMucGFyc2VNYXliZUltcG9ydFBoYXNlKG5vZGVJbXBvcnRFcXVhbHMsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVJbXBvcnRFcXVhbHMuaW1wb3J0S2luZCA9IFwidmFsdWVcIjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gdGhpcy50c1BhcnNlSW1wb3J0RXF1YWxzRGVjbGFyYXRpb24obm9kZUltcG9ydEVxdWFscywgbWF5YmVEZWZhdWx0SWRlbnRpZmllciwgdHJ1ZSk7XG4gICAgICB7XG4gICAgICAgIHJldHVybiBkZWNsYXJhdGlvbjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuZWF0KDI5KSkge1xuICAgICAgY29uc3QgYXNzaWduID0gbm9kZTtcbiAgICAgIGFzc2lnbi5leHByZXNzaW9uID0gc3VwZXIucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgICAgdGhpcy5zYXdVbmFtYmlndW91c0VTTSA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKGFzc2lnbiwgXCJUU0V4cG9ydEFzc2lnbm1lbnRcIik7XG4gICAgfSBlbHNlIGlmICh0aGlzLmVhdENvbnRleHR1YWwoOTMpKSB7XG4gICAgICBjb25zdCBkZWNsID0gbm9kZTtcbiAgICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbCgxMjgpO1xuICAgICAgZGVjbC5pZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShkZWNsLCBcIlRTTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb25cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdXBlci5wYXJzZUV4cG9ydChub2RlLCBkZWNvcmF0b3JzKTtcbiAgICB9XG4gIH1cbiAgaXNBYnN0cmFjdENsYXNzKCkge1xuICAgIHJldHVybiB0aGlzLmlzQ29udGV4dHVhbCgxMjQpICYmIHRoaXMuaXNMb29rYWhlYWRDb250ZXh0dWFsKFwiY2xhc3NcIik7XG4gIH1cbiAgcGFyc2VFeHBvcnREZWZhdWx0RXhwcmVzc2lvbigpIHtcbiAgICBpZiAodGhpcy5pc0Fic3RyYWN0Q2xhc3MoKSkge1xuICAgICAgY29uc3QgY2xzID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgY2xzLmFic3RyYWN0ID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3MoY2xzLCB0cnVlLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF0Y2goMTI5KSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy50c1BhcnNlSW50ZXJmYWNlRGVjbGFyYXRpb24odGhpcy5zdGFydE5vZGUoKSk7XG4gICAgICBpZiAocmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGFyc2VFeHBvcnREZWZhdWx0RXhwcmVzc2lvbigpO1xuICB9XG4gIHBhcnNlVmFyU3RhdGVtZW50KG5vZGUsIGtpbmQsIGFsbG93TWlzc2luZ0luaXRpYWxpemVyID0gZmFsc2UpIHtcbiAgICBjb25zdCB7XG4gICAgICBpc0FtYmllbnRDb250ZXh0XG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgZGVjbGFyYXRpb24gPSBzdXBlci5wYXJzZVZhclN0YXRlbWVudChub2RlLCBraW5kLCBhbGxvd01pc3NpbmdJbml0aWFsaXplciB8fCBpc0FtYmllbnRDb250ZXh0KTtcbiAgICBpZiAoIWlzQW1iaWVudENvbnRleHQpIHJldHVybiBkZWNsYXJhdGlvbjtcbiAgICBpZiAoIW5vZGUuZGVjbGFyZSAmJiAoa2luZCA9PT0gXCJ1c2luZ1wiIHx8IGtpbmQgPT09IFwiYXdhaXQgdXNpbmdcIikpIHtcbiAgICAgIHRoaXMucmFpc2VPdmVyd3JpdGUoVFNFcnJvcnMuVXNpbmdEZWNsYXJhdGlvbkluQW1iaWVudENvbnRleHQsIG5vZGUsIGtpbmQpO1xuICAgICAgcmV0dXJuIGRlY2xhcmF0aW9uO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIGlkLFxuICAgICAgaW5pdFxuICAgIH0gb2YgZGVjbGFyYXRpb24uZGVjbGFyYXRpb25zKSB7XG4gICAgICBpZiAoIWluaXQpIGNvbnRpbnVlO1xuICAgICAgaWYgKGtpbmQgPT09IFwidmFyXCIgfHwga2luZCA9PT0gXCJsZXRcIiB8fCAhIWlkLnR5cGVBbm5vdGF0aW9uKSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuSW5pdGlhbGl6ZXJOb3RBbGxvd2VkSW5BbWJpZW50Q29udGV4dCwgaW5pdCk7XG4gICAgICB9IGVsc2UgaWYgKCFpc1ZhbGlkQW1iaWVudENvbnN0SW5pdGlhbGl6ZXIoaW5pdCwgdGhpcy5oYXNQbHVnaW4oXCJlc3RyZWVcIikpKSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuQ29uc3RJbml0aWFsaXplck11c3RCZVN0cmluZ09yTnVtZXJpY0xpdGVyYWxPckxpdGVyYWxFbnVtUmVmZXJlbmNlLCBpbml0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlY2xhcmF0aW9uO1xuICB9XG4gIHBhcnNlU3RhdGVtZW50Q29udGVudChmbGFncywgZGVjb3JhdG9ycykge1xuICAgIGlmICh0aGlzLm1hdGNoKDc1KSAmJiB0aGlzLmlzTG9va2FoZWFkQ29udGV4dHVhbChcImVudW1cIikpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5leHBlY3QoNzUpO1xuICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZUVudW1EZWNsYXJhdGlvbihub2RlLCB7XG4gICAgICAgIGNvbnN0OiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEyNikpIHtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VFbnVtRGVjbGFyYXRpb24odGhpcy5zdGFydE5vZGUoKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMjkpKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnRzUGFyc2VJbnRlcmZhY2VEZWNsYXJhdGlvbih0aGlzLnN0YXJ0Tm9kZSgpKTtcbiAgICAgIGlmIChyZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZVN0YXRlbWVudENvbnRlbnQoZmxhZ3MsIGRlY29yYXRvcnMpO1xuICB9XG4gIHBhcnNlQWNjZXNzTW9kaWZpZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudHNQYXJzZU1vZGlmaWVyKFtcInB1YmxpY1wiLCBcInByb3RlY3RlZFwiLCBcInByaXZhdGVcIl0pO1xuICB9XG4gIHRzSGFzU29tZU1vZGlmaWVycyhtZW1iZXIsIG1vZGlmaWVycykge1xuICAgIHJldHVybiBtb2RpZmllcnMuc29tZShtb2RpZmllciA9PiB7XG4gICAgICBpZiAodHNJc0FjY2Vzc01vZGlmaWVyKG1vZGlmaWVyKSkge1xuICAgICAgICByZXR1cm4gbWVtYmVyLmFjY2Vzc2liaWxpdHkgPT09IG1vZGlmaWVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuICEhbWVtYmVyW21vZGlmaWVyXTtcbiAgICB9KTtcbiAgfVxuICB0c0lzU3RhcnRPZlN0YXRpY0Jsb2NrcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc0NvbnRleHR1YWwoMTA2KSAmJiB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgPT09IDEyMztcbiAgfVxuICBwYXJzZUNsYXNzTWVtYmVyKGNsYXNzQm9keSwgbWVtYmVyLCBzdGF0ZSkge1xuICAgIGNvbnN0IG1vZGlmaWVycyA9IFtcImRlY2xhcmVcIiwgXCJwcml2YXRlXCIsIFwicHVibGljXCIsIFwicHJvdGVjdGVkXCIsIFwib3ZlcnJpZGVcIiwgXCJhYnN0cmFjdFwiLCBcInJlYWRvbmx5XCIsIFwic3RhdGljXCJdO1xuICAgIHRoaXMudHNQYXJzZU1vZGlmaWVycyh7XG4gICAgICBhbGxvd2VkTW9kaWZpZXJzOiBtb2RpZmllcnMsXG4gICAgICBkaXNhbGxvd2VkTW9kaWZpZXJzOiBbXCJpblwiLCBcIm91dFwiXSxcbiAgICAgIHN0b3BPblN0YXJ0T2ZDbGFzc1N0YXRpY0Jsb2NrOiB0cnVlLFxuICAgICAgZXJyb3JUZW1wbGF0ZTogVFNFcnJvcnMuSW52YWxpZE1vZGlmaWVyT25UeXBlUGFyYW1ldGVyUG9zaXRpb25zXG4gICAgfSwgbWVtYmVyKTtcbiAgICBjb25zdCBjYWxsUGFyc2VDbGFzc01lbWJlcldpdGhJc1N0YXRpYyA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnRzSXNTdGFydE9mU3RhdGljQmxvY2tzKCkpIHtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBpZiAodGhpcy50c0hhc1NvbWVNb2RpZmllcnMobWVtYmVyLCBtb2RpZmllcnMpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5TdGF0aWNCbG9ja0Nhbm5vdEhhdmVNb2RpZmllciwgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5wYXJzZUNsYXNzU3RhdGljQmxvY2soY2xhc3NCb2R5LCBtZW1iZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJzZUNsYXNzTWVtYmVyV2l0aElzU3RhdGljKGNsYXNzQm9keSwgbWVtYmVyLCBzdGF0ZSwgISFtZW1iZXIuc3RhdGljKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChtZW1iZXIuZGVjbGFyZSkge1xuICAgICAgdGhpcy50c0luQW1iaWVudENvbnRleHQoY2FsbFBhcnNlQ2xhc3NNZW1iZXJXaXRoSXNTdGF0aWMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsUGFyc2VDbGFzc01lbWJlcldpdGhJc1N0YXRpYygpO1xuICAgIH1cbiAgfVxuICBwYXJzZUNsYXNzTWVtYmVyV2l0aElzU3RhdGljKGNsYXNzQm9keSwgbWVtYmVyLCBzdGF0ZSwgaXNTdGF0aWMpIHtcbiAgICBjb25zdCBpZHggPSB0aGlzLnRzVHJ5UGFyc2VJbmRleFNpZ25hdHVyZShtZW1iZXIpO1xuICAgIGlmIChpZHgpIHtcbiAgICAgIGNsYXNzQm9keS5ib2R5LnB1c2goaWR4KTtcbiAgICAgIGlmIChtZW1iZXIuYWJzdHJhY3QpIHtcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5JbmRleFNpZ25hdHVyZUhhc0Fic3RyYWN0LCBtZW1iZXIpO1xuICAgICAgfVxuICAgICAgaWYgKG1lbWJlci5hY2Nlc3NpYmlsaXR5KSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuSW5kZXhTaWduYXR1cmVIYXNBY2Nlc3NpYmlsaXR5LCBtZW1iZXIsIHtcbiAgICAgICAgICBtb2RpZmllcjogbWVtYmVyLmFjY2Vzc2liaWxpdHlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAobWVtYmVyLmRlY2xhcmUpIHtcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5JbmRleFNpZ25hdHVyZUhhc0RlY2xhcmUsIG1lbWJlcik7XG4gICAgICB9XG4gICAgICBpZiAobWVtYmVyLm92ZXJyaWRlKSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuSW5kZXhTaWduYXR1cmVIYXNPdmVycmlkZSwgbWVtYmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnN0YXRlLmluQWJzdHJhY3RDbGFzcyAmJiBtZW1iZXIuYWJzdHJhY3QpIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuTm9uQWJzdHJhY3RDbGFzc0hhc0Fic3RyYWN0TWV0aG9kLCBtZW1iZXIpO1xuICAgIH1cbiAgICBpZiAobWVtYmVyLm92ZXJyaWRlKSB7XG4gICAgICBpZiAoIXN0YXRlLmhhZFN1cGVyQ2xhc3MpIHtcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5PdmVycmlkZU5vdEluU3ViQ2xhc3MsIG1lbWJlcik7XG4gICAgICB9XG4gICAgfVxuICAgIHN1cGVyLnBhcnNlQ2xhc3NNZW1iZXJXaXRoSXNTdGF0aWMoY2xhc3NCb2R5LCBtZW1iZXIsIHN0YXRlLCBpc1N0YXRpYyk7XG4gIH1cbiAgcGFyc2VQb3N0TWVtYmVyTmFtZU1vZGlmaWVycyhtZXRob2RPclByb3ApIHtcbiAgICBjb25zdCBvcHRpb25hbCA9IHRoaXMuZWF0KDE3KTtcbiAgICBpZiAob3B0aW9uYWwpIG1ldGhvZE9yUHJvcC5vcHRpb25hbCA9IHRydWU7XG4gICAgaWYgKG1ldGhvZE9yUHJvcC5yZWFkb25seSAmJiB0aGlzLm1hdGNoKDEwKSkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5DbGFzc01ldGhvZEhhc1JlYWRvbmx5LCBtZXRob2RPclByb3ApO1xuICAgIH1cbiAgICBpZiAobWV0aG9kT3JQcm9wLmRlY2xhcmUgJiYgdGhpcy5tYXRjaCgxMCkpIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuQ2xhc3NNZXRob2RIYXNEZWNsYXJlLCBtZXRob2RPclByb3ApO1xuICAgIH1cbiAgfVxuICBwYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgZXhwciwgZGVjb3JhdG9ycykge1xuICAgIGNvbnN0IGRlY2wgPSBleHByLnR5cGUgPT09IFwiSWRlbnRpZmllclwiID8gdGhpcy50c1BhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCBleHByLCBkZWNvcmF0b3JzKSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gZGVjbCB8fCBzdXBlci5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgZXhwciwgZGVjb3JhdG9ycyk7XG4gIH1cbiAgc2hvdWxkUGFyc2VFeHBvcnREZWNsYXJhdGlvbigpIHtcbiAgICBpZiAodGhpcy50c0lzRGVjbGFyYXRpb25TdGFydCgpKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gc3VwZXIuc2hvdWxkUGFyc2VFeHBvcnREZWNsYXJhdGlvbigpO1xuICB9XG4gIHBhcnNlQ29uZGl0aW9uYWwoZXhwciwgc3RhcnRMb2MsIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBpZiAoIXRoaXMubWF0Y2goMTcpKSByZXR1cm4gZXhwcjtcbiAgICBpZiAodGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzKSB7XG4gICAgICBjb25zdCBuZXh0Q2ggPSB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCk7XG4gICAgICBpZiAobmV4dENoID09PSA0NCB8fCBuZXh0Q2ggPT09IDYxIHx8IG5leHRDaCA9PT0gNTggfHwgbmV4dENoID09PSA0MSkge1xuICAgICAgICB0aGlzLnNldE9wdGlvbmFsUGFyYW1ldGVyc0Vycm9yKHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlQ29uZGl0aW9uYWwoZXhwciwgc3RhcnRMb2MsIHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICB9XG4gIHBhcnNlUGFyZW5JdGVtKG5vZGUsIHN0YXJ0TG9jKSB7XG4gICAgY29uc3QgbmV3Tm9kZSA9IHN1cGVyLnBhcnNlUGFyZW5JdGVtKG5vZGUsIHN0YXJ0TG9jKTtcbiAgICBpZiAodGhpcy5lYXQoMTcpKSB7XG4gICAgICBuZXdOb2RlLm9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVzZXRFbmRMb2NhdGlvbihub2RlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICBjb25zdCB0eXBlQ2FzdE5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgIHR5cGVDYXN0Tm9kZS5leHByZXNzaW9uID0gbm9kZTtcbiAgICAgIHR5cGVDYXN0Tm9kZS50eXBlQW5ub3RhdGlvbiA9IHRoaXMudHNQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHR5cGVDYXN0Tm9kZSwgXCJUU1R5cGVDYXN0RXhwcmVzc2lvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcGFyc2VFeHBvcnREZWNsYXJhdGlvbihub2RlKSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLmlzQW1iaWVudENvbnRleHQgJiYgdGhpcy5pc0NvbnRleHR1YWwoMTI1KSkge1xuICAgICAgcmV0dXJuIHRoaXMudHNJbkFtYmllbnRDb250ZXh0KCgpID0+IHRoaXMucGFyc2VFeHBvcnREZWNsYXJhdGlvbihub2RlKSk7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBjb25zdCBpc0RlY2xhcmUgPSB0aGlzLmVhdENvbnRleHR1YWwoMTI1KTtcbiAgICBpZiAoaXNEZWNsYXJlICYmICh0aGlzLmlzQ29udGV4dHVhbCgxMjUpIHx8ICF0aGlzLnNob3VsZFBhcnNlRXhwb3J0RGVjbGFyYXRpb24oKSkpIHtcbiAgICAgIHRocm93IHRoaXMucmFpc2UoVFNFcnJvcnMuRXhwZWN0ZWRBbWJpZW50QWZ0ZXJFeHBvcnREZWNsYXJlLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICB9XG4gICAgY29uc3QgaXNJZGVudGlmaWVyID0gdG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKTtcbiAgICBjb25zdCBkZWNsYXJhdGlvbiA9IGlzSWRlbnRpZmllciAmJiB0aGlzLnRzVHJ5UGFyc2VFeHBvcnREZWNsYXJhdGlvbigpIHx8IHN1cGVyLnBhcnNlRXhwb3J0RGVjbGFyYXRpb24obm9kZSk7XG4gICAgaWYgKCFkZWNsYXJhdGlvbikgcmV0dXJuIG51bGw7XG4gICAgaWYgKGRlY2xhcmF0aW9uLnR5cGUgPT09IFwiVFNJbnRlcmZhY2VEZWNsYXJhdGlvblwiIHx8IGRlY2xhcmF0aW9uLnR5cGUgPT09IFwiVFNUeXBlQWxpYXNEZWNsYXJhdGlvblwiIHx8IGlzRGVjbGFyZSkge1xuICAgICAgbm9kZS5leHBvcnRLaW5kID0gXCJ0eXBlXCI7XG4gICAgfVxuICAgIGlmIChpc0RlY2xhcmUgJiYgZGVjbGFyYXRpb24udHlwZSAhPT0gXCJUU0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uXCIpIHtcbiAgICAgIHRoaXMucmVzZXRTdGFydExvY2F0aW9uKGRlY2xhcmF0aW9uLCBzdGFydExvYyk7XG4gICAgICBkZWNsYXJhdGlvbi5kZWNsYXJlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY2xhcmF0aW9uO1xuICB9XG4gIHBhcnNlQ2xhc3NJZChub2RlLCBpc1N0YXRlbWVudCwgb3B0aW9uYWxJZCwgYmluZGluZ1R5cGUpIHtcbiAgICBpZiAoKCFpc1N0YXRlbWVudCB8fCBvcHRpb25hbElkKSAmJiB0aGlzLmlzQ29udGV4dHVhbCgxMTMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLnBhcnNlQ2xhc3NJZChub2RlLCBpc1N0YXRlbWVudCwgb3B0aW9uYWxJZCwgbm9kZS5kZWNsYXJlID8gMTAyNCA6IDgzMzEpO1xuICAgIGNvbnN0IHR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1RyeVBhcnNlVHlwZVBhcmFtZXRlcnModGhpcy50c1BhcnNlSW5PdXRDb25zdE1vZGlmaWVycyk7XG4gICAgaWYgKHR5cGVQYXJhbWV0ZXJzKSBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdHlwZVBhcmFtZXRlcnM7XG4gIH1cbiAgcGFyc2VDbGFzc1Byb3BlcnR5QW5ub3RhdGlvbihub2RlKSB7XG4gICAgaWYgKCFub2RlLm9wdGlvbmFsKSB7XG4gICAgICBpZiAodGhpcy5lYXQoMzUpKSB7XG4gICAgICAgIG5vZGUuZGVmaW5pdGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmVhdCgxNykpIHtcbiAgICAgICAgbm9kZS5vcHRpb25hbCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSB0aGlzLnRzVHJ5UGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgIGlmICh0eXBlKSBub2RlLnR5cGVBbm5vdGF0aW9uID0gdHlwZTtcbiAgfVxuICBwYXJzZUNsYXNzUHJvcGVydHkobm9kZSkge1xuICAgIHRoaXMucGFyc2VDbGFzc1Byb3BlcnR5QW5ub3RhdGlvbihub2RlKTtcbiAgICBpZiAodGhpcy5zdGF0ZS5pc0FtYmllbnRDb250ZXh0ICYmICEobm9kZS5yZWFkb25seSAmJiAhbm9kZS50eXBlQW5ub3RhdGlvbikgJiYgdGhpcy5tYXRjaCgyOSkpIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuRGVjbGFyZUNsYXNzRmllbGRIYXNJbml0aWFsaXplciwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgfVxuICAgIGlmIChub2RlLmFic3RyYWN0ICYmIHRoaXMubWF0Y2goMjkpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGtleVxuICAgICAgfSA9IG5vZGU7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkFic3RyYWN0UHJvcGVydHlIYXNJbml0aWFsaXplciwgdGhpcy5zdGF0ZS5zdGFydExvYywge1xuICAgICAgICBwcm9wZXJ0eU5hbWU6IGtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiAhbm9kZS5jb21wdXRlZCA/IGtleS5uYW1lIDogYFske3RoaXMuaW5wdXQuc2xpY2UodGhpcy5vZmZzZXRUb1NvdXJjZVBvcyhrZXkuc3RhcnQpLCB0aGlzLm9mZnNldFRvU291cmNlUG9zKGtleS5lbmQpKX1dYFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZUNsYXNzUHJvcGVydHkobm9kZSk7XG4gIH1cbiAgcGFyc2VDbGFzc1ByaXZhdGVQcm9wZXJ0eShub2RlKSB7XG4gICAgaWYgKG5vZGUuYWJzdHJhY3QpIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuUHJpdmF0ZUVsZW1lbnRIYXNBYnN0cmFjdCwgbm9kZSk7XG4gICAgfVxuICAgIGlmIChub2RlLmFjY2Vzc2liaWxpdHkpIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuUHJpdmF0ZUVsZW1lbnRIYXNBY2Nlc3NpYmlsaXR5LCBub2RlLCB7XG4gICAgICAgIG1vZGlmaWVyOiBub2RlLmFjY2Vzc2liaWxpdHlcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnBhcnNlQ2xhc3NQcm9wZXJ0eUFubm90YXRpb24obm9kZSk7XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlQ2xhc3NQcml2YXRlUHJvcGVydHkobm9kZSk7XG4gIH1cbiAgcGFyc2VDbGFzc0FjY2Vzc29yUHJvcGVydHkobm9kZSkge1xuICAgIHRoaXMucGFyc2VDbGFzc1Byb3BlcnR5QW5ub3RhdGlvbihub2RlKTtcbiAgICBpZiAobm9kZS5vcHRpb25hbCkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5BY2Nlc3NvckNhbm5vdEJlT3B0aW9uYWwsIG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGFyc2VDbGFzc0FjY2Vzc29yUHJvcGVydHkobm9kZSk7XG4gIH1cbiAgcHVzaENsYXNzTWV0aG9kKGNsYXNzQm9keSwgbWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNDb25zdHJ1Y3RvciwgYWxsb3dzRGlyZWN0U3VwZXIpIHtcbiAgICBjb25zdCB0eXBlUGFyYW1ldGVycyA9IHRoaXMudHNUcnlQYXJzZVR5cGVQYXJhbWV0ZXJzKHRoaXMudHNQYXJzZUNvbnN0TW9kaWZpZXIpO1xuICAgIGlmICh0eXBlUGFyYW1ldGVycyAmJiBpc0NvbnN0cnVjdG9yKSB7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkNvbnN0cnVjdG9ySGFzVHlwZVBhcmFtZXRlcnMsIHR5cGVQYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZGVjbGFyZSA9IGZhbHNlLFxuICAgICAga2luZFxuICAgIH0gPSBtZXRob2Q7XG4gICAgaWYgKGRlY2xhcmUgJiYgKGtpbmQgPT09IFwiZ2V0XCIgfHwga2luZCA9PT0gXCJzZXRcIikpIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuRGVjbGFyZUFjY2Vzc29yLCBtZXRob2QsIHtcbiAgICAgICAga2luZFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0eXBlUGFyYW1ldGVycykgbWV0aG9kLnR5cGVQYXJhbWV0ZXJzID0gdHlwZVBhcmFtZXRlcnM7XG4gICAgc3VwZXIucHVzaENsYXNzTWV0aG9kKGNsYXNzQm9keSwgbWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNDb25zdHJ1Y3RvciwgYWxsb3dzRGlyZWN0U3VwZXIpO1xuICB9XG4gIHB1c2hDbGFzc1ByaXZhdGVNZXRob2QoY2xhc3NCb2R5LCBtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jKSB7XG4gICAgY29uc3QgdHlwZVBhcmFtZXRlcnMgPSB0aGlzLnRzVHJ5UGFyc2VUeXBlUGFyYW1ldGVycyh0aGlzLnRzUGFyc2VDb25zdE1vZGlmaWVyKTtcbiAgICBpZiAodHlwZVBhcmFtZXRlcnMpIG1ldGhvZC50eXBlUGFyYW1ldGVycyA9IHR5cGVQYXJhbWV0ZXJzO1xuICAgIHN1cGVyLnB1c2hDbGFzc1ByaXZhdGVNZXRob2QoY2xhc3NCb2R5LCBtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jKTtcbiAgfVxuICBkZWNsYXJlQ2xhc3NQcml2YXRlTWV0aG9kSW5TY29wZShub2RlLCBraW5kKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJUU0RlY2xhcmVNZXRob2RcIikgcmV0dXJuO1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiTWV0aG9kRGVmaW5pdGlvblwiICYmIG5vZGUudmFsdWUuYm9keSA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLmRlY2xhcmVDbGFzc1ByaXZhdGVNZXRob2RJblNjb3BlKG5vZGUsIGtpbmQpO1xuICB9XG4gIHBhcnNlQ2xhc3NTdXBlcihub2RlKSB7XG4gICAgc3VwZXIucGFyc2VDbGFzc1N1cGVyKG5vZGUpO1xuICAgIGlmIChub2RlLnN1cGVyQ2xhc3MgJiYgKHRoaXMubWF0Y2goNDcpIHx8IHRoaXMubWF0Y2goNTEpKSkge1xuICAgICAge1xuICAgICAgICBub2RlLnN1cGVyVHlwZVBhcmFtZXRlcnMgPSB0aGlzLnRzUGFyc2VUeXBlQXJndW1lbnRzSW5FeHByZXNzaW9uKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmVhdENvbnRleHR1YWwoMTEzKSkge1xuICAgICAgbm9kZS5pbXBsZW1lbnRzID0gdGhpcy50c1BhcnNlSGVyaXRhZ2VDbGF1c2UoXCJpbXBsZW1lbnRzXCIpO1xuICAgIH1cbiAgfVxuICBwYXJzZU9ialByb3BWYWx1ZShwcm9wLCBzdGFydExvYywgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzUGF0dGVybiwgaXNBY2Nlc3NvciwgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGNvbnN0IHR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1RyeVBhcnNlVHlwZVBhcmFtZXRlcnModGhpcy50c1BhcnNlQ29uc3RNb2RpZmllcik7XG4gICAgaWYgKHR5cGVQYXJhbWV0ZXJzKSBwcm9wLnR5cGVQYXJhbWV0ZXJzID0gdHlwZVBhcmFtZXRlcnM7XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlT2JqUHJvcFZhbHVlKHByb3AsIHN0YXJ0TG9jLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNQYXR0ZXJuLCBpc0FjY2Vzc29yLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgfVxuICBwYXJzZUZ1bmN0aW9uUGFyYW1zKG5vZGUsIGlzQ29uc3RydWN0b3IpIHtcbiAgICBjb25zdCB0eXBlUGFyYW1ldGVycyA9IHRoaXMudHNUcnlQYXJzZVR5cGVQYXJhbWV0ZXJzKHRoaXMudHNQYXJzZUNvbnN0TW9kaWZpZXIpO1xuICAgIGlmICh0eXBlUGFyYW1ldGVycykgbm9kZS50eXBlUGFyYW1ldGVycyA9IHR5cGVQYXJhbWV0ZXJzO1xuICAgIHN1cGVyLnBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSwgaXNDb25zdHJ1Y3Rvcik7XG4gIH1cbiAgcGFyc2VWYXJJZChkZWNsLCBraW5kKSB7XG4gICAgc3VwZXIucGFyc2VWYXJJZChkZWNsLCBraW5kKTtcbiAgICBpZiAoZGVjbC5pZC50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiAhdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSAmJiB0aGlzLmVhdCgzNSkpIHtcbiAgICAgIGRlY2wuZGVmaW5pdGUgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gdGhpcy50c1RyeVBhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICBpZiAodHlwZSkge1xuICAgICAgZGVjbC5pZC50eXBlQW5ub3RhdGlvbiA9IHR5cGU7XG4gICAgICB0aGlzLnJlc2V0RW5kTG9jYXRpb24oZGVjbC5pZCk7XG4gICAgfVxuICB9XG4gIHBhcnNlQXN5bmNBcnJvd0Zyb21DYWxsRXhwcmVzc2lvbihub2RlLCBjYWxsKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICBub2RlLnJldHVyblR5cGUgPSB0aGlzLnRzUGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGFyc2VBc3luY0Fycm93RnJvbUNhbGxFeHByZXNzaW9uKG5vZGUsIGNhbGwpO1xuICB9XG4gIHBhcnNlTWF5YmVBc3NpZ24ocmVmRXhwcmVzc2lvbkVycm9ycywgYWZ0ZXJMZWZ0UGFyc2UpIHtcbiAgICB2YXIgX2pzeCwgX2pzeDIsIF90eXBlQ2FzdCwgX2pzeDMsIF90eXBlQ2FzdDI7XG4gICAgbGV0IHN0YXRlO1xuICAgIGxldCBqc3g7XG4gICAgbGV0IHR5cGVDYXN0O1xuICAgIGlmICh0aGlzLmhhc1BsdWdpbihcImpzeFwiKSAmJiAodGhpcy5tYXRjaCgxNDMpIHx8IHRoaXMubWF0Y2goNDcpKSkge1xuICAgICAgc3RhdGUgPSB0aGlzLnN0YXRlLmNsb25lKCk7XG4gICAgICBqc3ggPSB0aGlzLnRyeVBhcnNlKCgpID0+IHN1cGVyLnBhcnNlTWF5YmVBc3NpZ24ocmVmRXhwcmVzc2lvbkVycm9ycywgYWZ0ZXJMZWZ0UGFyc2UpLCBzdGF0ZSk7XG4gICAgICBpZiAoIWpzeC5lcnJvcikgcmV0dXJuIGpzeC5ub2RlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb250ZXh0XG4gICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGNvbnN0IGN1cnJlbnRDb250ZXh0ID0gY29udGV4dFtjb250ZXh0Lmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGN1cnJlbnRDb250ZXh0ID09PSB0eXBlcy5qX29UYWcgfHwgY3VycmVudENvbnRleHQgPT09IHR5cGVzLmpfZXhwcikge1xuICAgICAgICBjb250ZXh0LnBvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoISgoX2pzeCA9IGpzeCkgIT0gbnVsbCAmJiBfanN4LmVycm9yKSAmJiAhdGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIHJldHVybiBzdXBlci5wYXJzZU1heWJlQXNzaWduKHJlZkV4cHJlc3Npb25FcnJvcnMsIGFmdGVyTGVmdFBhcnNlKTtcbiAgICB9XG4gICAgaWYgKCFzdGF0ZSB8fCBzdGF0ZSA9PT0gdGhpcy5zdGF0ZSkgc3RhdGUgPSB0aGlzLnN0YXRlLmNsb25lKCk7XG4gICAgbGV0IHR5cGVQYXJhbWV0ZXJzO1xuICAgIGNvbnN0IGFycm93ID0gdGhpcy50cnlQYXJzZShhYm9ydCA9PiB7XG4gICAgICB2YXIgX2V4cHIkZXh0cmEsIF90eXBlUGFyYW1ldGVycztcbiAgICAgIHR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1BhcnNlVHlwZVBhcmFtZXRlcnModGhpcy50c1BhcnNlQ29uc3RNb2RpZmllcik7XG4gICAgICBjb25zdCBleHByID0gc3VwZXIucGFyc2VNYXliZUFzc2lnbihyZWZFeHByZXNzaW9uRXJyb3JzLCBhZnRlckxlZnRQYXJzZSk7XG4gICAgICBpZiAoZXhwci50eXBlICE9PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgfHwgKF9leHByJGV4dHJhID0gZXhwci5leHRyYSkgIT0gbnVsbCAmJiBfZXhwciRleHRyYS5wYXJlbnRoZXNpemVkKSB7XG4gICAgICAgIGFib3J0KCk7XG4gICAgICB9XG4gICAgICBpZiAoKChfdHlwZVBhcmFtZXRlcnMgPSB0eXBlUGFyYW1ldGVycykgPT0gbnVsbCA/IHZvaWQgMCA6IF90eXBlUGFyYW1ldGVycy5wYXJhbXMubGVuZ3RoKSAhPT0gMCkge1xuICAgICAgICB0aGlzLnJlc2V0U3RhcnRMb2NhdGlvbkZyb21Ob2RlKGV4cHIsIHR5cGVQYXJhbWV0ZXJzKTtcbiAgICAgIH1cbiAgICAgIGV4cHIudHlwZVBhcmFtZXRlcnMgPSB0eXBlUGFyYW1ldGVycztcbiAgICAgIHJldHVybiBleHByO1xuICAgIH0sIHN0YXRlKTtcbiAgICBpZiAoIWFycm93LmVycm9yICYmICFhcnJvdy5hYm9ydGVkKSB7XG4gICAgICBpZiAodHlwZVBhcmFtZXRlcnMpIHRoaXMucmVwb3J0UmVzZXJ2ZWRBcnJvd1R5cGVQYXJhbSh0eXBlUGFyYW1ldGVycyk7XG4gICAgICByZXR1cm4gYXJyb3cubm9kZTtcbiAgICB9XG4gICAgaWYgKCFqc3gpIHtcbiAgICAgIGFzc2VydCghdGhpcy5oYXNQbHVnaW4oXCJqc3hcIikpO1xuICAgICAgdHlwZUNhc3QgPSB0aGlzLnRyeVBhcnNlKCgpID0+IHN1cGVyLnBhcnNlTWF5YmVBc3NpZ24ocmVmRXhwcmVzc2lvbkVycm9ycywgYWZ0ZXJMZWZ0UGFyc2UpLCBzdGF0ZSk7XG4gICAgICBpZiAoIXR5cGVDYXN0LmVycm9yKSByZXR1cm4gdHlwZUNhc3Qubm9kZTtcbiAgICB9XG4gICAgaWYgKChfanN4MiA9IGpzeCkgIT0gbnVsbCAmJiBfanN4Mi5ub2RlKSB7XG4gICAgICB0aGlzLnN0YXRlID0ganN4LmZhaWxTdGF0ZTtcbiAgICAgIHJldHVybiBqc3gubm9kZTtcbiAgICB9XG4gICAgaWYgKGFycm93Lm5vZGUpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBhcnJvdy5mYWlsU3RhdGU7XG4gICAgICBpZiAodHlwZVBhcmFtZXRlcnMpIHRoaXMucmVwb3J0UmVzZXJ2ZWRBcnJvd1R5cGVQYXJhbSh0eXBlUGFyYW1ldGVycyk7XG4gICAgICByZXR1cm4gYXJyb3cubm9kZTtcbiAgICB9XG4gICAgaWYgKChfdHlwZUNhc3QgPSB0eXBlQ2FzdCkgIT0gbnVsbCAmJiBfdHlwZUNhc3Qubm9kZSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IHR5cGVDYXN0LmZhaWxTdGF0ZTtcbiAgICAgIHJldHVybiB0eXBlQ2FzdC5ub2RlO1xuICAgIH1cbiAgICB0aHJvdyAoKF9qc3gzID0ganN4KSA9PSBudWxsID8gdm9pZCAwIDogX2pzeDMuZXJyb3IpIHx8IGFycm93LmVycm9yIHx8ICgoX3R5cGVDYXN0MiA9IHR5cGVDYXN0KSA9PSBudWxsID8gdm9pZCAwIDogX3R5cGVDYXN0Mi5lcnJvcik7XG4gIH1cbiAgcmVwb3J0UmVzZXJ2ZWRBcnJvd1R5cGVQYXJhbShub2RlKSB7XG4gICAgdmFyIF9ub2RlJGV4dHJhMjtcbiAgICBpZiAobm9kZS5wYXJhbXMubGVuZ3RoID09PSAxICYmICFub2RlLnBhcmFtc1swXS5jb25zdHJhaW50ICYmICEoKF9ub2RlJGV4dHJhMiA9IG5vZGUuZXh0cmEpICE9IG51bGwgJiYgX25vZGUkZXh0cmEyLnRyYWlsaW5nQ29tbWEpICYmIHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwidHlwZXNjcmlwdFwiLCBcImRpc2FsbG93QW1iaWd1b3VzSlNYTGlrZVwiKSkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5SZXNlcnZlZEFycm93VHlwZVBhcmFtLCBub2RlKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VNYXliZVVuYXJ5KHJlZkV4cHJlc3Npb25FcnJvcnMsIHNhd1VuYXJ5KSB7XG4gICAgaWYgKCF0aGlzLmhhc1BsdWdpbihcImpzeFwiKSAmJiB0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVR5cGVBc3NlcnRpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlTWF5YmVVbmFyeShyZWZFeHByZXNzaW9uRXJyb3JzLCBzYXdVbmFyeSk7XG4gIH1cbiAgcGFyc2VBcnJvdyhub2RlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnRyeVBhcnNlKGFib3J0ID0+IHtcbiAgICAgICAgY29uc3QgcmV0dXJuVHlwZSA9IHRoaXMudHNQYXJzZVR5cGVPclR5cGVQcmVkaWNhdGVBbm5vdGF0aW9uKDE0KTtcbiAgICAgICAgaWYgKHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgfHwgIXRoaXMubWF0Y2goMTkpKSBhYm9ydCgpO1xuICAgICAgICByZXR1cm4gcmV0dXJuVHlwZTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHJlc3VsdC5hYm9ydGVkKSByZXR1cm47XG4gICAgICBpZiAoIXJlc3VsdC50aHJvd24pIHtcbiAgICAgICAgaWYgKHJlc3VsdC5lcnJvcikgdGhpcy5zdGF0ZSA9IHJlc3VsdC5mYWlsU3RhdGU7XG4gICAgICAgIG5vZGUucmV0dXJuVHlwZSA9IHJlc3VsdC5ub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGFyc2VBcnJvdyhub2RlKTtcbiAgfVxuICBwYXJzZUZ1bmN0aW9uUGFyYW1UeXBlKHBhcmFtKSB7XG4gICAgaWYgKHRoaXMuZWF0KDE3KSkge1xuICAgICAgcGFyYW0ub3B0aW9uYWwgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gdGhpcy50c1RyeVBhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICBpZiAodHlwZSkgcGFyYW0udHlwZUFubm90YXRpb24gPSB0eXBlO1xuICAgIHRoaXMucmVzZXRFbmRMb2NhdGlvbihwYXJhbSk7XG4gICAgcmV0dXJuIHBhcmFtO1xuICB9XG4gIGlzQXNzaWduYWJsZShub2RlLCBpc0JpbmRpbmcpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcIlRTVHlwZUNhc3RFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmlzQXNzaWduYWJsZShub2RlLmV4cHJlc3Npb24sIGlzQmluZGluZyk7XG4gICAgICBjYXNlIFwiVFNQYXJhbWV0ZXJQcm9wZXJ0eVwiOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBzdXBlci5pc0Fzc2lnbmFibGUobm9kZSwgaXNCaW5kaW5nKTtcbiAgICB9XG4gIH1cbiAgdG9Bc3NpZ25hYmxlKG5vZGUsIGlzTEhTID0gZmFsc2UpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI6XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlUGFyZW50aGVzaXplZEV4cHJlc3Npb24obm9kZSwgaXNMSFMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJUU0FzRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIlRTU2F0aXNmaWVzRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIlRTTm9uTnVsbEV4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJUU1R5cGVBc3NlcnRpb25cIjpcbiAgICAgICAgaWYgKGlzTEhTKSB7XG4gICAgICAgICAgdGhpcy5leHByZXNzaW9uU2NvcGUucmVjb3JkQXJyb3dQYXJhbWV0ZXJCaW5kaW5nRXJyb3IoVFNFcnJvcnMuVW5leHBlY3RlZFR5cGVDYXN0SW5QYXJhbWV0ZXIsIG5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuVW5leHBlY3RlZFR5cGVDYXN0SW5QYXJhbWV0ZXIsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUuZXhwcmVzc2lvbiwgaXNMSFMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOlxuICAgICAgICBpZiAoIWlzTEhTICYmIG5vZGUubGVmdC50eXBlID09PSBcIlRTVHlwZUNhc3RFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgICBub2RlLmxlZnQgPSB0aGlzLnR5cGVDYXN0VG9QYXJhbWV0ZXIobm9kZS5sZWZ0KTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc3VwZXIudG9Bc3NpZ25hYmxlKG5vZGUsIGlzTEhTKTtcbiAgICB9XG4gIH1cbiAgdG9Bc3NpZ25hYmxlUGFyZW50aGVzaXplZEV4cHJlc3Npb24obm9kZSwgaXNMSFMpIHtcbiAgICBzd2l0Y2ggKG5vZGUuZXhwcmVzc2lvbi50eXBlKSB7XG4gICAgICBjYXNlIFwiVFNBc0V4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJUU1NhdGlzZmllc0V4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJUU05vbk51bGxFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiVFNUeXBlQXNzZXJ0aW9uXCI6XG4gICAgICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS5leHByZXNzaW9uLCBpc0xIUyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc3VwZXIudG9Bc3NpZ25hYmxlKG5vZGUsIGlzTEhTKTtcbiAgICB9XG4gIH1cbiAgY2hlY2tUb1Jlc3RDb252ZXJzaW9uKG5vZGUsIGFsbG93UGF0dGVybikge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwiVFNBc0V4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJUU1NhdGlzZmllc0V4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJUU1R5cGVBc3NlcnRpb25cIjpcbiAgICAgIGNhc2UgXCJUU05vbk51bGxFeHByZXNzaW9uXCI6XG4gICAgICAgIHRoaXMuY2hlY2tUb1Jlc3RDb252ZXJzaW9uKG5vZGUuZXhwcmVzc2lvbiwgZmFsc2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHN1cGVyLmNoZWNrVG9SZXN0Q29udmVyc2lvbihub2RlLCBhbGxvd1BhdHRlcm4pO1xuICAgIH1cbiAgfVxuICBpc1ZhbGlkTFZhbCh0eXBlLCBpc1VucGFyZW50aGVzaXplZEluQXNzaWduLCBiaW5kaW5nKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiVFNUeXBlQ2FzdEV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlIFwiVFNQYXJhbWV0ZXJQcm9wZXJ0eVwiOlxuICAgICAgICByZXR1cm4gXCJwYXJhbWV0ZXJcIjtcbiAgICAgIGNhc2UgXCJUU05vbk51bGxFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiBcImV4cHJlc3Npb25cIjtcbiAgICAgIGNhc2UgXCJUU0FzRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIlRTU2F0aXNmaWVzRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIlRTVHlwZUFzc2VydGlvblwiOlxuICAgICAgICByZXR1cm4gKGJpbmRpbmcgIT09IDY0IHx8ICFpc1VucGFyZW50aGVzaXplZEluQXNzaWduKSAmJiBbXCJleHByZXNzaW9uXCIsIHRydWVdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHN1cGVyLmlzVmFsaWRMVmFsKHR5cGUsIGlzVW5wYXJlbnRoZXNpemVkSW5Bc3NpZ24sIGJpbmRpbmcpO1xuICAgIH1cbiAgfVxuICBwYXJzZUJpbmRpbmdBdG9tKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLnR5cGUgPT09IDc4KSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gIH1cbiAgcGFyc2VNYXliZURlY29yYXRvckFyZ3VtZW50cyhleHByLCBzdGFydExvYykge1xuICAgIGlmICh0aGlzLm1hdGNoKDQ3KSB8fCB0aGlzLm1hdGNoKDUxKSkge1xuICAgICAgY29uc3QgdHlwZUFyZ3VtZW50cyA9IHRoaXMudHNQYXJzZVR5cGVBcmd1bWVudHNJbkV4cHJlc3Npb24oKTtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDEwKSkge1xuICAgICAgICBjb25zdCBjYWxsID0gc3VwZXIucGFyc2VNYXliZURlY29yYXRvckFyZ3VtZW50cyhleHByLCBzdGFydExvYyk7XG4gICAgICAgIHtcbiAgICAgICAgICBjYWxsLnR5cGVQYXJhbWV0ZXJzID0gdHlwZUFyZ3VtZW50cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMudW5leHBlY3RlZChudWxsLCAxMCk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZU1heWJlRGVjb3JhdG9yQXJndW1lbnRzKGV4cHIsIHN0YXJ0TG9jKTtcbiAgfVxuICBjaGVja0NvbW1hQWZ0ZXJSZXN0KGNsb3NlKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuaXNBbWJpZW50Q29udGV4dCAmJiB0aGlzLm1hdGNoKDEyKSAmJiB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgPT09IGNsb3NlKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmNoZWNrQ29tbWFBZnRlclJlc3QoY2xvc2UpO1xuICB9XG4gIGlzQ2xhc3NNZXRob2QoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goNDcpIHx8IHN1cGVyLmlzQ2xhc3NNZXRob2QoKTtcbiAgfVxuICBpc0NsYXNzUHJvcGVydHkoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goMzUpIHx8IHRoaXMubWF0Y2goMTQpIHx8IHN1cGVyLmlzQ2xhc3NQcm9wZXJ0eSgpO1xuICB9XG4gIHBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0TG9jLCBsZWZ0KSB7XG4gICAgY29uc3Qgbm9kZSA9IHN1cGVyLnBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0TG9jLCBsZWZ0KTtcbiAgICBpZiAobm9kZS50eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIgJiYgbm9kZS50eXBlQW5ub3RhdGlvbiAmJiBub2RlLnJpZ2h0LnN0YXJ0IDwgbm9kZS50eXBlQW5ub3RhdGlvbi5zdGFydCkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5UeXBlQW5ub3RhdGlvbkFmdGVyQXNzaWduLCBub2RlLnR5cGVBbm5vdGF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuaW5UeXBlKSB7XG4gICAgICBpZiAoY29kZSA9PT0gNjIpIHtcbiAgICAgICAgdGhpcy5maW5pc2hPcCg0OCwgMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjb2RlID09PSA2MCkge1xuICAgICAgICB0aGlzLmZpbmlzaE9wKDQ3LCAxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBzdXBlci5nZXRUb2tlbkZyb21Db2RlKGNvZGUpO1xuICB9XG4gIHJlU2Nhbl9sdF9ndCgpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHR5cGUgPT09IDQ3KSB7XG4gICAgICB0aGlzLnN0YXRlLnBvcyAtPSAxO1xuICAgICAgdGhpcy5yZWFkVG9rZW5fbHQoKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDQ4KSB7XG4gICAgICB0aGlzLnN0YXRlLnBvcyAtPSAxO1xuICAgICAgdGhpcy5yZWFkVG9rZW5fZ3QoKTtcbiAgICB9XG4gIH1cbiAgcmVTY2FuX2x0KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodHlwZSA9PT0gNTEpIHtcbiAgICAgIHRoaXMuc3RhdGUucG9zIC09IDI7XG4gICAgICB0aGlzLmZpbmlzaE9wKDQ3LCAxKTtcbiAgICAgIHJldHVybiA0NztcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgdG9Bc3NpZ25hYmxlTGlzdEl0ZW0oZXhwckxpc3QsIGluZGV4LCBpc0xIUykge1xuICAgIGNvbnN0IG5vZGUgPSBleHByTGlzdFtpbmRleF07XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJUU1R5cGVDYXN0RXhwcmVzc2lvblwiKSB7XG4gICAgICBleHByTGlzdFtpbmRleF0gPSB0aGlzLnR5cGVDYXN0VG9QYXJhbWV0ZXIobm9kZSk7XG4gICAgfVxuICAgIHN1cGVyLnRvQXNzaWduYWJsZUxpc3RJdGVtKGV4cHJMaXN0LCBpbmRleCwgaXNMSFMpO1xuICB9XG4gIHR5cGVDYXN0VG9QYXJhbWV0ZXIobm9kZSkge1xuICAgIG5vZGUuZXhwcmVzc2lvbi50eXBlQW5ub3RhdGlvbiA9IG5vZGUudHlwZUFubm90YXRpb247XG4gICAgdGhpcy5yZXNldEVuZExvY2F0aW9uKG5vZGUuZXhwcmVzc2lvbiwgbm9kZS50eXBlQW5ub3RhdGlvbi5sb2MuZW5kKTtcbiAgICByZXR1cm4gbm9kZS5leHByZXNzaW9uO1xuICB9XG4gIHNob3VsZFBhcnNlQXJyb3cocGFyYW1zKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICByZXR1cm4gcGFyYW1zLmV2ZXJ5KGV4cHIgPT4gdGhpcy5pc0Fzc2lnbmFibGUoZXhwciwgdHJ1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuc2hvdWxkUGFyc2VBcnJvdyhwYXJhbXMpO1xuICB9XG4gIHNob3VsZFBhcnNlQXN5bmNBcnJvdygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgxNCkgfHwgc3VwZXIuc2hvdWxkUGFyc2VBc3luY0Fycm93KCk7XG4gIH1cbiAgY2FuSGF2ZUxlYWRpbmdEZWNvcmF0b3IoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNhbkhhdmVMZWFkaW5nRGVjb3JhdG9yKCkgfHwgdGhpcy5pc0Fic3RyYWN0Q2xhc3MoKTtcbiAgfVxuICBqc3hQYXJzZU9wZW5pbmdFbGVtZW50QWZ0ZXJOYW1lKG5vZGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCg0NykgfHwgdGhpcy5tYXRjaCg1MSkpIHtcbiAgICAgIGNvbnN0IHR5cGVBcmd1bWVudHMgPSB0aGlzLnRzVHJ5UGFyc2VBbmRDYXRjaCgoKSA9PiB0aGlzLnRzUGFyc2VUeXBlQXJndW1lbnRzSW5FeHByZXNzaW9uKCkpO1xuICAgICAgaWYgKHR5cGVBcmd1bWVudHMpIHtcbiAgICAgICAge1xuICAgICAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0eXBlQXJndW1lbnRzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5qc3hQYXJzZU9wZW5pbmdFbGVtZW50QWZ0ZXJOYW1lKG5vZGUpO1xuICB9XG4gIGdldEdldHRlclNldHRlckV4cGVjdGVkUGFyYW1Db3VudChtZXRob2QpIHtcbiAgICBjb25zdCBiYXNlQ291bnQgPSBzdXBlci5nZXRHZXR0ZXJTZXR0ZXJFeHBlY3RlZFBhcmFtQ291bnQobWV0aG9kKTtcbiAgICBjb25zdCBwYXJhbXMgPSB0aGlzLmdldE9iamVjdE9yQ2xhc3NNZXRob2RQYXJhbXMobWV0aG9kKTtcbiAgICBjb25zdCBmaXJzdFBhcmFtID0gcGFyYW1zWzBdO1xuICAgIGNvbnN0IGhhc0NvbnRleHRQYXJhbSA9IGZpcnN0UGFyYW0gJiYgdGhpcy5pc1RoaXNQYXJhbShmaXJzdFBhcmFtKTtcbiAgICByZXR1cm4gaGFzQ29udGV4dFBhcmFtID8gYmFzZUNvdW50ICsgMSA6IGJhc2VDb3VudDtcbiAgfVxuICBwYXJzZUNhdGNoQ2xhdXNlUGFyYW0oKSB7XG4gICAgY29uc3QgcGFyYW0gPSBzdXBlci5wYXJzZUNhdGNoQ2xhdXNlUGFyYW0oKTtcbiAgICBjb25zdCB0eXBlID0gdGhpcy50c1RyeVBhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICBpZiAodHlwZSkge1xuICAgICAgcGFyYW0udHlwZUFubm90YXRpb24gPSB0eXBlO1xuICAgICAgdGhpcy5yZXNldEVuZExvY2F0aW9uKHBhcmFtKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtO1xuICB9XG4gIHRzSW5BbWJpZW50Q29udGV4dChjYikge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzQW1iaWVudENvbnRleHQ6IG9sZElzQW1iaWVudENvbnRleHQsXG4gICAgICBzdHJpY3Q6IG9sZFN0cmljdFxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIHRoaXMuc3RhdGUuaXNBbWJpZW50Q29udGV4dCA9IHRydWU7XG4gICAgdGhpcy5zdGF0ZS5zdHJpY3QgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNiKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuc3RhdGUuaXNBbWJpZW50Q29udGV4dCA9IG9sZElzQW1iaWVudENvbnRleHQ7XG4gICAgICB0aGlzLnN0YXRlLnN0cmljdCA9IG9sZFN0cmljdDtcbiAgICB9XG4gIH1cbiAgcGFyc2VDbGFzcyhub2RlLCBpc1N0YXRlbWVudCwgb3B0aW9uYWxJZCkge1xuICAgIGNvbnN0IG9sZEluQWJzdHJhY3RDbGFzcyA9IHRoaXMuc3RhdGUuaW5BYnN0cmFjdENsYXNzO1xuICAgIHRoaXMuc3RhdGUuaW5BYnN0cmFjdENsYXNzID0gISFub2RlLmFic3RyYWN0O1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gc3VwZXIucGFyc2VDbGFzcyhub2RlLCBpc1N0YXRlbWVudCwgb3B0aW9uYWxJZCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuc3RhdGUuaW5BYnN0cmFjdENsYXNzID0gb2xkSW5BYnN0cmFjdENsYXNzO1xuICAgIH1cbiAgfVxuICB0c1BhcnNlQWJzdHJhY3REZWNsYXJhdGlvbihub2RlLCBkZWNvcmF0b3JzKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goODApKSB7XG4gICAgICBub2RlLmFic3RyYWN0ID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLm1heWJlVGFrZURlY29yYXRvcnMoZGVjb3JhdG9ycywgdGhpcy5wYXJzZUNsYXNzKG5vZGUsIHRydWUsIGZhbHNlKSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMjkpKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzRm9sbG93aW5nTGluZUJyZWFrKCkpIHtcbiAgICAgICAgbm9kZS5hYnN0cmFjdCA9IHRydWU7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuTm9uQ2xhc3NNZXRob2RQcm9wZXJ0eUhhc0Fic3RyYWN0TW9kaWZpZXIsIG5vZGUpO1xuICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlSW50ZXJmYWNlRGVjbGFyYXRpb24obm9kZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZChudWxsLCA4MCk7XG4gICAgfVxuICB9XG4gIHBhcnNlTWV0aG9kKG5vZGUsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc0NvbnN0cnVjdG9yLCBhbGxvd0RpcmVjdFN1cGVyLCB0eXBlLCBpbkNsYXNzU2NvcGUpIHtcbiAgICBjb25zdCBtZXRob2QgPSBzdXBlci5wYXJzZU1ldGhvZChub2RlLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNDb25zdHJ1Y3RvciwgYWxsb3dEaXJlY3RTdXBlciwgdHlwZSwgaW5DbGFzc1Njb3BlKTtcbiAgICBpZiAobWV0aG9kLmFic3RyYWN0IHx8IG1ldGhvZC50eXBlID09PSBcIlRTQWJzdHJhY3RNZXRob2REZWZpbml0aW9uXCIpIHtcbiAgICAgIGNvbnN0IGhhc0VzdHJlZVBsdWdpbiA9IHRoaXMuaGFzUGx1Z2luKFwiZXN0cmVlXCIpO1xuICAgICAgY29uc3QgbWV0aG9kRm4gPSBoYXNFc3RyZWVQbHVnaW4gPyBtZXRob2QudmFsdWUgOiBtZXRob2Q7XG4gICAgICBpZiAobWV0aG9kRm4uYm9keSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAga2V5XG4gICAgICAgIH0gPSBtZXRob2Q7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuQWJzdHJhY3RNZXRob2RIYXNJbXBsZW1lbnRhdGlvbiwgbWV0aG9kLCB7XG4gICAgICAgICAgbWV0aG9kTmFtZToga2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmICFtZXRob2QuY29tcHV0ZWQgPyBrZXkubmFtZSA6IGBbJHt0aGlzLmlucHV0LnNsaWNlKHRoaXMub2Zmc2V0VG9Tb3VyY2VQb3Moa2V5LnN0YXJ0KSwgdGhpcy5vZmZzZXRUb1NvdXJjZVBvcyhrZXkuZW5kKSl9XWBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXRob2Q7XG4gIH1cbiAgdHNQYXJzZVR5cGVQYXJhbWV0ZXJOYW1lKCkge1xuICAgIGNvbnN0IHR5cGVOYW1lID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICByZXR1cm4gdHlwZU5hbWUubmFtZTtcbiAgfVxuICBzaG91bGRQYXJzZUFzQW1iaWVudENvbnRleHQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5nZXRQbHVnaW5PcHRpb24oXCJ0eXBlc2NyaXB0XCIsIFwiZHRzXCIpO1xuICB9XG4gIHBhcnNlKCkge1xuICAgIGlmICh0aGlzLnNob3VsZFBhcnNlQXNBbWJpZW50Q29udGV4dCgpKSB7XG4gICAgICB0aGlzLnN0YXRlLmlzQW1iaWVudENvbnRleHQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGFyc2UoKTtcbiAgfVxuICBnZXRFeHByZXNzaW9uKCkge1xuICAgIGlmICh0aGlzLnNob3VsZFBhcnNlQXNBbWJpZW50Q29udGV4dCgpKSB7XG4gICAgICB0aGlzLnN0YXRlLmlzQW1iaWVudENvbnRleHQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuZ2V0RXhwcmVzc2lvbigpO1xuICB9XG4gIHBhcnNlRXhwb3J0U3BlY2lmaWVyKG5vZGUsIGlzU3RyaW5nLCBpc0luVHlwZUV4cG9ydCwgaXNNYXliZVR5cGVPbmx5KSB7XG4gICAgaWYgKCFpc1N0cmluZyAmJiBpc01heWJlVHlwZU9ubHkpIHtcbiAgICAgIHRoaXMucGFyc2VUeXBlT25seUltcG9ydEV4cG9ydFNwZWNpZmllcihub2RlLCBmYWxzZSwgaXNJblR5cGVFeHBvcnQpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydFNwZWNpZmllclwiKTtcbiAgICB9XG4gICAgbm9kZS5leHBvcnRLaW5kID0gXCJ2YWx1ZVwiO1xuICAgIHJldHVybiBzdXBlci5wYXJzZUV4cG9ydFNwZWNpZmllcihub2RlLCBpc1N0cmluZywgaXNJblR5cGVFeHBvcnQsIGlzTWF5YmVUeXBlT25seSk7XG4gIH1cbiAgcGFyc2VJbXBvcnRTcGVjaWZpZXIoc3BlY2lmaWVyLCBpbXBvcnRlZElzU3RyaW5nLCBpc0luVHlwZU9ubHlJbXBvcnQsIGlzTWF5YmVUeXBlT25seSwgYmluZGluZ1R5cGUpIHtcbiAgICBpZiAoIWltcG9ydGVkSXNTdHJpbmcgJiYgaXNNYXliZVR5cGVPbmx5KSB7XG4gICAgICB0aGlzLnBhcnNlVHlwZU9ubHlJbXBvcnRFeHBvcnRTcGVjaWZpZXIoc3BlY2lmaWVyLCB0cnVlLCBpc0luVHlwZU9ubHlJbXBvcnQpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShzcGVjaWZpZXIsIFwiSW1wb3J0U3BlY2lmaWVyXCIpO1xuICAgIH1cbiAgICBzcGVjaWZpZXIuaW1wb3J0S2luZCA9IFwidmFsdWVcIjtcbiAgICByZXR1cm4gc3VwZXIucGFyc2VJbXBvcnRTcGVjaWZpZXIoc3BlY2lmaWVyLCBpbXBvcnRlZElzU3RyaW5nLCBpc0luVHlwZU9ubHlJbXBvcnQsIGlzTWF5YmVUeXBlT25seSwgaXNJblR5cGVPbmx5SW1wb3J0ID8gNDA5OCA6IDQwOTYpO1xuICB9XG4gIHBhcnNlVHlwZU9ubHlJbXBvcnRFeHBvcnRTcGVjaWZpZXIobm9kZSwgaXNJbXBvcnQsIGlzSW5UeXBlT25seUltcG9ydEV4cG9ydCkge1xuICAgIGNvbnN0IGxlZnRPZkFzS2V5ID0gaXNJbXBvcnQgPyBcImltcG9ydGVkXCIgOiBcImxvY2FsXCI7XG4gICAgY29uc3QgcmlnaHRPZkFzS2V5ID0gaXNJbXBvcnQgPyBcImxvY2FsXCIgOiBcImV4cG9ydGVkXCI7XG4gICAgbGV0IGxlZnRPZkFzID0gbm9kZVtsZWZ0T2ZBc0tleV07XG4gICAgbGV0IHJpZ2h0T2ZBcztcbiAgICBsZXQgaGFzVHlwZVNwZWNpZmllciA9IGZhbHNlO1xuICAgIGxldCBjYW5QYXJzZUFzS2V5d29yZCA9IHRydWU7XG4gICAgY29uc3QgbG9jID0gbGVmdE9mQXMubG9jLnN0YXJ0O1xuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCg5MykpIHtcbiAgICAgIGNvbnN0IGZpcnN0QXMgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDkzKSkge1xuICAgICAgICBjb25zdCBzZWNvbmRBcyA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICAgIGlmICh0b2tlbklzS2V5d29yZE9ySWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICAgICAgaGFzVHlwZVNwZWNpZmllciA9IHRydWU7XG4gICAgICAgICAgbGVmdE9mQXMgPSBmaXJzdEFzO1xuICAgICAgICAgIHJpZ2h0T2ZBcyA9IGlzSW1wb3J0ID8gdGhpcy5wYXJzZUlkZW50aWZpZXIoKSA6IHRoaXMucGFyc2VNb2R1bGVFeHBvcnROYW1lKCk7XG4gICAgICAgICAgY2FuUGFyc2VBc0tleXdvcmQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByaWdodE9mQXMgPSBzZWNvbmRBcztcbiAgICAgICAgICBjYW5QYXJzZUFzS2V5d29yZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRva2VuSXNLZXl3b3JkT3JJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgICAgY2FuUGFyc2VBc0tleXdvcmQgPSBmYWxzZTtcbiAgICAgICAgcmlnaHRPZkFzID0gaXNJbXBvcnQgPyB0aGlzLnBhcnNlSWRlbnRpZmllcigpIDogdGhpcy5wYXJzZU1vZHVsZUV4cG9ydE5hbWUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhc1R5cGVTcGVjaWZpZXIgPSB0cnVlO1xuICAgICAgICBsZWZ0T2ZBcyA9IGZpcnN0QXM7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0b2tlbklzS2V5d29yZE9ySWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICBoYXNUeXBlU3BlY2lmaWVyID0gdHJ1ZTtcbiAgICAgIGlmIChpc0ltcG9ydCkge1xuICAgICAgICBsZWZ0T2ZBcyA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgICAgICBpZiAoIXRoaXMuaXNDb250ZXh0dWFsKDkzKSkge1xuICAgICAgICAgIHRoaXMuY2hlY2tSZXNlcnZlZFdvcmQobGVmdE9mQXMubmFtZSwgbGVmdE9mQXMubG9jLnN0YXJ0LCB0cnVlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVmdE9mQXMgPSB0aGlzLnBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaGFzVHlwZVNwZWNpZmllciAmJiBpc0luVHlwZU9ubHlJbXBvcnRFeHBvcnQpIHtcbiAgICAgIHRoaXMucmFpc2UoaXNJbXBvcnQgPyBUU0Vycm9ycy5UeXBlTW9kaWZpZXJJc1VzZWRJblR5cGVJbXBvcnRzIDogVFNFcnJvcnMuVHlwZU1vZGlmaWVySXNVc2VkSW5UeXBlRXhwb3J0cywgbG9jKTtcbiAgICB9XG4gICAgbm9kZVtsZWZ0T2ZBc0tleV0gPSBsZWZ0T2ZBcztcbiAgICBub2RlW3JpZ2h0T2ZBc0tleV0gPSByaWdodE9mQXM7XG4gICAgY29uc3Qga2luZEtleSA9IGlzSW1wb3J0ID8gXCJpbXBvcnRLaW5kXCIgOiBcImV4cG9ydEtpbmRcIjtcbiAgICBub2RlW2tpbmRLZXldID0gaGFzVHlwZVNwZWNpZmllciA/IFwidHlwZVwiIDogXCJ2YWx1ZVwiO1xuICAgIGlmIChjYW5QYXJzZUFzS2V5d29yZCAmJiB0aGlzLmVhdENvbnRleHR1YWwoOTMpKSB7XG4gICAgICBub2RlW3JpZ2h0T2ZBc0tleV0gPSBpc0ltcG9ydCA/IHRoaXMucGFyc2VJZGVudGlmaWVyKCkgOiB0aGlzLnBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpO1xuICAgIH1cbiAgICBpZiAoIW5vZGVbcmlnaHRPZkFzS2V5XSkge1xuICAgICAgbm9kZVtyaWdodE9mQXNLZXldID0gdGhpcy5jbG9uZUlkZW50aWZpZXIobm9kZVtsZWZ0T2ZBc0tleV0pO1xuICAgIH1cbiAgICBpZiAoaXNJbXBvcnQpIHtcbiAgICAgIHRoaXMuY2hlY2tJZGVudGlmaWVyKG5vZGVbcmlnaHRPZkFzS2V5XSwgaGFzVHlwZVNwZWNpZmllciA/IDQwOTggOiA0MDk2KTtcbiAgICB9XG4gIH1cbiAgZmlsbE9wdGlvbmFsUHJvcGVydGllc0ZvclRTRVNMaW50KG5vZGUpIHtcbiAgICB2YXIgX25vZGUkZGlyZWN0aXZlLCBfbm9kZSRkZWNvcmF0b3JzLCBfbm9kZSRvcHRpb25hbCwgX25vZGUkdHlwZUFubm90YXRpb24sIF9ub2RlJGFjY2Vzc2liaWxpdHksIF9ub2RlJGRlY29yYXRvcnMyLCBfbm9kZSRvdmVycmlkZSwgX25vZGUkcmVhZG9ubHksIF9ub2RlJHN0YXRpYywgX25vZGUkZGVjbGFyZSwgX25vZGUkcmV0dXJuVHlwZSwgX25vZGUkdHlwZVBhcmFtZXRlcnMsIF9ub2RlJG9wdGlvbmFsMiwgX25vZGUkb3B0aW9uYWwzLCBfbm9kZSRhY2Nlc3NpYmlsaXR5MiwgX25vZGUkcmVhZG9ubHkyLCBfbm9kZSRzdGF0aWMyLCBfbm9kZSRkZWNsYXJlMiwgX25vZGUkZGVmaW5pdGUsIF9ub2RlJHJlYWRvbmx5MywgX25vZGUkdHlwZUFubm90YXRpb24yLCBfbm9kZSRhY2Nlc3NpYmlsaXR5MywgX25vZGUkZGVjb3JhdG9yczMsIF9ub2RlJG92ZXJyaWRlMiwgX25vZGUkb3B0aW9uYWw0LCBfbm9kZSRpZCwgX25vZGUkYWJzdHJhY3QsIF9ub2RlJGRlY2xhcmUzLCBfbm9kZSRkZWNvcmF0b3JzNCwgX25vZGUkaW1wbGVtZW50cywgX25vZGUkc3VwZXJUeXBlQXJndW1lLCBfbm9kZSR0eXBlUGFyYW1ldGVyczIsIF9ub2RlJGRlY2xhcmU0LCBfbm9kZSRkZWZpbml0ZTIsIF9ub2RlJGNvbnN0LCBfbm9kZSRkZWNsYXJlNSwgX25vZGUkY29tcHV0ZWQsIF9ub2RlJHF1YWxpZmllciwgX25vZGUkb3B0aW9ucywgX25vZGUkZGVjbGFyZTYsIF9ub2RlJGV4dGVuZHMsIF9ub2RlJGRlY2xhcmU3LCBfbm9kZSRnbG9iYWwsIF9ub2RlJGNvbnN0MiwgX25vZGUkaW4sIF9ub2RlJG91dDtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIjpcbiAgICAgICAgKF9ub2RlJGRpcmVjdGl2ZSA9IG5vZGUuZGlyZWN0aXZlKSAhPSBudWxsID8gX25vZGUkZGlyZWN0aXZlIDogbm9kZS5kaXJlY3RpdmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJSZXN0RWxlbWVudFwiOlxuICAgICAgICBub2RlLnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgICAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcbiAgICAgICAgKF9ub2RlJGRlY29yYXRvcnMgPSBub2RlLmRlY29yYXRvcnMpICE9IG51bGwgPyBfbm9kZSRkZWNvcmF0b3JzIDogbm9kZS5kZWNvcmF0b3JzID0gW107XG4gICAgICAgIChfbm9kZSRvcHRpb25hbCA9IG5vZGUub3B0aW9uYWwpICE9IG51bGwgPyBfbm9kZSRvcHRpb25hbCA6IG5vZGUub3B0aW9uYWwgPSBmYWxzZTtcbiAgICAgICAgKF9ub2RlJHR5cGVBbm5vdGF0aW9uID0gbm9kZS50eXBlQW5ub3RhdGlvbikgIT0gbnVsbCA/IF9ub2RlJHR5cGVBbm5vdGF0aW9uIDogbm9kZS50eXBlQW5ub3RhdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIlRTUGFyYW1ldGVyUHJvcGVydHlcIjpcbiAgICAgICAgKF9ub2RlJGFjY2Vzc2liaWxpdHkgPSBub2RlLmFjY2Vzc2liaWxpdHkpICE9IG51bGwgPyBfbm9kZSRhY2Nlc3NpYmlsaXR5IDogbm9kZS5hY2Nlc3NpYmlsaXR5ID0gdW5kZWZpbmVkO1xuICAgICAgICAoX25vZGUkZGVjb3JhdG9yczIgPSBub2RlLmRlY29yYXRvcnMpICE9IG51bGwgPyBfbm9kZSRkZWNvcmF0b3JzMiA6IG5vZGUuZGVjb3JhdG9ycyA9IFtdO1xuICAgICAgICAoX25vZGUkb3ZlcnJpZGUgPSBub2RlLm92ZXJyaWRlKSAhPSBudWxsID8gX25vZGUkb3ZlcnJpZGUgOiBub2RlLm92ZXJyaWRlID0gZmFsc2U7XG4gICAgICAgIChfbm9kZSRyZWFkb25seSA9IG5vZGUucmVhZG9ubHkpICE9IG51bGwgPyBfbm9kZSRyZWFkb25seSA6IG5vZGUucmVhZG9ubHkgPSBmYWxzZTtcbiAgICAgICAgKF9ub2RlJHN0YXRpYyA9IG5vZGUuc3RhdGljKSAhPSBudWxsID8gX25vZGUkc3RhdGljIDogbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIlRTRW1wdHlCb2R5RnVuY3Rpb25FeHByZXNzaW9uXCI6XG4gICAgICAgIG5vZGUuYm9keSA9IG51bGw7XG4gICAgICBjYXNlIFwiVFNEZWNsYXJlRnVuY3Rpb25cIjpcbiAgICAgIGNhc2UgXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCI6XG4gICAgICBjYXNlIFwiRnVuY3Rpb25FeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiQ2xhc3NNZXRob2RcIjpcbiAgICAgIGNhc2UgXCJDbGFzc1ByaXZhdGVNZXRob2RcIjpcbiAgICAgICAgKF9ub2RlJGRlY2xhcmUgPSBub2RlLmRlY2xhcmUpICE9IG51bGwgPyBfbm9kZSRkZWNsYXJlIDogbm9kZS5kZWNsYXJlID0gZmFsc2U7XG4gICAgICAgIChfbm9kZSRyZXR1cm5UeXBlID0gbm9kZS5yZXR1cm5UeXBlKSAhPSBudWxsID8gX25vZGUkcmV0dXJuVHlwZSA6IG5vZGUucmV0dXJuVHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgKF9ub2RlJHR5cGVQYXJhbWV0ZXJzID0gbm9kZS50eXBlUGFyYW1ldGVycykgIT0gbnVsbCA/IF9ub2RlJHR5cGVQYXJhbWV0ZXJzIDogbm9kZS50eXBlUGFyYW1ldGVycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIlByb3BlcnR5XCI6XG4gICAgICAgIChfbm9kZSRvcHRpb25hbDIgPSBub2RlLm9wdGlvbmFsKSAhPSBudWxsID8gX25vZGUkb3B0aW9uYWwyIDogbm9kZS5vcHRpb25hbCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiVFNNZXRob2RTaWduYXR1cmVcIjpcbiAgICAgIGNhc2UgXCJUU1Byb3BlcnR5U2lnbmF0dXJlXCI6XG4gICAgICAgIChfbm9kZSRvcHRpb25hbDMgPSBub2RlLm9wdGlvbmFsKSAhPSBudWxsID8gX25vZGUkb3B0aW9uYWwzIDogbm9kZS5vcHRpb25hbCA9IGZhbHNlO1xuICAgICAgY2FzZSBcIlRTSW5kZXhTaWduYXR1cmVcIjpcbiAgICAgICAgKF9ub2RlJGFjY2Vzc2liaWxpdHkyID0gbm9kZS5hY2Nlc3NpYmlsaXR5KSAhPSBudWxsID8gX25vZGUkYWNjZXNzaWJpbGl0eTIgOiBub2RlLmFjY2Vzc2liaWxpdHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIChfbm9kZSRyZWFkb25seTIgPSBub2RlLnJlYWRvbmx5KSAhPSBudWxsID8gX25vZGUkcmVhZG9ubHkyIDogbm9kZS5yZWFkb25seSA9IGZhbHNlO1xuICAgICAgICAoX25vZGUkc3RhdGljMiA9IG5vZGUuc3RhdGljKSAhPSBudWxsID8gX25vZGUkc3RhdGljMiA6IG5vZGUuc3RhdGljID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJUU0Fic3RyYWN0UHJvcGVydHlEZWZpbml0aW9uXCI6XG4gICAgICBjYXNlIFwiUHJvcGVydHlEZWZpbml0aW9uXCI6XG4gICAgICBjYXNlIFwiVFNBYnN0cmFjdEFjY2Vzc29yUHJvcGVydHlcIjpcbiAgICAgIGNhc2UgXCJBY2Nlc3NvclByb3BlcnR5XCI6XG4gICAgICAgIChfbm9kZSRkZWNsYXJlMiA9IG5vZGUuZGVjbGFyZSkgIT0gbnVsbCA/IF9ub2RlJGRlY2xhcmUyIDogbm9kZS5kZWNsYXJlID0gZmFsc2U7XG4gICAgICAgIChfbm9kZSRkZWZpbml0ZSA9IG5vZGUuZGVmaW5pdGUpICE9IG51bGwgPyBfbm9kZSRkZWZpbml0ZSA6IG5vZGUuZGVmaW5pdGUgPSBmYWxzZTtcbiAgICAgICAgKF9ub2RlJHJlYWRvbmx5MyA9IG5vZGUucmVhZG9ubHkpICE9IG51bGwgPyBfbm9kZSRyZWFkb25seTMgOiBub2RlLnJlYWRvbmx5ID0gZmFsc2U7XG4gICAgICAgIChfbm9kZSR0eXBlQW5ub3RhdGlvbjIgPSBub2RlLnR5cGVBbm5vdGF0aW9uKSAhPSBudWxsID8gX25vZGUkdHlwZUFubm90YXRpb24yIDogbm9kZS50eXBlQW5ub3RhdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgIGNhc2UgXCJUU0Fic3RyYWN0TWV0aG9kRGVmaW5pdGlvblwiOlxuICAgICAgY2FzZSBcIk1ldGhvZERlZmluaXRpb25cIjpcbiAgICAgICAgKF9ub2RlJGFjY2Vzc2liaWxpdHkzID0gbm9kZS5hY2Nlc3NpYmlsaXR5KSAhPSBudWxsID8gX25vZGUkYWNjZXNzaWJpbGl0eTMgOiBub2RlLmFjY2Vzc2liaWxpdHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIChfbm9kZSRkZWNvcmF0b3JzMyA9IG5vZGUuZGVjb3JhdG9ycykgIT0gbnVsbCA/IF9ub2RlJGRlY29yYXRvcnMzIDogbm9kZS5kZWNvcmF0b3JzID0gW107XG4gICAgICAgIChfbm9kZSRvdmVycmlkZTIgPSBub2RlLm92ZXJyaWRlKSAhPSBudWxsID8gX25vZGUkb3ZlcnJpZGUyIDogbm9kZS5vdmVycmlkZSA9IGZhbHNlO1xuICAgICAgICAoX25vZGUkb3B0aW9uYWw0ID0gbm9kZS5vcHRpb25hbCkgIT0gbnVsbCA/IF9ub2RlJG9wdGlvbmFsNCA6IG5vZGUub3B0aW9uYWwgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIkNsYXNzRXhwcmVzc2lvblwiOlxuICAgICAgICAoX25vZGUkaWQgPSBub2RlLmlkKSAhPSBudWxsID8gX25vZGUkaWQgOiBub2RlLmlkID0gbnVsbDtcbiAgICAgIGNhc2UgXCJDbGFzc0RlY2xhcmF0aW9uXCI6XG4gICAgICAgIChfbm9kZSRhYnN0cmFjdCA9IG5vZGUuYWJzdHJhY3QpICE9IG51bGwgPyBfbm9kZSRhYnN0cmFjdCA6IG5vZGUuYWJzdHJhY3QgPSBmYWxzZTtcbiAgICAgICAgKF9ub2RlJGRlY2xhcmUzID0gbm9kZS5kZWNsYXJlKSAhPSBudWxsID8gX25vZGUkZGVjbGFyZTMgOiBub2RlLmRlY2xhcmUgPSBmYWxzZTtcbiAgICAgICAgKF9ub2RlJGRlY29yYXRvcnM0ID0gbm9kZS5kZWNvcmF0b3JzKSAhPSBudWxsID8gX25vZGUkZGVjb3JhdG9yczQgOiBub2RlLmRlY29yYXRvcnMgPSBbXTtcbiAgICAgICAgKF9ub2RlJGltcGxlbWVudHMgPSBub2RlLmltcGxlbWVudHMpICE9IG51bGwgPyBfbm9kZSRpbXBsZW1lbnRzIDogbm9kZS5pbXBsZW1lbnRzID0gW107XG4gICAgICAgIChfbm9kZSRzdXBlclR5cGVBcmd1bWUgPSBub2RlLnN1cGVyVHlwZUFyZ3VtZW50cykgIT0gbnVsbCA/IF9ub2RlJHN1cGVyVHlwZUFyZ3VtZSA6IG5vZGUuc3VwZXJUeXBlQXJndW1lbnRzID0gdW5kZWZpbmVkO1xuICAgICAgICAoX25vZGUkdHlwZVBhcmFtZXRlcnMyID0gbm9kZS50eXBlUGFyYW1ldGVycykgIT0gbnVsbCA/IF9ub2RlJHR5cGVQYXJhbWV0ZXJzMiA6IG5vZGUudHlwZVBhcmFtZXRlcnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJUU1R5cGVBbGlhc0RlY2xhcmF0aW9uXCI6XG4gICAgICBjYXNlIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiOlxuICAgICAgICAoX25vZGUkZGVjbGFyZTQgPSBub2RlLmRlY2xhcmUpICE9IG51bGwgPyBfbm9kZSRkZWNsYXJlNCA6IG5vZGUuZGVjbGFyZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiVmFyaWFibGVEZWNsYXJhdG9yXCI6XG4gICAgICAgIChfbm9kZSRkZWZpbml0ZTIgPSBub2RlLmRlZmluaXRlKSAhPSBudWxsID8gX25vZGUkZGVmaW5pdGUyIDogbm9kZS5kZWZpbml0ZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiVFNFbnVtRGVjbGFyYXRpb25cIjpcbiAgICAgICAgKF9ub2RlJGNvbnN0ID0gbm9kZS5jb25zdCkgIT0gbnVsbCA/IF9ub2RlJGNvbnN0IDogbm9kZS5jb25zdCA9IGZhbHNlO1xuICAgICAgICAoX25vZGUkZGVjbGFyZTUgPSBub2RlLmRlY2xhcmUpICE9IG51bGwgPyBfbm9kZSRkZWNsYXJlNSA6IG5vZGUuZGVjbGFyZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiVFNFbnVtTWVtYmVyXCI6XG4gICAgICAgIChfbm9kZSRjb21wdXRlZCA9IG5vZGUuY29tcHV0ZWQpICE9IG51bGwgPyBfbm9kZSRjb21wdXRlZCA6IG5vZGUuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIlRTSW1wb3J0VHlwZVwiOlxuICAgICAgICAoX25vZGUkcXVhbGlmaWVyID0gbm9kZS5xdWFsaWZpZXIpICE9IG51bGwgPyBfbm9kZSRxdWFsaWZpZXIgOiBub2RlLnF1YWxpZmllciA9IG51bGw7XG4gICAgICAgIChfbm9kZSRvcHRpb25zID0gbm9kZS5vcHRpb25zKSAhPSBudWxsID8gX25vZGUkb3B0aW9ucyA6IG5vZGUub3B0aW9ucyA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJUU0ludGVyZmFjZURlY2xhcmF0aW9uXCI6XG4gICAgICAgIChfbm9kZSRkZWNsYXJlNiA9IG5vZGUuZGVjbGFyZSkgIT0gbnVsbCA/IF9ub2RlJGRlY2xhcmU2IDogbm9kZS5kZWNsYXJlID0gZmFsc2U7XG4gICAgICAgIChfbm9kZSRleHRlbmRzID0gbm9kZS5leHRlbmRzKSAhPSBudWxsID8gX25vZGUkZXh0ZW5kcyA6IG5vZGUuZXh0ZW5kcyA9IFtdO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiVFNNb2R1bGVEZWNsYXJhdGlvblwiOlxuICAgICAgICAoX25vZGUkZGVjbGFyZTcgPSBub2RlLmRlY2xhcmUpICE9IG51bGwgPyBfbm9kZSRkZWNsYXJlNyA6IG5vZGUuZGVjbGFyZSA9IGZhbHNlO1xuICAgICAgICAoX25vZGUkZ2xvYmFsID0gbm9kZS5nbG9iYWwpICE9IG51bGwgPyBfbm9kZSRnbG9iYWwgOiBub2RlLmdsb2JhbCA9IG5vZGUua2luZCA9PT0gXCJnbG9iYWxcIjtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIlRTVHlwZVBhcmFtZXRlclwiOlxuICAgICAgICAoX25vZGUkY29uc3QyID0gbm9kZS5jb25zdCkgIT0gbnVsbCA/IF9ub2RlJGNvbnN0MiA6IG5vZGUuY29uc3QgPSBmYWxzZTtcbiAgICAgICAgKF9ub2RlJGluID0gbm9kZS5pbikgIT0gbnVsbCA/IF9ub2RlJGluIDogbm9kZS5pbiA9IGZhbHNlO1xuICAgICAgICAoX25vZGUkb3V0ID0gbm9kZS5vdXQpICE9IG51bGwgPyBfbm9kZSRvdXQgOiBub2RlLm91dCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gaXNQb3NzaWJseUxpdGVyYWxFbnVtKGV4cHJlc3Npb24pIHtcbiAgaWYgKGV4cHJlc3Npb24udHlwZSAhPT0gXCJNZW1iZXJFeHByZXNzaW9uXCIpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qge1xuICAgIGNvbXB1dGVkLFxuICAgIHByb3BlcnR5XG4gIH0gPSBleHByZXNzaW9uO1xuICBpZiAoY29tcHV0ZWQgJiYgcHJvcGVydHkudHlwZSAhPT0gXCJTdHJpbmdMaXRlcmFsXCIgJiYgKHByb3BlcnR5LnR5cGUgIT09IFwiVGVtcGxhdGVMaXRlcmFsXCIgfHwgcHJvcGVydHkuZXhwcmVzc2lvbnMubGVuZ3RoID4gMCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzVW5jb21wdXRlZE1lbWJlckV4cHJlc3Npb25DaGFpbihleHByZXNzaW9uLm9iamVjdCk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkQW1iaWVudENvbnN0SW5pdGlhbGl6ZXIoZXhwcmVzc2lvbiwgZXN0cmVlKSB7XG4gIHZhciBfZXhwcmVzc2lvbiRleHRyYTtcbiAgY29uc3Qge1xuICAgIHR5cGVcbiAgfSA9IGV4cHJlc3Npb247XG4gIGlmICgoX2V4cHJlc3Npb24kZXh0cmEgPSBleHByZXNzaW9uLmV4dHJhKSAhPSBudWxsICYmIF9leHByZXNzaW9uJGV4dHJhLnBhcmVudGhlc2l6ZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGVzdHJlZSkge1xuICAgIGlmICh0eXBlID09PSBcIkxpdGVyYWxcIikge1xuICAgICAgY29uc3Qge1xuICAgICAgICB2YWx1ZVxuICAgICAgfSA9IGV4cHJlc3Npb247XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlID09PSBcIlN0cmluZ0xpdGVyYWxcIiB8fCB0eXBlID09PSBcIkJvb2xlYW5MaXRlcmFsXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNOdW1iZXIoZXhwcmVzc2lvbiwgZXN0cmVlKSB8fCBpc05lZ2F0aXZlTnVtYmVyKGV4cHJlc3Npb24sIGVzdHJlZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZSA9PT0gXCJUZW1wbGF0ZUxpdGVyYWxcIiAmJiBleHByZXNzaW9uLmV4cHJlc3Npb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc1Bvc3NpYmx5TGl0ZXJhbEVudW0oZXhwcmVzc2lvbikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc051bWJlcihleHByZXNzaW9uLCBlc3RyZWUpIHtcbiAgaWYgKGVzdHJlZSkge1xuICAgIHJldHVybiBleHByZXNzaW9uLnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmICh0eXBlb2YgZXhwcmVzc2lvbi52YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCBcImJpZ2ludFwiIGluIGV4cHJlc3Npb24pO1xuICB9XG4gIHJldHVybiBleHByZXNzaW9uLnR5cGUgPT09IFwiTnVtZXJpY0xpdGVyYWxcIiB8fCBleHByZXNzaW9uLnR5cGUgPT09IFwiQmlnSW50TGl0ZXJhbFwiO1xufVxuZnVuY3Rpb24gaXNOZWdhdGl2ZU51bWJlcihleHByZXNzaW9uLCBlc3RyZWUpIHtcbiAgaWYgKGV4cHJlc3Npb24udHlwZSA9PT0gXCJVbmFyeUV4cHJlc3Npb25cIikge1xuICAgIGNvbnN0IHtcbiAgICAgIG9wZXJhdG9yLFxuICAgICAgYXJndW1lbnRcbiAgICB9ID0gZXhwcmVzc2lvbjtcbiAgICBpZiAob3BlcmF0b3IgPT09IFwiLVwiICYmIGlzTnVtYmVyKGFyZ3VtZW50LCBlc3RyZWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNVbmNvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbkNoYWluKGV4cHJlc3Npb24pIHtcbiAgaWYgKGV4cHJlc3Npb24udHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHJldHVybiB0cnVlO1xuICBpZiAoZXhwcmVzc2lvbi50eXBlICE9PSBcIk1lbWJlckV4cHJlc3Npb25cIiB8fCBleHByZXNzaW9uLmNvbXB1dGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc1VuY29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uQ2hhaW4oZXhwcmVzc2lvbi5vYmplY3QpO1xufVxuY29uc3QgUGxhY2Vob2xkZXJFcnJvcnMgPSBQYXJzZUVycm9yRW51bWBwbGFjZWhvbGRlcnNgKHtcbiAgQ2xhc3NOYW1lSXNSZXF1aXJlZDogXCJBIGNsYXNzIG5hbWUgaXMgcmVxdWlyZWQuXCIsXG4gIFVuZXhwZWN0ZWRTcGFjZTogXCJVbmV4cGVjdGVkIHNwYWNlIGluIHBsYWNlaG9sZGVyLlwiXG59KTtcbnZhciBwbGFjZWhvbGRlcnMgPSBzdXBlckNsYXNzID0+IGNsYXNzIFBsYWNlaG9sZGVyc1BhcnNlck1peGluIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG4gIHBhcnNlUGxhY2Vob2xkZXIoZXhwZWN0ZWROb2RlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTMzKSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHRoaXMuYXNzZXJ0Tm9TcGFjZSgpO1xuICAgICAgbm9kZS5uYW1lID0gc3VwZXIucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgICAgdGhpcy5hc3NlcnROb1NwYWNlKCk7XG4gICAgICB0aGlzLmV4cGVjdCgxMzMpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoUGxhY2Vob2xkZXIobm9kZSwgZXhwZWN0ZWROb2RlKTtcbiAgICB9XG4gIH1cbiAgZmluaXNoUGxhY2Vob2xkZXIobm9kZSwgZXhwZWN0ZWROb2RlKSB7XG4gICAgbGV0IHBsYWNlaG9sZGVyID0gbm9kZTtcbiAgICBpZiAoIXBsYWNlaG9sZGVyLmV4cGVjdGVkTm9kZSB8fCAhcGxhY2Vob2xkZXIudHlwZSkge1xuICAgICAgcGxhY2Vob2xkZXIgPSB0aGlzLmZpbmlzaE5vZGUocGxhY2Vob2xkZXIsIFwiUGxhY2Vob2xkZXJcIik7XG4gICAgfVxuICAgIHBsYWNlaG9sZGVyLmV4cGVjdGVkTm9kZSA9IGV4cGVjdGVkTm9kZTtcbiAgICByZXR1cm4gcGxhY2Vob2xkZXI7XG4gIH1cbiAgZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDM3ICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpID09PSAzNykge1xuICAgICAgdGhpcy5maW5pc2hPcCgxMzMsIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlci5nZXRUb2tlbkZyb21Db2RlKGNvZGUpO1xuICAgIH1cbiAgfVxuICBwYXJzZUV4cHJBdG9tKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVBsYWNlaG9sZGVyKFwiRXhwcmVzc2lvblwiKSB8fCBzdXBlci5wYXJzZUV4cHJBdG9tKHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICB9XG4gIHBhcnNlSWRlbnRpZmllcihsaWJlcmFsKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VQbGFjZWhvbGRlcihcIklkZW50aWZpZXJcIikgfHwgc3VwZXIucGFyc2VJZGVudGlmaWVyKGxpYmVyYWwpO1xuICB9XG4gIGNoZWNrUmVzZXJ2ZWRXb3JkKHdvcmQsIHN0YXJ0TG9jLCBjaGVja0tleXdvcmRzLCBpc0JpbmRpbmcpIHtcbiAgICBpZiAod29yZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdXBlci5jaGVja1Jlc2VydmVkV29yZCh3b3JkLCBzdGFydExvYywgY2hlY2tLZXl3b3JkcywgaXNCaW5kaW5nKTtcbiAgICB9XG4gIH1cbiAgY2xvbmVJZGVudGlmaWVyKG5vZGUpIHtcbiAgICBjb25zdCBjbG9uZWQgPSBzdXBlci5jbG9uZUlkZW50aWZpZXIobm9kZSk7XG4gICAgaWYgKGNsb25lZC50eXBlID09PSBcIlBsYWNlaG9sZGVyXCIpIHtcbiAgICAgIGNsb25lZC5leHBlY3RlZE5vZGUgPSBub2RlLmV4cGVjdGVkTm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfVxuICBjbG9uZVN0cmluZ0xpdGVyYWwobm9kZSkge1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiUGxhY2Vob2xkZXJcIikge1xuICAgICAgcmV0dXJuIHRoaXMuY2xvbmVJZGVudGlmaWVyKG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuY2xvbmVTdHJpbmdMaXRlcmFsKG5vZGUpO1xuICB9XG4gIHBhcnNlQmluZGluZ0F0b20oKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VQbGFjZWhvbGRlcihcIlBhdHRlcm5cIikgfHwgc3VwZXIucGFyc2VCaW5kaW5nQXRvbSgpO1xuICB9XG4gIGlzVmFsaWRMVmFsKHR5cGUsIGlzUGFyZW50aGVzaXplZCwgYmluZGluZykge1xuICAgIHJldHVybiB0eXBlID09PSBcIlBsYWNlaG9sZGVyXCIgfHwgc3VwZXIuaXNWYWxpZExWYWwodHlwZSwgaXNQYXJlbnRoZXNpemVkLCBiaW5kaW5nKTtcbiAgfVxuICB0b0Fzc2lnbmFibGUobm9kZSwgaXNMSFMpIHtcbiAgICBpZiAobm9kZSAmJiBub2RlLnR5cGUgPT09IFwiUGxhY2Vob2xkZXJcIiAmJiBub2RlLmV4cGVjdGVkTm9kZSA9PT0gXCJFeHByZXNzaW9uXCIpIHtcbiAgICAgIG5vZGUuZXhwZWN0ZWROb2RlID0gXCJQYXR0ZXJuXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLnRvQXNzaWduYWJsZShub2RlLCBpc0xIUyk7XG4gICAgfVxuICB9XG4gIGNoU3RhcnRzQmluZGluZ0lkZW50aWZpZXIoY2gsIHBvcykge1xuICAgIGlmIChzdXBlci5jaFN0YXJ0c0JpbmRpbmdJZGVudGlmaWVyKGNoLCBwb3MpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgbmV4dCA9IHRoaXMubmV4dFRva2VuU3RhcnQoKTtcbiAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KG5leHQpID09PSAzNyAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQobmV4dCArIDEpID09PSAzNykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2ZXJpZnlCcmVha0NvbnRpbnVlKG5vZGUsIGlzQnJlYWspIHtcbiAgICBpZiAobm9kZS5sYWJlbCAmJiBub2RlLmxhYmVsLnR5cGUgPT09IFwiUGxhY2Vob2xkZXJcIikgcmV0dXJuO1xuICAgIHN1cGVyLnZlcmlmeUJyZWFrQ29udGludWUobm9kZSwgaXNCcmVhayk7XG4gIH1cbiAgcGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIpIHtcbiAgICB2YXIgX2V4cHIkZXh0cmE7XG4gICAgaWYgKGV4cHIudHlwZSAhPT0gXCJQbGFjZWhvbGRlclwiIHx8IChfZXhwciRleHRyYSA9IGV4cHIuZXh0cmEpICE9IG51bGwgJiYgX2V4cHIkZXh0cmEucGFyZW50aGVzaXplZCkge1xuICAgICAgcmV0dXJuIHN1cGVyLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCBleHByKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICBjb25zdCBzdG10ID0gbm9kZTtcbiAgICAgIHN0bXQubGFiZWwgPSB0aGlzLmZpbmlzaFBsYWNlaG9sZGVyKGV4cHIsIFwiSWRlbnRpZmllclwiKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgc3RtdC5ib2R5ID0gc3VwZXIucGFyc2VTdGF0ZW1lbnRPclNsb3BweUFubmV4QkZ1bmN0aW9uRGVjbGFyYXRpb24oKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoc3RtdCwgXCJMYWJlbGVkU3RhdGVtZW50XCIpO1xuICAgIH1cbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIGNvbnN0IHN0bXRQbGFjZWhvbGRlciA9IG5vZGU7XG4gICAgc3RtdFBsYWNlaG9sZGVyLm5hbWUgPSBleHByLm5hbWU7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoUGxhY2Vob2xkZXIoc3RtdFBsYWNlaG9sZGVyLCBcIlN0YXRlbWVudFwiKTtcbiAgfVxuICBwYXJzZUJsb2NrKGFsbG93RGlyZWN0aXZlcywgY3JlYXRlTmV3TGV4aWNhbFNjb3BlLCBhZnRlckJsb2NrUGFyc2UpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVBsYWNlaG9sZGVyKFwiQmxvY2tTdGF0ZW1lbnRcIikgfHwgc3VwZXIucGFyc2VCbG9jayhhbGxvd0RpcmVjdGl2ZXMsIGNyZWF0ZU5ld0xleGljYWxTY29wZSwgYWZ0ZXJCbG9ja1BhcnNlKTtcbiAgfVxuICBwYXJzZUZ1bmN0aW9uSWQocmVxdWlyZUlkKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VQbGFjZWhvbGRlcihcIklkZW50aWZpZXJcIikgfHwgc3VwZXIucGFyc2VGdW5jdGlvbklkKHJlcXVpcmVJZCk7XG4gIH1cbiAgcGFyc2VDbGFzcyhub2RlLCBpc1N0YXRlbWVudCwgb3B0aW9uYWxJZCkge1xuICAgIGNvbnN0IHR5cGUgPSBpc1N0YXRlbWVudCA/IFwiQ2xhc3NEZWNsYXJhdGlvblwiIDogXCJDbGFzc0V4cHJlc3Npb25cIjtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBjb25zdCBvbGRTdHJpY3QgPSB0aGlzLnN0YXRlLnN0cmljdDtcbiAgICBjb25zdCBwbGFjZWhvbGRlciA9IHRoaXMucGFyc2VQbGFjZWhvbGRlcihcIklkZW50aWZpZXJcIik7XG4gICAgaWYgKHBsYWNlaG9sZGVyKSB7XG4gICAgICBpZiAodGhpcy5tYXRjaCg4MSkgfHwgdGhpcy5tYXRjaCgxMzMpIHx8IHRoaXMubWF0Y2goNSkpIHtcbiAgICAgICAgbm9kZS5pZCA9IHBsYWNlaG9sZGVyO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25hbElkIHx8ICFpc1N0YXRlbWVudCkge1xuICAgICAgICBub2RlLmlkID0gbnVsbDtcbiAgICAgICAgbm9kZS5ib2R5ID0gdGhpcy5maW5pc2hQbGFjZWhvbGRlcihwbGFjZWhvbGRlciwgXCJDbGFzc0JvZHlcIik7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgdHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKFBsYWNlaG9sZGVyRXJyb3JzLkNsYXNzTmFtZUlzUmVxdWlyZWQsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhcnNlQ2xhc3NJZChub2RlLCBpc1N0YXRlbWVudCwgb3B0aW9uYWxJZCk7XG4gICAgfVxuICAgIHN1cGVyLnBhcnNlQ2xhc3NTdXBlcihub2RlKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlUGxhY2Vob2xkZXIoXCJDbGFzc0JvZHlcIikgfHwgc3VwZXIucGFyc2VDbGFzc0JvZHkoISFub2RlLnN1cGVyQ2xhc3MsIG9sZFN0cmljdCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCB0eXBlKTtcbiAgfVxuICBwYXJzZUV4cG9ydChub2RlLCBkZWNvcmF0b3JzKSB7XG4gICAgY29uc3QgcGxhY2Vob2xkZXIgPSB0aGlzLnBhcnNlUGxhY2Vob2xkZXIoXCJJZGVudGlmaWVyXCIpO1xuICAgIGlmICghcGxhY2Vob2xkZXIpIHJldHVybiBzdXBlci5wYXJzZUV4cG9ydChub2RlLCBkZWNvcmF0b3JzKTtcbiAgICBjb25zdCBub2RlMiA9IG5vZGU7XG4gICAgaWYgKCF0aGlzLmlzQ29udGV4dHVhbCg5OCkgJiYgIXRoaXMubWF0Y2goMTIpKSB7XG4gICAgICBub2RlMi5zcGVjaWZpZXJzID0gW107XG4gICAgICBub2RlMi5zb3VyY2UgPSBudWxsO1xuICAgICAgbm9kZTIuZGVjbGFyYXRpb24gPSB0aGlzLmZpbmlzaFBsYWNlaG9sZGVyKHBsYWNlaG9sZGVyLCBcIkRlY2xhcmF0aW9uXCIpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlMiwgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIpO1xuICAgIH1cbiAgICB0aGlzLmV4cGVjdFBsdWdpbihcImV4cG9ydERlZmF1bHRGcm9tXCIpO1xuICAgIGNvbnN0IHNwZWNpZmllciA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgc3BlY2lmaWVyLmV4cG9ydGVkID0gcGxhY2Vob2xkZXI7XG4gICAgbm9kZTIuc3BlY2lmaWVycyA9IFt0aGlzLmZpbmlzaE5vZGUoc3BlY2lmaWVyLCBcIkV4cG9ydERlZmF1bHRTcGVjaWZpZXJcIildO1xuICAgIHJldHVybiBzdXBlci5wYXJzZUV4cG9ydChub2RlMiwgZGVjb3JhdG9ycyk7XG4gIH1cbiAgaXNFeHBvcnREZWZhdWx0U3BlY2lmaWVyKCkge1xuICAgIGlmICh0aGlzLm1hdGNoKDY1KSkge1xuICAgICAgY29uc3QgbmV4dCA9IHRoaXMubmV4dFRva2VuU3RhcnQoKTtcbiAgICAgIGlmICh0aGlzLmlzVW5wYXJzZWRDb250ZXh0dWFsKG5leHQsIFwiZnJvbVwiKSkge1xuICAgICAgICBpZiAodGhpcy5pbnB1dC5zdGFydHNXaXRoKHRva2VuTGFiZWxOYW1lKDEzMyksIHRoaXMubmV4dFRva2VuU3RhcnRTaW5jZShuZXh0ICsgNCkpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmlzRXhwb3J0RGVmYXVsdFNwZWNpZmllcigpO1xuICB9XG4gIG1heWJlUGFyc2VFeHBvcnREZWZhdWx0U3BlY2lmaWVyKG5vZGUsIG1heWJlRGVmYXVsdElkZW50aWZpZXIpIHtcbiAgICB2YXIgX3NwZWNpZmllcnM7XG4gICAgaWYgKChfc3BlY2lmaWVycyA9IG5vZGUuc3BlY2lmaWVycykgIT0gbnVsbCAmJiBfc3BlY2lmaWVycy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIubWF5YmVQYXJzZUV4cG9ydERlZmF1bHRTcGVjaWZpZXIobm9kZSwgbWF5YmVEZWZhdWx0SWRlbnRpZmllcik7XG4gIH1cbiAgY2hlY2tFeHBvcnQobm9kZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNwZWNpZmllcnNcbiAgICB9ID0gbm9kZTtcbiAgICBpZiAoc3BlY2lmaWVycyAhPSBudWxsICYmIHNwZWNpZmllcnMubGVuZ3RoKSB7XG4gICAgICBub2RlLnNwZWNpZmllcnMgPSBzcGVjaWZpZXJzLmZpbHRlcihub2RlID0+IG5vZGUuZXhwb3J0ZWQudHlwZSA9PT0gXCJQbGFjZWhvbGRlclwiKTtcbiAgICB9XG4gICAgc3VwZXIuY2hlY2tFeHBvcnQobm9kZSk7XG4gICAgbm9kZS5zcGVjaWZpZXJzID0gc3BlY2lmaWVycztcbiAgfVxuICBwYXJzZUltcG9ydChub2RlKSB7XG4gICAgY29uc3QgcGxhY2Vob2xkZXIgPSB0aGlzLnBhcnNlUGxhY2Vob2xkZXIoXCJJZGVudGlmaWVyXCIpO1xuICAgIGlmICghcGxhY2Vob2xkZXIpIHJldHVybiBzdXBlci5wYXJzZUltcG9ydChub2RlKTtcbiAgICBub2RlLnNwZWNpZmllcnMgPSBbXTtcbiAgICBpZiAoIXRoaXMuaXNDb250ZXh0dWFsKDk4KSAmJiAhdGhpcy5tYXRjaCgxMikpIHtcbiAgICAgIG5vZGUuc291cmNlID0gdGhpcy5maW5pc2hQbGFjZWhvbGRlcihwbGFjZWhvbGRlciwgXCJTdHJpbmdMaXRlcmFsXCIpO1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnREZWNsYXJhdGlvblwiKTtcbiAgICB9XG4gICAgY29uc3Qgc3BlY2lmaWVyID0gdGhpcy5zdGFydE5vZGVBdE5vZGUocGxhY2Vob2xkZXIpO1xuICAgIHNwZWNpZmllci5sb2NhbCA9IHBsYWNlaG9sZGVyO1xuICAgIG5vZGUuc3BlY2lmaWVycy5wdXNoKHRoaXMuZmluaXNoTm9kZShzcGVjaWZpZXIsIFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiKSk7XG4gICAgaWYgKHRoaXMuZWF0KDEyKSkge1xuICAgICAgY29uc3QgaGFzU3RhckltcG9ydCA9IHRoaXMubWF5YmVQYXJzZVN0YXJJbXBvcnRTcGVjaWZpZXIobm9kZSk7XG4gICAgICBpZiAoIWhhc1N0YXJJbXBvcnQpIHRoaXMucGFyc2VOYW1lZEltcG9ydFNwZWNpZmllcnMobm9kZSk7XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbCg5OCk7XG4gICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlSW1wb3J0U291cmNlKCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RGVjbGFyYXRpb25cIik7XG4gIH1cbiAgcGFyc2VJbXBvcnRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VQbGFjZWhvbGRlcihcIlN0cmluZ0xpdGVyYWxcIikgfHwgc3VwZXIucGFyc2VJbXBvcnRTb3VyY2UoKTtcbiAgfVxuICBhc3NlcnROb1NwYWNlKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLnN0YXJ0ID4gdGhpcy5vZmZzZXRUb1NvdXJjZVBvcyh0aGlzLnN0YXRlLmxhc3RUb2tFbmRMb2MuaW5kZXgpKSB7XG4gICAgICB0aGlzLnJhaXNlKFBsYWNlaG9sZGVyRXJyb3JzLlVuZXhwZWN0ZWRTcGFjZSwgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jKTtcbiAgICB9XG4gIH1cbn07XG52YXIgdjhpbnRyaW5zaWMgPSBzdXBlckNsYXNzID0+IGNsYXNzIFY4SW50cmluc2ljTWl4aW4gZXh0ZW5kcyBzdXBlckNsYXNzIHtcbiAgcGFyc2VWOEludHJpbnNpYygpIHtcbiAgICBpZiAodGhpcy5tYXRjaCg1NCkpIHtcbiAgICAgIGNvbnN0IHY4SW50cmluc2ljU3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGlmICh0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcbiAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IHRoaXMuY3JlYXRlSWRlbnRpZmllcihub2RlLCBuYW1lKTtcbiAgICAgICAgdGhpcy5jYXN0Tm9kZVRvKGlkZW50aWZpZXIsIFwiVjhJbnRyaW5zaWNJZGVudGlmaWVyXCIpO1xuICAgICAgICBpZiAodGhpcy5tYXRjaCgxMCkpIHtcbiAgICAgICAgICByZXR1cm4gaWRlbnRpZmllcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy51bmV4cGVjdGVkKHY4SW50cmluc2ljU3RhcnRMb2MpO1xuICAgIH1cbiAgfVxuICBwYXJzZUV4cHJBdG9tKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVY4SW50cmluc2ljKCkgfHwgc3VwZXIucGFyc2VFeHByQXRvbShyZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgfVxufTtcbmNvbnN0IFBJUEVMSU5FX1BST1BPU0FMUyA9IFtcIm1pbmltYWxcIiwgXCJmc2hhcnBcIiwgXCJoYWNrXCIsIFwic21hcnRcIl07XG5jb25zdCBUT1BJQ19UT0tFTlMgPSBbXCJeXlwiLCBcIkBAXCIsIFwiXlwiLCBcIiVcIiwgXCIjXCJdO1xuZnVuY3Rpb24gdmFsaWRhdGVQbHVnaW5zKHBsdWdpbnNNYXApIHtcbiAgaWYgKHBsdWdpbnNNYXAuaGFzKFwiZGVjb3JhdG9yc1wiKSkge1xuICAgIGlmIChwbHVnaW5zTWFwLmhhcyhcImRlY29yYXRvcnMtbGVnYWN5XCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXNlIHRoZSBkZWNvcmF0b3JzIGFuZCBkZWNvcmF0b3JzLWxlZ2FjeSBwbHVnaW4gdG9nZXRoZXJcIik7XG4gICAgfVxuICAgIGNvbnN0IGRlY29yYXRvcnNCZWZvcmVFeHBvcnQgPSBwbHVnaW5zTWFwLmdldChcImRlY29yYXRvcnNcIikuZGVjb3JhdG9yc0JlZm9yZUV4cG9ydDtcbiAgICBpZiAoZGVjb3JhdG9yc0JlZm9yZUV4cG9ydCAhPSBudWxsICYmIHR5cGVvZiBkZWNvcmF0b3JzQmVmb3JlRXhwb3J0ICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ2RlY29yYXRvcnNCZWZvcmVFeHBvcnQnIG11c3QgYmUgYSBib29sZWFuLCBpZiBzcGVjaWZpZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCBhbGxvd0NhbGxQYXJlbnRoZXNpemVkID0gcGx1Z2luc01hcC5nZXQoXCJkZWNvcmF0b3JzXCIpLmFsbG93Q2FsbFBhcmVudGhlc2l6ZWQ7XG4gICAgaWYgKGFsbG93Q2FsbFBhcmVudGhlc2l6ZWQgIT0gbnVsbCAmJiB0eXBlb2YgYWxsb3dDYWxsUGFyZW50aGVzaXplZCAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIidhbGxvd0NhbGxQYXJlbnRoZXNpemVkJyBtdXN0IGJlIGEgYm9vbGVhbi5cIik7XG4gICAgfVxuICB9XG4gIGlmIChwbHVnaW5zTWFwLmhhcyhcImZsb3dcIikgJiYgcGx1Z2luc01hcC5oYXMoXCJ0eXBlc2NyaXB0XCIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbWJpbmUgZmxvdyBhbmQgdHlwZXNjcmlwdCBwbHVnaW5zLlwiKTtcbiAgfVxuICBpZiAocGx1Z2luc01hcC5oYXMoXCJwbGFjZWhvbGRlcnNcIikgJiYgcGx1Z2luc01hcC5oYXMoXCJ2OGludHJpbnNpY1wiKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb21iaW5lIHBsYWNlaG9sZGVycyBhbmQgdjhpbnRyaW5zaWMgcGx1Z2lucy5cIik7XG4gIH1cbiAgaWYgKHBsdWdpbnNNYXAuaGFzKFwicGlwZWxpbmVPcGVyYXRvclwiKSkge1xuICAgIHZhciBfcGx1Z2luc01hcCRnZXQyO1xuICAgIGNvbnN0IHByb3Bvc2FsID0gcGx1Z2luc01hcC5nZXQoXCJwaXBlbGluZU9wZXJhdG9yXCIpLnByb3Bvc2FsO1xuICAgIGlmICghUElQRUxJTkVfUFJPUE9TQUxTLmluY2x1ZGVzKHByb3Bvc2FsKSkge1xuICAgICAgY29uc3QgcHJvcG9zYWxMaXN0ID0gUElQRUxJTkVfUFJPUE9TQUxTLm1hcChwID0+IGBcIiR7cH1cImApLmpvaW4oXCIsIFwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgXCJwaXBlbGluZU9wZXJhdG9yXCIgcmVxdWlyZXMgXCJwcm9wb3NhbFwiIG9wdGlvbiB3aG9zZSB2YWx1ZSBtdXN0IGJlIG9uZSBvZjogJHtwcm9wb3NhbExpc3R9LmApO1xuICAgIH1cbiAgICBpZiAocHJvcG9zYWwgPT09IFwiaGFja1wiKSB7XG4gICAgICBpZiAocGx1Z2luc01hcC5oYXMoXCJwbGFjZWhvbGRlcnNcIikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbWJpbmUgcGxhY2Vob2xkZXJzIHBsdWdpbiBhbmQgSGFjay1zdHlsZSBwaXBlcy5cIik7XG4gICAgICB9XG4gICAgICBpZiAocGx1Z2luc01hcC5oYXMoXCJ2OGludHJpbnNpY1wiKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tYmluZSB2OGludHJpbnNpYyBwbHVnaW4gYW5kIEhhY2stc3R5bGUgcGlwZXMuXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgdG9waWNUb2tlbiA9IHBsdWdpbnNNYXAuZ2V0KFwicGlwZWxpbmVPcGVyYXRvclwiKS50b3BpY1Rva2VuO1xuICAgICAgaWYgKCFUT1BJQ19UT0tFTlMuaW5jbHVkZXModG9waWNUb2tlbikpIHtcbiAgICAgICAgY29uc3QgdG9rZW5MaXN0ID0gVE9QSUNfVE9LRU5TLm1hcCh0ID0+IGBcIiR7dH1cImApLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcInBpcGVsaW5lT3BlcmF0b3JcIiBpbiBcInByb3Bvc2FsXCI6IFwiaGFja1wiIG1vZGUgYWxzbyByZXF1aXJlcyBhIFwidG9waWNUb2tlblwiIG9wdGlvbiB3aG9zZSB2YWx1ZSBtdXN0IGJlIG9uZSBvZjogJHt0b2tlbkxpc3R9LmApO1xuICAgICAgfVxuICAgICAge1xuICAgICAgICB2YXIgX3BsdWdpbnNNYXAkZ2V0O1xuICAgICAgICBpZiAodG9waWNUb2tlbiA9PT0gXCIjXCIgJiYgKChfcGx1Z2luc01hcCRnZXQgPSBwbHVnaW5zTWFwLmdldChcInJlY29yZEFuZFR1cGxlXCIpKSA9PSBudWxsID8gdm9pZCAwIDogX3BsdWdpbnNNYXAkZ2V0LnN5bnRheFR5cGUpID09PSBcImhhc2hcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUGx1Z2luIGNvbmZsaWN0IGJldHdlZW4gXFxgW1wicGlwZWxpbmVPcGVyYXRvclwiLCB7IHByb3Bvc2FsOiBcImhhY2tcIiwgdG9waWNUb2tlbjogXCIjXCIgfV1cXGAgYW5kIFxcYCR7SlNPTi5zdHJpbmdpZnkoW1wicmVjb3JkQW5kVHVwbGVcIiwgcGx1Z2luc01hcC5nZXQoXCJyZWNvcmRBbmRUdXBsZVwiKV0pfVxcYC5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcG9zYWwgPT09IFwic21hcnRcIiAmJiAoKF9wbHVnaW5zTWFwJGdldDIgPSBwbHVnaW5zTWFwLmdldChcInJlY29yZEFuZFR1cGxlXCIpKSA9PSBudWxsID8gdm9pZCAwIDogX3BsdWdpbnNNYXAkZ2V0Mi5zeW50YXhUeXBlKSA9PT0gXCJoYXNoXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUGx1Z2luIGNvbmZsaWN0IGJldHdlZW4gXFxgW1wicGlwZWxpbmVPcGVyYXRvclwiLCB7IHByb3Bvc2FsOiBcInNtYXJ0XCIgfV1cXGAgYW5kIFxcYCR7SlNPTi5zdHJpbmdpZnkoW1wicmVjb3JkQW5kVHVwbGVcIiwgcGx1Z2luc01hcC5nZXQoXCJyZWNvcmRBbmRUdXBsZVwiKV0pfVxcYC5gKTtcbiAgICB9XG4gIH1cbiAgaWYgKHBsdWdpbnNNYXAuaGFzKFwibW9kdWxlQXR0cmlidXRlc1wiKSkge1xuICAgIHtcbiAgICAgIGlmIChwbHVnaW5zTWFwLmhhcyhcImRlcHJlY2F0ZWRJbXBvcnRBc3NlcnRcIikgfHwgcGx1Z2luc01hcC5oYXMoXCJpbXBvcnRBc3NlcnRpb25zXCIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb21iaW5lIGltcG9ydEFzc2VydGlvbnMsIGRlcHJlY2F0ZWRJbXBvcnRBc3NlcnQgYW5kIG1vZHVsZUF0dHJpYnV0ZXMgcGx1Z2lucy5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCBtb2R1bGVBdHRyaWJ1dGVzVmVyc2lvblBsdWdpbk9wdGlvbiA9IHBsdWdpbnNNYXAuZ2V0KFwibW9kdWxlQXR0cmlidXRlc1wiKS52ZXJzaW9uO1xuICAgICAgaWYgKG1vZHVsZUF0dHJpYnV0ZXNWZXJzaW9uUGx1Z2luT3B0aW9uICE9PSBcIm1heS0yMDIwXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlICdtb2R1bGVBdHRyaWJ1dGVzJyBwbHVnaW4gcmVxdWlyZXMgYSAndmVyc2lvbicgb3B0aW9uLFwiICsgXCIgcmVwcmVzZW50aW5nIHRoZSBsYXN0IHByb3Bvc2FsIHVwZGF0ZS4gQ3VycmVudGx5LCB0aGVcIiArIFwiIG9ubHkgc3VwcG9ydGVkIHZhbHVlIGlzICdtYXktMjAyMCcuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocGx1Z2luc01hcC5oYXMoXCJpbXBvcnRBc3NlcnRpb25zXCIpKSB7XG4gICAgaWYgKHBsdWdpbnNNYXAuaGFzKFwiZGVwcmVjYXRlZEltcG9ydEFzc2VydFwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbWJpbmUgaW1wb3J0QXNzZXJ0aW9ucyBhbmQgZGVwcmVjYXRlZEltcG9ydEFzc2VydCBwbHVnaW5zLlwiKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFwbHVnaW5zTWFwLmhhcyhcImRlcHJlY2F0ZWRJbXBvcnRBc3NlcnRcIikgJiYgcGx1Z2luc01hcC5oYXMoXCJpbXBvcnRBdHRyaWJ1dGVzXCIpICYmIHBsdWdpbnNNYXAuZ2V0KFwiaW1wb3J0QXR0cmlidXRlc1wiKS5kZXByZWNhdGVkQXNzZXJ0U3ludGF4KSB7XG4gICAge1xuICAgICAgcGx1Z2luc01hcC5zZXQoXCJkZXByZWNhdGVkSW1wb3J0QXNzZXJ0XCIsIHt9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHBsdWdpbnNNYXAuaGFzKFwicmVjb3JkQW5kVHVwbGVcIikpIHtcbiAgICB7XG4gICAgICBjb25zdCBzeW50YXhUeXBlID0gcGx1Z2luc01hcC5nZXQoXCJyZWNvcmRBbmRUdXBsZVwiKS5zeW50YXhUeXBlO1xuICAgICAgaWYgKHN5bnRheFR5cGUgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBSRUNPUkRfQU5EX1RVUExFX1NZTlRBWF9UWVBFUyA9IFtcImhhc2hcIiwgXCJiYXJcIl07XG4gICAgICAgIGlmICghUkVDT1JEX0FORF9UVVBMRV9TWU5UQVhfVFlQRVMuaW5jbHVkZXMoc3ludGF4VHlwZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgJ3N5bnRheFR5cGUnIG9wdGlvbiBvZiB0aGUgJ3JlY29yZEFuZFR1cGxlJyBwbHVnaW4gbXVzdCBiZSBvbmUgb2Y6IFwiICsgUkVDT1JEX0FORF9UVVBMRV9TWU5UQVhfVFlQRVMubWFwKHAgPT4gYCcke3B9J2ApLmpvaW4oXCIsIFwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHBsdWdpbnNNYXAuaGFzKFwiYXN5bmNEb0V4cHJlc3Npb25zXCIpICYmICFwbHVnaW5zTWFwLmhhcyhcImRvRXhwcmVzc2lvbnNcIikpIHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcIidhc3luY0RvRXhwcmVzc2lvbnMnIHJlcXVpcmVzICdkb0V4cHJlc3Npb25zJywgcGxlYXNlIGFkZCAnZG9FeHByZXNzaW9ucycgdG8gcGFyc2VyIHBsdWdpbnMuXCIpO1xuICAgIGVycm9yLm1pc3NpbmdQbHVnaW5zID0gXCJkb0V4cHJlc3Npb25zXCI7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgaWYgKHBsdWdpbnNNYXAuaGFzKFwib3B0aW9uYWxDaGFpbmluZ0Fzc2lnblwiKSAmJiBwbHVnaW5zTWFwLmdldChcIm9wdGlvbmFsQ2hhaW5pbmdBc3NpZ25cIikudmVyc2lvbiAhPT0gXCIyMDIzLTA3XCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgJ29wdGlvbmFsQ2hhaW5pbmdBc3NpZ24nIHBsdWdpbiByZXF1aXJlcyBhICd2ZXJzaW9uJyBvcHRpb24sXCIgKyBcIiByZXByZXNlbnRpbmcgdGhlIGxhc3QgcHJvcG9zYWwgdXBkYXRlLiBDdXJyZW50bHksIHRoZVwiICsgXCIgb25seSBzdXBwb3J0ZWQgdmFsdWUgaXMgJzIwMjMtMDcnLlwiKTtcbiAgfVxuICBpZiAocGx1Z2luc01hcC5oYXMoXCJkaXNjYXJkQmluZGluZ1wiKSAmJiBwbHVnaW5zTWFwLmdldChcImRpc2NhcmRCaW5kaW5nXCIpLnN5bnRheFR5cGUgIT09IFwidm9pZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlICdkaXNjYXJkQmluZGluZycgcGx1Z2luIHJlcXVpcmVzIGEgJ3N5bnRheFR5cGUnIG9wdGlvbi4gQ3VycmVudGx5IHRoZSBvbmx5IHN1cHBvcnRlZCB2YWx1ZSBpcyAndm9pZCcuXCIpO1xuICB9XG59XG5jb25zdCBtaXhpblBsdWdpbnMgPSB7XG4gIGVzdHJlZSxcbiAganN4LFxuICBmbG93LFxuICB0eXBlc2NyaXB0LFxuICB2OGludHJpbnNpYyxcbiAgcGxhY2Vob2xkZXJzXG59O1xuY29uc3QgbWl4aW5QbHVnaW5OYW1lcyA9IE9iamVjdC5rZXlzKG1peGluUGx1Z2lucyk7XG5jbGFzcyBFeHByZXNzaW9uUGFyc2VyIGV4dGVuZHMgTFZhbFBhcnNlciB7XG4gIGNoZWNrUHJvdG8ocHJvcCwgaXNSZWNvcmQsIHNhd1Byb3RvLCByZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgaWYgKHByb3AudHlwZSA9PT0gXCJTcHJlYWRFbGVtZW50XCIgfHwgdGhpcy5pc09iamVjdE1ldGhvZChwcm9wKSB8fCBwcm9wLmNvbXB1dGVkIHx8IHByb3Auc2hvcnRoYW5kKSB7XG4gICAgICByZXR1cm4gc2F3UHJvdG87XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IHByb3Aua2V5O1xuICAgIGNvbnN0IG5hbWUgPSBrZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgPyBrZXkubmFtZSA6IGtleS52YWx1ZTtcbiAgICBpZiAobmFtZSA9PT0gXCJfX3Byb3RvX19cIikge1xuICAgICAgaWYgKGlzUmVjb3JkKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlJlY29yZE5vUHJvdG8sIGtleSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHNhd1Byb3RvKSB7XG4gICAgICAgIGlmIChyZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgICAgICAgaWYgKHJlZkV4cHJlc3Npb25FcnJvcnMuZG91YmxlUHJvdG9Mb2MgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlZkV4cHJlc3Npb25FcnJvcnMuZG91YmxlUHJvdG9Mb2MgPSBrZXkubG9jLnN0YXJ0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5EdXBsaWNhdGVQcm90bywga2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzYXdQcm90bztcbiAgfVxuICBzaG91bGRFeGl0RGVzY2VuZGluZyhleHByLCBwb3RlbnRpYWxBcnJvd0F0KSB7XG4gICAgcmV0dXJuIGV4cHIudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiICYmIHRoaXMub2Zmc2V0VG9Tb3VyY2VQb3MoZXhwci5zdGFydCkgPT09IHBvdGVudGlhbEFycm93QXQ7XG4gIH1cbiAgZ2V0RXhwcmVzc2lvbigpIHtcbiAgICB0aGlzLmVudGVySW5pdGlhbFNjb3BlcygpO1xuICAgIHRoaXMubmV4dFRva2VuKCk7XG4gICAgaWYgKHRoaXMubWF0Y2goMTQwKSkge1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuUGFyc2VFeHByZXNzaW9uRW1wdHlJbnB1dCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgfVxuICAgIGNvbnN0IGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIGlmICghdGhpcy5tYXRjaCgxNDApKSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5QYXJzZUV4cHJlc3Npb25FeHBlY3RzRU9GLCB0aGlzLnN0YXRlLnN0YXJ0TG9jLCB7XG4gICAgICAgIHVuZXhwZWN0ZWQ6IHRoaXMuaW5wdXQuY29kZVBvaW50QXQodGhpcy5zdGF0ZS5zdGFydClcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmZpbmFsaXplUmVtYWluaW5nQ29tbWVudHMoKTtcbiAgICBleHByLmNvbW1lbnRzID0gdGhpcy5jb21tZW50cztcbiAgICBleHByLmVycm9ycyA9IHRoaXMuc3RhdGUuZXJyb3JzO1xuICAgIGlmICh0aGlzLm9wdGlvbkZsYWdzICYgMjU2KSB7XG4gICAgICBleHByLnRva2VucyA9IHRoaXMudG9rZW5zO1xuICAgIH1cbiAgICByZXR1cm4gZXhwcjtcbiAgfVxuICBwYXJzZUV4cHJlc3Npb24oZGlzYWxsb3dJbiwgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGlmIChkaXNhbGxvd0luKSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXNhbGxvd0luQW5kKCgpID0+IHRoaXMucGFyc2VFeHByZXNzaW9uQmFzZShyZWZFeHByZXNzaW9uRXJyb3JzKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFsbG93SW5BbmQoKCkgPT4gdGhpcy5wYXJzZUV4cHJlc3Npb25CYXNlKHJlZkV4cHJlc3Npb25FcnJvcnMpKTtcbiAgfVxuICBwYXJzZUV4cHJlc3Npb25CYXNlKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgZXhwciA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihyZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICBpZiAodGhpcy5tYXRjaCgxMikpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUuZXhwcmVzc2lvbnMgPSBbZXhwcl07XG4gICAgICB3aGlsZSAodGhpcy5lYXQoMTIpKSB7XG4gICAgICAgIG5vZGUuZXhwcmVzc2lvbnMucHVzaCh0aGlzLnBhcnNlTWF5YmVBc3NpZ24ocmVmRXhwcmVzc2lvbkVycm9ycykpO1xuICAgICAgfVxuICAgICAgdGhpcy50b1JlZmVyZW5jZWRMaXN0KG5vZGUuZXhwcmVzc2lvbnMpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlNlcXVlbmNlRXhwcmVzc2lvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cHI7XG4gIH1cbiAgcGFyc2VNYXliZUFzc2lnbkRpc2FsbG93SW4ocmVmRXhwcmVzc2lvbkVycm9ycywgYWZ0ZXJMZWZ0UGFyc2UpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNhbGxvd0luQW5kKCgpID0+IHRoaXMucGFyc2VNYXliZUFzc2lnbihyZWZFeHByZXNzaW9uRXJyb3JzLCBhZnRlckxlZnRQYXJzZSkpO1xuICB9XG4gIHBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKHJlZkV4cHJlc3Npb25FcnJvcnMsIGFmdGVyTGVmdFBhcnNlKSB7XG4gICAgcmV0dXJuIHRoaXMuYWxsb3dJbkFuZCgoKSA9PiB0aGlzLnBhcnNlTWF5YmVBc3NpZ24ocmVmRXhwcmVzc2lvbkVycm9ycywgYWZ0ZXJMZWZ0UGFyc2UpKTtcbiAgfVxuICBzZXRPcHRpb25hbFBhcmFtZXRlcnNFcnJvcihyZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgcmVmRXhwcmVzc2lvbkVycm9ycy5vcHRpb25hbFBhcmFtZXRlcnNMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICB9XG4gIHBhcnNlTWF5YmVBc3NpZ24ocmVmRXhwcmVzc2lvbkVycm9ycywgYWZ0ZXJMZWZ0UGFyc2UpIHtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgaXNZaWVsZCA9IHRoaXMuaXNDb250ZXh0dWFsKDEwOCk7XG4gICAgaWYgKGlzWWllbGQpIHtcbiAgICAgIGlmICh0aGlzLnByb2RQYXJhbS5oYXNZaWVsZCkge1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgbGV0IGxlZnQgPSB0aGlzLnBhcnNlWWllbGQoc3RhcnRMb2MpO1xuICAgICAgICBpZiAoYWZ0ZXJMZWZ0UGFyc2UpIHtcbiAgICAgICAgICBsZWZ0ID0gYWZ0ZXJMZWZ0UGFyc2UuY2FsbCh0aGlzLCBsZWZ0LCBzdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBvd25FeHByZXNzaW9uRXJyb3JzO1xuICAgIGlmIChyZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgICBvd25FeHByZXNzaW9uRXJyb3JzID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZkV4cHJlc3Npb25FcnJvcnMgPSBuZXcgRXhwcmVzc2lvbkVycm9ycygpO1xuICAgICAgb3duRXhwcmVzc2lvbkVycm9ycyA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodHlwZSA9PT0gMTAgfHwgdG9rZW5Jc0lkZW50aWZpZXIodHlwZSkpIHtcbiAgICAgIHRoaXMuc3RhdGUucG90ZW50aWFsQXJyb3dBdCA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgfVxuICAgIGxldCBsZWZ0ID0gdGhpcy5wYXJzZU1heWJlQ29uZGl0aW9uYWwocmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgaWYgKGFmdGVyTGVmdFBhcnNlKSB7XG4gICAgICBsZWZ0ID0gYWZ0ZXJMZWZ0UGFyc2UuY2FsbCh0aGlzLCBsZWZ0LCBzdGFydExvYyk7XG4gICAgfVxuICAgIGlmICh0b2tlbklzQXNzaWdubWVudCh0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICBjb25zdCBvcGVyYXRvciA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgICBub2RlLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICBpZiAodGhpcy5tYXRjaCgyOSkpIHtcbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGUobGVmdCwgdHJ1ZSk7XG4gICAgICAgIG5vZGUubGVmdCA9IGxlZnQ7XG4gICAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBzdGFydExvYy5pbmRleDtcbiAgICAgICAgaWYgKHJlZkV4cHJlc3Npb25FcnJvcnMuZG91YmxlUHJvdG9Mb2MgIT0gbnVsbCAmJiByZWZFeHByZXNzaW9uRXJyb3JzLmRvdWJsZVByb3RvTG9jLmluZGV4ID49IHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICByZWZFeHByZXNzaW9uRXJyb3JzLmRvdWJsZVByb3RvTG9jID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmRXhwcmVzc2lvbkVycm9ycy5zaG9ydGhhbmRBc3NpZ25Mb2MgIT0gbnVsbCAmJiByZWZFeHByZXNzaW9uRXJyb3JzLnNob3J0aGFuZEFzc2lnbkxvYy5pbmRleCA+PSBzdGFydEluZGV4KSB7XG4gICAgICAgICAgcmVmRXhwcmVzc2lvbkVycm9ycy5zaG9ydGhhbmRBc3NpZ25Mb2MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWZFeHByZXNzaW9uRXJyb3JzLnByaXZhdGVLZXlMb2MgIT0gbnVsbCAmJiByZWZFeHByZXNzaW9uRXJyb3JzLnByaXZhdGVLZXlMb2MuaW5kZXggPj0gc3RhcnRJbmRleCkge1xuICAgICAgICAgIHRoaXMuY2hlY2tEZXN0cnVjdHVyaW5nUHJpdmF0ZShyZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICAgICAgICByZWZFeHByZXNzaW9uRXJyb3JzLnByaXZhdGVLZXlMb2MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWZFeHByZXNzaW9uRXJyb3JzLnZvaWRQYXR0ZXJuTG9jICE9IG51bGwgJiYgcmVmRXhwcmVzc2lvbkVycm9ycy52b2lkUGF0dGVybkxvYy5pbmRleCA+PSBzdGFydEluZGV4KSB7XG4gICAgICAgICAgcmVmRXhwcmVzc2lvbkVycm9ycy52b2lkUGF0dGVybkxvYyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUubGVmdCA9IGxlZnQ7XG4gICAgICB9XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIG5vZGUucmlnaHQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgIHRoaXMuY2hlY2tMVmFsKGxlZnQsIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIpKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gZWxzZSBpZiAob3duRXhwcmVzc2lvbkVycm9ycykge1xuICAgICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRXhwcmVzc2lvbkVycm9ycywgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChpc1lpZWxkKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHR5cGVcbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3Qgc3RhcnRzRXhwciA9IHRoaXMuaGFzUGx1Z2luKFwidjhpbnRyaW5zaWNcIikgPyB0b2tlbkNhblN0YXJ0RXhwcmVzc2lvbih0eXBlKSA6IHRva2VuQ2FuU3RhcnRFeHByZXNzaW9uKHR5cGUpICYmICF0aGlzLm1hdGNoKDU0KTtcbiAgICAgIGlmIChzdGFydHNFeHByICYmICF0aGlzLmlzQW1iaWd1b3VzUHJlZml4T3JJZGVudGlmaWVyKCkpIHtcbiAgICAgICAgdGhpcy5yYWlzZU92ZXJ3cml0ZShFcnJvcnMuWWllbGROb3RJbkdlbmVyYXRvckZ1bmN0aW9uLCBzdGFydExvYyk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlWWllbGQoc3RhcnRMb2MpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGVmdDtcbiAgfVxuICBwYXJzZU1heWJlQ29uZGl0aW9uYWwocmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBjb25zdCBwb3RlbnRpYWxBcnJvd0F0ID0gdGhpcy5zdGF0ZS5wb3RlbnRpYWxBcnJvd0F0O1xuICAgIGNvbnN0IGV4cHIgPSB0aGlzLnBhcnNlRXhwck9wcyhyZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICBpZiAodGhpcy5zaG91bGRFeGl0RGVzY2VuZGluZyhleHByLCBwb3RlbnRpYWxBcnJvd0F0KSkge1xuICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlQ29uZGl0aW9uYWwoZXhwciwgc3RhcnRMb2MsIHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICB9XG4gIHBhcnNlQ29uZGl0aW9uYWwoZXhwciwgc3RhcnRMb2MsIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBpZiAodGhpcy5lYXQoMTcpKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICBub2RlLnRlc3QgPSBleHByO1xuICAgICAgbm9kZS5jb25zZXF1ZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduQWxsb3dJbigpO1xuICAgICAgdGhpcy5leHBlY3QoMTQpO1xuICAgICAgbm9kZS5hbHRlcm5hdGUgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIik7XG4gICAgfVxuICAgIHJldHVybiBleHByO1xuICB9XG4gIHBhcnNlTWF5YmVVbmFyeU9yUHJpdmF0ZShyZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goMTM5KSA/IHRoaXMucGFyc2VQcml2YXRlTmFtZSgpIDogdGhpcy5wYXJzZU1heWJlVW5hcnkocmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gIH1cbiAgcGFyc2VFeHByT3BzKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgcG90ZW50aWFsQXJyb3dBdCA9IHRoaXMuc3RhdGUucG90ZW50aWFsQXJyb3dBdDtcbiAgICBjb25zdCBleHByID0gdGhpcy5wYXJzZU1heWJlVW5hcnlPclByaXZhdGUocmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgaWYgKHRoaXMuc2hvdWxkRXhpdERlc2NlbmRpbmcoZXhwciwgcG90ZW50aWFsQXJyb3dBdCkpIHtcbiAgICAgIHJldHVybiBleHByO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJPcChleHByLCBzdGFydExvYywgLTEpO1xuICB9XG4gIHBhcnNlRXhwck9wKGxlZnQsIGxlZnRTdGFydExvYywgbWluUHJlYykge1xuICAgIGlmICh0aGlzLmlzUHJpdmF0ZU5hbWUobGVmdCkpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXRQcml2YXRlTmFtZVNWKGxlZnQpO1xuICAgICAgaWYgKG1pblByZWMgPj0gdG9rZW5PcGVyYXRvclByZWNlZGVuY2UoNTgpIHx8ICF0aGlzLnByb2RQYXJhbS5oYXNJbiB8fCAhdGhpcy5tYXRjaCg1OCkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuUHJpdmF0ZUluRXhwZWN0ZWRJbiwgbGVmdCwge1xuICAgICAgICAgIGlkZW50aWZpZXJOYW1lOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xhc3NTY29wZS51c2VQcml2YXRlTmFtZSh2YWx1ZSwgbGVmdC5sb2Muc3RhcnQpO1xuICAgIH1cbiAgICBjb25zdCBvcCA9IHRoaXMuc3RhdGUudHlwZTtcbiAgICBpZiAodG9rZW5Jc09wZXJhdG9yKG9wKSAmJiAodGhpcy5wcm9kUGFyYW0uaGFzSW4gfHwgIXRoaXMubWF0Y2goNTgpKSkge1xuICAgICAgbGV0IHByZWMgPSB0b2tlbk9wZXJhdG9yUHJlY2VkZW5jZShvcCk7XG4gICAgICBpZiAocHJlYyA+IG1pblByZWMpIHtcbiAgICAgICAgaWYgKG9wID09PSAzOSkge1xuICAgICAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwicGlwZWxpbmVPcGVyYXRvclwiKTtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSkge1xuICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY2hlY2tQaXBlbGluZUF0SW5maXhPcGVyYXRvcihsZWZ0LCBsZWZ0U3RhcnRMb2MpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KGxlZnRTdGFydExvYyk7XG4gICAgICAgIG5vZGUubGVmdCA9IGxlZnQ7XG4gICAgICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgICBjb25zdCBsb2dpY2FsID0gb3AgPT09IDQxIHx8IG9wID09PSA0MjtcbiAgICAgICAgY29uc3QgY29hbGVzY2UgPSBvcCA9PT0gNDA7XG4gICAgICAgIGlmIChjb2FsZXNjZSkge1xuICAgICAgICAgIHByZWMgPSB0b2tlbk9wZXJhdG9yUHJlY2VkZW5jZSg0Mik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIGlmIChvcCA9PT0gMzkgJiYgdGhpcy5oYXNQbHVnaW4oW1wicGlwZWxpbmVPcGVyYXRvclwiLCB7XG4gICAgICAgICAgcHJvcG9zYWw6IFwibWluaW1hbFwiXG4gICAgICAgIH1dKSkge1xuICAgICAgICAgIGlmICh0aGlzLnN0YXRlLnR5cGUgPT09IDk2ICYmIHRoaXMucHJvZFBhcmFtLmhhc0F3YWl0KSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkQXdhaXRBZnRlclBpcGVsaW5lQm9keSwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5vZGUucmlnaHQgPSB0aGlzLnBhcnNlRXhwck9wUmlnaHRFeHByKG9wLCBwcmVjKTtcbiAgICAgICAgY29uc3QgZmluaXNoZWROb2RlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGxvZ2ljYWwgfHwgY29hbGVzY2UgPyBcIkxvZ2ljYWxFeHByZXNzaW9uXCIgOiBcIkJpbmFyeUV4cHJlc3Npb25cIik7XG4gICAgICAgIGNvbnN0IG5leHRPcCA9IHRoaXMuc3RhdGUudHlwZTtcbiAgICAgICAgaWYgKGNvYWxlc2NlICYmIChuZXh0T3AgPT09IDQxIHx8IG5leHRPcCA9PT0gNDIpIHx8IGxvZ2ljYWwgJiYgbmV4dE9wID09PSA0MCkge1xuICAgICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLk1peGluZ0NvYWxlc2NlV2l0aExvZ2ljYWwsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXhwck9wKGZpbmlzaGVkTm9kZSwgbGVmdFN0YXJ0TG9jLCBtaW5QcmVjKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxlZnQ7XG4gIH1cbiAgcGFyc2VFeHByT3BSaWdodEV4cHIob3AsIHByZWMpIHtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgc3dpdGNoIChvcCkge1xuICAgICAgY2FzZSAzOTpcbiAgICAgICAgc3dpdGNoICh0aGlzLmdldFBsdWdpbk9wdGlvbihcInBpcGVsaW5lT3BlcmF0b3JcIiwgXCJwcm9wb3NhbFwiKSkge1xuICAgICAgICAgIGNhc2UgXCJoYWNrXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aXRoVG9waWNCaW5kaW5nQ29udGV4dCgoKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlSGFja1BpcGVCb2R5KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICBjYXNlIFwiZnNoYXJwXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aXRoU29sb0F3YWl0UGVybWl0dGluZ0NvbnRleHQoKCkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZTaGFycFBpcGVsaW5lQm9keShwcmVjKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdldFBsdWdpbk9wdGlvbihcInBpcGVsaW5lT3BlcmF0b3JcIiwgXCJwcm9wb3NhbFwiKSA9PT0gXCJzbWFydFwiKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMud2l0aFRvcGljQmluZGluZ0NvbnRleHQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvZFBhcmFtLmhhc1lpZWxkICYmIHRoaXMuaXNDb250ZXh0dWFsKDEwOCkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuUGlwZUJvZHlJc1RpZ2h0ZXIsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTbWFydFBpcGVsaW5lQm9keUluU3R5bGUodGhpcy5wYXJzZUV4cHJPcEJhc2VSaWdodEV4cHIob3AsIHByZWMpLCBzdGFydExvYyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXhwck9wQmFzZVJpZ2h0RXhwcihvcCwgcHJlYyk7XG4gICAgfVxuICB9XG4gIHBhcnNlRXhwck9wQmFzZVJpZ2h0RXhwcihvcCwgcHJlYykge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJPcCh0aGlzLnBhcnNlTWF5YmVVbmFyeU9yUHJpdmF0ZSgpLCBzdGFydExvYywgdG9rZW5Jc1JpZ2h0QXNzb2NpYXRpdmUob3ApID8gcHJlYyAtIDEgOiBwcmVjKTtcbiAgfVxuICBwYXJzZUhhY2tQaXBlQm9keSgpIHtcbiAgICB2YXIgX2JvZHkkZXh0cmE7XG4gICAgY29uc3Qge1xuICAgICAgc3RhcnRMb2NcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBib2R5ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgY29uc3QgcmVxdWlyZWRQYXJlbnRoZXNlcyA9IFVucGFyZW50aGVzaXplZFBpcGVCb2R5RGVzY3JpcHRpb25zLmhhcyhib2R5LnR5cGUpO1xuICAgIGlmIChyZXF1aXJlZFBhcmVudGhlc2VzICYmICEoKF9ib2R5JGV4dHJhID0gYm9keS5leHRyYSkgIT0gbnVsbCAmJiBfYm9keSRleHRyYS5wYXJlbnRoZXNpemVkKSkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuUGlwZVVucGFyZW50aGVzaXplZEJvZHksIHN0YXJ0TG9jLCB7XG4gICAgICAgIHR5cGU6IGJvZHkudHlwZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghdGhpcy50b3BpY1JlZmVyZW5jZVdhc1VzZWRJbkN1cnJlbnRDb250ZXh0KCkpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlBpcGVUb3BpY1VudXNlZCwgc3RhcnRMb2MpO1xuICAgIH1cbiAgICByZXR1cm4gYm9keTtcbiAgfVxuICBjaGVja0V4cG9uZW50aWFsQWZ0ZXJVbmFyeShub2RlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goNTcpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkVG9rZW5VbmFyeUV4cG9uZW50aWF0aW9uLCBub2RlLmFyZ3VtZW50KTtcbiAgICB9XG4gIH1cbiAgcGFyc2VNYXliZVVuYXJ5KHJlZkV4cHJlc3Npb25FcnJvcnMsIHNhd1VuYXJ5KSB7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGNvbnN0IGlzQXdhaXQgPSB0aGlzLmlzQ29udGV4dHVhbCg5Nik7XG4gICAgaWYgKGlzQXdhaXQgJiYgdGhpcy5yZWNvcmRBd2FpdElmQWxsb3dlZCgpKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGNvbnN0IGV4cHIgPSB0aGlzLnBhcnNlQXdhaXQoc3RhcnRMb2MpO1xuICAgICAgaWYgKCFzYXdVbmFyeSkgdGhpcy5jaGVja0V4cG9uZW50aWFsQWZ0ZXJVbmFyeShleHByKTtcbiAgICAgIHJldHVybiBleHByO1xuICAgIH1cbiAgICBjb25zdCB1cGRhdGUgPSB0aGlzLm1hdGNoKDM0KTtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBpZiAodG9rZW5Jc1ByZWZpeCh0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICBub2RlLm9wZXJhdG9yID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICAgIG5vZGUucHJlZml4ID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDcyKSkge1xuICAgICAgICB0aGlzLmV4cGVjdFBsdWdpbihcInRocm93RXhwcmVzc2lvbnNcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBpc0RlbGV0ZSA9IHRoaXMubWF0Y2goODkpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgdHJ1ZSk7XG4gICAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZFeHByZXNzaW9uRXJyb3JzLCB0cnVlKTtcbiAgICAgIGlmICh0aGlzLnN0YXRlLnN0cmljdCAmJiBpc0RlbGV0ZSkge1xuICAgICAgICBjb25zdCBhcmcgPSBub2RlLmFyZ3VtZW50O1xuICAgICAgICBpZiAoYXJnLnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuU3RyaWN0RGVsZXRlLCBub2RlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmhhc1Byb3BlcnR5QXNQcml2YXRlTmFtZShhcmcpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRGVsZXRlUHJpdmF0ZUZpZWxkLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF1cGRhdGUpIHtcbiAgICAgICAgaWYgKCFzYXdVbmFyeSkge1xuICAgICAgICAgIHRoaXMuY2hlY2tFeHBvbmVudGlhbEFmdGVyVW5hcnkobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlVuYXJ5RXhwcmVzc2lvblwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXhwciA9IHRoaXMucGFyc2VVcGRhdGUobm9kZSwgdXBkYXRlLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICBpZiAoaXNBd2FpdCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB0eXBlXG4gICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGNvbnN0IHN0YXJ0c0V4cHIgPSB0aGlzLmhhc1BsdWdpbihcInY4aW50cmluc2ljXCIpID8gdG9rZW5DYW5TdGFydEV4cHJlc3Npb24odHlwZSkgOiB0b2tlbkNhblN0YXJ0RXhwcmVzc2lvbih0eXBlKSAmJiAhdGhpcy5tYXRjaCg1NCk7XG4gICAgICBpZiAoc3RhcnRzRXhwciAmJiAhdGhpcy5pc0FtYmlndW91c1ByZWZpeE9ySWRlbnRpZmllcigpKSB7XG4gICAgICAgIHRoaXMucmFpc2VPdmVyd3JpdGUoRXJyb3JzLkF3YWl0Tm90SW5Bc3luY0NvbnRleHQsIHN0YXJ0TG9jKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBd2FpdChzdGFydExvYyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHByO1xuICB9XG4gIHBhcnNlVXBkYXRlKG5vZGUsIHVwZGF0ZSwgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGlmICh1cGRhdGUpIHtcbiAgICAgIGNvbnN0IHVwZGF0ZUV4cHJlc3Npb25Ob2RlID0gbm9kZTtcbiAgICAgIHRoaXMuY2hlY2tMVmFsKHVwZGF0ZUV4cHJlc3Npb25Ob2RlLmFyZ3VtZW50LCB0aGlzLmZpbmlzaE5vZGUodXBkYXRlRXhwcmVzc2lvbk5vZGUsIFwiVXBkYXRlRXhwcmVzc2lvblwiKSk7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGxldCBleHByID0gdGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZFeHByZXNzaW9uRXJyb3JzLCBmYWxzZSkpIHJldHVybiBleHByO1xuICAgIHdoaWxlICh0b2tlbklzUG9zdGZpeCh0aGlzLnN0YXRlLnR5cGUpICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICBub2RlLm9wZXJhdG9yID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICAgIG5vZGUucHJlZml4ID0gZmFsc2U7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gZXhwcjtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgdGhpcy5jaGVja0xWYWwoZXhwciwgZXhwciA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlVwZGF0ZUV4cHJlc3Npb25cIikpO1xuICAgIH1cbiAgICByZXR1cm4gZXhwcjtcbiAgfVxuICBwYXJzZUV4cHJTdWJzY3JpcHRzKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgcG90ZW50aWFsQXJyb3dBdCA9IHRoaXMuc3RhdGUucG90ZW50aWFsQXJyb3dBdDtcbiAgICBjb25zdCBleHByID0gdGhpcy5wYXJzZUV4cHJBdG9tKHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgIGlmICh0aGlzLnNob3VsZEV4aXREZXNjZW5kaW5nKGV4cHIsIHBvdGVudGlhbEFycm93QXQpKSB7XG4gICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VTdWJzY3JpcHRzKGV4cHIsIHN0YXJ0TG9jKTtcbiAgfVxuICBwYXJzZVN1YnNjcmlwdHMoYmFzZSwgc3RhcnRMb2MsIG5vQ2FsbHMpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgIG9wdGlvbmFsQ2hhaW5NZW1iZXI6IGZhbHNlLFxuICAgICAgbWF5YmVBc3luY0Fycm93OiB0aGlzLmF0UG9zc2libGVBc3luY0Fycm93KGJhc2UpLFxuICAgICAgc3RvcDogZmFsc2VcbiAgICB9O1xuICAgIGRvIHtcbiAgICAgIGJhc2UgPSB0aGlzLnBhcnNlU3Vic2NyaXB0KGJhc2UsIHN0YXJ0TG9jLCBub0NhbGxzLCBzdGF0ZSk7XG4gICAgICBzdGF0ZS5tYXliZUFzeW5jQXJyb3cgPSBmYWxzZTtcbiAgICB9IHdoaWxlICghc3RhdGUuc3RvcCk7XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbiAgcGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhcnRMb2MsIG5vQ2FsbHMsIHN0YXRlKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICghbm9DYWxscyAmJiB0eXBlID09PSAxNSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VCaW5kKGJhc2UsIHN0YXJ0TG9jLCBub0NhbGxzLCBzdGF0ZSk7XG4gICAgfSBlbHNlIGlmICh0b2tlbklzVGVtcGxhdGUodHlwZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKGJhc2UsIHN0YXJ0TG9jLCBzdGF0ZSk7XG4gICAgfVxuICAgIGxldCBvcHRpb25hbCA9IGZhbHNlO1xuICAgIGlmICh0eXBlID09PSAxOCkge1xuICAgICAgaWYgKG5vQ2FsbHMpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuT3B0aW9uYWxDaGFpbmluZ05vTmV3LCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKSA9PT0gNDApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zdG9wUGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGF0ZS5vcHRpb25hbENoYWluTWVtYmVyID0gb3B0aW9uYWwgPSB0cnVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIGlmICghbm9DYWxscyAmJiB0aGlzLm1hdGNoKDEwKSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VDb3ZlckNhbGxBbmRBc3luY0Fycm93SGVhZChiYXNlLCBzdGFydExvYywgc3RhdGUsIG9wdGlvbmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29tcHV0ZWQgPSB0aGlzLmVhdCgwKTtcbiAgICAgIGlmIChjb21wdXRlZCB8fCBvcHRpb25hbCB8fCB0aGlzLmVhdCgxNikpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VNZW1iZXIoYmFzZSwgc3RhcnRMb2MsIHN0YXRlLCBjb21wdXRlZCwgb3B0aW9uYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcFBhcnNlU3Vic2NyaXB0KGJhc2UsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3RvcFBhcnNlU3Vic2NyaXB0KGJhc2UsIHN0YXRlKSB7XG4gICAgc3RhdGUuc3RvcCA9IHRydWU7XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbiAgcGFyc2VNZW1iZXIoYmFzZSwgc3RhcnRMb2MsIHN0YXRlLCBjb21wdXRlZCwgb3B0aW9uYWwpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgbm9kZS5vYmplY3QgPSBiYXNlO1xuICAgIG5vZGUuY29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICBpZiAoY29tcHV0ZWQpIHtcbiAgICAgIG5vZGUucHJvcGVydHkgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgdGhpcy5leHBlY3QoMyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKDEzOSkpIHtcbiAgICAgIGlmIChiYXNlLnR5cGUgPT09IFwiU3VwZXJcIikge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5TdXBlclByaXZhdGVGaWVsZCwgc3RhcnRMb2MpO1xuICAgICAgfVxuICAgICAgdGhpcy5jbGFzc1Njb3BlLnVzZVByaXZhdGVOYW1lKHRoaXMuc3RhdGUudmFsdWUsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VQcml2YXRlTmFtZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnByb3BlcnR5ID0gdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5vcHRpb25hbENoYWluTWVtYmVyKSB7XG4gICAgICBub2RlLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTWVtYmVyRXhwcmVzc2lvblwiKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VCaW5kKGJhc2UsIHN0YXJ0TG9jLCBub0NhbGxzLCBzdGF0ZSkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICBub2RlLm9iamVjdCA9IGJhc2U7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5jYWxsZWUgPSB0aGlzLnBhcnNlTm9DYWxsRXhwcigpO1xuICAgIHN0YXRlLnN0b3AgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzLnBhcnNlU3Vic2NyaXB0cyh0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJCaW5kRXhwcmVzc2lvblwiKSwgc3RhcnRMb2MsIG5vQ2FsbHMpO1xuICB9XG4gIHBhcnNlQ292ZXJDYWxsQW5kQXN5bmNBcnJvd0hlYWQoYmFzZSwgc3RhcnRMb2MsIHN0YXRlLCBvcHRpb25hbCkge1xuICAgIGNvbnN0IG9sZE1heWJlSW5BcnJvd1BhcmFtZXRlcnMgPSB0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnM7XG4gICAgbGV0IHJlZkV4cHJlc3Npb25FcnJvcnMgPSBudWxsO1xuICAgIHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycyA9IHRydWU7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgIG5vZGUuY2FsbGVlID0gYmFzZTtcbiAgICBjb25zdCB7XG4gICAgICBtYXliZUFzeW5jQXJyb3csXG4gICAgICBvcHRpb25hbENoYWluTWVtYmVyXG4gICAgfSA9IHN0YXRlO1xuICAgIGlmIChtYXliZUFzeW5jQXJyb3cpIHtcbiAgICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLmVudGVyKG5ld0FzeW5jQXJyb3dTY29wZSgpKTtcbiAgICAgIHJlZkV4cHJlc3Npb25FcnJvcnMgPSBuZXcgRXhwcmVzc2lvbkVycm9ycygpO1xuICAgIH1cbiAgICBpZiAob3B0aW9uYWxDaGFpbk1lbWJlcikge1xuICAgICAgbm9kZS5vcHRpb25hbCA9IG9wdGlvbmFsO1xuICAgIH1cbiAgICBpZiAob3B0aW9uYWwpIHtcbiAgICAgIG5vZGUuYXJndW1lbnRzID0gdGhpcy5wYXJzZUNhbGxFeHByZXNzaW9uQXJndW1lbnRzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuYXJndW1lbnRzID0gdGhpcy5wYXJzZUNhbGxFeHByZXNzaW9uQXJndW1lbnRzKGJhc2UudHlwZSAhPT0gXCJTdXBlclwiLCBub2RlLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICB9XG4gICAgbGV0IGZpbmlzaGVkTm9kZSA9IHRoaXMuZmluaXNoQ2FsbEV4cHJlc3Npb24obm9kZSwgb3B0aW9uYWxDaGFpbk1lbWJlcik7XG4gICAgaWYgKG1heWJlQXN5bmNBcnJvdyAmJiB0aGlzLnNob3VsZFBhcnNlQXN5bmNBcnJvdygpICYmICFvcHRpb25hbCkge1xuICAgICAgc3RhdGUuc3RvcCA9IHRydWU7XG4gICAgICB0aGlzLmNoZWNrRGVzdHJ1Y3R1cmluZ1ByaXZhdGUocmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgICB0aGlzLmV4cHJlc3Npb25TY29wZS52YWxpZGF0ZUFzUGF0dGVybigpO1xuICAgICAgdGhpcy5leHByZXNzaW9uU2NvcGUuZXhpdCgpO1xuICAgICAgZmluaXNoZWROb2RlID0gdGhpcy5wYXJzZUFzeW5jQXJyb3dGcm9tQ2FsbEV4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydExvYyksIGZpbmlzaGVkTm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChtYXliZUFzeW5jQXJyb3cpIHtcbiAgICAgICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRXhwcmVzc2lvbkVycm9ycywgdHJ1ZSk7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLmV4aXQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudG9SZWZlcmVuY2VkQXJndW1lbnRzKGZpbmlzaGVkTm9kZSk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycyA9IG9sZE1heWJlSW5BcnJvd1BhcmFtZXRlcnM7XG4gICAgcmV0dXJuIGZpbmlzaGVkTm9kZTtcbiAgfVxuICB0b1JlZmVyZW5jZWRBcmd1bWVudHMobm9kZSwgaXNQYXJlbnRoZXNpemVkRXhwcikge1xuICAgIHRoaXMudG9SZWZlcmVuY2VkTGlzdERlZXAobm9kZS5hcmd1bWVudHMsIGlzUGFyZW50aGVzaXplZEV4cHIpO1xuICB9XG4gIHBhcnNlVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKGJhc2UsIHN0YXJ0TG9jLCBzdGF0ZSkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICBub2RlLnRhZyA9IGJhc2U7XG4gICAgbm9kZS5xdWFzaSA9IHRoaXMucGFyc2VUZW1wbGF0ZSh0cnVlKTtcbiAgICBpZiAoc3RhdGUub3B0aW9uYWxDaGFpbk1lbWJlcikge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuT3B0aW9uYWxDaGFpbmluZ05vVGVtcGxhdGUsIHN0YXJ0TG9jKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiKTtcbiAgfVxuICBhdFBvc3NpYmxlQXN5bmNBcnJvdyhiYXNlKSB7XG4gICAgcmV0dXJuIGJhc2UudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgYmFzZS5uYW1lID09PSBcImFzeW5jXCIgJiYgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jLmluZGV4ID09PSBiYXNlLmVuZCAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSAmJiBiYXNlLmVuZCAtIGJhc2Uuc3RhcnQgPT09IDUgJiYgdGhpcy5vZmZzZXRUb1NvdXJjZVBvcyhiYXNlLnN0YXJ0KSA9PT0gdGhpcy5zdGF0ZS5wb3RlbnRpYWxBcnJvd0F0O1xuICB9XG4gIGZpbmlzaENhbGxFeHByZXNzaW9uKG5vZGUsIG9wdGlvbmFsKSB7XG4gICAgaWYgKG5vZGUuY2FsbGVlLnR5cGUgPT09IFwiSW1wb3J0XCIpIHtcbiAgICAgIGlmIChub2RlLmFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgbm9kZS5hcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbXBvcnRDYWxsQXJpdHksIG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBhcmcgb2Ygbm9kZS5hcmd1bWVudHMpIHtcbiAgICAgICAgICBpZiAoYXJnLnR5cGUgPT09IFwiU3ByZWFkRWxlbWVudFwiKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbXBvcnRDYWxsU3ByZWFkQXJndW1lbnQsIGFyZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgb3B0aW9uYWwgPyBcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIiA6IFwiQ2FsbEV4cHJlc3Npb25cIik7XG4gIH1cbiAgcGFyc2VDYWxsRXhwcmVzc2lvbkFyZ3VtZW50cyhhbGxvd1BsYWNlaG9sZGVyLCBub2RlRm9yRXh0cmEsIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBjb25zdCBlbHRzID0gW107XG4gICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICBjb25zdCBvbGRJbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHk7XG4gICAgdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IGZhbHNlO1xuICAgIHdoaWxlICghdGhpcy5lYXQoMTEpKSB7XG4gICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KDEyKTtcbiAgICAgICAgaWYgKHRoaXMubWF0Y2goMTEpKSB7XG4gICAgICAgICAgaWYgKG5vZGVGb3JFeHRyYSkge1xuICAgICAgICAgICAgdGhpcy5hZGRUcmFpbGluZ0NvbW1hRXh0cmFUb05vZGUobm9kZUZvckV4dHJhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsdHMucHVzaCh0aGlzLnBhcnNlRXhwckxpc3RJdGVtKDExLCBmYWxzZSwgcmVmRXhwcmVzc2lvbkVycm9ycywgYWxsb3dQbGFjZWhvbGRlcikpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5ID0gb2xkSW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHk7XG4gICAgcmV0dXJuIGVsdHM7XG4gIH1cbiAgc2hvdWxkUGFyc2VBc3luY0Fycm93KCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKDE5KSAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKTtcbiAgfVxuICBwYXJzZUFzeW5jQXJyb3dGcm9tQ2FsbEV4cHJlc3Npb24obm9kZSwgY2FsbCkge1xuICAgIHZhciBfY2FsbCRleHRyYTtcbiAgICB0aGlzLnJlc2V0UHJldmlvdXNOb2RlVHJhaWxpbmdDb21tZW50cyhjYWxsKTtcbiAgICB0aGlzLmV4cGVjdCgxOSk7XG4gICAgdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbihub2RlLCBjYWxsLmFyZ3VtZW50cywgdHJ1ZSwgKF9jYWxsJGV4dHJhID0gY2FsbC5leHRyYSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jYWxsJGV4dHJhLnRyYWlsaW5nQ29tbWFMb2MpO1xuICAgIGlmIChjYWxsLmlubmVyQ29tbWVudHMpIHtcbiAgICAgIHNldElubmVyQ29tbWVudHMobm9kZSwgY2FsbC5pbm5lckNvbW1lbnRzKTtcbiAgICB9XG4gICAgaWYgKGNhbGwuY2FsbGVlLnRyYWlsaW5nQ29tbWVudHMpIHtcbiAgICAgIHNldElubmVyQ29tbWVudHMobm9kZSwgY2FsbC5jYWxsZWUudHJhaWxpbmdDb21tZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHBhcnNlTm9DYWxsRXhwcigpIHtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VTdWJzY3JpcHRzKHRoaXMucGFyc2VFeHByQXRvbSgpLCBzdGFydExvYywgdHJ1ZSk7XG4gIH1cbiAgcGFyc2VFeHByQXRvbShyZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgbGV0IG5vZGU7XG4gICAgbGV0IGRlY29yYXRvcnMgPSBudWxsO1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgNzk6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlU3VwZXIoKTtcbiAgICAgIGNhc2UgODM6XG4gICAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKHRoaXMubWF0Y2goMTYpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VJbXBvcnRNZXRhUHJvcGVydHlPclBoYXNlQ2FsbChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXRjaCgxMCkpIHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25GbGFncyAmIDUxMikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VJbXBvcnRDYWxsKG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbnN1cHBvcnRlZEltcG9ydCwgdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnRMb2MpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnRcIik7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgNzg6XG4gICAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRoaXNFeHByZXNzaW9uXCIpO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRG8odGhpcy5zdGFydE5vZGUoKSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICBjYXNlIDU2OlxuICAgICAgY2FzZSAzMTpcbiAgICAgICAge1xuICAgICAgICAgIHRoaXMucmVhZFJlZ2V4cCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlUmVnRXhwTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAxMzU6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTnVtZXJpY0xpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSk7XG4gICAgICBjYXNlIDEzNjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCaWdJbnRMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpO1xuICAgICAgY2FzZSAxMzQ6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlU3RyaW5nTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlKTtcbiAgICAgIGNhc2UgODQ6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTnVsbExpdGVyYWwoKTtcbiAgICAgIGNhc2UgODU6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQm9vbGVhbkxpdGVyYWwodHJ1ZSk7XG4gICAgICBjYXNlIDg2OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJvb2xlYW5MaXRlcmFsKGZhbHNlKTtcbiAgICAgIGNhc2UgMTA6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBjYW5CZUFycm93ID0gdGhpcy5zdGF0ZS5wb3RlbnRpYWxBcnJvd0F0ID09PSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlUGFyZW5BbmREaXN0aW5ndWlzaEV4cHJlc3Npb24oY2FuQmVBcnJvdyk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgMDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXJyYXlMaWtlKDMsIHRydWUsIGZhbHNlLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSA1OlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPYmplY3RMaWtlKDgsIGZhbHNlLCBmYWxzZSwgcmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgNjg6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb25PckZ1bmN0aW9uU2VudCgpO1xuICAgICAgY2FzZSAyNjpcbiAgICAgICAgZGVjb3JhdG9ycyA9IHRoaXMucGFyc2VEZWNvcmF0b3JzKCk7XG4gICAgICBjYXNlIDgwOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKHRoaXMubWF5YmVUYWtlRGVjb3JhdG9ycyhkZWNvcmF0b3JzLCB0aGlzLnN0YXJ0Tm9kZSgpKSwgZmFsc2UpO1xuICAgICAgY2FzZSA3NzpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VOZXdPck5ld1RhcmdldCgpO1xuICAgICAgY2FzZSAyNTpcbiAgICAgIGNhc2UgMjQ6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVGVtcGxhdGUoZmFsc2UpO1xuICAgICAgY2FzZSAxNTpcbiAgICAgICAge1xuICAgICAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIG5vZGUub2JqZWN0ID0gbnVsbDtcbiAgICAgICAgICBjb25zdCBjYWxsZWUgPSBub2RlLmNhbGxlZSA9IHRoaXMucGFyc2VOb0NhbGxFeHByKCk7XG4gICAgICAgICAgaWYgKGNhbGxlZS50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkJpbmRFeHByZXNzaW9uXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5VbnN1cHBvcnRlZEJpbmQsIGNhbGxlZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBjYXNlIDEzOTpcbiAgICAgICAge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlByaXZhdGVJbkV4cGVjdGVkSW4sIHRoaXMuc3RhdGUuc3RhcnRMb2MsIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXJOYW1lOiB0aGlzLnN0YXRlLnZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VQcml2YXRlTmFtZSgpO1xuICAgICAgICB9XG4gICAgICBjYXNlIDMzOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUb3BpY1JlZmVyZW5jZVRoZW5FcXVhbHNTaWduKDU0LCBcIiVcIik7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgMzI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRvcGljUmVmZXJlbmNlVGhlbkVxdWFsc1NpZ24oNDQsIFwiXlwiKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAzNzpcbiAgICAgIGNhc2UgMzg6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRvcGljUmVmZXJlbmNlKFwiaGFja1wiKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSA0NDpcbiAgICAgIGNhc2UgNTQ6XG4gICAgICBjYXNlIDI3OlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgcGlwZVByb3Bvc2FsID0gdGhpcy5nZXRQbHVnaW5PcHRpb24oXCJwaXBlbGluZU9wZXJhdG9yXCIsIFwicHJvcG9zYWxcIik7XG4gICAgICAgICAgaWYgKHBpcGVQcm9wb3NhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUb3BpY1JlZmVyZW5jZShwaXBlUHJvcG9zYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSA0NzpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGxvb2thaGVhZENoID0gdGhpcy5pbnB1dC5jb2RlUG9pbnRBdCh0aGlzLm5leHRUb2tlblN0YXJ0KCkpO1xuICAgICAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChsb29rYWhlYWRDaCkgfHwgbG9va2FoZWFkQ2ggPT09IDYyKSB7XG4gICAgICAgICAgICB0aGlzLmV4cGVjdE9uZVBsdWdpbihbXCJqc3hcIiwgXCJmbG93XCIsIFwidHlwZXNjcmlwdFwiXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0eXBlID09PSAxMzcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRGVjaW1hbExpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAyIHx8IHR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXJyYXlMaWtlKHRoaXMuc3RhdGUudHlwZSA9PT0gMiA/IDQgOiAzLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSA2IHx8IHR5cGUgPT09IDcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqZWN0TGlrZSh0aGlzLnN0YXRlLnR5cGUgPT09IDYgPyA5IDogOCwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW5Jc0lkZW50aWZpZXIodHlwZSkpIHtcbiAgICAgICAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTI3KSAmJiB0aGlzLmxvb2thaGVhZEluTGluZUNoYXJDb2RlKCkgPT09IDEyMykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VNb2R1bGVFeHByZXNzaW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGNhbkJlQXJyb3cgPSB0aGlzLnN0YXRlLnBvdGVudGlhbEFycm93QXQgPT09IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgICAgICAgY29uc3QgY29udGFpbnNFc2MgPSB0aGlzLnN0YXRlLmNvbnRhaW5zRXNjO1xuICAgICAgICAgIGNvbnN0IGlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgICAgICBpZiAoIWNvbnRhaW5zRXNjICYmIGlkLm5hbWUgPT09IFwiYXN5bmNcIiAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICB0eXBlXG4gICAgICAgICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSA2OCkge1xuICAgICAgICAgICAgICB0aGlzLnJlc2V0UHJldmlvdXNOb2RlVHJhaWxpbmdDb21tZW50cyhpZCk7XG4gICAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFzeW5jRnVuY3Rpb25FeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXROb2RlKGlkKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuSXNJZGVudGlmaWVyKHR5cGUpKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgPT09IDYxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBc3luY0Fycm93VW5hcnlGdW5jdGlvbih0aGlzLnN0YXJ0Tm9kZUF0Tm9kZShpZCkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSA5MCkge1xuICAgICAgICAgICAgICB0aGlzLnJlc2V0UHJldmlvdXNOb2RlVHJhaWxpbmdDb21tZW50cyhpZCk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRG8odGhpcy5zdGFydE5vZGVBdE5vZGUoaWQpLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbkJlQXJyb3cgJiYgdGhpcy5tYXRjaCgxOSkgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdE5vZGUoaWQpLCBbaWRdLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICBwYXJzZVRvcGljUmVmZXJlbmNlVGhlbkVxdWFsc1NpZ24odG9waWNUb2tlblR5cGUsIHRvcGljVG9rZW5WYWx1ZSkge1xuICAgIGNvbnN0IHBpcGVQcm9wb3NhbCA9IHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwicGlwZWxpbmVPcGVyYXRvclwiLCBcInByb3Bvc2FsXCIpO1xuICAgIGlmIChwaXBlUHJvcG9zYWwpIHtcbiAgICAgIHRoaXMuc3RhdGUudHlwZSA9IHRvcGljVG9rZW5UeXBlO1xuICAgICAgdGhpcy5zdGF0ZS52YWx1ZSA9IHRvcGljVG9rZW5WYWx1ZTtcbiAgICAgIHRoaXMuc3RhdGUucG9zLS07XG4gICAgICB0aGlzLnN0YXRlLmVuZC0tO1xuICAgICAgdGhpcy5zdGF0ZS5lbmRMb2MgPSBjcmVhdGVQb3NpdGlvbldpdGhDb2x1bW5PZmZzZXQodGhpcy5zdGF0ZS5lbmRMb2MsIC0xKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlVG9waWNSZWZlcmVuY2UocGlwZVByb3Bvc2FsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICB9XG4gIHBhcnNlVG9waWNSZWZlcmVuY2UocGlwZVByb3Bvc2FsKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGNvbnN0IHRva2VuVHlwZSA9IHRoaXMuc3RhdGUudHlwZTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb3BpY1JlZmVyZW5jZShub2RlLCBzdGFydExvYywgcGlwZVByb3Bvc2FsLCB0b2tlblR5cGUpO1xuICB9XG4gIGZpbmlzaFRvcGljUmVmZXJlbmNlKG5vZGUsIHN0YXJ0TG9jLCBwaXBlUHJvcG9zYWwsIHRva2VuVHlwZSkge1xuICAgIGlmICh0aGlzLnRlc3RUb3BpY1JlZmVyZW5jZUNvbmZpZ3VyYXRpb24ocGlwZVByb3Bvc2FsLCBzdGFydExvYywgdG9rZW5UeXBlKSkge1xuICAgICAgaWYgKHBpcGVQcm9wb3NhbCA9PT0gXCJoYWNrXCIpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRvcGljUmVmZXJlbmNlSXNBbGxvd2VkSW5DdXJyZW50Q29udGV4dCgpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuUGlwZVRvcGljVW5ib3VuZCwgc3RhcnRMb2MpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVnaXN0ZXJUb3BpY1JlZmVyZW5jZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVG9waWNSZWZlcmVuY2VcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMudG9waWNSZWZlcmVuY2VJc0FsbG93ZWRJbkN1cnJlbnRDb250ZXh0KCkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5QcmltYXJ5VG9waWNOb3RBbGxvd2VkLCBzdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWdpc3RlclRvcGljUmVmZXJlbmNlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJQaXBlbGluZVByaW1hcnlUb3BpY1JlZmVyZW5jZVwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuUGlwZVRvcGljVW5jb25maWd1cmVkVG9rZW4sIHN0YXJ0TG9jLCB7XG4gICAgICAgIHRva2VuOiB0b2tlbkxhYmVsTmFtZSh0b2tlblR5cGUpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgdGVzdFRvcGljUmVmZXJlbmNlQ29uZmlndXJhdGlvbihwaXBlUHJvcG9zYWwsIHN0YXJ0TG9jLCB0b2tlblR5cGUpIHtcbiAgICBzd2l0Y2ggKHBpcGVQcm9wb3NhbCkge1xuICAgICAgY2FzZSBcImhhY2tcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB0aGlzLmhhc1BsdWdpbihbXCJwaXBlbGluZU9wZXJhdG9yXCIsIHtcbiAgICAgICAgICAgIHRvcGljVG9rZW46IHRva2VuTGFiZWxOYW1lKHRva2VuVHlwZSlcbiAgICAgICAgICB9XSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCJzbWFydFwiOlxuICAgICAgICByZXR1cm4gdG9rZW5UeXBlID09PSAyNztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlBpcGVUb3BpY1JlcXVpcmVzSGFja1BpcGVzLCBzdGFydExvYyk7XG4gICAgfVxuICB9XG4gIHBhcnNlQXN5bmNBcnJvd1VuYXJ5RnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMucHJvZFBhcmFtLmVudGVyKGZ1bmN0aW9uRmxhZ3ModHJ1ZSwgdGhpcy5wcm9kUGFyYW0uaGFzWWllbGQpKTtcbiAgICBjb25zdCBwYXJhbXMgPSBbdGhpcy5wYXJzZUlkZW50aWZpZXIoKV07XG4gICAgdGhpcy5wcm9kUGFyYW0uZXhpdCgpO1xuICAgIGlmICh0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5MaW5lVGVybWluYXRvckJlZm9yZUFycm93LCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgIH1cbiAgICB0aGlzLmV4cGVjdCgxOSk7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24obm9kZSwgcGFyYW1zLCB0cnVlKTtcbiAgfVxuICBwYXJzZURvKG5vZGUsIGlzQXN5bmMpIHtcbiAgICB0aGlzLmV4cGVjdFBsdWdpbihcImRvRXhwcmVzc2lvbnNcIik7XG4gICAgaWYgKGlzQXN5bmMpIHtcbiAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwiYXN5bmNEb0V4cHJlc3Npb25zXCIpO1xuICAgIH1cbiAgICBub2RlLmFzeW5jID0gaXNBc3luYztcbiAgICB0aGlzLm5leHQoKTtcbiAgICBjb25zdCBvbGRMYWJlbHMgPSB0aGlzLnN0YXRlLmxhYmVscztcbiAgICB0aGlzLnN0YXRlLmxhYmVscyA9IFtdO1xuICAgIGlmIChpc0FzeW5jKSB7XG4gICAgICB0aGlzLnByb2RQYXJhbS5lbnRlcigyKTtcbiAgICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VCbG9jaygpO1xuICAgICAgdGhpcy5wcm9kUGFyYW0uZXhpdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlQmxvY2soKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZS5sYWJlbHMgPSBvbGRMYWJlbHM7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRvRXhwcmVzc2lvblwiKTtcbiAgfVxuICBwYXJzZVN1cGVyKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLm1hdGNoKDEwKSAmJiAhdGhpcy5zY29wZS5hbGxvd0RpcmVjdFN1cGVyICYmICEodGhpcy5vcHRpb25GbGFncyAmIDE2KSkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuU3VwZXJOb3RBbGxvd2VkLCBub2RlKTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnNjb3BlLmFsbG93U3VwZXIgJiYgISh0aGlzLm9wdGlvbkZsYWdzICYgMTYpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkU3VwZXIsIG5vZGUpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMubWF0Y2goMTApICYmICF0aGlzLm1hdGNoKDApICYmICF0aGlzLm1hdGNoKDE2KSkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5zdXBwb3J0ZWRTdXBlciwgbm9kZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTdXBlclwiKTtcbiAgfVxuICBwYXJzZVByaXZhdGVOYW1lKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGNvbnN0IGlkID0gdGhpcy5zdGFydE5vZGVBdChjcmVhdGVQb3NpdGlvbldpdGhDb2x1bW5PZmZzZXQodGhpcy5zdGF0ZS5zdGFydExvYywgMSkpO1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuaWQgPSB0aGlzLmNyZWF0ZUlkZW50aWZpZXIoaWQsIG5hbWUpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJQcml2YXRlTmFtZVwiKTtcbiAgfVxuICBwYXJzZUZ1bmN0aW9uT3JGdW5jdGlvblNlbnQoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMucHJvZFBhcmFtLmhhc1lpZWxkICYmIHRoaXMubWF0Y2goMTYpKSB7XG4gICAgICBjb25zdCBtZXRhID0gdGhpcy5jcmVhdGVJZGVudGlmaWVyKHRoaXMuc3RhcnROb2RlQXROb2RlKG5vZGUpLCBcImZ1bmN0aW9uXCIpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAodGhpcy5tYXRjaCgxMDMpKSB7XG4gICAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwiZnVuY3Rpb25TZW50XCIpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5oYXNQbHVnaW4oXCJmdW5jdGlvblNlbnRcIikpIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZU1ldGFQcm9wZXJ0eShub2RlLCBtZXRhLCBcInNlbnRcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24obm9kZSk7XG4gIH1cbiAgcGFyc2VNZXRhUHJvcGVydHkobm9kZSwgbWV0YSwgcHJvcGVydHlOYW1lKSB7XG4gICAgbm9kZS5tZXRhID0gbWV0YTtcbiAgICBjb25zdCBjb250YWluc0VzYyA9IHRoaXMuc3RhdGUuY29udGFpbnNFc2M7XG4gICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgIGlmIChub2RlLnByb3BlcnR5Lm5hbWUgIT09IHByb3BlcnR5TmFtZSB8fCBjb250YWluc0VzYykge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5zdXBwb3J0ZWRNZXRhUHJvcGVydHksIG5vZGUucHJvcGVydHksIHtcbiAgICAgICAgdGFyZ2V0OiBtZXRhLm5hbWUsXG4gICAgICAgIG9ubHlWYWxpZFByb3BlcnR5TmFtZTogcHJvcGVydHlOYW1lXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1ldGFQcm9wZXJ0eVwiKTtcbiAgfVxuICBwYXJzZUltcG9ydE1ldGFQcm9wZXJ0eU9yUGhhc2VDYWxsKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTA1KSB8fCB0aGlzLmlzQ29udGV4dHVhbCg5NykpIHtcbiAgICAgIGNvbnN0IGlzU291cmNlID0gdGhpcy5pc0NvbnRleHR1YWwoMTA1KTtcbiAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKGlzU291cmNlID8gXCJzb3VyY2VQaGFzZUltcG9ydHNcIiA6IFwiZGVmZXJyZWRJbXBvcnRFdmFsdWF0aW9uXCIpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBub2RlLnBoYXNlID0gaXNTb3VyY2UgPyBcInNvdXJjZVwiIDogXCJkZWZlclwiO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VJbXBvcnRDYWxsKG5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpZCA9IHRoaXMuY3JlYXRlSWRlbnRpZmllckF0KHRoaXMuc3RhcnROb2RlQXROb2RlKG5vZGUpLCBcImltcG9ydFwiLCB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYyk7XG4gICAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTAxKSkge1xuICAgICAgICBpZiAoIXRoaXMuaW5Nb2R1bGUpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbXBvcnRNZXRhT3V0c2lkZU1vZHVsZSwgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2F3VW5hbWJpZ3VvdXNFU00gPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VNZXRhUHJvcGVydHkobm9kZSwgaWQsIFwibWV0YVwiKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VMaXRlcmFsQXROb2RlKHZhbHVlLCB0eXBlLCBub2RlKSB7XG4gICAgdGhpcy5hZGRFeHRyYShub2RlLCBcInJhd1ZhbHVlXCIsIHZhbHVlKTtcbiAgICB0aGlzLmFkZEV4dHJhKG5vZGUsIFwicmF3XCIsIHRoaXMuaW5wdXQuc2xpY2UodGhpcy5vZmZzZXRUb1NvdXJjZVBvcyhub2RlLnN0YXJ0KSwgdGhpcy5zdGF0ZS5lbmQpKTtcbiAgICBub2RlLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCB0eXBlKTtcbiAgfVxuICBwYXJzZUxpdGVyYWwodmFsdWUsIHR5cGUpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWxBdE5vZGUodmFsdWUsIHR5cGUsIG5vZGUpO1xuICB9XG4gIHBhcnNlU3RyaW5nTGl0ZXJhbCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCh2YWx1ZSwgXCJTdHJpbmdMaXRlcmFsXCIpO1xuICB9XG4gIHBhcnNlTnVtZXJpY0xpdGVyYWwodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodmFsdWUsIFwiTnVtZXJpY0xpdGVyYWxcIik7XG4gIH1cbiAgcGFyc2VCaWdJbnRMaXRlcmFsKHZhbHVlKSB7XG4gICAge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsKHZhbHVlLCBcIkJpZ0ludExpdGVyYWxcIik7XG4gICAgfVxuICB9XG4gIHBhcnNlRGVjaW1hbExpdGVyYWwodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodmFsdWUsIFwiRGVjaW1hbExpdGVyYWxcIik7XG4gIH1cbiAgcGFyc2VSZWdFeHBMaXRlcmFsKHZhbHVlKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5hZGRFeHRyYShub2RlLCBcInJhd1wiLCB0aGlzLmlucHV0LnNsaWNlKHRoaXMub2Zmc2V0VG9Tb3VyY2VQb3Mobm9kZS5zdGFydCksIHRoaXMuc3RhdGUuZW5kKSk7XG4gICAgbm9kZS5wYXR0ZXJuID0gdmFsdWUucGF0dGVybjtcbiAgICBub2RlLmZsYWdzID0gdmFsdWUuZmxhZ3M7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlJlZ0V4cExpdGVyYWxcIik7XG4gIH1cbiAgcGFyc2VCb29sZWFuTGl0ZXJhbCh2YWx1ZSkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQm9vbGVhbkxpdGVyYWxcIik7XG4gIH1cbiAgcGFyc2VOdWxsTGl0ZXJhbCgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTnVsbExpdGVyYWxcIik7XG4gIH1cbiAgcGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbihjYW5CZUFycm93KSB7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGxldCB2YWw7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5leHByZXNzaW9uU2NvcGUuZW50ZXIobmV3QXJyb3dIZWFkU2NvcGUoKSk7XG4gICAgY29uc3Qgb2xkTWF5YmVJbkFycm93UGFyYW1ldGVycyA9IHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycztcbiAgICBjb25zdCBvbGRJbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHk7XG4gICAgdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gdHJ1ZTtcbiAgICB0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5ID0gZmFsc2U7XG4gICAgY29uc3QgaW5uZXJTdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgZXhwckxpc3QgPSBbXTtcbiAgICBjb25zdCByZWZFeHByZXNzaW9uRXJyb3JzID0gbmV3IEV4cHJlc3Npb25FcnJvcnMoKTtcbiAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgIGxldCBzcHJlYWRTdGFydExvYztcbiAgICBsZXQgb3B0aW9uYWxDb21tYVN0YXJ0TG9jO1xuICAgIHdoaWxlICghdGhpcy5tYXRjaCgxMSkpIHtcbiAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leHBlY3QoMTIsIHJlZkV4cHJlc3Npb25FcnJvcnMub3B0aW9uYWxQYXJhbWV0ZXJzTG9jID09PSBudWxsID8gbnVsbCA6IHJlZkV4cHJlc3Npb25FcnJvcnMub3B0aW9uYWxQYXJhbWV0ZXJzTG9jKTtcbiAgICAgICAgaWYgKHRoaXMubWF0Y2goMTEpKSB7XG4gICAgICAgICAgb3B0aW9uYWxDb21tYVN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMubWF0Y2goMjEpKSB7XG4gICAgICAgIGNvbnN0IHNwcmVhZE5vZGVTdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgICAgIHNwcmVhZFN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgICAgZXhwckxpc3QucHVzaCh0aGlzLnBhcnNlUGFyZW5JdGVtKHRoaXMucGFyc2VSZXN0QmluZGluZygpLCBzcHJlYWROb2RlU3RhcnRMb2MpKTtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrQ29tbWFBZnRlclJlc3QoNDEpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4cHJMaXN0LnB1c2godGhpcy5wYXJzZU1heWJlQXNzaWduQWxsb3dJbk9yVm9pZFBhdHRlcm4oMTEsIHJlZkV4cHJlc3Npb25FcnJvcnMsIHRoaXMucGFyc2VQYXJlbkl0ZW0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW5uZXJFbmRMb2MgPSB0aGlzLnN0YXRlLmxhc3RUb2tFbmRMb2M7XG4gICAgdGhpcy5leHBlY3QoMTEpO1xuICAgIHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycyA9IG9sZE1heWJlSW5BcnJvd1BhcmFtZXRlcnM7XG4gICAgdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IG9sZEluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5O1xuICAgIGxldCBhcnJvd05vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICBpZiAoY2FuQmVBcnJvdyAmJiB0aGlzLnNob3VsZFBhcnNlQXJyb3coZXhwckxpc3QpICYmIChhcnJvd05vZGUgPSB0aGlzLnBhcnNlQXJyb3coYXJyb3dOb2RlKSkpIHtcbiAgICAgIHRoaXMuY2hlY2tEZXN0cnVjdHVyaW5nUHJpdmF0ZShyZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLnZhbGlkYXRlQXNQYXR0ZXJuKCk7XG4gICAgICB0aGlzLmV4cHJlc3Npb25TY29wZS5leGl0KCk7XG4gICAgICB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKGFycm93Tm9kZSwgZXhwckxpc3QsIGZhbHNlKTtcbiAgICAgIHJldHVybiBhcnJvd05vZGU7XG4gICAgfVxuICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLmV4aXQoKTtcbiAgICBpZiAoIWV4cHJMaXN0Lmxlbmd0aCkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0TG9jKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbmFsQ29tbWFTdGFydExvYykgdGhpcy51bmV4cGVjdGVkKG9wdGlvbmFsQ29tbWFTdGFydExvYyk7XG4gICAgaWYgKHNwcmVhZFN0YXJ0TG9jKSB0aGlzLnVuZXhwZWN0ZWQoc3ByZWFkU3RhcnRMb2MpO1xuICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkV4cHJlc3Npb25FcnJvcnMsIHRydWUpO1xuICAgIHRoaXMudG9SZWZlcmVuY2VkTGlzdERlZXAoZXhwckxpc3QsIHRydWUpO1xuICAgIGlmIChleHByTGlzdC5sZW5ndGggPiAxKSB7XG4gICAgICB2YWwgPSB0aGlzLnN0YXJ0Tm9kZUF0KGlubmVyU3RhcnRMb2MpO1xuICAgICAgdmFsLmV4cHJlc3Npb25zID0gZXhwckxpc3Q7XG4gICAgICB0aGlzLmZpbmlzaE5vZGUodmFsLCBcIlNlcXVlbmNlRXhwcmVzc2lvblwiKTtcbiAgICAgIHRoaXMucmVzZXRFbmRMb2NhdGlvbih2YWwsIGlubmVyRW5kTG9jKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsID0gZXhwckxpc3RbMF07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndyYXBQYXJlbnRoZXNpcyhzdGFydExvYywgdmFsKTtcbiAgfVxuICB3cmFwUGFyZW50aGVzaXMoc3RhcnRMb2MsIGV4cHJlc3Npb24pIHtcbiAgICBpZiAoISh0aGlzLm9wdGlvbkZsYWdzICYgMTAyNCkpIHtcbiAgICAgIHRoaXMuYWRkRXh0cmEoZXhwcmVzc2lvbiwgXCJwYXJlbnRoZXNpemVkXCIsIHRydWUpO1xuICAgICAgdGhpcy5hZGRFeHRyYShleHByZXNzaW9uLCBcInBhcmVuU3RhcnRcIiwgc3RhcnRMb2MuaW5kZXgpO1xuICAgICAgdGhpcy50YWtlU3Vycm91bmRpbmdDb21tZW50cyhleHByZXNzaW9uLCBzdGFydExvYy5pbmRleCwgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jLmluZGV4KTtcbiAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbkV4cHJlc3Npb24gPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICBwYXJlbkV4cHJlc3Npb24uZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwYXJlbkV4cHJlc3Npb24sIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIik7XG4gIH1cbiAgc2hvdWxkUGFyc2VBcnJvdyhwYXJhbXMpIHtcbiAgICByZXR1cm4gIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCk7XG4gIH1cbiAgcGFyc2VBcnJvdyhub2RlKSB7XG4gICAgaWYgKHRoaXMuZWF0KDE5KSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG4gIHBhcnNlUGFyZW5JdGVtKG5vZGUsIHN0YXJ0TG9jKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcGFyc2VOZXdPck5ld1RhcmdldCgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy5tYXRjaCgxNikpIHtcbiAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLmNyZWF0ZUlkZW50aWZpZXIodGhpcy5zdGFydE5vZGVBdE5vZGUobm9kZSksIFwibmV3XCIpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBjb25zdCBtZXRhUHJvcCA9IHRoaXMucGFyc2VNZXRhUHJvcGVydHkobm9kZSwgbWV0YSwgXCJ0YXJnZXRcIik7XG4gICAgICBpZiAoIXRoaXMuc2NvcGUuYWxsb3dOZXdUYXJnZXQpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZE5ld1RhcmdldCwgbWV0YVByb3ApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ldGFQcm9wO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZU5ldyhub2RlKTtcbiAgfVxuICBwYXJzZU5ldyhub2RlKSB7XG4gICAgdGhpcy5wYXJzZU5ld0NhbGxlZShub2RlKTtcbiAgICBpZiAodGhpcy5lYXQoMTApKSB7XG4gICAgICBjb25zdCBhcmdzID0gdGhpcy5wYXJzZUV4cHJMaXN0KDExKTtcbiAgICAgIHRoaXMudG9SZWZlcmVuY2VkTGlzdChhcmdzKTtcbiAgICAgIG5vZGUuYXJndW1lbnRzID0gYXJncztcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5hcmd1bWVudHMgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk5ld0V4cHJlc3Npb25cIik7XG4gIH1cbiAgcGFyc2VOZXdDYWxsZWUobm9kZSkge1xuICAgIGNvbnN0IGlzSW1wb3J0ID0gdGhpcy5tYXRjaCg4Myk7XG4gICAgY29uc3QgY2FsbGVlID0gdGhpcy5wYXJzZU5vQ2FsbEV4cHIoKTtcbiAgICBub2RlLmNhbGxlZSA9IGNhbGxlZTtcbiAgICBpZiAoaXNJbXBvcnQgJiYgKGNhbGxlZS50eXBlID09PSBcIkltcG9ydFwiIHx8IGNhbGxlZS50eXBlID09PSBcIkltcG9ydEV4cHJlc3Npb25cIikpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkltcG9ydENhbGxOb3ROZXdFeHByZXNzaW9uLCBjYWxsZWUpO1xuICAgIH1cbiAgfVxuICBwYXJzZVRlbXBsYXRlRWxlbWVudChpc1RhZ2dlZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YXJ0LFxuICAgICAgc3RhcnRMb2MsXG4gICAgICBlbmQsXG4gICAgICB2YWx1ZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGVsZW1TdGFydCA9IHN0YXJ0ICsgMTtcbiAgICBjb25zdCBlbGVtID0gdGhpcy5zdGFydE5vZGVBdChjcmVhdGVQb3NpdGlvbldpdGhDb2x1bW5PZmZzZXQoc3RhcnRMb2MsIDEpKTtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIGlmICghaXNUYWdnZWQpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW52YWxpZEVzY2FwZVNlcXVlbmNlVGVtcGxhdGUsIGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldCh0aGlzLnN0YXRlLmZpcnN0SW52YWxpZFRlbXBsYXRlRXNjYXBlUG9zLCAxKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGlzVGFpbCA9IHRoaXMubWF0Y2goMjQpO1xuICAgIGNvbnN0IGVuZE9mZnNldCA9IGlzVGFpbCA/IC0xIDogLTI7XG4gICAgY29uc3QgZWxlbUVuZCA9IGVuZCArIGVuZE9mZnNldDtcbiAgICBlbGVtLnZhbHVlID0ge1xuICAgICAgcmF3OiB0aGlzLmlucHV0LnNsaWNlKGVsZW1TdGFydCwgZWxlbUVuZCkucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKSxcbiAgICAgIGNvb2tlZDogdmFsdWUgPT09IG51bGwgPyBudWxsIDogdmFsdWUuc2xpY2UoMSwgZW5kT2Zmc2V0KVxuICAgIH07XG4gICAgZWxlbS50YWlsID0gaXNUYWlsO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGNvbnN0IGZpbmlzaGVkTm9kZSA9IHRoaXMuZmluaXNoTm9kZShlbGVtLCBcIlRlbXBsYXRlRWxlbWVudFwiKTtcbiAgICB0aGlzLnJlc2V0RW5kTG9jYXRpb24oZmluaXNoZWROb2RlLCBjcmVhdGVQb3NpdGlvbldpdGhDb2x1bW5PZmZzZXQodGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jLCBlbmRPZmZzZXQpKTtcbiAgICByZXR1cm4gZmluaXNoZWROb2RlO1xuICB9XG4gIHBhcnNlVGVtcGxhdGUoaXNUYWdnZWQpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBsZXQgY3VyRWx0ID0gdGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudChpc1RhZ2dlZCk7XG4gICAgY29uc3QgcXVhc2lzID0gW2N1ckVsdF07XG4gICAgY29uc3Qgc3Vic3RpdHV0aW9ucyA9IFtdO1xuICAgIHdoaWxlICghY3VyRWx0LnRhaWwpIHtcbiAgICAgIHN1YnN0aXR1dGlvbnMucHVzaCh0aGlzLnBhcnNlVGVtcGxhdGVTdWJzdGl0dXRpb24oKSk7XG4gICAgICB0aGlzLnJlYWRUZW1wbGF0ZUNvbnRpbnVhdGlvbigpO1xuICAgICAgcXVhc2lzLnB1c2goY3VyRWx0ID0gdGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudChpc1RhZ2dlZCkpO1xuICAgIH1cbiAgICBub2RlLmV4cHJlc3Npb25zID0gc3Vic3RpdHV0aW9ucztcbiAgICBub2RlLnF1YXNpcyA9IHF1YXNpcztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGVtcGxhdGVMaXRlcmFsXCIpO1xuICB9XG4gIHBhcnNlVGVtcGxhdGVTdWJzdGl0dXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gIH1cbiAgcGFyc2VPYmplY3RMaWtlKGNsb3NlLCBpc1BhdHRlcm4sIGlzUmVjb3JkLCByZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgaWYgKGlzUmVjb3JkKSB7XG4gICAgICB0aGlzLmV4cGVjdFBsdWdpbihcInJlY29yZEFuZFR1cGxlXCIpO1xuICAgIH1cbiAgICBjb25zdCBvbGRJbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHk7XG4gICAgdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IGZhbHNlO1xuICAgIGxldCBzYXdQcm90byA9IGZhbHNlO1xuICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS5wcm9wZXJ0aWVzID0gW107XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgd2hpbGUgKCF0aGlzLm1hdGNoKGNsb3NlKSkge1xuICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgICAgIGlmICh0aGlzLm1hdGNoKGNsb3NlKSkge1xuICAgICAgICAgIHRoaXMuYWRkVHJhaWxpbmdDb21tYUV4dHJhVG9Ob2RlKG5vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgcHJvcDtcbiAgICAgIGlmIChpc1BhdHRlcm4pIHtcbiAgICAgICAgcHJvcCA9IHRoaXMucGFyc2VCaW5kaW5nUHJvcGVydHkoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3AgPSB0aGlzLnBhcnNlUHJvcGVydHlEZWZpbml0aW9uKHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgICAgICBzYXdQcm90byA9IHRoaXMuY2hlY2tQcm90byhwcm9wLCBpc1JlY29yZCwgc2F3UHJvdG8sIHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgICAgfVxuICAgICAgaWYgKGlzUmVjb3JkICYmICF0aGlzLmlzT2JqZWN0UHJvcGVydHkocHJvcCkgJiYgcHJvcC50eXBlICE9PSBcIlNwcmVhZEVsZW1lbnRcIikge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkUmVjb3JkUHJvcGVydHksIHByb3ApO1xuICAgICAgfVxuICAgICAge1xuICAgICAgICBpZiAocHJvcC5zaG9ydGhhbmQpIHtcbiAgICAgICAgICB0aGlzLmFkZEV4dHJhKHByb3AsIFwic2hvcnRoYW5kXCIsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2RlLnByb3BlcnRpZXMucHVzaChwcm9wKTtcbiAgICB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IG9sZEluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5O1xuICAgIGxldCB0eXBlID0gXCJPYmplY3RFeHByZXNzaW9uXCI7XG4gICAgaWYgKGlzUGF0dGVybikge1xuICAgICAgdHlwZSA9IFwiT2JqZWN0UGF0dGVyblwiO1xuICAgIH0gZWxzZSBpZiAoaXNSZWNvcmQpIHtcbiAgICAgIHR5cGUgPSBcIlJlY29yZEV4cHJlc3Npb25cIjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCB0eXBlKTtcbiAgfVxuICBhZGRUcmFpbGluZ0NvbW1hRXh0cmFUb05vZGUobm9kZSkge1xuICAgIHRoaXMuYWRkRXh0cmEobm9kZSwgXCJ0cmFpbGluZ0NvbW1hXCIsIHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0TG9jLmluZGV4KTtcbiAgICB0aGlzLmFkZEV4dHJhKG5vZGUsIFwidHJhaWxpbmdDb21tYUxvY1wiLCB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYywgZmFsc2UpO1xuICB9XG4gIG1heWJlQXN5bmNPckFjY2Vzc29yUHJvcChwcm9wKSB7XG4gICAgcmV0dXJuICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmICh0aGlzLmlzTGl0ZXJhbFByb3BlcnR5TmFtZSgpIHx8IHRoaXMubWF0Y2goMCkgfHwgdGhpcy5tYXRjaCg1NSkpO1xuICB9XG4gIHBhcnNlUHJvcGVydHlEZWZpbml0aW9uKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBsZXQgZGVjb3JhdG9ycyA9IFtdO1xuICAgIGlmICh0aGlzLm1hdGNoKDI2KSkge1xuICAgICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwiZGVjb3JhdG9yc1wiKSkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbnN1cHBvcnRlZFByb3BlcnR5RGVjb3JhdG9yLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICh0aGlzLm1hdGNoKDI2KSkge1xuICAgICAgICBkZWNvcmF0b3JzLnB1c2godGhpcy5wYXJzZURlY29yYXRvcigpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcHJvcCA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbGV0IGlzQXN5bmMgPSBmYWxzZTtcbiAgICBsZXQgaXNBY2Nlc3NvciA9IGZhbHNlO1xuICAgIGxldCBzdGFydExvYztcbiAgICBpZiAodGhpcy5tYXRjaCgyMSkpIHtcbiAgICAgIGlmIChkZWNvcmF0b3JzLmxlbmd0aCkgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVNwcmVhZCgpO1xuICAgIH1cbiAgICBpZiAoZGVjb3JhdG9ycy5sZW5ndGgpIHtcbiAgICAgIHByb3AuZGVjb3JhdG9ycyA9IGRlY29yYXRvcnM7XG4gICAgICBkZWNvcmF0b3JzID0gW107XG4gICAgfVxuICAgIHByb3AubWV0aG9kID0gZmFsc2U7XG4gICAgaWYgKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICAgIHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICB9XG4gICAgbGV0IGlzR2VuZXJhdG9yID0gdGhpcy5lYXQoNTUpO1xuICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWVQcmVmaXhPcGVyYXRvcihwcm9wKTtcbiAgICBjb25zdCBjb250YWluc0VzYyA9IHRoaXMuc3RhdGUuY29udGFpbnNFc2M7XG4gICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICBpZiAoIWlzR2VuZXJhdG9yICYmICFjb250YWluc0VzYyAmJiB0aGlzLm1heWJlQXN5bmNPckFjY2Vzc29yUHJvcChwcm9wKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBrZXlcbiAgICAgIH0gPSBwcm9wO1xuICAgICAgY29uc3Qga2V5TmFtZSA9IGtleS5uYW1lO1xuICAgICAgaWYgKGtleU5hbWUgPT09IFwiYXN5bmNcIiAmJiAhdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSkge1xuICAgICAgICBpc0FzeW5jID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZXNldFByZXZpb3VzTm9kZVRyYWlsaW5nQ29tbWVudHMoa2V5KTtcbiAgICAgICAgaXNHZW5lcmF0b3IgPSB0aGlzLmVhdCg1NSk7XG4gICAgICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCk7XG4gICAgICB9XG4gICAgICBpZiAoa2V5TmFtZSA9PT0gXCJnZXRcIiB8fCBrZXlOYW1lID09PSBcInNldFwiKSB7XG4gICAgICAgIGlzQWNjZXNzb3IgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlc2V0UHJldmlvdXNOb2RlVHJhaWxpbmdDb21tZW50cyhrZXkpO1xuICAgICAgICBwcm9wLmtpbmQgPSBrZXlOYW1lO1xuICAgICAgICBpZiAodGhpcy5tYXRjaCg1NSkpIHtcbiAgICAgICAgICBpc0dlbmVyYXRvciA9IHRydWU7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQWNjZXNzb3JJc0dlbmVyYXRvciwgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpLCB7XG4gICAgICAgICAgICBraW5kOiBrZXlOYW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VPYmpQcm9wVmFsdWUocHJvcCwgc3RhcnRMb2MsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBmYWxzZSwgaXNBY2Nlc3NvciwgcmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gIH1cbiAgZ2V0R2V0dGVyU2V0dGVyRXhwZWN0ZWRQYXJhbUNvdW50KG1ldGhvZCkge1xuICAgIHJldHVybiBtZXRob2Qua2luZCA9PT0gXCJnZXRcIiA/IDAgOiAxO1xuICB9XG4gIGdldE9iamVjdE9yQ2xhc3NNZXRob2RQYXJhbXMobWV0aG9kKSB7XG4gICAgcmV0dXJuIG1ldGhvZC5wYXJhbXM7XG4gIH1cbiAgY2hlY2tHZXR0ZXJTZXR0ZXJQYXJhbXMobWV0aG9kKSB7XG4gICAgdmFyIF9wYXJhbXM7XG4gICAgY29uc3QgcGFyYW1Db3VudCA9IHRoaXMuZ2V0R2V0dGVyU2V0dGVyRXhwZWN0ZWRQYXJhbUNvdW50KG1ldGhvZCk7XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy5nZXRPYmplY3RPckNsYXNzTWV0aG9kUGFyYW1zKG1ldGhvZCk7XG4gICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IHBhcmFtQ291bnQpIHtcbiAgICAgIHRoaXMucmFpc2UobWV0aG9kLmtpbmQgPT09IFwiZ2V0XCIgPyBFcnJvcnMuQmFkR2V0dGVyQXJpdHkgOiBFcnJvcnMuQmFkU2V0dGVyQXJpdHksIG1ldGhvZCk7XG4gICAgfVxuICAgIGlmIChtZXRob2Qua2luZCA9PT0gXCJzZXRcIiAmJiAoKF9wYXJhbXMgPSBwYXJhbXNbcGFyYW1zLmxlbmd0aCAtIDFdKSA9PSBudWxsID8gdm9pZCAwIDogX3BhcmFtcy50eXBlKSA9PT0gXCJSZXN0RWxlbWVudFwiKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5CYWRTZXR0ZXJSZXN0UGFyYW1ldGVyLCBtZXRob2QpO1xuICAgIH1cbiAgfVxuICBwYXJzZU9iamVjdE1ldGhvZChwcm9wLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNQYXR0ZXJuLCBpc0FjY2Vzc29yKSB7XG4gICAgaWYgKGlzQWNjZXNzb3IpIHtcbiAgICAgIGNvbnN0IGZpbmlzaGVkUHJvcCA9IHRoaXMucGFyc2VNZXRob2QocHJvcCwgaXNHZW5lcmF0b3IsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIFwiT2JqZWN0TWV0aG9kXCIpO1xuICAgICAgdGhpcy5jaGVja0dldHRlclNldHRlclBhcmFtcyhmaW5pc2hlZFByb3ApO1xuICAgICAgcmV0dXJuIGZpbmlzaGVkUHJvcDtcbiAgICB9XG4gICAgaWYgKGlzQXN5bmMgfHwgaXNHZW5lcmF0b3IgfHwgdGhpcy5tYXRjaCgxMCkpIHtcbiAgICAgIGlmIChpc1BhdHRlcm4pIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgcHJvcC5raW5kID0gXCJtZXRob2RcIjtcbiAgICAgIHByb3AubWV0aG9kID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlTWV0aG9kKHByb3AsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBmYWxzZSwgZmFsc2UsIFwiT2JqZWN0TWV0aG9kXCIpO1xuICAgIH1cbiAgfVxuICBwYXJzZU9iamVjdFByb3BlcnR5KHByb3AsIHN0YXJ0TG9jLCBpc1BhdHRlcm4sIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBwcm9wLnNob3J0aGFuZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLmVhdCgxNCkpIHtcbiAgICAgIHByb3AudmFsdWUgPSBpc1BhdHRlcm4gPyB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHRoaXMuc3RhdGUuc3RhcnRMb2MpIDogdGhpcy5wYXJzZU1heWJlQXNzaWduQWxsb3dJbk9yVm9pZFBhdHRlcm4oOCwgcmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hPYmplY3RQcm9wZXJ0eShwcm9wKTtcbiAgICB9XG4gICAgaWYgKCFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICB0aGlzLmNoZWNrUmVzZXJ2ZWRXb3JkKHByb3Aua2V5Lm5hbWUsIHByb3Aua2V5LmxvYy5zdGFydCwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgaWYgKGlzUGF0dGVybikge1xuICAgICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChzdGFydExvYywgdGhpcy5jbG9uZUlkZW50aWZpZXIocHJvcC5rZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5tYXRjaCgyOSkpIHtcbiAgICAgICAgY29uc3Qgc2hvcnRoYW5kQXNzaWduTG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgICAgaWYgKHJlZkV4cHJlc3Npb25FcnJvcnMgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChyZWZFeHByZXNzaW9uRXJyb3JzLnNob3J0aGFuZEFzc2lnbkxvYyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmVmRXhwcmVzc2lvbkVycm9ycy5zaG9ydGhhbmRBc3NpZ25Mb2MgPSBzaG9ydGhhbmRBc3NpZ25Mb2M7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWRDb3ZlckluaXRpYWxpemVkTmFtZSwgc2hvcnRoYW5kQXNzaWduTG9jKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChzdGFydExvYywgdGhpcy5jbG9uZUlkZW50aWZpZXIocHJvcC5rZXkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3AudmFsdWUgPSB0aGlzLmNsb25lSWRlbnRpZmllcihwcm9wLmtleSk7XG4gICAgICB9XG4gICAgICBwcm9wLnNob3J0aGFuZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hPYmplY3RQcm9wZXJ0eShwcm9wKTtcbiAgICB9XG4gIH1cbiAgZmluaXNoT2JqZWN0UHJvcGVydHkobm9kZSkge1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJPYmplY3RQcm9wZXJ0eVwiKTtcbiAgfVxuICBwYXJzZU9ialByb3BWYWx1ZShwcm9wLCBzdGFydExvYywgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzUGF0dGVybiwgaXNBY2Nlc3NvciwgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnBhcnNlT2JqZWN0TWV0aG9kKHByb3AsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc1BhdHRlcm4sIGlzQWNjZXNzb3IpIHx8IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eShwcm9wLCBzdGFydExvYywgaXNQYXR0ZXJuLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICBpZiAoIW5vZGUpIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHBhcnNlUHJvcGVydHlOYW1lKHByb3AsIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBpZiAodGhpcy5lYXQoMCkpIHtcbiAgICAgIHByb3AuY29tcHV0ZWQgPSB0cnVlO1xuICAgICAgcHJvcC5rZXkgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKCk7XG4gICAgICB0aGlzLmV4cGVjdCgzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qge1xuICAgICAgICB0eXBlLFxuICAgICAgICB2YWx1ZVxuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBsZXQga2V5O1xuICAgICAgaWYgKHRva2VuSXNLZXl3b3JkT3JJZGVudGlmaWVyKHR5cGUpKSB7XG4gICAgICAgIGtleSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSAxMzU6XG4gICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlTnVtZXJpY0xpdGVyYWwodmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMzQ6XG4gICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlU3RyaW5nTGl0ZXJhbCh2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDEzNjpcbiAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VCaWdJbnRMaXRlcmFsKHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTM5OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCBwcml2YXRlS2V5TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgICAgICAgICAgaWYgKHJlZkV4cHJlc3Npb25FcnJvcnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChyZWZFeHByZXNzaW9uRXJyb3JzLnByaXZhdGVLZXlMb2MgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHJlZkV4cHJlc3Npb25FcnJvcnMucHJpdmF0ZUtleUxvYyA9IHByaXZhdGVLZXlMb2M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWRQcml2YXRlRmllbGQsIHByaXZhdGVLZXlMb2MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VQcml2YXRlTmFtZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IDEzNykge1xuICAgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlRGVjaW1hbExpdGVyYWwodmFsdWUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcm9wLmtleSA9IGtleTtcbiAgICAgIGlmICh0eXBlICE9PSAxMzkpIHtcbiAgICAgICAgcHJvcC5jb21wdXRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpbml0RnVuY3Rpb24obm9kZSwgaXNBc3luYykge1xuICAgIG5vZGUuaWQgPSBudWxsO1xuICAgIG5vZGUuZ2VuZXJhdG9yID0gZmFsc2U7XG4gICAgbm9kZS5hc3luYyA9IGlzQXN5bmM7XG4gIH1cbiAgcGFyc2VNZXRob2Qobm9kZSwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzQ29uc3RydWN0b3IsIGFsbG93RGlyZWN0U3VwZXIsIHR5cGUsIGluQ2xhc3NTY29wZSA9IGZhbHNlKSB7XG4gICAgdGhpcy5pbml0RnVuY3Rpb24obm9kZSwgaXNBc3luYyk7XG4gICAgbm9kZS5nZW5lcmF0b3IgPSBpc0dlbmVyYXRvcjtcbiAgICB0aGlzLnNjb3BlLmVudGVyKDUxNCB8IDE2IHwgKGluQ2xhc3NTY29wZSA/IDU3NiA6IDApIHwgKGFsbG93RGlyZWN0U3VwZXIgPyAzMiA6IDApKTtcbiAgICB0aGlzLnByb2RQYXJhbS5lbnRlcihmdW5jdGlvbkZsYWdzKGlzQXN5bmMsIG5vZGUuZ2VuZXJhdG9yKSk7XG4gICAgdGhpcy5wYXJzZUZ1bmN0aW9uUGFyYW1zKG5vZGUsIGlzQ29uc3RydWN0b3IpO1xuICAgIGNvbnN0IGZpbmlzaGVkTm9kZSA9IHRoaXMucGFyc2VGdW5jdGlvbkJvZHlBbmRGaW5pc2gobm9kZSwgdHlwZSwgdHJ1ZSk7XG4gICAgdGhpcy5wcm9kUGFyYW0uZXhpdCgpO1xuICAgIHRoaXMuc2NvcGUuZXhpdCgpO1xuICAgIHJldHVybiBmaW5pc2hlZE5vZGU7XG4gIH1cbiAgcGFyc2VBcnJheUxpa2UoY2xvc2UsIGNhbkJlUGF0dGVybiwgaXNUdXBsZSwgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGlmIChpc1R1cGxlKSB7XG4gICAgICB0aGlzLmV4cGVjdFBsdWdpbihcInJlY29yZEFuZFR1cGxlXCIpO1xuICAgIH1cbiAgICBjb25zdCBvbGRJbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHk7XG4gICAgdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IGZhbHNlO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuZWxlbWVudHMgPSB0aGlzLnBhcnNlRXhwckxpc3QoY2xvc2UsICFpc1R1cGxlLCByZWZFeHByZXNzaW9uRXJyb3JzLCBub2RlKTtcbiAgICB0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5ID0gb2xkSW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc1R1cGxlID8gXCJUdXBsZUV4cHJlc3Npb25cIiA6IFwiQXJyYXlFeHByZXNzaW9uXCIpO1xuICB9XG4gIHBhcnNlQXJyb3dFeHByZXNzaW9uKG5vZGUsIHBhcmFtcywgaXNBc3luYywgdHJhaWxpbmdDb21tYUxvYykge1xuICAgIHRoaXMuc2NvcGUuZW50ZXIoNTE0IHwgNCk7XG4gICAgbGV0IGZsYWdzID0gZnVuY3Rpb25GbGFncyhpc0FzeW5jLCBmYWxzZSk7XG4gICAgaWYgKCF0aGlzLm1hdGNoKDUpICYmIHRoaXMucHJvZFBhcmFtLmhhc0luKSB7XG4gICAgICBmbGFncyB8PSA4O1xuICAgIH1cbiAgICB0aGlzLnByb2RQYXJhbS5lbnRlcihmbGFncyk7XG4gICAgdGhpcy5pbml0RnVuY3Rpb24obm9kZSwgaXNBc3luYyk7XG4gICAgY29uc3Qgb2xkTWF5YmVJbkFycm93UGFyYW1ldGVycyA9IHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycztcbiAgICBpZiAocGFyYW1zKSB7XG4gICAgICB0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnMgPSB0cnVlO1xuICAgICAgdGhpcy5zZXRBcnJvd0Z1bmN0aW9uUGFyYW1ldGVycyhub2RlLCBwYXJhbXMsIHRyYWlsaW5nQ29tbWFMb2MpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnMgPSBmYWxzZTtcbiAgICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIHRydWUpO1xuICAgIHRoaXMucHJvZFBhcmFtLmV4aXQoKTtcbiAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgICB0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnMgPSBvbGRNYXliZUluQXJyb3dQYXJhbWV0ZXJzO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiKTtcbiAgfVxuICBzZXRBcnJvd0Z1bmN0aW9uUGFyYW1ldGVycyhub2RlLCBwYXJhbXMsIHRyYWlsaW5nQ29tbWFMb2MpIHtcbiAgICB0aGlzLnRvQXNzaWduYWJsZUxpc3QocGFyYW1zLCB0cmFpbGluZ0NvbW1hTG9jLCBmYWxzZSk7XG4gICAgbm9kZS5wYXJhbXMgPSBwYXJhbXM7XG4gIH1cbiAgcGFyc2VGdW5jdGlvbkJvZHlBbmRGaW5pc2gobm9kZSwgdHlwZSwgaXNNZXRob2QgPSBmYWxzZSkge1xuICAgIHRoaXMucGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgZmFsc2UsIGlzTWV0aG9kKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIHR5cGUpO1xuICB9XG4gIHBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIGFsbG93RXhwcmVzc2lvbiwgaXNNZXRob2QgPSBmYWxzZSkge1xuICAgIGNvbnN0IGlzRXhwcmVzc2lvbiA9IGFsbG93RXhwcmVzc2lvbiAmJiAhdGhpcy5tYXRjaCg1KTtcbiAgICB0aGlzLmV4cHJlc3Npb25TY29wZS5lbnRlcihuZXdFeHByZXNzaW9uU2NvcGUoKSk7XG4gICAgaWYgKGlzRXhwcmVzc2lvbikge1xuICAgICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICB0aGlzLmNoZWNrUGFyYW1zKG5vZGUsIGZhbHNlLCBhbGxvd0V4cHJlc3Npb24sIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb2xkU3RyaWN0ID0gdGhpcy5zdGF0ZS5zdHJpY3Q7XG4gICAgICBjb25zdCBvbGRMYWJlbHMgPSB0aGlzLnN0YXRlLmxhYmVscztcbiAgICAgIHRoaXMuc3RhdGUubGFiZWxzID0gW107XG4gICAgICB0aGlzLnByb2RQYXJhbS5lbnRlcih0aGlzLnByb2RQYXJhbS5jdXJyZW50RmxhZ3MoKSB8IDQpO1xuICAgICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKHRydWUsIGZhbHNlLCBoYXNTdHJpY3RNb2RlRGlyZWN0aXZlID0+IHtcbiAgICAgICAgY29uc3Qgbm9uU2ltcGxlID0gIXRoaXMuaXNTaW1wbGVQYXJhbUxpc3Qobm9kZS5wYXJhbXMpO1xuICAgICAgICBpZiAoaGFzU3RyaWN0TW9kZURpcmVjdGl2ZSAmJiBub25TaW1wbGUpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbGxlZ2FsTGFuZ3VhZ2VNb2RlRGlyZWN0aXZlLCAobm9kZS5raW5kID09PSBcIm1ldGhvZFwiIHx8IG5vZGUua2luZCA9PT0gXCJjb25zdHJ1Y3RvclwiKSAmJiAhIW5vZGUua2V5ID8gbm9kZS5rZXkubG9jLmVuZCA6IG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0cmljdE1vZGVDaGFuZ2VkID0gIW9sZFN0cmljdCAmJiB0aGlzLnN0YXRlLnN0cmljdDtcbiAgICAgICAgdGhpcy5jaGVja1BhcmFtcyhub2RlLCAhdGhpcy5zdGF0ZS5zdHJpY3QgJiYgIWFsbG93RXhwcmVzc2lvbiAmJiAhaXNNZXRob2QgJiYgIW5vblNpbXBsZSwgYWxsb3dFeHByZXNzaW9uLCBzdHJpY3RNb2RlQ2hhbmdlZCk7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnN0cmljdCAmJiBub2RlLmlkKSB7XG4gICAgICAgICAgdGhpcy5jaGVja0lkZW50aWZpZXIobm9kZS5pZCwgNjUsIHN0cmljdE1vZGVDaGFuZ2VkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnByb2RQYXJhbS5leGl0KCk7XG4gICAgICB0aGlzLnN0YXRlLmxhYmVscyA9IG9sZExhYmVscztcbiAgICB9XG4gICAgdGhpcy5leHByZXNzaW9uU2NvcGUuZXhpdCgpO1xuICB9XG4gIGlzU2ltcGxlUGFyYW1ldGVyKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcIklkZW50aWZpZXJcIjtcbiAgfVxuICBpc1NpbXBsZVBhcmFtTGlzdChwYXJhbXMpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gcGFyYW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMuaXNTaW1wbGVQYXJhbWV0ZXIocGFyYW1zW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjaGVja1BhcmFtcyhub2RlLCBhbGxvd0R1cGxpY2F0ZXMsIGlzQXJyb3dGdW5jdGlvbiwgc3RyaWN0TW9kZUNoYW5nZWQgPSB0cnVlKSB7XG4gICAgY29uc3QgY2hlY2tDbGFzaGVzID0gIWFsbG93RHVwbGljYXRlcyAmJiBuZXcgU2V0KCk7XG4gICAgY29uc3QgZm9ybWFsUGFyYW1ldGVycyA9IHtcbiAgICAgIHR5cGU6IFwiRm9ybWFsUGFyYW1ldGVyc1wiXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IHBhcmFtIG9mIG5vZGUucGFyYW1zKSB7XG4gICAgICB0aGlzLmNoZWNrTFZhbChwYXJhbSwgZm9ybWFsUGFyYW1ldGVycywgNSwgY2hlY2tDbGFzaGVzLCBzdHJpY3RNb2RlQ2hhbmdlZCk7XG4gICAgfVxuICB9XG4gIHBhcnNlRXhwckxpc3QoY2xvc2UsIGFsbG93RW1wdHksIHJlZkV4cHJlc3Npb25FcnJvcnMsIG5vZGVGb3JFeHRyYSkge1xuICAgIGNvbnN0IGVsdHMgPSBbXTtcbiAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgIHdoaWxlICghdGhpcy5lYXQoY2xvc2UpKSB7XG4gICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KDEyKTtcbiAgICAgICAgaWYgKHRoaXMubWF0Y2goY2xvc2UpKSB7XG4gICAgICAgICAgaWYgKG5vZGVGb3JFeHRyYSkge1xuICAgICAgICAgICAgdGhpcy5hZGRUcmFpbGluZ0NvbW1hRXh0cmFUb05vZGUobm9kZUZvckV4dHJhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsdHMucHVzaCh0aGlzLnBhcnNlRXhwckxpc3RJdGVtKGNsb3NlLCBhbGxvd0VtcHR5LCByZWZFeHByZXNzaW9uRXJyb3JzKSk7XG4gICAgfVxuICAgIHJldHVybiBlbHRzO1xuICB9XG4gIHBhcnNlRXhwckxpc3RJdGVtKGNsb3NlLCBhbGxvd0VtcHR5LCByZWZFeHByZXNzaW9uRXJyb3JzLCBhbGxvd1BsYWNlaG9sZGVyKSB7XG4gICAgbGV0IGVsdDtcbiAgICBpZiAodGhpcy5tYXRjaCgxMikpIHtcbiAgICAgIGlmICghYWxsb3dFbXB0eSkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkVG9rZW4sIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSwge1xuICAgICAgICAgIHVuZXhwZWN0ZWQ6IFwiLFwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWx0ID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2goMjEpKSB7XG4gICAgICBjb25zdCBzcHJlYWROb2RlU3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgICAgZWx0ID0gdGhpcy5wYXJzZVBhcmVuSXRlbSh0aGlzLnBhcnNlU3ByZWFkKHJlZkV4cHJlc3Npb25FcnJvcnMpLCBzcHJlYWROb2RlU3RhcnRMb2MpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tYXRjaCgxNykpIHtcbiAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwicGFydGlhbEFwcGxpY2F0aW9uXCIpO1xuICAgICAgaWYgKCFhbGxvd1BsYWNlaG9sZGVyKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWRBcmd1bWVudFBsYWNlaG9sZGVyLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBlbHQgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcmd1bWVudFBsYWNlaG9sZGVyXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbHQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luT3JWb2lkUGF0dGVybihjbG9zZSwgcmVmRXhwcmVzc2lvbkVycm9ycywgdGhpcy5wYXJzZVBhcmVuSXRlbSk7XG4gICAgfVxuICAgIHJldHVybiBlbHQ7XG4gIH1cbiAgcGFyc2VJZGVudGlmaWVyKGxpYmVyYWwpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKGxpYmVyYWwpO1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZUlkZW50aWZpZXIobm9kZSwgbmFtZSk7XG4gIH1cbiAgY3JlYXRlSWRlbnRpZmllcihub2RlLCBuYW1lKSB7XG4gICAgbm9kZS5uYW1lID0gbmFtZTtcbiAgICBub2RlLmxvYy5pZGVudGlmaWVyTmFtZSA9IG5hbWU7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIklkZW50aWZpZXJcIik7XG4gIH1cbiAgY3JlYXRlSWRlbnRpZmllckF0KG5vZGUsIG5hbWUsIGVuZExvYykge1xuICAgIG5vZGUubmFtZSA9IG5hbWU7XG4gICAgbm9kZS5sb2MuaWRlbnRpZmllck5hbWUgPSBuYW1lO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGVBdChub2RlLCBcIklkZW50aWZpZXJcIiwgZW5kTG9jKTtcbiAgfVxuICBwYXJzZUlkZW50aWZpZXJOYW1lKGxpYmVyYWwpIHtcbiAgICBsZXQgbmFtZTtcbiAgICBjb25zdCB7XG4gICAgICBzdGFydExvYyxcbiAgICAgIHR5cGVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodG9rZW5Jc0tleXdvcmRPcklkZW50aWZpZXIodHlwZSkpIHtcbiAgICAgIG5hbWUgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gICAgY29uc3QgdG9rZW5Jc0tleXdvcmQgPSB0b2tlbktleXdvcmRPcklkZW50aWZpZXJJc0tleXdvcmQodHlwZSk7XG4gICAgaWYgKGxpYmVyYWwpIHtcbiAgICAgIGlmICh0b2tlbklzS2V5d29yZCkge1xuICAgICAgICB0aGlzLnJlcGxhY2VUb2tlbigxMzIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNoZWNrUmVzZXJ2ZWRXb3JkKG5hbWUsIHN0YXJ0TG9jLCB0b2tlbklzS2V5d29yZCwgZmFsc2UpO1xuICAgIH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gbmFtZTtcbiAgfVxuICBjaGVja1Jlc2VydmVkV29yZCh3b3JkLCBzdGFydExvYywgY2hlY2tLZXl3b3JkcywgaXNCaW5kaW5nKSB7XG4gICAgaWYgKHdvcmQubGVuZ3RoID4gMTApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFjYW5CZVJlc2VydmVkV29yZCh3b3JkKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2hlY2tLZXl3b3JkcyAmJiBpc0tleXdvcmQod29yZCkpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWRLZXl3b3JkLCBzdGFydExvYywge1xuICAgICAgICBrZXl3b3JkOiB3b3JkXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVzZXJ2ZWRUZXN0ID0gIXRoaXMuc3RhdGUuc3RyaWN0ID8gaXNSZXNlcnZlZFdvcmQgOiBpc0JpbmRpbmcgPyBpc1N0cmljdEJpbmRSZXNlcnZlZFdvcmQgOiBpc1N0cmljdFJlc2VydmVkV29yZDtcbiAgICBpZiAocmVzZXJ2ZWRUZXN0KHdvcmQsIHRoaXMuaW5Nb2R1bGUpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkUmVzZXJ2ZWRXb3JkLCBzdGFydExvYywge1xuICAgICAgICByZXNlcnZlZFdvcmQ6IHdvcmRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAod29yZCA9PT0gXCJ5aWVsZFwiKSB7XG4gICAgICBpZiAodGhpcy5wcm9kUGFyYW0uaGFzWWllbGQpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuWWllbGRCaW5kaW5nSWRlbnRpZmllciwgc3RhcnRMb2MpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh3b3JkID09PSBcImF3YWl0XCIpIHtcbiAgICAgIGlmICh0aGlzLnByb2RQYXJhbS5oYXNBd2FpdCkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Bd2FpdEJpbmRpbmdJZGVudGlmaWVyLCBzdGFydExvYyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNjb3BlLmluU3RhdGljQmxvY2spIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQXdhaXRCaW5kaW5nSWRlbnRpZmllckluU3RhdGljQmxvY2ssIHN0YXJ0TG9jKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5leHByZXNzaW9uU2NvcGUucmVjb3JkQXN5bmNBcnJvd1BhcmFtZXRlcnNFcnJvcihzdGFydExvYyk7XG4gICAgfSBlbHNlIGlmICh3b3JkID09PSBcImFyZ3VtZW50c1wiKSB7XG4gICAgICBpZiAodGhpcy5zY29wZS5pbkNsYXNzQW5kTm90SW5Ob25BcnJvd0Z1bmN0aW9uKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkFyZ3VtZW50c0luQ2xhc3MsIHN0YXJ0TG9jKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZWNvcmRBd2FpdElmQWxsb3dlZCgpIHtcbiAgICBjb25zdCBpc0F3YWl0QWxsb3dlZCA9IHRoaXMucHJvZFBhcmFtLmhhc0F3YWl0O1xuICAgIGlmIChpc0F3YWl0QWxsb3dlZCAmJiAhdGhpcy5zY29wZS5pbkZ1bmN0aW9uKSB7XG4gICAgICB0aGlzLnN0YXRlLmhhc1RvcExldmVsQXdhaXQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gaXNBd2FpdEFsbG93ZWQ7XG4gIH1cbiAgcGFyc2VBd2FpdChzdGFydExvYykge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICB0aGlzLmV4cHJlc3Npb25TY29wZS5yZWNvcmRQYXJhbWV0ZXJJbml0aWFsaXplckVycm9yKEVycm9ycy5Bd2FpdEV4cHJlc3Npb25Gb3JtYWxQYXJhbWV0ZXIsIG5vZGUpO1xuICAgIGlmICh0aGlzLmVhdCg1NSkpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLk9ic29sZXRlQXdhaXRTdGFyLCBub2RlKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnNjb3BlLmluRnVuY3Rpb24gJiYgISh0aGlzLm9wdGlvbkZsYWdzICYgMSkpIHtcbiAgICAgIGlmICh0aGlzLmlzQW1iaWd1b3VzUHJlZml4T3JJZGVudGlmaWVyKCkpIHtcbiAgICAgICAgdGhpcy5hbWJpZ3VvdXNTY3JpcHREaWZmZXJlbnRBc3QgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zYXdVbmFtYmlndW91c0VTTSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5zdGF0ZS5zb2xvQXdhaXQpIHtcbiAgICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkF3YWl0RXhwcmVzc2lvblwiKTtcbiAgfVxuICBpc0FtYmlndW91c1ByZWZpeE9ySWRlbnRpZmllcigpIHtcbiAgICBpZiAodGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSkgcmV0dXJuIHRydWU7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIHJldHVybiB0eXBlID09PSA1MyB8fCB0eXBlID09PSAxMCB8fCB0eXBlID09PSAwIHx8IHRva2VuSXNUZW1wbGF0ZSh0eXBlKSB8fCB0eXBlID09PSAxMDIgJiYgIXRoaXMuc3RhdGUuY29udGFpbnNFc2MgfHwgdHlwZSA9PT0gMTM4IHx8IHR5cGUgPT09IDU2IHx8IHRoaXMuaGFzUGx1Z2luKFwidjhpbnRyaW5zaWNcIikgJiYgdHlwZSA9PT0gNTQ7XG4gIH1cbiAgcGFyc2VZaWVsZChzdGFydExvYykge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICB0aGlzLmV4cHJlc3Npb25TY29wZS5yZWNvcmRQYXJhbWV0ZXJJbml0aWFsaXplckVycm9yKEVycm9ycy5ZaWVsZEluUGFyYW1ldGVyLCBub2RlKTtcbiAgICBsZXQgZGVsZWdhdGluZyA9IGZhbHNlO1xuICAgIGxldCBhcmd1bWVudCA9IG51bGw7XG4gICAgaWYgKCF0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpKSB7XG4gICAgICBkZWxlZ2F0aW5nID0gdGhpcy5lYXQoNTUpO1xuICAgICAgc3dpdGNoICh0aGlzLnN0YXRlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgY2FzZSAxNDA6XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICBjYXNlIDk6XG4gICAgICAgIGNhc2UgMTQ6XG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgaWYgKCFkZWxlZ2F0aW5nKSBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBhcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgfVxuICAgIH1cbiAgICBub2RlLmRlbGVnYXRlID0gZGVsZWdhdGluZztcbiAgICBub2RlLmFyZ3VtZW50ID0gYXJndW1lbnQ7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIllpZWxkRXhwcmVzc2lvblwiKTtcbiAgfVxuICBwYXJzZUltcG9ydENhbGwobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZU1heWJlQXNzaWduQWxsb3dJbigpO1xuICAgIG5vZGUub3B0aW9ucyA9IG51bGw7XG4gICAgaWYgKHRoaXMuZWF0KDEyKSkge1xuICAgICAgaWYgKCF0aGlzLm1hdGNoKDExKSkge1xuICAgICAgICBub2RlLm9wdGlvbnMgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKCk7XG4gICAgICAgIGlmICh0aGlzLmVhdCgxMikpIHtcbiAgICAgICAgICB0aGlzLmFkZFRyYWlsaW5nQ29tbWFFeHRyYVRvTm9kZShub2RlLm9wdGlvbnMpO1xuICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgxMSkpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgdGhpcy5wYXJzZU1heWJlQXNzaWduQWxsb3dJbigpO1xuICAgICAgICAgICAgfSB3aGlsZSAodGhpcy5lYXQoMTIpICYmICF0aGlzLm1hdGNoKDExKSk7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbXBvcnRDYWxsQXJpdHksIG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hZGRUcmFpbGluZ0NvbW1hRXh0cmFUb05vZGUobm9kZS5zb3VyY2UpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmV4cGVjdCgxMSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydEV4cHJlc3Npb25cIik7XG4gIH1cbiAgY2hlY2tQaXBlbGluZUF0SW5maXhPcGVyYXRvcihsZWZ0LCBsZWZ0U3RhcnRMb2MpIHtcbiAgICBpZiAodGhpcy5oYXNQbHVnaW4oW1wicGlwZWxpbmVPcGVyYXRvclwiLCB7XG4gICAgICBwcm9wb3NhbDogXCJzbWFydFwiXG4gICAgfV0pKSB7XG4gICAgICBpZiAobGVmdC50eXBlID09PSBcIlNlcXVlbmNlRXhwcmVzc2lvblwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlBpcGVsaW5lSGVhZFNlcXVlbmNlRXhwcmVzc2lvbiwgbGVmdFN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcGFyc2VTbWFydFBpcGVsaW5lQm9keUluU3R5bGUoY2hpbGRFeHByLCBzdGFydExvYykge1xuICAgIGlmICh0aGlzLmlzU2ltcGxlUmVmZXJlbmNlKGNoaWxkRXhwcikpIHtcbiAgICAgIGNvbnN0IGJvZHlOb2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICBib2R5Tm9kZS5jYWxsZWUgPSBjaGlsZEV4cHI7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKGJvZHlOb2RlLCBcIlBpcGVsaW5lQmFyZUZ1bmN0aW9uXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBib2R5Tm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgdGhpcy5jaGVja1NtYXJ0UGlwZVRvcGljQm9keUVhcmx5RXJyb3JzKHN0YXJ0TG9jKTtcbiAgICAgIGJvZHlOb2RlLmV4cHJlc3Npb24gPSBjaGlsZEV4cHI7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKGJvZHlOb2RlLCBcIlBpcGVsaW5lVG9waWNFeHByZXNzaW9uXCIpO1xuICAgIH1cbiAgfVxuICBpc1NpbXBsZVJlZmVyZW5jZShleHByZXNzaW9uKSB7XG4gICAgc3dpdGNoIChleHByZXNzaW9uLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiAhZXhwcmVzc2lvbi5jb21wdXRlZCAmJiB0aGlzLmlzU2ltcGxlUmVmZXJlbmNlKGV4cHJlc3Npb24ub2JqZWN0KTtcbiAgICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBjaGVja1NtYXJ0UGlwZVRvcGljQm9keUVhcmx5RXJyb3JzKHN0YXJ0TG9jKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTkpKSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5QaXBlbGluZUJvZHlOb0Fycm93LCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnRvcGljUmVmZXJlbmNlV2FzVXNlZEluQ3VycmVudENvbnRleHQoKSkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuUGlwZWxpbmVUb3BpY1VudXNlZCwgc3RhcnRMb2MpO1xuICAgIH1cbiAgfVxuICB3aXRoVG9waWNCaW5kaW5nQ29udGV4dChjYWxsYmFjaykge1xuICAgIGNvbnN0IG91dGVyQ29udGV4dFRvcGljU3RhdGUgPSB0aGlzLnN0YXRlLnRvcGljQ29udGV4dDtcbiAgICB0aGlzLnN0YXRlLnRvcGljQ29udGV4dCA9IHtcbiAgICAgIG1heE51bU9mUmVzb2x2YWJsZVRvcGljczogMSxcbiAgICAgIG1heFRvcGljSW5kZXg6IG51bGxcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5zdGF0ZS50b3BpY0NvbnRleHQgPSBvdXRlckNvbnRleHRUb3BpY1N0YXRlO1xuICAgIH1cbiAgfVxuICB3aXRoU21hcnRNaXhUb3BpY0ZvcmJpZGRpbmdDb250ZXh0KGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuaGFzUGx1Z2luKFtcInBpcGVsaW5lT3BlcmF0b3JcIiwge1xuICAgICAgcHJvcG9zYWw6IFwic21hcnRcIlxuICAgIH1dKSkge1xuICAgICAgY29uc3Qgb3V0ZXJDb250ZXh0VG9waWNTdGF0ZSA9IHRoaXMuc3RhdGUudG9waWNDb250ZXh0O1xuICAgICAgdGhpcy5zdGF0ZS50b3BpY0NvbnRleHQgPSB7XG4gICAgICAgIG1heE51bU9mUmVzb2x2YWJsZVRvcGljczogMCxcbiAgICAgICAgbWF4VG9waWNJbmRleDogbnVsbFxuICAgICAgfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5zdGF0ZS50b3BpY0NvbnRleHQgPSBvdXRlckNvbnRleHRUb3BpY1N0YXRlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG4gIH1cbiAgd2l0aFNvbG9Bd2FpdFBlcm1pdHRpbmdDb250ZXh0KGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgb3V0ZXJDb250ZXh0U29sb0F3YWl0U3RhdGUgPSB0aGlzLnN0YXRlLnNvbG9Bd2FpdDtcbiAgICB0aGlzLnN0YXRlLnNvbG9Bd2FpdCA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLnN0YXRlLnNvbG9Bd2FpdCA9IG91dGVyQ29udGV4dFNvbG9Bd2FpdFN0YXRlO1xuICAgIH1cbiAgfVxuICBhbGxvd0luQW5kKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZmxhZ3MgPSB0aGlzLnByb2RQYXJhbS5jdXJyZW50RmxhZ3MoKTtcbiAgICBjb25zdCBwcm9kUGFyYW1Ub1NldCA9IDggJiB+ZmxhZ3M7XG4gICAgaWYgKHByb2RQYXJhbVRvU2V0KSB7XG4gICAgICB0aGlzLnByb2RQYXJhbS5lbnRlcihmbGFncyB8IDgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLnByb2RQYXJhbS5leGl0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjYWxsYmFjaygpO1xuICB9XG4gIGRpc2FsbG93SW5BbmQoY2FsbGJhY2spIHtcbiAgICBjb25zdCBmbGFncyA9IHRoaXMucHJvZFBhcmFtLmN1cnJlbnRGbGFncygpO1xuICAgIGNvbnN0IHByb2RQYXJhbVRvQ2xlYXIgPSA4ICYgZmxhZ3M7XG4gICAgaWYgKHByb2RQYXJhbVRvQ2xlYXIpIHtcbiAgICAgIHRoaXMucHJvZFBhcmFtLmVudGVyKGZsYWdzICYgfjgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLnByb2RQYXJhbS5leGl0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjYWxsYmFjaygpO1xuICB9XG4gIHJlZ2lzdGVyVG9waWNSZWZlcmVuY2UoKSB7XG4gICAgdGhpcy5zdGF0ZS50b3BpY0NvbnRleHQubWF4VG9waWNJbmRleCA9IDA7XG4gIH1cbiAgdG9waWNSZWZlcmVuY2VJc0FsbG93ZWRJbkN1cnJlbnRDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnRvcGljQ29udGV4dC5tYXhOdW1PZlJlc29sdmFibGVUb3BpY3MgPj0gMTtcbiAgfVxuICB0b3BpY1JlZmVyZW5jZVdhc1VzZWRJbkN1cnJlbnRDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnRvcGljQ29udGV4dC5tYXhUb3BpY0luZGV4ICE9IG51bGwgJiYgdGhpcy5zdGF0ZS50b3BpY0NvbnRleHQubWF4VG9waWNJbmRleCA+PSAwO1xuICB9XG4gIHBhcnNlRlNoYXJwUGlwZWxpbmVCb2R5KHByZWMpIHtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgdGhpcy5zdGF0ZS5wb3RlbnRpYWxBcnJvd0F0ID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICBjb25zdCBvbGRJbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHk7XG4gICAgdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IHRydWU7XG4gICAgY29uc3QgcmV0ID0gdGhpcy5wYXJzZUV4cHJPcCh0aGlzLnBhcnNlTWF5YmVVbmFyeU9yUHJpdmF0ZSgpLCBzdGFydExvYywgcHJlYyk7XG4gICAgdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IG9sZEluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5O1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgcGFyc2VNb2R1bGVFeHByZXNzaW9uKCkge1xuICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwibW9kdWxlQmxvY2tzXCIpO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICghdGhpcy5tYXRjaCg1KSkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKG51bGwsIDUpO1xuICAgIH1cbiAgICBjb25zdCBwcm9ncmFtID0gdGhpcy5zdGFydE5vZGVBdCh0aGlzLnN0YXRlLmVuZExvYyk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgY29uc3QgcmV2ZXJ0U2NvcGVzID0gdGhpcy5pbml0aWFsaXplU2NvcGVzKHRydWUpO1xuICAgIHRoaXMuZW50ZXJJbml0aWFsU2NvcGVzKCk7XG4gICAgdHJ5IHtcbiAgICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VQcm9ncmFtKHByb2dyYW0sIDgsIFwibW9kdWxlXCIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICByZXZlcnRTY29wZXMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1vZHVsZUV4cHJlc3Npb25cIik7XG4gIH1cbiAgcGFyc2VWb2lkUGF0dGVybihyZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgdGhpcy5leHBlY3RQbHVnaW4oXCJkaXNjYXJkQmluZGluZ1wiKTtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBpZiAocmVmRXhwcmVzc2lvbkVycm9ycyAhPSBudWxsKSB7XG4gICAgICByZWZFeHByZXNzaW9uRXJyb3JzLnZvaWRQYXR0ZXJuTG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlZvaWRQYXR0ZXJuXCIpO1xuICB9XG4gIHBhcnNlTWF5YmVBc3NpZ25BbGxvd0luT3JWb2lkUGF0dGVybihjbG9zZSwgcmVmRXhwcmVzc2lvbkVycm9ycywgYWZ0ZXJMZWZ0UGFyc2UpIHtcbiAgICBpZiAocmVmRXhwcmVzc2lvbkVycm9ycyAhPSBudWxsICYmIHRoaXMubWF0Y2goODgpKSB7XG4gICAgICBjb25zdCBuZXh0Q29kZSA9IHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKTtcbiAgICAgIGlmIChuZXh0Q29kZSA9PT0gNDQgfHwgbmV4dENvZGUgPT09IChjbG9zZSA9PT0gMyA/IDkzIDogY2xvc2UgPT09IDggPyAxMjUgOiA0MSkgfHwgbmV4dENvZGUgPT09IDYxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHRoaXMuc3RhdGUuc3RhcnRMb2MsIHRoaXMucGFyc2VWb2lkUGF0dGVybihyZWZFeHByZXNzaW9uRXJyb3JzKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKHJlZkV4cHJlc3Npb25FcnJvcnMsIGFmdGVyTGVmdFBhcnNlKTtcbiAgfVxuICBwYXJzZVByb3BlcnR5TmFtZVByZWZpeE9wZXJhdG9yKHByb3ApIHt9XG59XG5jb25zdCBsb29wTGFiZWwgPSB7XG4gICAga2luZDogMVxuICB9LFxuICBzd2l0Y2hMYWJlbCA9IHtcbiAgICBraW5kOiAyXG4gIH07XG5jb25zdCBsb25lU3Vycm9nYXRlID0gL1tcXHVEODAwLVxcdURGRkZdL3U7XG5jb25zdCBrZXl3b3JkUmVsYXRpb25hbE9wZXJhdG9yID0gL2luKD86c3RhbmNlb2YpPy95O1xuZnVuY3Rpb24gYmFiZWw3Q29tcGF0VG9rZW5zKHRva2VucywgaW5wdXQsIHN0YXJ0SW5kZXgpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlXG4gICAgfSA9IHRva2VuO1xuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAge1xuICAgICAgICBpZiAodHlwZSA9PT0gMTM5KSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgbG9jLFxuICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIH0gPSB0b2tlbjtcbiAgICAgICAgICBjb25zdCBoYXNoRW5kUG9zID0gc3RhcnQgKyAxO1xuICAgICAgICAgIGNvbnN0IGhhc2hFbmRMb2MgPSBjcmVhdGVQb3NpdGlvbldpdGhDb2x1bW5PZmZzZXQobG9jLnN0YXJ0LCAxKTtcbiAgICAgICAgICB0b2tlbnMuc3BsaWNlKGksIDEsIG5ldyBUb2tlbih7XG4gICAgICAgICAgICB0eXBlOiBnZXRFeHBvcnRlZFRva2VuKDI3KSxcbiAgICAgICAgICAgIHZhbHVlOiBcIiNcIixcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogaGFzaEVuZFBvcyxcbiAgICAgICAgICAgIHN0YXJ0TG9jOiBsb2Muc3RhcnQsXG4gICAgICAgICAgICBlbmRMb2M6IGhhc2hFbmRMb2NcbiAgICAgICAgICB9KSwgbmV3IFRva2VuKHtcbiAgICAgICAgICAgIHR5cGU6IGdldEV4cG9ydGVkVG9rZW4oMTMyKSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHN0YXJ0OiBoYXNoRW5kUG9zLFxuICAgICAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgICAgICBzdGFydExvYzogaGFzaEVuZExvYyxcbiAgICAgICAgICAgIGVuZExvYzogbG9jLmVuZFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBpKys7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuSXNUZW1wbGF0ZSh0eXBlKSkge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGxvYyxcbiAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICB9ID0gdG9rZW47XG4gICAgICAgICAgY29uc3QgYmFja3F1b3RlRW5kID0gc3RhcnQgKyAxO1xuICAgICAgICAgIGNvbnN0IGJhY2txdW90ZUVuZExvYyA9IGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldChsb2Muc3RhcnQsIDEpO1xuICAgICAgICAgIGxldCBzdGFydFRva2VuO1xuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHN0YXJ0IC0gc3RhcnRJbmRleCkgPT09IDk2KSB7XG4gICAgICAgICAgICBzdGFydFRva2VuID0gbmV3IFRva2VuKHtcbiAgICAgICAgICAgICAgdHlwZTogZ2V0RXhwb3J0ZWRUb2tlbigyMiksXG4gICAgICAgICAgICAgIHZhbHVlOiBcImBcIixcbiAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICBlbmQ6IGJhY2txdW90ZUVuZCxcbiAgICAgICAgICAgICAgc3RhcnRMb2M6IGxvYy5zdGFydCxcbiAgICAgICAgICAgICAgZW5kTG9jOiBiYWNrcXVvdGVFbmRMb2NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFydFRva2VuID0gbmV3IFRva2VuKHtcbiAgICAgICAgICAgICAgdHlwZTogZ2V0RXhwb3J0ZWRUb2tlbig4KSxcbiAgICAgICAgICAgICAgdmFsdWU6IFwifVwiLFxuICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogYmFja3F1b3RlRW5kLFxuICAgICAgICAgICAgICBzdGFydExvYzogbG9jLnN0YXJ0LFxuICAgICAgICAgICAgICBlbmRMb2M6IGJhY2txdW90ZUVuZExvY1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCB0ZW1wbGF0ZVZhbHVlLCB0ZW1wbGF0ZUVsZW1lbnRFbmQsIHRlbXBsYXRlRWxlbWVudEVuZExvYywgZW5kVG9rZW47XG4gICAgICAgICAgaWYgKHR5cGUgPT09IDI0KSB7XG4gICAgICAgICAgICB0ZW1wbGF0ZUVsZW1lbnRFbmQgPSBlbmQgLSAxO1xuICAgICAgICAgICAgdGVtcGxhdGVFbGVtZW50RW5kTG9jID0gY3JlYXRlUG9zaXRpb25XaXRoQ29sdW1uT2Zmc2V0KGxvYy5lbmQsIC0xKTtcbiAgICAgICAgICAgIHRlbXBsYXRlVmFsdWUgPSB2YWx1ZSA9PT0gbnVsbCA/IG51bGwgOiB2YWx1ZS5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICBlbmRUb2tlbiA9IG5ldyBUb2tlbih7XG4gICAgICAgICAgICAgIHR5cGU6IGdldEV4cG9ydGVkVG9rZW4oMjIpLFxuICAgICAgICAgICAgICB2YWx1ZTogXCJgXCIsXG4gICAgICAgICAgICAgIHN0YXJ0OiB0ZW1wbGF0ZUVsZW1lbnRFbmQsXG4gICAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgICBzdGFydExvYzogdGVtcGxhdGVFbGVtZW50RW5kTG9jLFxuICAgICAgICAgICAgICBlbmRMb2M6IGxvYy5lbmRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZW1wbGF0ZUVsZW1lbnRFbmQgPSBlbmQgLSAyO1xuICAgICAgICAgICAgdGVtcGxhdGVFbGVtZW50RW5kTG9jID0gY3JlYXRlUG9zaXRpb25XaXRoQ29sdW1uT2Zmc2V0KGxvYy5lbmQsIC0yKTtcbiAgICAgICAgICAgIHRlbXBsYXRlVmFsdWUgPSB2YWx1ZSA9PT0gbnVsbCA/IG51bGwgOiB2YWx1ZS5zbGljZSgxLCAtMik7XG4gICAgICAgICAgICBlbmRUb2tlbiA9IG5ldyBUb2tlbih7XG4gICAgICAgICAgICAgIHR5cGU6IGdldEV4cG9ydGVkVG9rZW4oMjMpLFxuICAgICAgICAgICAgICB2YWx1ZTogXCIke1wiLFxuICAgICAgICAgICAgICBzdGFydDogdGVtcGxhdGVFbGVtZW50RW5kLFxuICAgICAgICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgICAgICAgc3RhcnRMb2M6IHRlbXBsYXRlRWxlbWVudEVuZExvYyxcbiAgICAgICAgICAgICAgZW5kTG9jOiBsb2MuZW5kXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdG9rZW5zLnNwbGljZShpLCAxLCBzdGFydFRva2VuLCBuZXcgVG9rZW4oe1xuICAgICAgICAgICAgdHlwZTogZ2V0RXhwb3J0ZWRUb2tlbigyMCksXG4gICAgICAgICAgICB2YWx1ZTogdGVtcGxhdGVWYWx1ZSxcbiAgICAgICAgICAgIHN0YXJ0OiBiYWNrcXVvdGVFbmQsXG4gICAgICAgICAgICBlbmQ6IHRlbXBsYXRlRWxlbWVudEVuZCxcbiAgICAgICAgICAgIHN0YXJ0TG9jOiBiYWNrcXVvdGVFbmRMb2MsXG4gICAgICAgICAgICBlbmRMb2M6IHRlbXBsYXRlRWxlbWVudEVuZExvY1xuICAgICAgICAgIH0pLCBlbmRUb2tlbik7XG4gICAgICAgICAgaSArPSAyO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0b2tlbi50eXBlID0gZ2V0RXhwb3J0ZWRUb2tlbih0eXBlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRva2Vucztcbn1cbmNsYXNzIFN0YXRlbWVudFBhcnNlciBleHRlbmRzIEV4cHJlc3Npb25QYXJzZXIge1xuICBwYXJzZVRvcExldmVsKGZpbGUsIHByb2dyYW0pIHtcbiAgICBmaWxlLnByb2dyYW0gPSB0aGlzLnBhcnNlUHJvZ3JhbShwcm9ncmFtLCAxNDAsIHRoaXMub3B0aW9ucy5zb3VyY2VUeXBlID09PSBcIm1vZHVsZVwiID8gXCJtb2R1bGVcIiA6IFwic2NyaXB0XCIpO1xuICAgIGZpbGUuY29tbWVudHMgPSB0aGlzLmNvbW1lbnRzO1xuICAgIGlmICh0aGlzLm9wdGlvbkZsYWdzICYgMjU2KSB7XG4gICAgICBmaWxlLnRva2VucyA9IGJhYmVsN0NvbXBhdFRva2Vucyh0aGlzLnRva2VucywgdGhpcy5pbnB1dCwgdGhpcy5zdGFydEluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShmaWxlLCBcIkZpbGVcIik7XG4gIH1cbiAgcGFyc2VQcm9ncmFtKHByb2dyYW0sIGVuZCwgc291cmNlVHlwZSkge1xuICAgIHByb2dyYW0uc291cmNlVHlwZSA9IHNvdXJjZVR5cGU7XG4gICAgcHJvZ3JhbS5pbnRlcnByZXRlciA9IHRoaXMucGFyc2VJbnRlcnByZXRlckRpcmVjdGl2ZSgpO1xuICAgIHRoaXMucGFyc2VCbG9ja0JvZHkocHJvZ3JhbSwgdHJ1ZSwgdHJ1ZSwgZW5kKTtcbiAgICBpZiAodGhpcy5pbk1vZHVsZSkge1xuICAgICAgaWYgKCEodGhpcy5vcHRpb25GbGFncyAmIDY0KSAmJiB0aGlzLnNjb3BlLnVuZGVmaW5lZEV4cG9ydHMuc2l6ZSA+IDApIHtcbiAgICAgICAgZm9yIChjb25zdCBbbG9jYWxOYW1lLCBhdF0gb2YgQXJyYXkuZnJvbSh0aGlzLnNjb3BlLnVuZGVmaW5lZEV4cG9ydHMpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuTW9kdWxlRXhwb3J0VW5kZWZpbmVkLCBhdCwge1xuICAgICAgICAgICAgbG9jYWxOYW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYWRkRXh0cmEocHJvZ3JhbSwgXCJ0b3BMZXZlbEF3YWl0XCIsIHRoaXMuc3RhdGUuaGFzVG9wTGV2ZWxBd2FpdCk7XG4gICAgfVxuICAgIGxldCBmaW5pc2hlZFByb2dyYW07XG4gICAgaWYgKGVuZCA9PT0gMTQwKSB7XG4gICAgICBmaW5pc2hlZFByb2dyYW0gPSB0aGlzLmZpbmlzaE5vZGUocHJvZ3JhbSwgXCJQcm9ncmFtXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaW5pc2hlZFByb2dyYW0gPSB0aGlzLmZpbmlzaE5vZGVBdChwcm9ncmFtLCBcIlByb2dyYW1cIiwgY3JlYXRlUG9zaXRpb25XaXRoQ29sdW1uT2Zmc2V0KHRoaXMuc3RhdGUuc3RhcnRMb2MsIC0xKSk7XG4gICAgfVxuICAgIHJldHVybiBmaW5pc2hlZFByb2dyYW07XG4gIH1cbiAgc3RtdFRvRGlyZWN0aXZlKHN0bXQpIHtcbiAgICBjb25zdCBkaXJlY3RpdmUgPSB0aGlzLmNhc3ROb2RlVG8oc3RtdCwgXCJEaXJlY3RpdmVcIik7XG4gICAgY29uc3QgZGlyZWN0aXZlTGl0ZXJhbCA9IHRoaXMuY2FzdE5vZGVUbyhzdG10LmV4cHJlc3Npb24sIFwiRGlyZWN0aXZlTGl0ZXJhbFwiKTtcbiAgICBjb25zdCBleHByZXNzaW9uVmFsdWUgPSBkaXJlY3RpdmVMaXRlcmFsLnZhbHVlO1xuICAgIGNvbnN0IHJhdyA9IHRoaXMuaW5wdXQuc2xpY2UodGhpcy5vZmZzZXRUb1NvdXJjZVBvcyhkaXJlY3RpdmVMaXRlcmFsLnN0YXJ0KSwgdGhpcy5vZmZzZXRUb1NvdXJjZVBvcyhkaXJlY3RpdmVMaXRlcmFsLmVuZCkpO1xuICAgIGNvbnN0IHZhbCA9IGRpcmVjdGl2ZUxpdGVyYWwudmFsdWUgPSByYXcuc2xpY2UoMSwgLTEpO1xuICAgIHRoaXMuYWRkRXh0cmEoZGlyZWN0aXZlTGl0ZXJhbCwgXCJyYXdcIiwgcmF3KTtcbiAgICB0aGlzLmFkZEV4dHJhKGRpcmVjdGl2ZUxpdGVyYWwsIFwicmF3VmFsdWVcIiwgdmFsKTtcbiAgICB0aGlzLmFkZEV4dHJhKGRpcmVjdGl2ZUxpdGVyYWwsIFwiZXhwcmVzc2lvblZhbHVlXCIsIGV4cHJlc3Npb25WYWx1ZSk7XG4gICAgZGlyZWN0aXZlLnZhbHVlID0gZGlyZWN0aXZlTGl0ZXJhbDtcbiAgICBkZWxldGUgc3RtdC5leHByZXNzaW9uO1xuICAgIHJldHVybiBkaXJlY3RpdmU7XG4gIH1cbiAgcGFyc2VJbnRlcnByZXRlckRpcmVjdGl2ZSgpIHtcbiAgICBpZiAoIXRoaXMubWF0Y2goMjgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS52YWx1ZSA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkludGVycHJldGVyRGlyZWN0aXZlXCIpO1xuICB9XG4gIGlzTGV0KCkge1xuICAgIGlmICghdGhpcy5pc0NvbnRleHR1YWwoMTAwKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5oYXNGb2xsb3dpbmdCaW5kaW5nQXRvbSgpO1xuICB9XG4gIGlzVXNpbmcoKSB7XG4gICAgaWYgKCF0aGlzLmlzQ29udGV4dHVhbCgxMDcpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG5leHQgPSB0aGlzLm5leHRUb2tlbkluTGluZVN0YXJ0KCk7XG4gICAgY29uc3QgbmV4dENoID0gdGhpcy5jb2RlUG9pbnRBdFBvcyhuZXh0KTtcbiAgICByZXR1cm4gdGhpcy5jaFN0YXJ0c0JpbmRpbmdJZGVudGlmaWVyKG5leHRDaCwgbmV4dCk7XG4gIH1cbiAgaXNGb3JVc2luZygpIHtcbiAgICBpZiAoIXRoaXMuaXNDb250ZXh0dWFsKDEwNykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbmV4dCA9IHRoaXMubmV4dFRva2VuSW5MaW5lU3RhcnQoKTtcbiAgICBjb25zdCBuZXh0Q2ggPSB0aGlzLmNvZGVQb2ludEF0UG9zKG5leHQpO1xuICAgIGlmICh0aGlzLmlzVW5wYXJzZWRDb250ZXh0dWFsKG5leHQsIFwib2ZcIikpIHtcbiAgICAgIGNvbnN0IG5leHRDaGFyQWZ0ZXJPZiA9IHRoaXMubG9va2FoZWFkQ2hhckNvZGVTaW5jZShuZXh0ICsgMik7XG4gICAgICBpZiAobmV4dENoYXJBZnRlck9mICE9PSA2MSAmJiBuZXh0Q2hhckFmdGVyT2YgIT09IDU4ICYmIG5leHRDaGFyQWZ0ZXJPZiAhPT0gNTkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5jaFN0YXJ0c0JpbmRpbmdJZGVudGlmaWVyKG5leHRDaCwgbmV4dCkgfHwgdGhpcy5pc1VucGFyc2VkQ29udGV4dHVhbChuZXh0LCBcInZvaWRcIikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaXNBd2FpdFVzaW5nKCkge1xuICAgIGlmICghdGhpcy5pc0NvbnRleHR1YWwoOTYpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBuZXh0ID0gdGhpcy5uZXh0VG9rZW5JbkxpbmVTdGFydCgpO1xuICAgIGlmICh0aGlzLmlzVW5wYXJzZWRDb250ZXh0dWFsKG5leHQsIFwidXNpbmdcIikpIHtcbiAgICAgIG5leHQgPSB0aGlzLm5leHRUb2tlbkluTGluZVN0YXJ0U2luY2UobmV4dCArIDUpO1xuICAgICAgY29uc3QgbmV4dENoID0gdGhpcy5jb2RlUG9pbnRBdFBvcyhuZXh0KTtcbiAgICAgIGlmICh0aGlzLmNoU3RhcnRzQmluZGluZ0lkZW50aWZpZXIobmV4dENoLCBuZXh0KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNoU3RhcnRzQmluZGluZ0lkZW50aWZpZXIoY2gsIHBvcykge1xuICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChjaCkpIHtcbiAgICAgIGtleXdvcmRSZWxhdGlvbmFsT3BlcmF0b3IubGFzdEluZGV4ID0gcG9zO1xuICAgICAgaWYgKGtleXdvcmRSZWxhdGlvbmFsT3BlcmF0b3IudGVzdCh0aGlzLmlucHV0KSkge1xuICAgICAgICBjb25zdCBlbmRDaCA9IHRoaXMuY29kZVBvaW50QXRQb3Moa2V5d29yZFJlbGF0aW9uYWxPcGVyYXRvci5sYXN0SW5kZXgpO1xuICAgICAgICBpZiAoIWlzSWRlbnRpZmllckNoYXIoZW5kQ2gpICYmIGVuZENoICE9PSA5Mikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gOTIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGNoU3RhcnRzQmluZGluZ1BhdHRlcm4oY2gpIHtcbiAgICByZXR1cm4gY2ggPT09IDkxIHx8IGNoID09PSAxMjM7XG4gIH1cbiAgaGFzRm9sbG93aW5nQmluZGluZ0F0b20oKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMubmV4dFRva2VuU3RhcnQoKTtcbiAgICBjb25zdCBuZXh0Q2ggPSB0aGlzLmNvZGVQb2ludEF0UG9zKG5leHQpO1xuICAgIHJldHVybiB0aGlzLmNoU3RhcnRzQmluZGluZ1BhdHRlcm4obmV4dENoKSB8fCB0aGlzLmNoU3RhcnRzQmluZGluZ0lkZW50aWZpZXIobmV4dENoLCBuZXh0KTtcbiAgfVxuICBoYXNJbkxpbmVGb2xsb3dpbmdCaW5kaW5nSWRlbnRpZmllck9yQnJhY2UoKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMubmV4dFRva2VuSW5MaW5lU3RhcnQoKTtcbiAgICBjb25zdCBuZXh0Q2ggPSB0aGlzLmNvZGVQb2ludEF0UG9zKG5leHQpO1xuICAgIHJldHVybiBuZXh0Q2ggPT09IDEyMyB8fCB0aGlzLmNoU3RhcnRzQmluZGluZ0lkZW50aWZpZXIobmV4dENoLCBuZXh0KTtcbiAgfVxuICBhbGxvd3NVc2luZygpIHtcbiAgICByZXR1cm4gKHRoaXMuc2NvcGUuaW5Nb2R1bGUgfHwgIXRoaXMuc2NvcGUuaW5Ub3BMZXZlbCkgJiYgIXRoaXMuc2NvcGUuaW5CYXJlQ2FzZVN0YXRlbWVudDtcbiAgfVxuICBwYXJzZU1vZHVsZUl0ZW0oKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VTdGF0ZW1lbnRMaWtlKDEgfCAyIHwgNCB8IDgpO1xuICB9XG4gIHBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VTdGF0ZW1lbnRMaWtlKDIgfCA0IHwgKCF0aGlzLm9wdGlvbnMuYW5uZXhCIHx8IHRoaXMuc3RhdGUuc3RyaWN0ID8gMCA6IDgpKTtcbiAgfVxuICBwYXJzZVN0YXRlbWVudE9yU2xvcHB5QW5uZXhCRnVuY3Rpb25EZWNsYXJhdGlvbihhbGxvd0xhYmVsZWRGdW5jdGlvbiA9IGZhbHNlKSB7XG4gICAgbGV0IGZsYWdzID0gMDtcbiAgICBpZiAodGhpcy5vcHRpb25zLmFubmV4QiAmJiAhdGhpcy5zdGF0ZS5zdHJpY3QpIHtcbiAgICAgIGZsYWdzIHw9IDQ7XG4gICAgICBpZiAoYWxsb3dMYWJlbGVkRnVuY3Rpb24pIHtcbiAgICAgICAgZmxhZ3MgfD0gODtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VTdGF0ZW1lbnRMaWtlKGZsYWdzKTtcbiAgfVxuICBwYXJzZVN0YXRlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVN0YXRlbWVudExpa2UoMCk7XG4gIH1cbiAgcGFyc2VTdGF0ZW1lbnRMaWtlKGZsYWdzKSB7XG4gICAgbGV0IGRlY29yYXRvcnMgPSBudWxsO1xuICAgIGlmICh0aGlzLm1hdGNoKDI2KSkge1xuICAgICAgZGVjb3JhdG9ycyA9IHRoaXMucGFyc2VEZWNvcmF0b3JzKHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZVN0YXRlbWVudENvbnRlbnQoZmxhZ3MsIGRlY29yYXRvcnMpO1xuICB9XG4gIHBhcnNlU3RhdGVtZW50Q29udGVudChmbGFncywgZGVjb3JhdG9ycykge1xuICAgIGNvbnN0IHN0YXJ0VHlwZSA9IHRoaXMuc3RhdGUudHlwZTtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCBhbGxvd0RlY2xhcmF0aW9uID0gISEoZmxhZ3MgJiAyKTtcbiAgICBjb25zdCBhbGxvd0Z1bmN0aW9uRGVjbGFyYXRpb24gPSAhIShmbGFncyAmIDQpO1xuICAgIGNvbnN0IHRvcExldmVsID0gZmxhZ3MgJiAxO1xuICAgIHN3aXRjaCAoc3RhcnRUeXBlKSB7XG4gICAgICBjYXNlIDYwOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJyZWFrQ29udGludWVTdGF0ZW1lbnQobm9kZSwgdHJ1ZSk7XG4gICAgICBjYXNlIDYzOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJyZWFrQ29udGludWVTdGF0ZW1lbnQobm9kZSwgZmFsc2UpO1xuICAgICAgY2FzZSA2NDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VEZWJ1Z2dlclN0YXRlbWVudChub2RlKTtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRG9XaGlsZVN0YXRlbWVudChub2RlKTtcbiAgICAgIGNhc2UgOTE6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9yU3RhdGVtZW50KG5vZGUpO1xuICAgICAgY2FzZSA2ODpcbiAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKSA9PT0gNDYpIGJyZWFrO1xuICAgICAgICBpZiAoIWFsbG93RnVuY3Rpb25EZWNsYXJhdGlvbikge1xuICAgICAgICAgIHRoaXMucmFpc2UodGhpcy5zdGF0ZS5zdHJpY3QgPyBFcnJvcnMuU3RyaWN0RnVuY3Rpb24gOiB0aGlzLm9wdGlvbnMuYW5uZXhCID8gRXJyb3JzLlNsb3BweUZ1bmN0aW9uQW5uZXhCIDogRXJyb3JzLlNsb3BweUZ1bmN0aW9uLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uU3RhdGVtZW50KG5vZGUsIGZhbHNlLCAhYWxsb3dEZWNsYXJhdGlvbiAmJiBhbGxvd0Z1bmN0aW9uRGVjbGFyYXRpb24pO1xuICAgICAgY2FzZSA4MDpcbiAgICAgICAgaWYgKCFhbGxvd0RlY2xhcmF0aW9uKSB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzcyh0aGlzLm1heWJlVGFrZURlY29yYXRvcnMoZGVjb3JhdG9ycywgbm9kZSksIHRydWUpO1xuICAgICAgY2FzZSA2OTpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VJZlN0YXRlbWVudChub2RlKTtcbiAgICAgIGNhc2UgNzA6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlUmV0dXJuU3RhdGVtZW50KG5vZGUpO1xuICAgICAgY2FzZSA3MTpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTd2l0Y2hTdGF0ZW1lbnQobm9kZSk7XG4gICAgICBjYXNlIDcyOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRocm93U3RhdGVtZW50KG5vZGUpO1xuICAgICAgY2FzZSA3MzpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcnlTdGF0ZW1lbnQobm9kZSk7XG4gICAgICBjYXNlIDk2OlxuICAgICAgICBpZiAodGhpcy5pc0F3YWl0VXNpbmcoKSkge1xuICAgICAgICAgIGlmICghdGhpcy5hbGxvd3NVc2luZygpKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkVXNpbmdEZWNsYXJhdGlvbiwgbm9kZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICghYWxsb3dEZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZExleGljYWxEZWNsYXJhdGlvbiwgbm9kZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5yZWNvcmRBd2FpdElmQWxsb3dlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Bd2FpdFVzaW5nTm90SW5Bc3luY0NvbnRleHQsIG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVZhclN0YXRlbWVudChub2RlLCBcImF3YWl0IHVzaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMDc6XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmNvbnRhaW5zRXNjIHx8ICF0aGlzLmhhc0luTGluZUZvbGxvd2luZ0JpbmRpbmdJZGVudGlmaWVyT3JCcmFjZSgpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmFsbG93c1VzaW5nKCkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkVXNpbmdEZWNsYXJhdGlvbiwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWFsbG93RGVjbGFyYXRpb24pIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkTGV4aWNhbERlY2xhcmF0aW9uLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVZhclN0YXRlbWVudChub2RlLCBcInVzaW5nXCIpO1xuICAgICAgY2FzZSAxMDA6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5jb250YWluc0VzYykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLm5leHRUb2tlblN0YXJ0KCk7XG4gICAgICAgICAgY29uc3QgbmV4dENoID0gdGhpcy5jb2RlUG9pbnRBdFBvcyhuZXh0KTtcbiAgICAgICAgICBpZiAobmV4dENoICE9PSA5MSkge1xuICAgICAgICAgICAgaWYgKCFhbGxvd0RlY2xhcmF0aW9uICYmIHRoaXMuaGFzRm9sbG93aW5nTGluZUJyZWFrKCkpIGJyZWFrO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNoU3RhcnRzQmluZGluZ0lkZW50aWZpZXIobmV4dENoLCBuZXh0KSAmJiBuZXh0Q2ggIT09IDEyMykge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGNhc2UgNzU6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoIWFsbG93RGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWRMZXhpY2FsRGVjbGFyYXRpb24sIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgY2FzZSA3NDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGtpbmQgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVmFyU3RhdGVtZW50KG5vZGUsIGtpbmQpO1xuICAgICAgICB9XG4gICAgICBjYXNlIDkyOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVdoaWxlU3RhdGVtZW50KG5vZGUpO1xuICAgICAgY2FzZSA3NjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VXaXRoU3RhdGVtZW50KG5vZGUpO1xuICAgICAgY2FzZSA1OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJsb2NrKCk7XG4gICAgICBjYXNlIDEzOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUVtcHR5U3RhdGVtZW50KG5vZGUpO1xuICAgICAgY2FzZSA4MzpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IG5leHRUb2tlbkNoYXJDb2RlID0gdGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpO1xuICAgICAgICAgIGlmIChuZXh0VG9rZW5DaGFyQ29kZSA9PT0gNDAgfHwgbmV4dFRva2VuQ2hhckNvZGUgPT09IDQ2KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGNhc2UgODI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoISh0aGlzLm9wdGlvbkZsYWdzICYgOCkgJiYgIXRvcExldmVsKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkSW1wb3J0RXhwb3J0LCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICBpZiAoc3RhcnRUeXBlID09PSA4Mykge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZUltcG9ydChub2RlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZUV4cG9ydChub2RlLCBkZWNvcmF0b3JzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5hc3NlcnRNb2R1bGVOb2RlQWxsb3dlZChyZXN1bHQpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAodGhpcy5pc0FzeW5jRnVuY3Rpb24oKSkge1xuICAgICAgICAgICAgaWYgKCFhbGxvd0RlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkFzeW5jRnVuY3Rpb25JblNpbmdsZVN0YXRlbWVudENvbnRleHQsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uU3RhdGVtZW50KG5vZGUsIHRydWUsICFhbGxvd0RlY2xhcmF0aW9uICYmIGFsbG93RnVuY3Rpb25EZWNsYXJhdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1heWJlTmFtZSA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgY29uc3QgZXhwciA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgaWYgKHRva2VuSXNJZGVudGlmaWVyKHN0YXJ0VHlwZSkgJiYgZXhwci50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiB0aGlzLmVhdCgxNCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlTGFiZWxlZFN0YXRlbWVudChub2RlLCBtYXliZU5hbWUsIGV4cHIsIGZsYWdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIsIGRlY29yYXRvcnMpO1xuICAgIH1cbiAgfVxuICBhc3NlcnRNb2R1bGVOb2RlQWxsb3dlZChub2RlKSB7XG4gICAgaWYgKCEodGhpcy5vcHRpb25GbGFncyAmIDgpICYmICF0aGlzLmluTW9kdWxlKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbXBvcnRPdXRzaWRlTW9kdWxlLCBub2RlKTtcbiAgICB9XG4gIH1cbiAgZGVjb3JhdG9yc0VuYWJsZWRCZWZvcmVFeHBvcnQoKSB7XG4gICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwiZGVjb3JhdG9ycy1sZWdhY3lcIikpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiB0aGlzLmhhc1BsdWdpbihcImRlY29yYXRvcnNcIikgJiYgdGhpcy5nZXRQbHVnaW5PcHRpb24oXCJkZWNvcmF0b3JzXCIsIFwiZGVjb3JhdG9yc0JlZm9yZUV4cG9ydFwiKSAhPT0gZmFsc2U7XG4gIH1cbiAgbWF5YmVUYWtlRGVjb3JhdG9ycyhtYXliZURlY29yYXRvcnMsIGNsYXNzTm9kZSwgZXhwb3J0Tm9kZSkge1xuICAgIGlmIChtYXliZURlY29yYXRvcnMpIHtcbiAgICAgIHZhciBfY2xhc3NOb2RlJGRlY29yYXRvcnM7XG4gICAgICBpZiAoKF9jbGFzc05vZGUkZGVjb3JhdG9ycyA9IGNsYXNzTm9kZS5kZWNvcmF0b3JzKSAhPSBudWxsICYmIF9jbGFzc05vZGUkZGVjb3JhdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmdldFBsdWdpbk9wdGlvbihcImRlY29yYXRvcnNcIiwgXCJkZWNvcmF0b3JzQmVmb3JlRXhwb3J0XCIpICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkRlY29yYXRvcnNCZWZvcmVBZnRlckV4cG9ydCwgY2xhc3NOb2RlLmRlY29yYXRvcnNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGNsYXNzTm9kZS5kZWNvcmF0b3JzLnVuc2hpZnQoLi4ubWF5YmVEZWNvcmF0b3JzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsYXNzTm9kZS5kZWNvcmF0b3JzID0gbWF5YmVEZWNvcmF0b3JzO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXNldFN0YXJ0TG9jYXRpb25Gcm9tTm9kZShjbGFzc05vZGUsIG1heWJlRGVjb3JhdG9yc1swXSk7XG4gICAgICBpZiAoZXhwb3J0Tm9kZSkgdGhpcy5yZXNldFN0YXJ0TG9jYXRpb25Gcm9tTm9kZShleHBvcnROb2RlLCBjbGFzc05vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOb2RlO1xuICB9XG4gIGNhbkhhdmVMZWFkaW5nRGVjb3JhdG9yKCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKDgwKTtcbiAgfVxuICBwYXJzZURlY29yYXRvcnMoYWxsb3dFeHBvcnQpIHtcbiAgICBjb25zdCBkZWNvcmF0b3JzID0gW107XG4gICAgZG8ge1xuICAgICAgZGVjb3JhdG9ycy5wdXNoKHRoaXMucGFyc2VEZWNvcmF0b3IoKSk7XG4gICAgfSB3aGlsZSAodGhpcy5tYXRjaCgyNikpO1xuICAgIGlmICh0aGlzLm1hdGNoKDgyKSkge1xuICAgICAgaWYgKCFhbGxvd0V4cG9ydCkge1xuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5kZWNvcmF0b3JzRW5hYmxlZEJlZm9yZUV4cG9ydCgpKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkRlY29yYXRvckV4cG9ydENsYXNzLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCF0aGlzLmNhbkhhdmVMZWFkaW5nRGVjb3JhdG9yKCkpIHtcbiAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWRMZWFkaW5nRGVjb3JhdG9yLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29yYXRvcnM7XG4gIH1cbiAgcGFyc2VEZWNvcmF0b3IoKSB7XG4gICAgdGhpcy5leHBlY3RPbmVQbHVnaW4oW1wiZGVjb3JhdG9yc1wiLCBcImRlY29yYXRvcnMtbGVnYWN5XCJdKTtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJkZWNvcmF0b3JzXCIpKSB7XG4gICAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgICBsZXQgZXhwcjtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDEwKSkge1xuICAgICAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBleHByID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgdGhpcy5leHBlY3QoMTEpO1xuICAgICAgICBleHByID0gdGhpcy53cmFwUGFyZW50aGVzaXMoc3RhcnRMb2MsIGV4cHIpO1xuICAgICAgICBjb25zdCBwYXJhbXNTdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VNYXliZURlY29yYXRvckFyZ3VtZW50cyhleHByLCBzdGFydExvYyk7XG4gICAgICAgIGlmICh0aGlzLmdldFBsdWdpbk9wdGlvbihcImRlY29yYXRvcnNcIiwgXCJhbGxvd0NhbGxQYXJlbnRoZXNpemVkXCIpID09PSBmYWxzZSAmJiBub2RlLmV4cHJlc3Npb24gIT09IGV4cHIpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5EZWNvcmF0b3JBcmd1bWVudHNPdXRzaWRlUGFyZW50aGVzZXMsIHBhcmFtc1N0YXJ0TG9jKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhwciA9IHRoaXMucGFyc2VJZGVudGlmaWVyKGZhbHNlKTtcbiAgICAgICAgd2hpbGUgKHRoaXMuZWF0KDE2KSkge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgICAgICBub2RlLm9iamVjdCA9IGV4cHI7XG4gICAgICAgICAgaWYgKHRoaXMubWF0Y2goMTM5KSkge1xuICAgICAgICAgICAgdGhpcy5jbGFzc1Njb3BlLnVzZVByaXZhdGVOYW1lKHRoaXMuc3RhdGUudmFsdWUsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgICAgICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VQcml2YXRlTmFtZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlLnByb3BlcnR5ID0gdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICAgICAgICBleHByID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTWVtYmVyRXhwcmVzc2lvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLmV4cHJlc3Npb24gPSB0aGlzLnBhcnNlTWF5YmVEZWNvcmF0b3JBcmd1bWVudHMoZXhwciwgc3RhcnRMb2MpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmV4cHJlc3Npb24gPSB0aGlzLnBhcnNlRXhwclN1YnNjcmlwdHMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlY29yYXRvclwiKTtcbiAgfVxuICBwYXJzZU1heWJlRGVjb3JhdG9yQXJndW1lbnRzKGV4cHIsIHN0YXJ0TG9jKSB7XG4gICAgaWYgKHRoaXMuZWF0KDEwKSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgbm9kZS5jYWxsZWUgPSBleHByO1xuICAgICAgbm9kZS5hcmd1bWVudHMgPSB0aGlzLnBhcnNlQ2FsbEV4cHJlc3Npb25Bcmd1bWVudHMoKTtcbiAgICAgIHRoaXMudG9SZWZlcmVuY2VkTGlzdChub2RlLmFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQ2FsbEV4cHJlc3Npb25cIik7XG4gICAgfVxuICAgIHJldHVybiBleHByO1xuICB9XG4gIHBhcnNlQnJlYWtDb250aW51ZVN0YXRlbWVudChub2RlLCBpc0JyZWFrKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMuaXNMaW5lVGVybWluYXRvcigpKSB7XG4gICAgICBub2RlLmxhYmVsID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5sYWJlbCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIH1cbiAgICB0aGlzLnZlcmlmeUJyZWFrQ29udGludWUobm9kZSwgaXNCcmVhayk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc0JyZWFrID8gXCJCcmVha1N0YXRlbWVudFwiIDogXCJDb250aW51ZVN0YXRlbWVudFwiKTtcbiAgfVxuICB2ZXJpZnlCcmVha0NvbnRpbnVlKG5vZGUsIGlzQnJlYWspIHtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zdGF0ZS5sYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGxhYiA9IHRoaXMuc3RhdGUubGFiZWxzW2ldO1xuICAgICAgaWYgKG5vZGUubGFiZWwgPT0gbnVsbCB8fCBsYWIubmFtZSA9PT0gbm9kZS5sYWJlbC5uYW1lKSB7XG4gICAgICAgIGlmIChsYWIua2luZCAhPSBudWxsICYmIChpc0JyZWFrIHx8IGxhYi5raW5kID09PSAxKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLmxhYmVsICYmIGlzQnJlYWspIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaSA9PT0gdGhpcy5zdGF0ZS5sYWJlbHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCB0eXBlID0gaXNCcmVhayA/IFwiQnJlYWtTdGF0ZW1lbnRcIiA6IFwiQ29udGludWVTdGF0ZW1lbnRcIjtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLklsbGVnYWxCcmVha0NvbnRpbnVlLCBub2RlLCB7XG4gICAgICAgIHR5cGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBwYXJzZURlYnVnZ2VyU3RhdGVtZW50KG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWJ1Z2dlclN0YXRlbWVudFwiKTtcbiAgfVxuICBwYXJzZUhlYWRlckV4cHJlc3Npb24oKSB7XG4gICAgdGhpcy5leHBlY3QoMTApO1xuICAgIGNvbnN0IHZhbCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5leHBlY3QoMTEpO1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgcGFyc2VEb1doaWxlU3RhdGVtZW50KG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLnN0YXRlLmxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy53aXRoU21hcnRNaXhUb3BpY0ZvcmJpZGRpbmdDb250ZXh0KCgpID0+IHRoaXMucGFyc2VTdGF0ZW1lbnQoKSk7XG4gICAgdGhpcy5zdGF0ZS5sYWJlbHMucG9wKCk7XG4gICAgdGhpcy5leHBlY3QoOTIpO1xuICAgIG5vZGUudGVzdCA9IHRoaXMucGFyc2VIZWFkZXJFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5lYXQoMTMpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEb1doaWxlU3RhdGVtZW50XCIpO1xuICB9XG4gIHBhcnNlRm9yU3RhdGVtZW50KG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLnN0YXRlLmxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG4gICAgbGV0IGF3YWl0QXQgPSBudWxsO1xuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCg5NikgJiYgdGhpcy5yZWNvcmRBd2FpdElmQWxsb3dlZCgpKSB7XG4gICAgICBhd2FpdEF0ID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cbiAgICB0aGlzLnNjb3BlLmVudGVyKDApO1xuICAgIHRoaXMuZXhwZWN0KDEwKTtcbiAgICBpZiAodGhpcy5tYXRjaCgxMykpIHtcbiAgICAgIGlmIChhd2FpdEF0ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIG51bGwpO1xuICAgIH1cbiAgICBjb25zdCBzdGFydHNXaXRoTGV0ID0gdGhpcy5pc0NvbnRleHR1YWwoMTAwKTtcbiAgICB7XG4gICAgICBjb25zdCBzdGFydHNXaXRoQXdhaXRVc2luZyA9IHRoaXMuaXNBd2FpdFVzaW5nKCk7XG4gICAgICBjb25zdCBzdGFyc1dpdGhVc2luZ0RlY2xhcmF0aW9uID0gc3RhcnRzV2l0aEF3YWl0VXNpbmcgfHwgdGhpcy5pc0ZvclVzaW5nKCk7XG4gICAgICBjb25zdCBpc0xldE9yVXNpbmcgPSBzdGFydHNXaXRoTGV0ICYmIHRoaXMuaGFzRm9sbG93aW5nQmluZGluZ0F0b20oKSB8fCBzdGFyc1dpdGhVc2luZ0RlY2xhcmF0aW9uO1xuICAgICAgaWYgKHRoaXMubWF0Y2goNzQpIHx8IHRoaXMubWF0Y2goNzUpIHx8IGlzTGV0T3JVc2luZykge1xuICAgICAgICBjb25zdCBpbml0Tm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIGxldCBraW5kO1xuICAgICAgICBpZiAoc3RhcnRzV2l0aEF3YWl0VXNpbmcpIHtcbiAgICAgICAgICBraW5kID0gXCJhd2FpdCB1c2luZ1wiO1xuICAgICAgICAgIGlmICghdGhpcy5yZWNvcmRBd2FpdElmQWxsb3dlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Bd2FpdFVzaW5nTm90SW5Bc3luY0NvbnRleHQsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBraW5kID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgdGhpcy5wYXJzZVZhcihpbml0Tm9kZSwgdHJ1ZSwga2luZCk7XG4gICAgICAgIGNvbnN0IGluaXQgPSB0aGlzLmZpbmlzaE5vZGUoaW5pdE5vZGUsIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKTtcbiAgICAgICAgY29uc3QgaXNGb3JJbiA9IHRoaXMubWF0Y2goNTgpO1xuICAgICAgICBpZiAoaXNGb3JJbiAmJiBzdGFyc1dpdGhVc2luZ0RlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRm9ySW5Vc2luZywgaW5pdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChpc0ZvckluIHx8IHRoaXMuaXNDb250ZXh0dWFsKDEwMikpICYmIGluaXQuZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9ySW4obm9kZSwgaW5pdCwgYXdhaXRBdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF3YWl0QXQgIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgaW5pdCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0c1dpdGhBc3luYyA9IHRoaXMuaXNDb250ZXh0dWFsKDk1KTtcbiAgICBjb25zdCByZWZFeHByZXNzaW9uRXJyb3JzID0gbmV3IEV4cHJlc3Npb25FcnJvcnMoKTtcbiAgICBjb25zdCBpbml0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24odHJ1ZSwgcmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgY29uc3QgaXNGb3JPZiA9IHRoaXMuaXNDb250ZXh0dWFsKDEwMik7XG4gICAgaWYgKGlzRm9yT2YpIHtcbiAgICAgIGlmIChzdGFydHNXaXRoTGV0KSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkZvck9mTGV0LCBpbml0KTtcbiAgICAgIH1cbiAgICAgIGlmIChhd2FpdEF0ID09PSBudWxsICYmIHN0YXJ0c1dpdGhBc3luYyAmJiBpbml0LnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkZvck9mQXN5bmMsIGluaXQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNGb3JPZiB8fCB0aGlzLm1hdGNoKDU4KSkge1xuICAgICAgdGhpcy5jaGVja0Rlc3RydWN0dXJpbmdQcml2YXRlKHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgICAgdGhpcy50b0Fzc2lnbmFibGUoaW5pdCwgdHJ1ZSk7XG4gICAgICBjb25zdCB0eXBlID0gaXNGb3JPZiA/IFwiRm9yT2ZTdGF0ZW1lbnRcIiA6IFwiRm9ySW5TdGF0ZW1lbnRcIjtcbiAgICAgIHRoaXMuY2hlY2tMVmFsKGluaXQsIHtcbiAgICAgICAgdHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZvckluKG5vZGUsIGluaXQsIGF3YWl0QXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZFeHByZXNzaW9uRXJyb3JzLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKGF3YWl0QXQgIT09IG51bGwpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgaW5pdCk7XG4gIH1cbiAgcGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlLCBpc0FzeW5jLCBpc0hhbmdpbmdEZWNsYXJhdGlvbikge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24obm9kZSwgMSB8IChpc0hhbmdpbmdEZWNsYXJhdGlvbiA/IDIgOiAwKSB8IChpc0FzeW5jID8gOCA6IDApKTtcbiAgfVxuICBwYXJzZUlmU3RhdGVtZW50KG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlSGVhZGVyRXhwcmVzc2lvbigpO1xuICAgIG5vZGUuY29uc2VxdWVudCA9IHRoaXMucGFyc2VTdGF0ZW1lbnRPclNsb3BweUFubmV4QkZ1bmN0aW9uRGVjbGFyYXRpb24oKTtcbiAgICBub2RlLmFsdGVybmF0ZSA9IHRoaXMuZWF0KDY2KSA/IHRoaXMucGFyc2VTdGF0ZW1lbnRPclNsb3BweUFubmV4QkZ1bmN0aW9uRGVjbGFyYXRpb24oKSA6IG51bGw7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIklmU3RhdGVtZW50XCIpO1xuICB9XG4gIHBhcnNlUmV0dXJuU3RhdGVtZW50KG5vZGUpIHtcbiAgICBpZiAoIXRoaXMucHJvZFBhcmFtLmhhc1JldHVybikge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSWxsZWdhbFJldHVybiwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLmlzTGluZVRlcm1pbmF0b3IoKSkge1xuICAgICAgbm9kZS5hcmd1bWVudCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlJldHVyblN0YXRlbWVudFwiKTtcbiAgfVxuICBwYXJzZVN3aXRjaFN0YXRlbWVudChub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5kaXNjcmltaW5hbnQgPSB0aGlzLnBhcnNlSGVhZGVyRXhwcmVzc2lvbigpO1xuICAgIGNvbnN0IGNhc2VzID0gbm9kZS5jYXNlcyA9IFtdO1xuICAgIHRoaXMuZXhwZWN0KDUpO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzLnB1c2goc3dpdGNoTGFiZWwpO1xuICAgIHRoaXMuc2NvcGUuZW50ZXIoMjU2KTtcbiAgICBsZXQgY3VyO1xuICAgIGZvciAobGV0IHNhd0RlZmF1bHQ7ICF0aGlzLm1hdGNoKDgpOykge1xuICAgICAgaWYgKHRoaXMubWF0Y2goNjEpIHx8IHRoaXMubWF0Y2goNjUpKSB7XG4gICAgICAgIGNvbnN0IGlzQ2FzZSA9IHRoaXMubWF0Y2goNjEpO1xuICAgICAgICBpZiAoY3VyKSB0aGlzLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7XG4gICAgICAgIGNhc2VzLnB1c2goY3VyID0gdGhpcy5zdGFydE5vZGUoKSk7XG4gICAgICAgIGN1ci5jb25zZXF1ZW50ID0gW107XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBpZiAoaXNDYXNlKSB7XG4gICAgICAgICAgY3VyLnRlc3QgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzYXdEZWZhdWx0KSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5NdWx0aXBsZURlZmF1bHRzSW5Td2l0Y2gsIHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0TG9jKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2F3RGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgY3VyLnRlc3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXhwZWN0KDE0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjdXIpIHtcbiAgICAgICAgICBjdXIuY29uc2VxdWVudC5wdXNoKHRoaXMucGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgICBpZiAoY3VyKSB0aGlzLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5zdGF0ZS5sYWJlbHMucG9wKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlN3aXRjaFN0YXRlbWVudFwiKTtcbiAgfVxuICBwYXJzZVRocm93U3RhdGVtZW50KG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuTmV3bGluZUFmdGVyVGhyb3csIHRoaXMuc3RhdGUubGFzdFRva0VuZExvYyk7XG4gICAgfVxuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRocm93U3RhdGVtZW50XCIpO1xuICB9XG4gIHBhcnNlQ2F0Y2hDbGF1c2VQYXJhbSgpIHtcbiAgICBjb25zdCBwYXJhbSA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICAgIHRoaXMuc2NvcGUuZW50ZXIodGhpcy5vcHRpb25zLmFubmV4QiAmJiBwYXJhbS50eXBlID09PSBcIklkZW50aWZpZXJcIiA/IDggOiAwKTtcbiAgICB0aGlzLmNoZWNrTFZhbChwYXJhbSwge1xuICAgICAgdHlwZTogXCJDYXRjaENsYXVzZVwiXG4gICAgfSwgOSk7XG4gICAgcmV0dXJuIHBhcmFtO1xuICB9XG4gIHBhcnNlVHJ5U3RhdGVtZW50KG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmJsb2NrID0gdGhpcy5wYXJzZUJsb2NrKCk7XG4gICAgbm9kZS5oYW5kbGVyID0gbnVsbDtcbiAgICBpZiAodGhpcy5tYXRjaCg2MikpIHtcbiAgICAgIGNvbnN0IGNsYXVzZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDEwKSkge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMCk7XG4gICAgICAgIGNsYXVzZS5wYXJhbSA9IHRoaXMucGFyc2VDYXRjaENsYXVzZVBhcmFtKCk7XG4gICAgICAgIHRoaXMuZXhwZWN0KDExKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsYXVzZS5wYXJhbSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2NvcGUuZW50ZXIoMCk7XG4gICAgICB9XG4gICAgICBjbGF1c2UuYm9keSA9IHRoaXMud2l0aFNtYXJ0TWl4VG9waWNGb3JiaWRkaW5nQ29udGV4dCgoKSA9PiB0aGlzLnBhcnNlQmxvY2soZmFsc2UsIGZhbHNlKSk7XG4gICAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgICAgIG5vZGUuaGFuZGxlciA9IHRoaXMuZmluaXNoTm9kZShjbGF1c2UsIFwiQ2F0Y2hDbGF1c2VcIik7XG4gICAgfVxuICAgIG5vZGUuZmluYWxpemVyID0gdGhpcy5lYXQoNjcpID8gdGhpcy5wYXJzZUJsb2NrKCkgOiBudWxsO1xuICAgIGlmICghbm9kZS5oYW5kbGVyICYmICFub2RlLmZpbmFsaXplcikge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuTm9DYXRjaE9yRmluYWxseSwgbm9kZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUcnlTdGF0ZW1lbnRcIik7XG4gIH1cbiAgcGFyc2VWYXJTdGF0ZW1lbnQobm9kZSwga2luZCwgYWxsb3dNaXNzaW5nSW5pdGlhbGl6ZXIgPSBmYWxzZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMucGFyc2VWYXIobm9kZSwgZmFsc2UsIGtpbmQsIGFsbG93TWlzc2luZ0luaXRpYWxpemVyKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpO1xuICB9XG4gIHBhcnNlV2hpbGVTdGF0ZW1lbnQobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUudGVzdCA9IHRoaXMucGFyc2VIZWFkZXJFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5zdGF0ZS5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMud2l0aFNtYXJ0TWl4VG9waWNGb3JiaWRkaW5nQ29udGV4dCgoKSA9PiB0aGlzLnBhcnNlU3RhdGVtZW50KCkpO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzLnBvcCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJXaGlsZVN0YXRlbWVudFwiKTtcbiAgfVxuICBwYXJzZVdpdGhTdGF0ZW1lbnQobm9kZSkge1xuICAgIGlmICh0aGlzLnN0YXRlLnN0cmljdCkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuU3RyaWN0V2l0aCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUub2JqZWN0ID0gdGhpcy5wYXJzZUhlYWRlckV4cHJlc3Npb24oKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLndpdGhTbWFydE1peFRvcGljRm9yYmlkZGluZ0NvbnRleHQoKCkgPT4gdGhpcy5wYXJzZVN0YXRlbWVudCgpKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiV2l0aFN0YXRlbWVudFwiKTtcbiAgfVxuICBwYXJzZUVtcHR5U3RhdGVtZW50KG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW1wdHlTdGF0ZW1lbnRcIik7XG4gIH1cbiAgcGFyc2VMYWJlbGVkU3RhdGVtZW50KG5vZGUsIG1heWJlTmFtZSwgZXhwciwgZmxhZ3MpIHtcbiAgICBmb3IgKGNvbnN0IGxhYmVsIG9mIHRoaXMuc3RhdGUubGFiZWxzKSB7XG4gICAgICBpZiAobGFiZWwubmFtZSA9PT0gbWF5YmVOYW1lKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkxhYmVsUmVkZWNsYXJhdGlvbiwgZXhwciwge1xuICAgICAgICAgIGxhYmVsTmFtZTogbWF5YmVOYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBraW5kID0gdG9rZW5Jc0xvb3AodGhpcy5zdGF0ZS50eXBlKSA/IDEgOiB0aGlzLm1hdGNoKDcxKSA/IDIgOiBudWxsO1xuICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXRlLmxhYmVscy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgbGFiZWwgPSB0aGlzLnN0YXRlLmxhYmVsc1tpXTtcbiAgICAgIGlmIChsYWJlbC5zdGF0ZW1lbnRTdGFydCA9PT0gbm9kZS5zdGFydCkge1xuICAgICAgICBsYWJlbC5zdGF0ZW1lbnRTdGFydCA9IHRoaXMuc291cmNlVG9PZmZzZXRQb3ModGhpcy5zdGF0ZS5zdGFydCk7XG4gICAgICAgIGxhYmVsLmtpbmQgPSBraW5kO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc3RhdGUubGFiZWxzLnB1c2goe1xuICAgICAgbmFtZTogbWF5YmVOYW1lLFxuICAgICAga2luZDoga2luZCxcbiAgICAgIHN0YXRlbWVudFN0YXJ0OiB0aGlzLnNvdXJjZVRvT2Zmc2V0UG9zKHRoaXMuc3RhdGUuc3RhcnQpXG4gICAgfSk7XG4gICAgbm9kZS5ib2R5ID0gZmxhZ3MgJiA4ID8gdGhpcy5wYXJzZVN0YXRlbWVudE9yU2xvcHB5QW5uZXhCRnVuY3Rpb25EZWNsYXJhdGlvbih0cnVlKSA6IHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcbiAgICB0aGlzLnN0YXRlLmxhYmVscy5wb3AoKTtcbiAgICBub2RlLmxhYmVsID0gZXhwcjtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTGFiZWxlZFN0YXRlbWVudFwiKTtcbiAgfVxuICBwYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgZXhwciwgZGVjb3JhdG9ycykge1xuICAgIG5vZGUuZXhwcmVzc2lvbiA9IGV4cHI7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiKTtcbiAgfVxuICBwYXJzZUJsb2NrKGFsbG93RGlyZWN0aXZlcyA9IGZhbHNlLCBjcmVhdGVOZXdMZXhpY2FsU2NvcGUgPSB0cnVlLCBhZnRlckJsb2NrUGFyc2UpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBpZiAoYWxsb3dEaXJlY3RpdmVzKSB7XG4gICAgICB0aGlzLnN0YXRlLnN0cmljdEVycm9ycy5jbGVhcigpO1xuICAgIH1cbiAgICB0aGlzLmV4cGVjdCg1KTtcbiAgICBpZiAoY3JlYXRlTmV3TGV4aWNhbFNjb3BlKSB7XG4gICAgICB0aGlzLnNjb3BlLmVudGVyKDApO1xuICAgIH1cbiAgICB0aGlzLnBhcnNlQmxvY2tCb2R5KG5vZGUsIGFsbG93RGlyZWN0aXZlcywgZmFsc2UsIDgsIGFmdGVyQmxvY2tQYXJzZSk7XG4gICAgaWYgKGNyZWF0ZU5ld0xleGljYWxTY29wZSkge1xuICAgICAgdGhpcy5zY29wZS5leGl0KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJCbG9ja1N0YXRlbWVudFwiKTtcbiAgfVxuICBpc1ZhbGlkRGlyZWN0aXZlKHN0bXQpIHtcbiAgICByZXR1cm4gc3RtdC50eXBlID09PSBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiAmJiBzdG10LmV4cHJlc3Npb24udHlwZSA9PT0gXCJTdHJpbmdMaXRlcmFsXCIgJiYgIXN0bXQuZXhwcmVzc2lvbi5leHRyYS5wYXJlbnRoZXNpemVkO1xuICB9XG4gIHBhcnNlQmxvY2tCb2R5KG5vZGUsIGFsbG93RGlyZWN0aXZlcywgdG9wTGV2ZWwsIGVuZCwgYWZ0ZXJCbG9ja1BhcnNlKSB7XG4gICAgY29uc3QgYm9keSA9IG5vZGUuYm9keSA9IFtdO1xuICAgIGNvbnN0IGRpcmVjdGl2ZXMgPSBub2RlLmRpcmVjdGl2ZXMgPSBbXTtcbiAgICB0aGlzLnBhcnNlQmxvY2tPck1vZHVsZUJsb2NrQm9keShib2R5LCBhbGxvd0RpcmVjdGl2ZXMgPyBkaXJlY3RpdmVzIDogdW5kZWZpbmVkLCB0b3BMZXZlbCwgZW5kLCBhZnRlckJsb2NrUGFyc2UpO1xuICB9XG4gIHBhcnNlQmxvY2tPck1vZHVsZUJsb2NrQm9keShib2R5LCBkaXJlY3RpdmVzLCB0b3BMZXZlbCwgZW5kLCBhZnRlckJsb2NrUGFyc2UpIHtcbiAgICBjb25zdCBvbGRTdHJpY3QgPSB0aGlzLnN0YXRlLnN0cmljdDtcbiAgICBsZXQgaGFzU3RyaWN0TW9kZURpcmVjdGl2ZSA9IGZhbHNlO1xuICAgIGxldCBwYXJzZWROb25EaXJlY3RpdmUgPSBmYWxzZTtcbiAgICB3aGlsZSAoIXRoaXMubWF0Y2goZW5kKSkge1xuICAgICAgY29uc3Qgc3RtdCA9IHRvcExldmVsID8gdGhpcy5wYXJzZU1vZHVsZUl0ZW0oKSA6IHRoaXMucGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpO1xuICAgICAgaWYgKGRpcmVjdGl2ZXMgJiYgIXBhcnNlZE5vbkRpcmVjdGl2ZSkge1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkRGlyZWN0aXZlKHN0bXQpKSB7XG4gICAgICAgICAgY29uc3QgZGlyZWN0aXZlID0gdGhpcy5zdG10VG9EaXJlY3RpdmUoc3RtdCk7XG4gICAgICAgICAgZGlyZWN0aXZlcy5wdXNoKGRpcmVjdGl2ZSk7XG4gICAgICAgICAgaWYgKCFoYXNTdHJpY3RNb2RlRGlyZWN0aXZlICYmIGRpcmVjdGl2ZS52YWx1ZS52YWx1ZSA9PT0gXCJ1c2Ugc3RyaWN0XCIpIHtcbiAgICAgICAgICAgIGhhc1N0cmljdE1vZGVEaXJlY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zZXRTdHJpY3QodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlZE5vbkRpcmVjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhdGUuc3RyaWN0RXJyb3JzLmNsZWFyKCk7XG4gICAgICB9XG4gICAgICBib2R5LnB1c2goc3RtdCk7XG4gICAgfVxuICAgIGFmdGVyQmxvY2tQYXJzZSA9PSBudWxsIHx8IGFmdGVyQmxvY2tQYXJzZS5jYWxsKHRoaXMsIGhhc1N0cmljdE1vZGVEaXJlY3RpdmUpO1xuICAgIGlmICghb2xkU3RyaWN0KSB7XG4gICAgICB0aGlzLnNldFN0cmljdChmYWxzZSk7XG4gICAgfVxuICAgIHRoaXMubmV4dCgpO1xuICB9XG4gIHBhcnNlRm9yKG5vZGUsIGluaXQpIHtcbiAgICBub2RlLmluaXQgPSBpbml0O1xuICAgIHRoaXMuc2VtaWNvbG9uKGZhbHNlKTtcbiAgICBub2RlLnRlc3QgPSB0aGlzLm1hdGNoKDEzKSA/IG51bGwgOiB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuc2VtaWNvbG9uKGZhbHNlKTtcbiAgICBub2RlLnVwZGF0ZSA9IHRoaXMubWF0Y2goMTEpID8gbnVsbCA6IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5leHBlY3QoMTEpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMud2l0aFNtYXJ0TWl4VG9waWNGb3JiaWRkaW5nQ29udGV4dCgoKSA9PiB0aGlzLnBhcnNlU3RhdGVtZW50KCkpO1xuICAgIHRoaXMuc2NvcGUuZXhpdCgpO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzLnBvcCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJGb3JTdGF0ZW1lbnRcIik7XG4gIH1cbiAgcGFyc2VGb3JJbihub2RlLCBpbml0LCBhd2FpdEF0KSB7XG4gICAgY29uc3QgaXNGb3JJbiA9IHRoaXMubWF0Y2goNTgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmIChpc0ZvckluKSB7XG4gICAgICBpZiAoYXdhaXRBdCAhPT0gbnVsbCkgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmF3YWl0ID0gYXdhaXRBdCAhPT0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGluaXQudHlwZSA9PT0gXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIgJiYgaW5pdC5kZWNsYXJhdGlvbnNbMF0uaW5pdCAhPSBudWxsICYmICghaXNGb3JJbiB8fCAhdGhpcy5vcHRpb25zLmFubmV4QiB8fCB0aGlzLnN0YXRlLnN0cmljdCB8fCBpbml0LmtpbmQgIT09IFwidmFyXCIgfHwgaW5pdC5kZWNsYXJhdGlvbnNbMF0uaWQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5Gb3JJbk9mTG9vcEluaXRpYWxpemVyLCBpbml0LCB7XG4gICAgICAgIHR5cGU6IGlzRm9ySW4gPyBcIkZvckluU3RhdGVtZW50XCIgOiBcIkZvck9mU3RhdGVtZW50XCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaW5pdC50eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWRMaHMsIGluaXQsIHtcbiAgICAgICAgYW5jZXN0b3I6IHtcbiAgICAgICAgICB0eXBlOiBcIkZvclN0YXRlbWVudFwiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBub2RlLmxlZnQgPSBpbml0O1xuICAgIG5vZGUucmlnaHQgPSBpc0ZvckluID8gdGhpcy5wYXJzZUV4cHJlc3Npb24oKSA6IHRoaXMucGFyc2VNYXliZUFzc2lnbkFsbG93SW4oKTtcbiAgICB0aGlzLmV4cGVjdCgxMSk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy53aXRoU21hcnRNaXhUb3BpY0ZvcmJpZGRpbmdDb250ZXh0KCgpID0+IHRoaXMucGFyc2VTdGF0ZW1lbnQoKSk7XG4gICAgdGhpcy5zY29wZS5leGl0KCk7XG4gICAgdGhpcy5zdGF0ZS5sYWJlbHMucG9wKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc0ZvckluID8gXCJGb3JJblN0YXRlbWVudFwiIDogXCJGb3JPZlN0YXRlbWVudFwiKTtcbiAgfVxuICBwYXJzZVZhcihub2RlLCBpc0Zvciwga2luZCwgYWxsb3dNaXNzaW5nSW5pdGlhbGl6ZXIgPSBmYWxzZSkge1xuICAgIGNvbnN0IGRlY2xhcmF0aW9ucyA9IG5vZGUuZGVjbGFyYXRpb25zID0gW107XG4gICAgbm9kZS5raW5kID0ga2luZDtcbiAgICBmb3IgKDs7KSB7XG4gICAgICBjb25zdCBkZWNsID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMucGFyc2VWYXJJZChkZWNsLCBraW5kKTtcbiAgICAgIGRlY2wuaW5pdCA9ICF0aGlzLmVhdCgyOSkgPyBudWxsIDogaXNGb3IgPyB0aGlzLnBhcnNlTWF5YmVBc3NpZ25EaXNhbGxvd0luKCkgOiB0aGlzLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKCk7XG4gICAgICBpZiAoZGVjbC5pbml0ID09PSBudWxsICYmICFhbGxvd01pc3NpbmdJbml0aWFsaXplcikge1xuICAgICAgICBpZiAoZGVjbC5pZC50eXBlICE9PSBcIklkZW50aWZpZXJcIiAmJiAhKGlzRm9yICYmICh0aGlzLm1hdGNoKDU4KSB8fCB0aGlzLmlzQ29udGV4dHVhbCgxMDIpKSkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5EZWNsYXJhdGlvbk1pc3NpbmdJbml0aWFsaXplciwgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jLCB7XG4gICAgICAgICAgICBraW5kOiBcImRlc3RydWN0dXJpbmdcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKChraW5kID09PSBcImNvbnN0XCIgfHwga2luZCA9PT0gXCJ1c2luZ1wiIHx8IGtpbmQgPT09IFwiYXdhaXQgdXNpbmdcIikgJiYgISh0aGlzLm1hdGNoKDU4KSB8fCB0aGlzLmlzQ29udGV4dHVhbCgxMDIpKSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkRlY2xhcmF0aW9uTWlzc2luZ0luaXRpYWxpemVyLCB0aGlzLnN0YXRlLmxhc3RUb2tFbmRMb2MsIHtcbiAgICAgICAgICAgIGtpbmRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVjbGFyYXRpb25zLnB1c2godGhpcy5maW5pc2hOb2RlKGRlY2wsIFwiVmFyaWFibGVEZWNsYXJhdG9yXCIpKTtcbiAgICAgIGlmICghdGhpcy5lYXQoMTIpKSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcGFyc2VWYXJJZChkZWNsLCBraW5kKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgICBpZiAoa2luZCA9PT0gXCJ1c2luZ1wiIHx8IGtpbmQgPT09IFwiYXdhaXQgdXNpbmdcIikge1xuICAgICAgaWYgKGlkLnR5cGUgPT09IFwiQXJyYXlQYXR0ZXJuXCIgfHwgaWQudHlwZSA9PT0gXCJPYmplY3RQYXR0ZXJuXCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVXNpbmdEZWNsYXJhdGlvbkhhc0JpbmRpbmdQYXR0ZXJuLCBpZC5sb2Muc3RhcnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaWQudHlwZSA9PT0gXCJWb2lkUGF0dGVyblwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWRWb2lkUGF0dGVybiwgaWQubG9jLnN0YXJ0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jaGVja0xWYWwoaWQsIHtcbiAgICAgIHR5cGU6IFwiVmFyaWFibGVEZWNsYXJhdG9yXCJcbiAgICB9LCBraW5kID09PSBcInZhclwiID8gNSA6IDgyMDEpO1xuICAgIGRlY2wuaWQgPSBpZDtcbiAgfVxuICBwYXJzZUFzeW5jRnVuY3Rpb25FeHByZXNzaW9uKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKG5vZGUsIDgpO1xuICB9XG4gIHBhcnNlRnVuY3Rpb24obm9kZSwgZmxhZ3MgPSAwKSB7XG4gICAgY29uc3QgaGFuZ2luZ0RlY2xhcmF0aW9uID0gZmxhZ3MgJiAyO1xuICAgIGNvbnN0IGlzRGVjbGFyYXRpb24gPSAhIShmbGFncyAmIDEpO1xuICAgIGNvbnN0IHJlcXVpcmVJZCA9IGlzRGVjbGFyYXRpb24gJiYgIShmbGFncyAmIDQpO1xuICAgIGNvbnN0IGlzQXN5bmMgPSAhIShmbGFncyAmIDgpO1xuICAgIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUsIGlzQXN5bmMpO1xuICAgIGlmICh0aGlzLm1hdGNoKDU1KSkge1xuICAgICAgaWYgKGhhbmdpbmdEZWNsYXJhdGlvbikge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5HZW5lcmF0b3JJblNpbmdsZVN0YXRlbWVudENvbnRleHQsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgfVxuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBub2RlLmdlbmVyYXRvciA9IHRydWU7XG4gICAgfVxuICAgIGlmIChpc0RlY2xhcmF0aW9uKSB7XG4gICAgICBub2RlLmlkID0gdGhpcy5wYXJzZUZ1bmN0aW9uSWQocmVxdWlyZUlkKTtcbiAgICB9XG4gICAgY29uc3Qgb2xkTWF5YmVJbkFycm93UGFyYW1ldGVycyA9IHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycztcbiAgICB0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnMgPSBmYWxzZTtcbiAgICB0aGlzLnNjb3BlLmVudGVyKDUxNCk7XG4gICAgdGhpcy5wcm9kUGFyYW0uZW50ZXIoZnVuY3Rpb25GbGFncyhpc0FzeW5jLCBub2RlLmdlbmVyYXRvcikpO1xuICAgIGlmICghaXNEZWNsYXJhdGlvbikge1xuICAgICAgbm9kZS5pZCA9IHRoaXMucGFyc2VGdW5jdGlvbklkKCk7XG4gICAgfVxuICAgIHRoaXMucGFyc2VGdW5jdGlvblBhcmFtcyhub2RlLCBmYWxzZSk7XG4gICAgdGhpcy53aXRoU21hcnRNaXhUb3BpY0ZvcmJpZGRpbmdDb250ZXh0KCgpID0+IHtcbiAgICAgIHRoaXMucGFyc2VGdW5jdGlvbkJvZHlBbmRGaW5pc2gobm9kZSwgaXNEZWNsYXJhdGlvbiA/IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiIDogXCJGdW5jdGlvbkV4cHJlc3Npb25cIik7XG4gICAgfSk7XG4gICAgdGhpcy5wcm9kUGFyYW0uZXhpdCgpO1xuICAgIHRoaXMuc2NvcGUuZXhpdCgpO1xuICAgIGlmIChpc0RlY2xhcmF0aW9uICYmICFoYW5naW5nRGVjbGFyYXRpb24pIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJGdW5jdGlvblN0YXRlbWVudElkKG5vZGUpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnMgPSBvbGRNYXliZUluQXJyb3dQYXJhbWV0ZXJzO1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHBhcnNlRnVuY3Rpb25JZChyZXF1aXJlSWQpIHtcbiAgICByZXR1cm4gcmVxdWlyZUlkIHx8IHRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkgPyB0aGlzLnBhcnNlSWRlbnRpZmllcigpIDogbnVsbDtcbiAgfVxuICBwYXJzZUZ1bmN0aW9uUGFyYW1zKG5vZGUsIGlzQ29uc3RydWN0b3IpIHtcbiAgICB0aGlzLmV4cGVjdCgxMCk7XG4gICAgdGhpcy5leHByZXNzaW9uU2NvcGUuZW50ZXIobmV3UGFyYW1ldGVyRGVjbGFyYXRpb25TY29wZSgpKTtcbiAgICBub2RlLnBhcmFtcyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdCgxMSwgNDEsIDIgfCAoaXNDb25zdHJ1Y3RvciA/IDQgOiAwKSk7XG4gICAgdGhpcy5leHByZXNzaW9uU2NvcGUuZXhpdCgpO1xuICB9XG4gIHJlZ2lzdGVyRnVuY3Rpb25TdGF0ZW1lbnRJZChub2RlKSB7XG4gICAgaWYgKCFub2RlLmlkKSByZXR1cm47XG4gICAgdGhpcy5zY29wZS5kZWNsYXJlTmFtZShub2RlLmlkLm5hbWUsICF0aGlzLm9wdGlvbnMuYW5uZXhCIHx8IHRoaXMuc3RhdGUuc3RyaWN0IHx8IG5vZGUuZ2VuZXJhdG9yIHx8IG5vZGUuYXN5bmMgPyB0aGlzLnNjb3BlLnRyZWF0RnVuY3Rpb25zQXNWYXIgPyA1IDogODIwMSA6IDE3LCBub2RlLmlkLmxvYy5zdGFydCk7XG4gIH1cbiAgcGFyc2VDbGFzcyhub2RlLCBpc1N0YXRlbWVudCwgb3B0aW9uYWxJZCkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGNvbnN0IG9sZFN0cmljdCA9IHRoaXMuc3RhdGUuc3RyaWN0O1xuICAgIHRoaXMuc3RhdGUuc3RyaWN0ID0gdHJ1ZTtcbiAgICB0aGlzLnBhcnNlQ2xhc3NJZChub2RlLCBpc1N0YXRlbWVudCwgb3B0aW9uYWxJZCk7XG4gICAgdGhpcy5wYXJzZUNsYXNzU3VwZXIobm9kZSk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZUNsYXNzQm9keSghIW5vZGUuc3VwZXJDbGFzcywgb2xkU3RyaWN0KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzU3RhdGVtZW50ID8gXCJDbGFzc0RlY2xhcmF0aW9uXCIgOiBcIkNsYXNzRXhwcmVzc2lvblwiKTtcbiAgfVxuICBpc0NsYXNzUHJvcGVydHkoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goMjkpIHx8IHRoaXMubWF0Y2goMTMpIHx8IHRoaXMubWF0Y2goOCk7XG4gIH1cbiAgaXNDbGFzc01ldGhvZCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgxMCk7XG4gIH1cbiAgbmFtZUlzQ29uc3RydWN0b3Ioa2V5KSB7XG4gICAgcmV0dXJuIGtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBrZXkubmFtZSA9PT0gXCJjb25zdHJ1Y3RvclwiIHx8IGtleS50eXBlID09PSBcIlN0cmluZ0xpdGVyYWxcIiAmJiBrZXkudmFsdWUgPT09IFwiY29uc3RydWN0b3JcIjtcbiAgfVxuICBpc05vbnN0YXRpY0NvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgIHJldHVybiAhbWV0aG9kLmNvbXB1dGVkICYmICFtZXRob2Quc3RhdGljICYmIHRoaXMubmFtZUlzQ29uc3RydWN0b3IobWV0aG9kLmtleSk7XG4gIH1cbiAgcGFyc2VDbGFzc0JvZHkoaGFkU3VwZXJDbGFzcywgb2xkU3RyaWN0KSB7XG4gICAgdGhpcy5jbGFzc1Njb3BlLmVudGVyKCk7XG4gICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICBoYWRDb25zdHJ1Y3RvcjogZmFsc2UsXG4gICAgICBoYWRTdXBlckNsYXNzXG4gICAgfTtcbiAgICBsZXQgZGVjb3JhdG9ycyA9IFtdO1xuICAgIGNvbnN0IGNsYXNzQm9keSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY2xhc3NCb2R5LmJvZHkgPSBbXTtcbiAgICB0aGlzLmV4cGVjdCg1KTtcbiAgICB0aGlzLndpdGhTbWFydE1peFRvcGljRm9yYmlkZGluZ0NvbnRleHQoKCkgPT4ge1xuICAgICAgd2hpbGUgKCF0aGlzLm1hdGNoKDgpKSB7XG4gICAgICAgIGlmICh0aGlzLmVhdCgxMykpIHtcbiAgICAgICAgICBpZiAoZGVjb3JhdG9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5EZWNvcmF0b3JTZW1pY29sb24sIHRoaXMuc3RhdGUubGFzdFRva0VuZExvYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1hdGNoKDI2KSkge1xuICAgICAgICAgIGRlY29yYXRvcnMucHVzaCh0aGlzLnBhcnNlRGVjb3JhdG9yKCkpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lbWJlciA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIGlmIChkZWNvcmF0b3JzLmxlbmd0aCkge1xuICAgICAgICAgIG1lbWJlci5kZWNvcmF0b3JzID0gZGVjb3JhdG9ycztcbiAgICAgICAgICB0aGlzLnJlc2V0U3RhcnRMb2NhdGlvbkZyb21Ob2RlKG1lbWJlciwgZGVjb3JhdG9yc1swXSk7XG4gICAgICAgICAgZGVjb3JhdG9ycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFyc2VDbGFzc01lbWJlcihjbGFzc0JvZHksIG1lbWJlciwgc3RhdGUpO1xuICAgICAgICBpZiAobWVtYmVyLmtpbmQgPT09IFwiY29uc3RydWN0b3JcIiAmJiBtZW1iZXIuZGVjb3JhdG9ycyAmJiBtZW1iZXIuZGVjb3JhdG9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRGVjb3JhdG9yQ29uc3RydWN0b3IsIG1lbWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnN0YXRlLnN0cmljdCA9IG9sZFN0cmljdDtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAoZGVjb3JhdG9ycy5sZW5ndGgpIHtcbiAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlRyYWlsaW5nRGVjb3JhdG9yLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICB9XG4gICAgdGhpcy5jbGFzc1Njb3BlLmV4aXQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKGNsYXNzQm9keSwgXCJDbGFzc0JvZHlcIik7XG4gIH1cbiAgcGFyc2VDbGFzc01lbWJlckZyb21Nb2RpZmllcihjbGFzc0JvZHksIG1lbWJlcikge1xuICAgIGNvbnN0IGtleSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgIGlmICh0aGlzLmlzQ2xhc3NNZXRob2QoKSkge1xuICAgICAgY29uc3QgbWV0aG9kID0gbWVtYmVyO1xuICAgICAgbWV0aG9kLmtpbmQgPSBcIm1ldGhvZFwiO1xuICAgICAgbWV0aG9kLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgICBtZXRob2Qua2V5ID0ga2V5O1xuICAgICAgbWV0aG9kLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgdGhpcy5wdXNoQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBtZXRob2QsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0NsYXNzUHJvcGVydHkoKSkge1xuICAgICAgY29uc3QgcHJvcCA9IG1lbWJlcjtcbiAgICAgIHByb3AuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICAgIHByb3Aua2V5ID0ga2V5O1xuICAgICAgcHJvcC5zdGF0aWMgPSBmYWxzZTtcbiAgICAgIGNsYXNzQm9keS5ib2R5LnB1c2godGhpcy5wYXJzZUNsYXNzUHJvcGVydHkocHJvcCkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHRoaXMucmVzZXRQcmV2aW91c05vZGVUcmFpbGluZ0NvbW1lbnRzKGtleSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHBhcnNlQ2xhc3NNZW1iZXIoY2xhc3NCb2R5LCBtZW1iZXIsIHN0YXRlKSB7XG4gICAgY29uc3QgaXNTdGF0aWMgPSB0aGlzLmlzQ29udGV4dHVhbCgxMDYpO1xuICAgIGlmIChpc1N0YXRpYykge1xuICAgICAgaWYgKHRoaXMucGFyc2VDbGFzc01lbWJlckZyb21Nb2RpZmllcihjbGFzc0JvZHksIG1lbWJlcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZWF0KDUpKSB7XG4gICAgICAgIHRoaXMucGFyc2VDbGFzc1N0YXRpY0Jsb2NrKGNsYXNzQm9keSwgbWVtYmVyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnBhcnNlQ2xhc3NNZW1iZXJXaXRoSXNTdGF0aWMoY2xhc3NCb2R5LCBtZW1iZXIsIHN0YXRlLCBpc1N0YXRpYyk7XG4gIH1cbiAgcGFyc2VDbGFzc01lbWJlcldpdGhJc1N0YXRpYyhjbGFzc0JvZHksIG1lbWJlciwgc3RhdGUsIGlzU3RhdGljKSB7XG4gICAgY29uc3QgcHVibGljTWV0aG9kID0gbWVtYmVyO1xuICAgIGNvbnN0IHByaXZhdGVNZXRob2QgPSBtZW1iZXI7XG4gICAgY29uc3QgcHVibGljUHJvcCA9IG1lbWJlcjtcbiAgICBjb25zdCBwcml2YXRlUHJvcCA9IG1lbWJlcjtcbiAgICBjb25zdCBhY2Nlc3NvclByb3AgPSBtZW1iZXI7XG4gICAgY29uc3QgbWV0aG9kID0gcHVibGljTWV0aG9kO1xuICAgIGNvbnN0IHB1YmxpY01lbWJlciA9IHB1YmxpY01ldGhvZDtcbiAgICBtZW1iZXIuc3RhdGljID0gaXNTdGF0aWM7XG4gICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZVByZWZpeE9wZXJhdG9yKG1lbWJlcik7XG4gICAgaWYgKHRoaXMuZWF0KDU1KSkge1xuICAgICAgbWV0aG9kLmtpbmQgPSBcIm1ldGhvZFwiO1xuICAgICAgY29uc3QgaXNQcml2YXRlTmFtZSA9IHRoaXMubWF0Y2goMTM5KTtcbiAgICAgIHRoaXMucGFyc2VDbGFzc0VsZW1lbnROYW1lKG1ldGhvZCk7XG4gICAgICB0aGlzLnBhcnNlUG9zdE1lbWJlck5hbWVNb2RpZmllcnMobWV0aG9kKTtcbiAgICAgIGlmIChpc1ByaXZhdGVOYW1lKSB7XG4gICAgICAgIHRoaXMucHVzaENsYXNzUHJpdmF0ZU1ldGhvZChjbGFzc0JvZHksIHByaXZhdGVNZXRob2QsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNOb25zdGF0aWNDb25zdHJ1Y3RvcihwdWJsaWNNZXRob2QpKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkNvbnN0cnVjdG9ySXNHZW5lcmF0b3IsIHB1YmxpY01ldGhvZC5rZXkpO1xuICAgICAgfVxuICAgICAgdGhpcy5wdXNoQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBwdWJsaWNNZXRob2QsIHRydWUsIGZhbHNlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpc0NvbnRleHR1YWwgPSAhdGhpcy5zdGF0ZS5jb250YWluc0VzYyAmJiB0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpO1xuICAgIGNvbnN0IGtleSA9IHRoaXMucGFyc2VDbGFzc0VsZW1lbnROYW1lKG1lbWJlcik7XG4gICAgY29uc3QgbWF5YmVDb250ZXh0dWFsS3cgPSBpc0NvbnRleHR1YWwgPyBrZXkubmFtZSA6IG51bGw7XG4gICAgY29uc3QgaXNQcml2YXRlID0gdGhpcy5pc1ByaXZhdGVOYW1lKGtleSk7XG4gICAgY29uc3QgbWF5YmVRdWVzdGlvblRva2VuU3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIHRoaXMucGFyc2VQb3N0TWVtYmVyTmFtZU1vZGlmaWVycyhwdWJsaWNNZW1iZXIpO1xuICAgIGlmICh0aGlzLmlzQ2xhc3NNZXRob2QoKSkge1xuICAgICAgbWV0aG9kLmtpbmQgPSBcIm1ldGhvZFwiO1xuICAgICAgaWYgKGlzUHJpdmF0ZSkge1xuICAgICAgICB0aGlzLnB1c2hDbGFzc1ByaXZhdGVNZXRob2QoY2xhc3NCb2R5LCBwcml2YXRlTWV0aG9kLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpc0NvbnN0cnVjdG9yID0gdGhpcy5pc05vbnN0YXRpY0NvbnN0cnVjdG9yKHB1YmxpY01ldGhvZCk7XG4gICAgICBsZXQgYWxsb3dzRGlyZWN0U3VwZXIgPSBmYWxzZTtcbiAgICAgIGlmIChpc0NvbnN0cnVjdG9yKSB7XG4gICAgICAgIHB1YmxpY01ldGhvZC5raW5kID0gXCJjb25zdHJ1Y3RvclwiO1xuICAgICAgICBpZiAoc3RhdGUuaGFkQ29uc3RydWN0b3IgJiYgIXRoaXMuaGFzUGx1Z2luKFwidHlwZXNjcmlwdFwiKSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkR1cGxpY2F0ZUNvbnN0cnVjdG9yLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NvbnN0cnVjdG9yICYmIHRoaXMuaGFzUGx1Z2luKFwidHlwZXNjcmlwdFwiKSAmJiBtZW1iZXIub3ZlcnJpZGUpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5PdmVycmlkZU9uQ29uc3RydWN0b3IsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuaGFkQ29uc3RydWN0b3IgPSB0cnVlO1xuICAgICAgICBhbGxvd3NEaXJlY3RTdXBlciA9IHN0YXRlLmhhZFN1cGVyQ2xhc3M7XG4gICAgICB9XG4gICAgICB0aGlzLnB1c2hDbGFzc01ldGhvZChjbGFzc0JvZHksIHB1YmxpY01ldGhvZCwgZmFsc2UsIGZhbHNlLCBpc0NvbnN0cnVjdG9yLCBhbGxvd3NEaXJlY3RTdXBlcik7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ2xhc3NQcm9wZXJ0eSgpKSB7XG4gICAgICBpZiAoaXNQcml2YXRlKSB7XG4gICAgICAgIHRoaXMucHVzaENsYXNzUHJpdmF0ZVByb3BlcnR5KGNsYXNzQm9keSwgcHJpdmF0ZVByb3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wdXNoQ2xhc3NQcm9wZXJ0eShjbGFzc0JvZHksIHB1YmxpY1Byb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobWF5YmVDb250ZXh0dWFsS3cgPT09IFwiYXN5bmNcIiAmJiAhdGhpcy5pc0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgIHRoaXMucmVzZXRQcmV2aW91c05vZGVUcmFpbGluZ0NvbW1lbnRzKGtleSk7XG4gICAgICBjb25zdCBpc0dlbmVyYXRvciA9IHRoaXMuZWF0KDU1KTtcbiAgICAgIGlmIChwdWJsaWNNZW1iZXIub3B0aW9uYWwpIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKG1heWJlUXVlc3Rpb25Ub2tlblN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICAgIG1ldGhvZC5raW5kID0gXCJtZXRob2RcIjtcbiAgICAgIGNvbnN0IGlzUHJpdmF0ZSA9IHRoaXMubWF0Y2goMTM5KTtcbiAgICAgIHRoaXMucGFyc2VDbGFzc0VsZW1lbnROYW1lKG1ldGhvZCk7XG4gICAgICB0aGlzLnBhcnNlUG9zdE1lbWJlck5hbWVNb2RpZmllcnMocHVibGljTWVtYmVyKTtcbiAgICAgIGlmIChpc1ByaXZhdGUpIHtcbiAgICAgICAgdGhpcy5wdXNoQ2xhc3NQcml2YXRlTWV0aG9kKGNsYXNzQm9keSwgcHJpdmF0ZU1ldGhvZCwgaXNHZW5lcmF0b3IsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuaXNOb25zdGF0aWNDb25zdHJ1Y3RvcihwdWJsaWNNZXRob2QpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQ29uc3RydWN0b3JJc0FzeW5jLCBwdWJsaWNNZXRob2Qua2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnB1c2hDbGFzc01ldGhvZChjbGFzc0JvZHksIHB1YmxpY01ldGhvZCwgaXNHZW5lcmF0b3IsIHRydWUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgobWF5YmVDb250ZXh0dWFsS3cgPT09IFwiZ2V0XCIgfHwgbWF5YmVDb250ZXh0dWFsS3cgPT09IFwic2V0XCIpICYmICEodGhpcy5tYXRjaCg1NSkgJiYgdGhpcy5pc0xpbmVUZXJtaW5hdG9yKCkpKSB7XG4gICAgICB0aGlzLnJlc2V0UHJldmlvdXNOb2RlVHJhaWxpbmdDb21tZW50cyhrZXkpO1xuICAgICAgbWV0aG9kLmtpbmQgPSBtYXliZUNvbnRleHR1YWxLdztcbiAgICAgIGNvbnN0IGlzUHJpdmF0ZSA9IHRoaXMubWF0Y2goMTM5KTtcbiAgICAgIHRoaXMucGFyc2VDbGFzc0VsZW1lbnROYW1lKHB1YmxpY01ldGhvZCk7XG4gICAgICBpZiAoaXNQcml2YXRlKSB7XG4gICAgICAgIHRoaXMucHVzaENsYXNzUHJpdmF0ZU1ldGhvZChjbGFzc0JvZHksIHByaXZhdGVNZXRob2QsIGZhbHNlLCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5pc05vbnN0YXRpY0NvbnN0cnVjdG9yKHB1YmxpY01ldGhvZCkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Db25zdHJ1Y3RvcklzQWNjZXNzb3IsIHB1YmxpY01ldGhvZC5rZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHVzaENsYXNzTWV0aG9kKGNsYXNzQm9keSwgcHVibGljTWV0aG9kLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICB0aGlzLmNoZWNrR2V0dGVyU2V0dGVyUGFyYW1zKHB1YmxpY01ldGhvZCk7XG4gICAgfSBlbHNlIGlmIChtYXliZUNvbnRleHR1YWxLdyA9PT0gXCJhY2Nlc3NvclwiICYmICF0aGlzLmlzTGluZVRlcm1pbmF0b3IoKSkge1xuICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJkZWNvcmF0b3JBdXRvQWNjZXNzb3JzXCIpO1xuICAgICAgdGhpcy5yZXNldFByZXZpb3VzTm9kZVRyYWlsaW5nQ29tbWVudHMoa2V5KTtcbiAgICAgIGNvbnN0IGlzUHJpdmF0ZSA9IHRoaXMubWF0Y2goMTM5KTtcbiAgICAgIHRoaXMucGFyc2VDbGFzc0VsZW1lbnROYW1lKHB1YmxpY1Byb3ApO1xuICAgICAgdGhpcy5wdXNoQ2xhc3NBY2Nlc3NvclByb3BlcnR5KGNsYXNzQm9keSwgYWNjZXNzb3JQcm9wLCBpc1ByaXZhdGUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgIGlmIChpc1ByaXZhdGUpIHtcbiAgICAgICAgdGhpcy5wdXNoQ2xhc3NQcml2YXRlUHJvcGVydHkoY2xhc3NCb2R5LCBwcml2YXRlUHJvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnB1c2hDbGFzc1Byb3BlcnR5KGNsYXNzQm9keSwgcHVibGljUHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgfVxuICBwYXJzZUNsYXNzRWxlbWVudE5hbWUobWVtYmVyKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZSxcbiAgICAgIHZhbHVlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKCh0eXBlID09PSAxMzIgfHwgdHlwZSA9PT0gMTM0KSAmJiBtZW1iZXIuc3RhdGljICYmIHZhbHVlID09PSBcInByb3RvdHlwZVwiKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5TdGF0aWNQcm90b3R5cGUsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gMTM5KSB7XG4gICAgICBpZiAodmFsdWUgPT09IFwiY29uc3RydWN0b3JcIikge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Db25zdHJ1Y3RvckNsYXNzUHJpdmF0ZUZpZWxkLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGtleSA9IHRoaXMucGFyc2VQcml2YXRlTmFtZSgpO1xuICAgICAgbWVtYmVyLmtleSA9IGtleTtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUobWVtYmVyKTtcbiAgICByZXR1cm4gbWVtYmVyLmtleTtcbiAgfVxuICBwYXJzZUNsYXNzU3RhdGljQmxvY2soY2xhc3NCb2R5LCBtZW1iZXIpIHtcbiAgICB2YXIgX21lbWJlciRkZWNvcmF0b3JzO1xuICAgIHRoaXMuc2NvcGUuZW50ZXIoNTc2IHwgMTI4IHwgMTYpO1xuICAgIGNvbnN0IG9sZExhYmVscyA9IHRoaXMuc3RhdGUubGFiZWxzO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzID0gW107XG4gICAgdGhpcy5wcm9kUGFyYW0uZW50ZXIoMCk7XG4gICAgY29uc3QgYm9keSA9IG1lbWJlci5ib2R5ID0gW107XG4gICAgdGhpcy5wYXJzZUJsb2NrT3JNb2R1bGVCbG9ja0JvZHkoYm9keSwgdW5kZWZpbmVkLCBmYWxzZSwgOCk7XG4gICAgdGhpcy5wcm9kUGFyYW0uZXhpdCgpO1xuICAgIHRoaXMuc2NvcGUuZXhpdCgpO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzID0gb2xkTGFiZWxzO1xuICAgIGNsYXNzQm9keS5ib2R5LnB1c2godGhpcy5maW5pc2hOb2RlKG1lbWJlciwgXCJTdGF0aWNCbG9ja1wiKSk7XG4gICAgaWYgKChfbWVtYmVyJGRlY29yYXRvcnMgPSBtZW1iZXIuZGVjb3JhdG9ycykgIT0gbnVsbCAmJiBfbWVtYmVyJGRlY29yYXRvcnMubGVuZ3RoKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5EZWNvcmF0b3JTdGF0aWNCbG9jaywgbWVtYmVyKTtcbiAgICB9XG4gIH1cbiAgcHVzaENsYXNzUHJvcGVydHkoY2xhc3NCb2R5LCBwcm9wKSB7XG4gICAgaWYgKCFwcm9wLmNvbXB1dGVkICYmIHRoaXMubmFtZUlzQ29uc3RydWN0b3IocHJvcC5rZXkpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5Db25zdHJ1Y3RvckNsYXNzRmllbGQsIHByb3Aua2V5KTtcbiAgICB9XG4gICAgY2xhc3NCb2R5LmJvZHkucHVzaCh0aGlzLnBhcnNlQ2xhc3NQcm9wZXJ0eShwcm9wKSk7XG4gIH1cbiAgcHVzaENsYXNzUHJpdmF0ZVByb3BlcnR5KGNsYXNzQm9keSwgcHJvcCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnBhcnNlQ2xhc3NQcml2YXRlUHJvcGVydHkocHJvcCk7XG4gICAgY2xhc3NCb2R5LmJvZHkucHVzaChub2RlKTtcbiAgICB0aGlzLmNsYXNzU2NvcGUuZGVjbGFyZVByaXZhdGVOYW1lKHRoaXMuZ2V0UHJpdmF0ZU5hbWVTVihub2RlLmtleSksIDAsIG5vZGUua2V5LmxvYy5zdGFydCk7XG4gIH1cbiAgcHVzaENsYXNzQWNjZXNzb3JQcm9wZXJ0eShjbGFzc0JvZHksIHByb3AsIGlzUHJpdmF0ZSkge1xuICAgIGlmICghaXNQcml2YXRlICYmICFwcm9wLmNvbXB1dGVkICYmIHRoaXMubmFtZUlzQ29uc3RydWN0b3IocHJvcC5rZXkpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5Db25zdHJ1Y3RvckNsYXNzRmllbGQsIHByb3Aua2V5KTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMucGFyc2VDbGFzc0FjY2Vzc29yUHJvcGVydHkocHJvcCk7XG4gICAgY2xhc3NCb2R5LmJvZHkucHVzaChub2RlKTtcbiAgICBpZiAoaXNQcml2YXRlKSB7XG4gICAgICB0aGlzLmNsYXNzU2NvcGUuZGVjbGFyZVByaXZhdGVOYW1lKHRoaXMuZ2V0UHJpdmF0ZU5hbWVTVihub2RlLmtleSksIDAsIG5vZGUua2V5LmxvYy5zdGFydCk7XG4gICAgfVxuICB9XG4gIHB1c2hDbGFzc01ldGhvZChjbGFzc0JvZHksIG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzQ29uc3RydWN0b3IsIGFsbG93c0RpcmVjdFN1cGVyKSB7XG4gICAgY2xhc3NCb2R5LmJvZHkucHVzaCh0aGlzLnBhcnNlTWV0aG9kKG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzQ29uc3RydWN0b3IsIGFsbG93c0RpcmVjdFN1cGVyLCBcIkNsYXNzTWV0aG9kXCIsIHRydWUpKTtcbiAgfVxuICBwdXNoQ2xhc3NQcml2YXRlTWV0aG9kKGNsYXNzQm9keSwgbWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYykge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnBhcnNlTWV0aG9kKG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGZhbHNlLCBmYWxzZSwgXCJDbGFzc1ByaXZhdGVNZXRob2RcIiwgdHJ1ZSk7XG4gICAgY2xhc3NCb2R5LmJvZHkucHVzaChub2RlKTtcbiAgICBjb25zdCBraW5kID0gbm9kZS5raW5kID09PSBcImdldFwiID8gbm9kZS5zdGF0aWMgPyA2IDogMiA6IG5vZGUua2luZCA9PT0gXCJzZXRcIiA/IG5vZGUuc3RhdGljID8gNSA6IDEgOiAwO1xuICAgIHRoaXMuZGVjbGFyZUNsYXNzUHJpdmF0ZU1ldGhvZEluU2NvcGUobm9kZSwga2luZCk7XG4gIH1cbiAgZGVjbGFyZUNsYXNzUHJpdmF0ZU1ldGhvZEluU2NvcGUobm9kZSwga2luZCkge1xuICAgIHRoaXMuY2xhc3NTY29wZS5kZWNsYXJlUHJpdmF0ZU5hbWUodGhpcy5nZXRQcml2YXRlTmFtZVNWKG5vZGUua2V5KSwga2luZCwgbm9kZS5rZXkubG9jLnN0YXJ0KTtcbiAgfVxuICBwYXJzZVBvc3RNZW1iZXJOYW1lTW9kaWZpZXJzKG1ldGhvZE9yUHJvcCkge31cbiAgcGFyc2VDbGFzc1ByaXZhdGVQcm9wZXJ0eShub2RlKSB7XG4gICAgdGhpcy5wYXJzZUluaXRpYWxpemVyKG5vZGUpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkNsYXNzUHJpdmF0ZVByb3BlcnR5XCIpO1xuICB9XG4gIHBhcnNlQ2xhc3NQcm9wZXJ0eShub2RlKSB7XG4gICAgdGhpcy5wYXJzZUluaXRpYWxpemVyKG5vZGUpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkNsYXNzUHJvcGVydHlcIik7XG4gIH1cbiAgcGFyc2VDbGFzc0FjY2Vzc29yUHJvcGVydHkobm9kZSkge1xuICAgIHRoaXMucGFyc2VJbml0aWFsaXplcihub2RlKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJDbGFzc0FjY2Vzc29yUHJvcGVydHlcIik7XG4gIH1cbiAgcGFyc2VJbml0aWFsaXplcihub2RlKSB7XG4gICAgdGhpcy5zY29wZS5lbnRlcig1NzYgfCAxNik7XG4gICAgdGhpcy5leHByZXNzaW9uU2NvcGUuZW50ZXIobmV3RXhwcmVzc2lvblNjb3BlKCkpO1xuICAgIHRoaXMucHJvZFBhcmFtLmVudGVyKDApO1xuICAgIG5vZGUudmFsdWUgPSB0aGlzLmVhdCgyOSkgPyB0aGlzLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKCkgOiBudWxsO1xuICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLmV4aXQoKTtcbiAgICB0aGlzLnByb2RQYXJhbS5leGl0KCk7XG4gICAgdGhpcy5zY29wZS5leGl0KCk7XG4gIH1cbiAgcGFyc2VDbGFzc0lkKG5vZGUsIGlzU3RhdGVtZW50LCBvcHRpb25hbElkLCBiaW5kaW5nVHlwZSA9IDgzMzEpIHtcbiAgICBpZiAodG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgbm9kZS5pZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICBpZiAoaXNTdGF0ZW1lbnQpIHtcbiAgICAgICAgdGhpcy5kZWNsYXJlTmFtZUZyb21JZGVudGlmaWVyKG5vZGUuaWQsIGJpbmRpbmdUeXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9wdGlvbmFsSWQgfHwgIWlzU3RhdGVtZW50KSB7XG4gICAgICAgIG5vZGUuaWQgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuTWlzc2luZ0NsYXNzTmFtZSwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBhcnNlQ2xhc3NTdXBlcihub2RlKSB7XG4gICAgbm9kZS5zdXBlckNsYXNzID0gdGhpcy5lYXQoODEpID8gdGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKCkgOiBudWxsO1xuICB9XG4gIHBhcnNlRXhwb3J0KG5vZGUsIGRlY29yYXRvcnMpIHtcbiAgICBjb25zdCBtYXliZURlZmF1bHRJZGVudGlmaWVyID0gdGhpcy5wYXJzZU1heWJlSW1wb3J0UGhhc2Uobm9kZSwgdHJ1ZSk7XG4gICAgY29uc3QgaGFzRGVmYXVsdCA9IHRoaXMubWF5YmVQYXJzZUV4cG9ydERlZmF1bHRTcGVjaWZpZXIobm9kZSwgbWF5YmVEZWZhdWx0SWRlbnRpZmllcik7XG4gICAgY29uc3QgcGFyc2VBZnRlckRlZmF1bHQgPSAhaGFzRGVmYXVsdCB8fCB0aGlzLmVhdCgxMik7XG4gICAgY29uc3QgaGFzU3RhciA9IHBhcnNlQWZ0ZXJEZWZhdWx0ICYmIHRoaXMuZWF0RXhwb3J0U3Rhcihub2RlKTtcbiAgICBjb25zdCBoYXNOYW1lc3BhY2UgPSBoYXNTdGFyICYmIHRoaXMubWF5YmVQYXJzZUV4cG9ydE5hbWVzcGFjZVNwZWNpZmllcihub2RlKTtcbiAgICBjb25zdCBwYXJzZUFmdGVyTmFtZXNwYWNlID0gcGFyc2VBZnRlckRlZmF1bHQgJiYgKCFoYXNOYW1lc3BhY2UgfHwgdGhpcy5lYXQoMTIpKTtcbiAgICBjb25zdCBpc0Zyb21SZXF1aXJlZCA9IGhhc0RlZmF1bHQgfHwgaGFzU3RhcjtcbiAgICBpZiAoaGFzU3RhciAmJiAhaGFzTmFtZXNwYWNlKSB7XG4gICAgICBpZiAoaGFzRGVmYXVsdCkgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICBpZiAoZGVjb3JhdG9ycykge1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5VbnN1cHBvcnRlZERlY29yYXRvckV4cG9ydCwgbm9kZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnBhcnNlRXhwb3J0RnJvbShub2RlLCB0cnVlKTtcbiAgICAgIHRoaXMuc2F3VW5hbWJpZ3VvdXNFU00gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIpO1xuICAgIH1cbiAgICBjb25zdCBoYXNTcGVjaWZpZXJzID0gdGhpcy5tYXliZVBhcnNlRXhwb3J0TmFtZWRTcGVjaWZpZXJzKG5vZGUpO1xuICAgIGlmIChoYXNEZWZhdWx0ICYmIHBhcnNlQWZ0ZXJEZWZhdWx0ICYmICFoYXNTdGFyICYmICFoYXNTcGVjaWZpZXJzKSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQobnVsbCwgNSk7XG4gICAgfVxuICAgIGlmIChoYXNOYW1lc3BhY2UgJiYgcGFyc2VBZnRlck5hbWVzcGFjZSkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKG51bGwsIDk4KTtcbiAgICB9XG4gICAgbGV0IGhhc0RlY2xhcmF0aW9uO1xuICAgIGlmIChpc0Zyb21SZXF1aXJlZCB8fCBoYXNTcGVjaWZpZXJzKSB7XG4gICAgICBoYXNEZWNsYXJhdGlvbiA9IGZhbHNlO1xuICAgICAgaWYgKGRlY29yYXRvcnMpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuVW5zdXBwb3J0ZWREZWNvcmF0b3JFeHBvcnQsIG5vZGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5wYXJzZUV4cG9ydEZyb20obm9kZSwgaXNGcm9tUmVxdWlyZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYXNEZWNsYXJhdGlvbiA9IHRoaXMubWF5YmVQYXJzZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUpO1xuICAgIH1cbiAgICBpZiAoaXNGcm9tUmVxdWlyZWQgfHwgaGFzU3BlY2lmaWVycyB8fCBoYXNEZWNsYXJhdGlvbikge1xuICAgICAgdmFyIF9ub2RlMiRkZWNsYXJhdGlvbjtcbiAgICAgIGNvbnN0IG5vZGUyID0gbm9kZTtcbiAgICAgIHRoaXMuY2hlY2tFeHBvcnQobm9kZTIsIHRydWUsIGZhbHNlLCAhIW5vZGUyLnNvdXJjZSk7XG4gICAgICBpZiAoKChfbm9kZTIkZGVjbGFyYXRpb24gPSBub2RlMi5kZWNsYXJhdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlMiRkZWNsYXJhdGlvbi50eXBlKSA9PT0gXCJDbGFzc0RlY2xhcmF0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5tYXliZVRha2VEZWNvcmF0b3JzKGRlY29yYXRvcnMsIG5vZGUyLmRlY2xhcmF0aW9uLCBub2RlMik7XG4gICAgICB9IGVsc2UgaWYgKGRlY29yYXRvcnMpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuVW5zdXBwb3J0ZWREZWNvcmF0b3JFeHBvcnQsIG5vZGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5zYXdVbmFtYmlndW91c0VTTSA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUyLCBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIik7XG4gICAgfVxuICAgIGlmICh0aGlzLmVhdCg2NSkpIHtcbiAgICAgIGNvbnN0IG5vZGUyID0gbm9kZTtcbiAgICAgIGNvbnN0IGRlY2wgPSB0aGlzLnBhcnNlRXhwb3J0RGVmYXVsdEV4cHJlc3Npb24oKTtcbiAgICAgIG5vZGUyLmRlY2xhcmF0aW9uID0gZGVjbDtcbiAgICAgIGlmIChkZWNsLnR5cGUgPT09IFwiQ2xhc3NEZWNsYXJhdGlvblwiKSB7XG4gICAgICAgIHRoaXMubWF5YmVUYWtlRGVjb3JhdG9ycyhkZWNvcmF0b3JzLCBkZWNsLCBub2RlMik7XG4gICAgICB9IGVsc2UgaWYgKGRlY29yYXRvcnMpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuVW5zdXBwb3J0ZWREZWNvcmF0b3JFeHBvcnQsIG5vZGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5jaGVja0V4cG9ydChub2RlMiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICB0aGlzLnNhd1VuYW1iaWd1b3VzRVNNID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZTIsIFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIpO1xuICAgIH1cbiAgICB0aGlzLnVuZXhwZWN0ZWQobnVsbCwgNSk7XG4gIH1cbiAgZWF0RXhwb3J0U3Rhcihub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuZWF0KDU1KTtcbiAgfVxuICBtYXliZVBhcnNlRXhwb3J0RGVmYXVsdFNwZWNpZmllcihub2RlLCBtYXliZURlZmF1bHRJZGVudGlmaWVyKSB7XG4gICAgaWYgKG1heWJlRGVmYXVsdElkZW50aWZpZXIgfHwgdGhpcy5pc0V4cG9ydERlZmF1bHRTcGVjaWZpZXIoKSkge1xuICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJleHBvcnREZWZhdWx0RnJvbVwiLCBtYXliZURlZmF1bHRJZGVudGlmaWVyID09IG51bGwgPyB2b2lkIDAgOiBtYXliZURlZmF1bHRJZGVudGlmaWVyLmxvYy5zdGFydCk7XG4gICAgICBjb25zdCBpZCA9IG1heWJlRGVmYXVsdElkZW50aWZpZXIgfHwgdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG4gICAgICBjb25zdCBzcGVjaWZpZXIgPSB0aGlzLnN0YXJ0Tm9kZUF0Tm9kZShpZCk7XG4gICAgICBzcGVjaWZpZXIuZXhwb3J0ZWQgPSBpZDtcbiAgICAgIG5vZGUuc3BlY2lmaWVycyA9IFt0aGlzLmZpbmlzaE5vZGUoc3BlY2lmaWVyLCBcIkV4cG9ydERlZmF1bHRTcGVjaWZpZXJcIildO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBtYXliZVBhcnNlRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyKG5vZGUpIHtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoOTMpKSB7XG4gICAgICB2YXIgX3JlZiwgX3JlZiRzcGVjaWZpZXJzO1xuICAgICAgKF9yZWYkc3BlY2lmaWVycyA9IChfcmVmID0gbm9kZSkuc3BlY2lmaWVycykgIT0gbnVsbCA/IF9yZWYkc3BlY2lmaWVycyA6IF9yZWYuc3BlY2lmaWVycyA9IFtdO1xuICAgICAgY29uc3Qgc3BlY2lmaWVyID0gdGhpcy5zdGFydE5vZGVBdCh0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYyk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHNwZWNpZmllci5leHBvcnRlZCA9IHRoaXMucGFyc2VNb2R1bGVFeHBvcnROYW1lKCk7XG4gICAgICBub2RlLnNwZWNpZmllcnMucHVzaCh0aGlzLmZpbmlzaE5vZGUoc3BlY2lmaWVyLCBcIkV4cG9ydE5hbWVzcGFjZVNwZWNpZmllclwiKSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIG1heWJlUGFyc2VFeHBvcnROYW1lZFNwZWNpZmllcnMobm9kZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKDUpKSB7XG4gICAgICBjb25zdCBub2RlMiA9IG5vZGU7XG4gICAgICBpZiAoIW5vZGUyLnNwZWNpZmllcnMpIG5vZGUyLnNwZWNpZmllcnMgPSBbXTtcbiAgICAgIGNvbnN0IGlzVHlwZUV4cG9ydCA9IG5vZGUyLmV4cG9ydEtpbmQgPT09IFwidHlwZVwiO1xuICAgICAgbm9kZTIuc3BlY2lmaWVycy5wdXNoKC4uLnRoaXMucGFyc2VFeHBvcnRTcGVjaWZpZXJzKGlzVHlwZUV4cG9ydCkpO1xuICAgICAgbm9kZTIuc291cmNlID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLmhhc1BsdWdpbihcImltcG9ydEFzc2VydGlvbnNcIikpIHtcbiAgICAgICAgbm9kZTIuYXNzZXJ0aW9ucyA9IFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZTIuYXR0cmlidXRlcyA9IFtdO1xuICAgICAgfVxuICAgICAgbm9kZTIuZGVjbGFyYXRpb24gPSBudWxsO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBtYXliZVBhcnNlRXhwb3J0RGVjbGFyYXRpb24obm9kZSkge1xuICAgIGlmICh0aGlzLnNob3VsZFBhcnNlRXhwb3J0RGVjbGFyYXRpb24oKSkge1xuICAgICAgbm9kZS5zcGVjaWZpZXJzID0gW107XG4gICAgICBub2RlLnNvdXJjZSA9IG51bGw7XG4gICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJpbXBvcnRBc3NlcnRpb25zXCIpKSB7XG4gICAgICAgIG5vZGUuYXNzZXJ0aW9ucyA9IFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5hdHRyaWJ1dGVzID0gW107XG4gICAgICB9XG4gICAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpc0FzeW5jRnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmlzQ29udGV4dHVhbCg5NSkpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5uZXh0VG9rZW5JbkxpbmVTdGFydCgpO1xuICAgIHJldHVybiB0aGlzLmlzVW5wYXJzZWRDb250ZXh0dWFsKG5leHQsIFwiZnVuY3Rpb25cIik7XG4gIH1cbiAgcGFyc2VFeHBvcnREZWZhdWx0RXhwcmVzc2lvbigpIHtcbiAgICBjb25zdCBleHByID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBpZiAodGhpcy5tYXRjaCg2OCkpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihleHByLCAxIHwgNCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQXN5bmNGdW5jdGlvbigpKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihleHByLCAxIHwgNCB8IDgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXRjaCg4MCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3MoZXhwciwgdHJ1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hdGNoKDI2KSkge1xuICAgICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwiZGVjb3JhdG9yc1wiKSAmJiB0aGlzLmdldFBsdWdpbk9wdGlvbihcImRlY29yYXRvcnNcIiwgXCJkZWNvcmF0b3JzQmVmb3JlRXhwb3J0XCIpID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkRlY29yYXRvckJlZm9yZUV4cG9ydCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKHRoaXMubWF5YmVUYWtlRGVjb3JhdG9ycyh0aGlzLnBhcnNlRGVjb3JhdG9ycyhmYWxzZSksIHRoaXMuc3RhcnROb2RlKCkpLCB0cnVlLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF0Y2goNzUpIHx8IHRoaXMubWF0Y2goNzQpIHx8IHRoaXMuaXNMZXQoKSB8fCB0aGlzLmlzVXNpbmcoKSB8fCB0aGlzLmlzQXdhaXRVc2luZygpKSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5VbnN1cHBvcnRlZERlZmF1bHRFeHBvcnQsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIHBhcnNlRXhwb3J0RGVjbGFyYXRpb24obm9kZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKDgwKSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMucGFyc2VDbGFzcyh0aGlzLnN0YXJ0Tm9kZSgpLCB0cnVlLCBmYWxzZSk7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpO1xuICB9XG4gIGlzRXhwb3J0RGVmYXVsdFNwZWNpZmllcigpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHRva2VuSXNJZGVudGlmaWVyKHR5cGUpKSB7XG4gICAgICBpZiAodHlwZSA9PT0gOTUgJiYgIXRoaXMuc3RhdGUuY29udGFpbnNFc2MgfHwgdHlwZSA9PT0gMTAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICgodHlwZSA9PT0gMTMwIHx8IHR5cGUgPT09IDEyOSkgJiYgIXRoaXMuc3RhdGUuY29udGFpbnNFc2MpIHtcbiAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMubmV4dFRva2VuU3RhcnQoKTtcbiAgICAgICAgY29uc3QgbmV4dENoYXIgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQobmV4dCk7XG4gICAgICAgIGlmIChuZXh0Q2hhciA9PT0gMTIzIHx8IHRoaXMuY2hTdGFydHNCaW5kaW5nSWRlbnRpZmllcihuZXh0Q2hhciwgbmV4dCkgJiYgIXRoaXMuaW5wdXQuc3RhcnRzV2l0aChcImZyb21cIiwgbmV4dCkpIHtcbiAgICAgICAgICB0aGlzLmV4cGVjdE9uZVBsdWdpbihbXCJmbG93XCIsIFwidHlwZXNjcmlwdFwiXSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghdGhpcy5tYXRjaCg2NSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbmV4dCA9IHRoaXMubmV4dFRva2VuU3RhcnQoKTtcbiAgICBjb25zdCBoYXNGcm9tID0gdGhpcy5pc1VucGFyc2VkQ29udGV4dHVhbChuZXh0LCBcImZyb21cIik7XG4gICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdChuZXh0KSA9PT0gNDQgfHwgdG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSAmJiBoYXNGcm9tKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF0Y2goNjUpICYmIGhhc0Zyb20pIHtcbiAgICAgIGNvbnN0IG5leHRBZnRlckZyb20gPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5uZXh0VG9rZW5TdGFydFNpbmNlKG5leHQgKyA0KSk7XG4gICAgICByZXR1cm4gbmV4dEFmdGVyRnJvbSA9PT0gMzQgfHwgbmV4dEFmdGVyRnJvbSA9PT0gMzk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBwYXJzZUV4cG9ydEZyb20obm9kZSwgZXhwZWN0KSB7XG4gICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbCg5OCkpIHtcbiAgICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZUltcG9ydFNvdXJjZSgpO1xuICAgICAgdGhpcy5jaGVja0V4cG9ydChub2RlKTtcbiAgICAgIHRoaXMubWF5YmVQYXJzZUltcG9ydEF0dHJpYnV0ZXMobm9kZSk7XG4gICAgICB0aGlzLmNoZWNrSlNPTk1vZHVsZUltcG9ydChub2RlKTtcbiAgICB9IGVsc2UgaWYgKGV4cGVjdCkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gIH1cbiAgc2hvdWxkUGFyc2VFeHBvcnREZWNsYXJhdGlvbigpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHR5cGUgPT09IDI2KSB7XG4gICAgICB0aGlzLmV4cGVjdE9uZVBsdWdpbihbXCJkZWNvcmF0b3JzXCIsIFwiZGVjb3JhdG9ycy1sZWdhY3lcIl0pO1xuICAgICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwiZGVjb3JhdG9yc1wiKSkge1xuICAgICAgICBpZiAodGhpcy5nZXRQbHVnaW5PcHRpb24oXCJkZWNvcmF0b3JzXCIsIFwiZGVjb3JhdG9yc0JlZm9yZUV4cG9ydFwiKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkRlY29yYXRvckJlZm9yZUV4cG9ydCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmlzVXNpbmcoKSkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVXNpbmdEZWNsYXJhdGlvbkV4cG9ydCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNBd2FpdFVzaW5nKCkpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVzaW5nRGVjbGFyYXRpb25FeHBvcnQsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0eXBlID09PSA3NCB8fCB0eXBlID09PSA3NSB8fCB0eXBlID09PSA2OCB8fCB0eXBlID09PSA4MCB8fCB0aGlzLmlzTGV0KCkgfHwgdGhpcy5pc0FzeW5jRnVuY3Rpb24oKTtcbiAgfVxuICBjaGVja0V4cG9ydChub2RlLCBjaGVja05hbWVzLCBpc0RlZmF1bHQsIGlzRnJvbSkge1xuICAgIGlmIChjaGVja05hbWVzKSB7XG4gICAgICB2YXIgX25vZGUkc3BlY2lmaWVycztcbiAgICAgIGlmIChpc0RlZmF1bHQpIHtcbiAgICAgICAgdGhpcy5jaGVja0R1cGxpY2F0ZUV4cG9ydHMobm9kZSwgXCJkZWZhdWx0XCIpO1xuICAgICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJleHBvcnREZWZhdWx0RnJvbVwiKSkge1xuICAgICAgICAgIHZhciBfZGVjbGFyYXRpb24kZXh0cmE7XG4gICAgICAgICAgY29uc3QgZGVjbGFyYXRpb24gPSBub2RlLmRlY2xhcmF0aW9uO1xuICAgICAgICAgIGlmIChkZWNsYXJhdGlvbi50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBkZWNsYXJhdGlvbi5uYW1lID09PSBcImZyb21cIiAmJiBkZWNsYXJhdGlvbi5lbmQgLSBkZWNsYXJhdGlvbi5zdGFydCA9PT0gNCAmJiAhKChfZGVjbGFyYXRpb24kZXh0cmEgPSBkZWNsYXJhdGlvbi5leHRyYSkgIT0gbnVsbCAmJiBfZGVjbGFyYXRpb24kZXh0cmEucGFyZW50aGVzaXplZCkpIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkV4cG9ydERlZmF1bHRGcm9tQXNJZGVudGlmaWVyLCBkZWNsYXJhdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKChfbm9kZSRzcGVjaWZpZXJzID0gbm9kZS5zcGVjaWZpZXJzKSAhPSBudWxsICYmIF9ub2RlJHNwZWNpZmllcnMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc3BlY2lmaWVyIG9mIG5vZGUuc3BlY2lmaWVycykge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGV4cG9ydGVkXG4gICAgICAgICAgfSA9IHNwZWNpZmllcjtcbiAgICAgICAgICBjb25zdCBleHBvcnROYW1lID0gZXhwb3J0ZWQudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgPyBleHBvcnRlZC5uYW1lIDogZXhwb3J0ZWQudmFsdWU7XG4gICAgICAgICAgdGhpcy5jaGVja0R1cGxpY2F0ZUV4cG9ydHMoc3BlY2lmaWVyLCBleHBvcnROYW1lKTtcbiAgICAgICAgICBpZiAoIWlzRnJvbSAmJiBzcGVjaWZpZXIubG9jYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgbG9jYWxcbiAgICAgICAgICAgIH0gPSBzcGVjaWZpZXI7XG4gICAgICAgICAgICBpZiAobG9jYWwudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICAgICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRXhwb3J0QmluZGluZ0lzU3RyaW5nLCBzcGVjaWZpZXIsIHtcbiAgICAgICAgICAgICAgICBsb2NhbE5hbWU6IGxvY2FsLnZhbHVlLFxuICAgICAgICAgICAgICAgIGV4cG9ydE5hbWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmNoZWNrUmVzZXJ2ZWRXb3JkKGxvY2FsLm5hbWUsIGxvY2FsLmxvYy5zdGFydCwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICB0aGlzLnNjb3BlLmNoZWNrTG9jYWxFeHBvcnQobG9jYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlLmRlY2xhcmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGRlY2wgPSBub2RlLmRlY2xhcmF0aW9uO1xuICAgICAgICBpZiAoZGVjbC50eXBlID09PSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiB8fCBkZWNsLnR5cGUgPT09IFwiQ2xhc3NEZWNsYXJhdGlvblwiKSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgaWRcbiAgICAgICAgICB9ID0gZGVjbDtcbiAgICAgICAgICBpZiAoIWlkKSB0aHJvdyBuZXcgRXJyb3IoXCJBc3NlcnRpb24gZmFpbHVyZVwiKTtcbiAgICAgICAgICB0aGlzLmNoZWNrRHVwbGljYXRlRXhwb3J0cyhub2RlLCBpZC5uYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChkZWNsLnR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBkZWNsYXJhdGlvbiBvZiBkZWNsLmRlY2xhcmF0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5jaGVja0RlY2xhcmF0aW9uKGRlY2xhcmF0aW9uLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2hlY2tEZWNsYXJhdGlvbihub2RlKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICAgIHRoaXMuY2hlY2tEdXBsaWNhdGVFeHBvcnRzKG5vZGUsIG5vZGUubmFtZSk7XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiT2JqZWN0UGF0dGVyblwiKSB7XG4gICAgICBmb3IgKGNvbnN0IHByb3Agb2Ygbm9kZS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tEZWNsYXJhdGlvbihwcm9wKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJBcnJheVBhdHRlcm5cIikge1xuICAgICAgZm9yIChjb25zdCBlbGVtIG9mIG5vZGUuZWxlbWVudHMpIHtcbiAgICAgICAgaWYgKGVsZW0pIHtcbiAgICAgICAgICB0aGlzLmNoZWNrRGVjbGFyYXRpb24oZWxlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJPYmplY3RQcm9wZXJ0eVwiKSB7XG4gICAgICB0aGlzLmNoZWNrRGVjbGFyYXRpb24obm9kZS52YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIikge1xuICAgICAgdGhpcy5jaGVja0RlY2xhcmF0aW9uKG5vZGUuYXJndW1lbnQpO1xuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpIHtcbiAgICAgIHRoaXMuY2hlY2tEZWNsYXJhdGlvbihub2RlLmxlZnQpO1xuICAgIH1cbiAgfVxuICBjaGVja0R1cGxpY2F0ZUV4cG9ydHMobm9kZSwgZXhwb3J0TmFtZSkge1xuICAgIGlmICh0aGlzLmV4cG9ydGVkSWRlbnRpZmllcnMuaGFzKGV4cG9ydE5hbWUpKSB7XG4gICAgICBpZiAoZXhwb3J0TmFtZSA9PT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRHVwbGljYXRlRGVmYXVsdEV4cG9ydCwgbm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5EdXBsaWNhdGVFeHBvcnQsIG5vZGUsIHtcbiAgICAgICAgICBleHBvcnROYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmV4cG9ydGVkSWRlbnRpZmllcnMuYWRkKGV4cG9ydE5hbWUpO1xuICB9XG4gIHBhcnNlRXhwb3J0U3BlY2lmaWVycyhpc0luVHlwZUV4cG9ydCkge1xuICAgIGNvbnN0IG5vZGVzID0gW107XG4gICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICB0aGlzLmV4cGVjdCg1KTtcbiAgICB3aGlsZSAoIXRoaXMuZWF0KDgpKSB7XG4gICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KDEyKTtcbiAgICAgICAgaWYgKHRoaXMuZWF0KDgpKSBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzTWF5YmVUeXBlT25seSA9IHRoaXMuaXNDb250ZXh0dWFsKDEzMCk7XG4gICAgICBjb25zdCBpc1N0cmluZyA9IHRoaXMubWF0Y2goMTM0KTtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgbm9kZS5sb2NhbCA9IHRoaXMucGFyc2VNb2R1bGVFeHBvcnROYW1lKCk7XG4gICAgICBub2Rlcy5wdXNoKHRoaXMucGFyc2VFeHBvcnRTcGVjaWZpZXIobm9kZSwgaXNTdHJpbmcsIGlzSW5UeXBlRXhwb3J0LCBpc01heWJlVHlwZU9ubHkpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzO1xuICB9XG4gIHBhcnNlRXhwb3J0U3BlY2lmaWVyKG5vZGUsIGlzU3RyaW5nLCBpc0luVHlwZUV4cG9ydCwgaXNNYXliZVR5cGVPbmx5KSB7XG4gICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbCg5MykpIHtcbiAgICAgIG5vZGUuZXhwb3J0ZWQgPSB0aGlzLnBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpO1xuICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcpIHtcbiAgICAgIG5vZGUuZXhwb3J0ZWQgPSB0aGlzLmNsb25lU3RyaW5nTGl0ZXJhbChub2RlLmxvY2FsKTtcbiAgICB9IGVsc2UgaWYgKCFub2RlLmV4cG9ydGVkKSB7XG4gICAgICBub2RlLmV4cG9ydGVkID0gdGhpcy5jbG9uZUlkZW50aWZpZXIobm9kZS5sb2NhbCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRTcGVjaWZpZXJcIik7XG4gIH1cbiAgcGFyc2VNb2R1bGVFeHBvcnROYW1lKCkge1xuICAgIGlmICh0aGlzLm1hdGNoKDEzNCkpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucGFyc2VTdHJpbmdMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpO1xuICAgICAgY29uc3Qgc3Vycm9nYXRlID0gbG9uZVN1cnJvZ2F0ZS5leGVjKHJlc3VsdC52YWx1ZSk7XG4gICAgICBpZiAoc3Vycm9nYXRlKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLk1vZHVsZUV4cG9ydE5hbWVIYXNMb25lU3Vycm9nYXRlLCByZXN1bHQsIHtcbiAgICAgICAgICBzdXJyb2dhdGVDaGFyQ29kZTogc3Vycm9nYXRlWzBdLmNoYXJDb2RlQXQoMClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG4gIH1cbiAgaXNKU09OTW9kdWxlSW1wb3J0KG5vZGUpIHtcbiAgICBpZiAobm9kZS5hc3NlcnRpb25zICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBub2RlLmFzc2VydGlvbnMuc29tZSgoe1xuICAgICAgICBrZXksXG4gICAgICAgIHZhbHVlXG4gICAgICB9KSA9PiB7XG4gICAgICAgIHJldHVybiB2YWx1ZS52YWx1ZSA9PT0gXCJqc29uXCIgJiYgKGtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiA/IGtleS5uYW1lID09PSBcInR5cGVcIiA6IGtleS52YWx1ZSA9PT0gXCJ0eXBlXCIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjaGVja0ltcG9ydFJlZmxlY3Rpb24obm9kZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNwZWNpZmllcnNcbiAgICB9ID0gbm9kZTtcbiAgICBjb25zdCBzaW5nbGVCaW5kaW5nVHlwZSA9IHNwZWNpZmllcnMubGVuZ3RoID09PSAxID8gc3BlY2lmaWVyc1swXS50eXBlIDogbnVsbDtcbiAgICBpZiAobm9kZS5waGFzZSA9PT0gXCJzb3VyY2VcIikge1xuICAgICAgaWYgKHNpbmdsZUJpbmRpbmdUeXBlICE9PSBcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIikge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Tb3VyY2VQaGFzZUltcG9ydFJlcXVpcmVzRGVmYXVsdCwgc3BlY2lmaWVyc1swXS5sb2Muc3RhcnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS5waGFzZSA9PT0gXCJkZWZlclwiKSB7XG4gICAgICBpZiAoc2luZ2xlQmluZGluZ1R5cGUgIT09IFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRGVmZXJJbXBvcnRSZXF1aXJlc05hbWVzcGFjZSwgc3BlY2lmaWVyc1swXS5sb2Muc3RhcnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS5tb2R1bGUpIHtcbiAgICAgIHZhciBfbm9kZSRhc3NlcnRpb25zO1xuICAgICAgaWYgKHNpbmdsZUJpbmRpbmdUeXBlICE9PSBcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIikge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbXBvcnRSZWZsZWN0aW9uTm90QmluZGluZywgc3BlY2lmaWVyc1swXS5sb2Muc3RhcnQpO1xuICAgICAgfVxuICAgICAgaWYgKCgoX25vZGUkYXNzZXJ0aW9ucyA9IG5vZGUuYXNzZXJ0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGFzc2VydGlvbnMubGVuZ3RoKSA+IDApIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW1wb3J0UmVmbGVjdGlvbkhhc0Fzc2VydGlvbiwgc3BlY2lmaWVyc1swXS5sb2Muc3RhcnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjaGVja0pTT05Nb2R1bGVJbXBvcnQobm9kZSkge1xuICAgIGlmICh0aGlzLmlzSlNPTk1vZHVsZUltcG9ydChub2RlKSAmJiBub2RlLnR5cGUgIT09IFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIikge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzcGVjaWZpZXJzXG4gICAgICB9ID0gbm9kZTtcbiAgICAgIGlmIChzcGVjaWZpZXJzICE9IG51bGwpIHtcbiAgICAgICAgY29uc3Qgbm9uRGVmYXVsdE5hbWVkU3BlY2lmaWVyID0gc3BlY2lmaWVycy5maW5kKHNwZWNpZmllciA9PiB7XG4gICAgICAgICAgbGV0IGltcG9ydGVkO1xuICAgICAgICAgIGlmIChzcGVjaWZpZXIudHlwZSA9PT0gXCJFeHBvcnRTcGVjaWZpZXJcIikge1xuICAgICAgICAgICAgaW1wb3J0ZWQgPSBzcGVjaWZpZXIubG9jYWw7XG4gICAgICAgICAgfSBlbHNlIGlmIChzcGVjaWZpZXIudHlwZSA9PT0gXCJJbXBvcnRTcGVjaWZpZXJcIikge1xuICAgICAgICAgICAgaW1wb3J0ZWQgPSBzcGVjaWZpZXIuaW1wb3J0ZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbXBvcnRlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaW1wb3J0ZWQudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgPyBpbXBvcnRlZC5uYW1lICE9PSBcImRlZmF1bHRcIiA6IGltcG9ydGVkLnZhbHVlICE9PSBcImRlZmF1bHRcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobm9uRGVmYXVsdE5hbWVkU3BlY2lmaWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbXBvcnRKU09OQmluZGluZ05vdERlZmF1bHQsIG5vbkRlZmF1bHROYW1lZFNwZWNpZmllci5sb2Muc3RhcnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlzUG90ZW50aWFsSW1wb3J0UGhhc2UoaXNFeHBvcnQpIHtcbiAgICBpZiAoaXNFeHBvcnQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5pc0NvbnRleHR1YWwoMTA1KSB8fCB0aGlzLmlzQ29udGV4dHVhbCg5NykgfHwgdGhpcy5pc0NvbnRleHR1YWwoMTI3KTtcbiAgfVxuICBhcHBseUltcG9ydFBoYXNlKG5vZGUsIGlzRXhwb3J0LCBwaGFzZSwgbG9jKSB7XG4gICAgaWYgKGlzRXhwb3J0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwaGFzZSA9PT0gXCJtb2R1bGVcIikge1xuICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJpbXBvcnRSZWZsZWN0aW9uXCIsIGxvYyk7XG4gICAgICBub2RlLm1vZHVsZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmhhc1BsdWdpbihcImltcG9ydFJlZmxlY3Rpb25cIikpIHtcbiAgICAgIG5vZGUubW9kdWxlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwaGFzZSA9PT0gXCJzb3VyY2VcIikge1xuICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJzb3VyY2VQaGFzZUltcG9ydHNcIiwgbG9jKTtcbiAgICAgIG5vZGUucGhhc2UgPSBcInNvdXJjZVwiO1xuICAgIH0gZWxzZSBpZiAocGhhc2UgPT09IFwiZGVmZXJcIikge1xuICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJkZWZlcnJlZEltcG9ydEV2YWx1YXRpb25cIiwgbG9jKTtcbiAgICAgIG5vZGUucGhhc2UgPSBcImRlZmVyXCI7XG4gICAgfSBlbHNlIGlmICh0aGlzLmhhc1BsdWdpbihcInNvdXJjZVBoYXNlSW1wb3J0c1wiKSkge1xuICAgICAgbm9kZS5waGFzZSA9IG51bGw7XG4gICAgfVxuICB9XG4gIHBhcnNlTWF5YmVJbXBvcnRQaGFzZShub2RlLCBpc0V4cG9ydCkge1xuICAgIGlmICghdGhpcy5pc1BvdGVudGlhbEltcG9ydFBoYXNlKGlzRXhwb3J0KSkge1xuICAgICAgdGhpcy5hcHBseUltcG9ydFBoYXNlKG5vZGUsIGlzRXhwb3J0LCBudWxsKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBwaGFzZUlkZW50aWZpZXIgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGNvbnN0IHBoYXNlSWRlbnRpZmllck5hbWUgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUodHJ1ZSk7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGlzSW1wb3J0UGhhc2UgPSB0b2tlbklzS2V5d29yZE9ySWRlbnRpZmllcih0eXBlKSA/IHR5cGUgIT09IDk4IHx8IHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKSA9PT0gMTAyIDogdHlwZSAhPT0gMTI7XG4gICAgaWYgKGlzSW1wb3J0UGhhc2UpIHtcbiAgICAgIHRoaXMuYXBwbHlJbXBvcnRQaGFzZShub2RlLCBpc0V4cG9ydCwgcGhhc2VJZGVudGlmaWVyTmFtZSwgcGhhc2VJZGVudGlmaWVyLmxvYy5zdGFydCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hcHBseUltcG9ydFBoYXNlKG5vZGUsIGlzRXhwb3J0LCBudWxsKTtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUlkZW50aWZpZXIocGhhc2VJZGVudGlmaWVyLCBwaGFzZUlkZW50aWZpZXJOYW1lKTtcbiAgICB9XG4gIH1cbiAgaXNQcmVjZWRpbmdJZEltcG9ydFBoYXNlKHBoYXNlKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIHJldHVybiB0b2tlbklzSWRlbnRpZmllcih0eXBlKSA/IHR5cGUgIT09IDk4IHx8IHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKSA9PT0gMTAyIDogdHlwZSAhPT0gMTI7XG4gIH1cbiAgcGFyc2VJbXBvcnQobm9kZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKDEzNCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlSW1wb3J0U291cmNlQW5kQXR0cmlidXRlcyhub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VJbXBvcnRTcGVjaWZpZXJzQW5kQWZ0ZXIobm9kZSwgdGhpcy5wYXJzZU1heWJlSW1wb3J0UGhhc2Uobm9kZSwgZmFsc2UpKTtcbiAgfVxuICBwYXJzZUltcG9ydFNwZWNpZmllcnNBbmRBZnRlcihub2RlLCBtYXliZURlZmF1bHRJZGVudGlmaWVyKSB7XG4gICAgbm9kZS5zcGVjaWZpZXJzID0gW107XG4gICAgY29uc3QgaGFzRGVmYXVsdCA9IHRoaXMubWF5YmVQYXJzZURlZmF1bHRJbXBvcnRTcGVjaWZpZXIobm9kZSwgbWF5YmVEZWZhdWx0SWRlbnRpZmllcik7XG4gICAgY29uc3QgcGFyc2VOZXh0ID0gIWhhc0RlZmF1bHQgfHwgdGhpcy5lYXQoMTIpO1xuICAgIGNvbnN0IGhhc1N0YXIgPSBwYXJzZU5leHQgJiYgdGhpcy5tYXliZVBhcnNlU3RhckltcG9ydFNwZWNpZmllcihub2RlKTtcbiAgICBpZiAocGFyc2VOZXh0ICYmICFoYXNTdGFyKSB0aGlzLnBhcnNlTmFtZWRJbXBvcnRTcGVjaWZpZXJzKG5vZGUpO1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbCg5OCk7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VJbXBvcnRTb3VyY2VBbmRBdHRyaWJ1dGVzKG5vZGUpO1xuICB9XG4gIHBhcnNlSW1wb3J0U291cmNlQW5kQXR0cmlidXRlcyhub2RlKSB7XG4gICAgdmFyIF9ub2RlJHNwZWNpZmllcnMyO1xuICAgIChfbm9kZSRzcGVjaWZpZXJzMiA9IG5vZGUuc3BlY2lmaWVycykgIT0gbnVsbCA/IF9ub2RlJHNwZWNpZmllcnMyIDogbm9kZS5zcGVjaWZpZXJzID0gW107XG4gICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlSW1wb3J0U291cmNlKCk7XG4gICAgdGhpcy5tYXliZVBhcnNlSW1wb3J0QXR0cmlidXRlcyhub2RlKTtcbiAgICB0aGlzLmNoZWNrSW1wb3J0UmVmbGVjdGlvbihub2RlKTtcbiAgICB0aGlzLmNoZWNrSlNPTk1vZHVsZUltcG9ydChub2RlKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHRoaXMuc2F3VW5hbWJpZ3VvdXNFU00gPSB0cnVlO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnREZWNsYXJhdGlvblwiKTtcbiAgfVxuICBwYXJzZUltcG9ydFNvdXJjZSgpIHtcbiAgICBpZiAoIXRoaXMubWF0Y2goMTM0KSkgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICB9XG4gIHBhcnNlSW1wb3J0U3BlY2lmaWVyTG9jYWwobm9kZSwgc3BlY2lmaWVyLCB0eXBlKSB7XG4gICAgc3BlY2lmaWVyLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICBub2RlLnNwZWNpZmllcnMucHVzaCh0aGlzLmZpbmlzaEltcG9ydFNwZWNpZmllcihzcGVjaWZpZXIsIHR5cGUpKTtcbiAgfVxuICBmaW5pc2hJbXBvcnRTcGVjaWZpZXIoc3BlY2lmaWVyLCB0eXBlLCBiaW5kaW5nVHlwZSA9IDgyMDEpIHtcbiAgICB0aGlzLmNoZWNrTFZhbChzcGVjaWZpZXIubG9jYWwsIHtcbiAgICAgIHR5cGVcbiAgICB9LCBiaW5kaW5nVHlwZSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShzcGVjaWZpZXIsIHR5cGUpO1xuICB9XG4gIHBhcnNlSW1wb3J0QXR0cmlidXRlcygpIHtcbiAgICB0aGlzLmV4cGVjdCg1KTtcbiAgICBjb25zdCBhdHRycyA9IFtdO1xuICAgIGNvbnN0IGF0dHJOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICBkbyB7XG4gICAgICBpZiAodGhpcy5tYXRjaCg4KSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgY29uc3Qga2V5TmFtZSA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgICBpZiAoYXR0ck5hbWVzLmhhcyhrZXlOYW1lKSkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Nb2R1bGVBdHRyaWJ1dGVzV2l0aER1cGxpY2F0ZUtleXMsIHRoaXMuc3RhdGUuc3RhcnRMb2MsIHtcbiAgICAgICAgICBrZXk6IGtleU5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBhdHRyTmFtZXMuYWRkKGtleU5hbWUpO1xuICAgICAgaWYgKHRoaXMubWF0Y2goMTM0KSkge1xuICAgICAgICBub2RlLmtleSA9IHRoaXMucGFyc2VTdHJpbmdMaXRlcmFsKGtleU5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5rZXkgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhwZWN0KDE0KTtcbiAgICAgIGlmICghdGhpcy5tYXRjaCgxMzQpKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLk1vZHVsZUF0dHJpYnV0ZUludmFsaWRWYWx1ZSwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICB9XG4gICAgICBub2RlLnZhbHVlID0gdGhpcy5wYXJzZVN0cmluZ0xpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSk7XG4gICAgICBhdHRycy5wdXNoKHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydEF0dHJpYnV0ZVwiKSk7XG4gICAgfSB3aGlsZSAodGhpcy5lYXQoMTIpKTtcbiAgICB0aGlzLmV4cGVjdCg4KTtcbiAgICByZXR1cm4gYXR0cnM7XG4gIH1cbiAgcGFyc2VNb2R1bGVBdHRyaWJ1dGVzKCkge1xuICAgIGNvbnN0IGF0dHJzID0gW107XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IG5ldyBTZXQoKTtcbiAgICBkbyB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIG5vZGUua2V5ID0gdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG4gICAgICBpZiAobm9kZS5rZXkubmFtZSAhPT0gXCJ0eXBlXCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuTW9kdWxlQXR0cmlidXRlRGlmZmVyZW50RnJvbVR5cGUsIG5vZGUua2V5KTtcbiAgICAgIH1cbiAgICAgIGlmIChhdHRyaWJ1dGVzLmhhcyhub2RlLmtleS5uYW1lKSkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Nb2R1bGVBdHRyaWJ1dGVzV2l0aER1cGxpY2F0ZUtleXMsIG5vZGUua2V5LCB7XG4gICAgICAgICAga2V5OiBub2RlLmtleS5uYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYXR0cmlidXRlcy5hZGQobm9kZS5rZXkubmFtZSk7XG4gICAgICB0aGlzLmV4cGVjdCgxNCk7XG4gICAgICBpZiAoIXRoaXMubWF0Y2goMTM0KSkge1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5Nb2R1bGVBdHRyaWJ1dGVJbnZhbGlkVmFsdWUsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgfVxuICAgICAgbm9kZS52YWx1ZSA9IHRoaXMucGFyc2VTdHJpbmdMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpO1xuICAgICAgYXR0cnMucHVzaCh0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnRBdHRyaWJ1dGVcIikpO1xuICAgIH0gd2hpbGUgKHRoaXMuZWF0KDEyKSk7XG4gICAgcmV0dXJuIGF0dHJzO1xuICB9XG4gIG1heWJlUGFyc2VJbXBvcnRBdHRyaWJ1dGVzKG5vZGUpIHtcbiAgICBsZXQgYXR0cmlidXRlcztcbiAgICB7XG4gICAgICB2YXIgdXNlV2l0aCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXRjaCg3NikpIHtcbiAgICAgIGlmICh0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpICYmIHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKSA9PT0gNDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJtb2R1bGVBdHRyaWJ1dGVzXCIpKSB7XG4gICAgICAgIGF0dHJpYnV0ZXMgPSB0aGlzLnBhcnNlTW9kdWxlQXR0cmlidXRlcygpO1xuICAgICAgICB0aGlzLmFkZEV4dHJhKG5vZGUsIFwiZGVwcmVjYXRlZFdpdGhMZWdhY3lTeW50YXhcIiwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyaWJ1dGVzID0gdGhpcy5wYXJzZUltcG9ydEF0dHJpYnV0ZXMoKTtcbiAgICAgIH1cbiAgICAgIHtcbiAgICAgICAgdXNlV2l0aCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ29udGV4dHVhbCg5NCkgJiYgIXRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkpIHtcbiAgICAgIGlmICghdGhpcy5oYXNQbHVnaW4oXCJkZXByZWNhdGVkSW1wb3J0QXNzZXJ0XCIpICYmICF0aGlzLmhhc1BsdWdpbihcImltcG9ydEFzc2VydGlvbnNcIikpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW1wb3J0QXR0cmlidXRlc1VzZUFzc2VydCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuaGFzUGx1Z2luKFwiaW1wb3J0QXNzZXJ0aW9uc1wiKSkge1xuICAgICAgICB0aGlzLmFkZEV4dHJhKG5vZGUsIFwiZGVwcmVjYXRlZEFzc2VydFN5bnRheFwiLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgYXR0cmlidXRlcyA9IHRoaXMucGFyc2VJbXBvcnRBdHRyaWJ1dGVzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF0dHJpYnV0ZXMgPSBbXTtcbiAgICB9XG4gICAgaWYgKCF1c2VXaXRoICYmIHRoaXMuaGFzUGx1Z2luKFwiaW1wb3J0QXNzZXJ0aW9uc1wiKSkge1xuICAgICAgbm9kZS5hc3NlcnRpb25zID0gYXR0cmlidXRlcztcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICB9XG4gIH1cbiAgbWF5YmVQYXJzZURlZmF1bHRJbXBvcnRTcGVjaWZpZXIobm9kZSwgbWF5YmVEZWZhdWx0SWRlbnRpZmllcikge1xuICAgIGlmIChtYXliZURlZmF1bHRJZGVudGlmaWVyKSB7XG4gICAgICBjb25zdCBzcGVjaWZpZXIgPSB0aGlzLnN0YXJ0Tm9kZUF0Tm9kZShtYXliZURlZmF1bHRJZGVudGlmaWVyKTtcbiAgICAgIHNwZWNpZmllci5sb2NhbCA9IG1heWJlRGVmYXVsdElkZW50aWZpZXI7XG4gICAgICBub2RlLnNwZWNpZmllcnMucHVzaCh0aGlzLmZpbmlzaEltcG9ydFNwZWNpZmllcihzcGVjaWZpZXIsIFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiKSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRva2VuSXNLZXl3b3JkT3JJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgIHRoaXMucGFyc2VJbXBvcnRTcGVjaWZpZXJMb2NhbChub2RlLCB0aGlzLnN0YXJ0Tm9kZSgpLCBcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIG1heWJlUGFyc2VTdGFySW1wb3J0U3BlY2lmaWVyKG5vZGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCg1NSkpIHtcbiAgICAgIGNvbnN0IHNwZWNpZmllciA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbCg5Myk7XG4gICAgICB0aGlzLnBhcnNlSW1wb3J0U3BlY2lmaWVyTG9jYWwobm9kZSwgc3BlY2lmaWVyLCBcIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllclwiKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcGFyc2VOYW1lZEltcG9ydFNwZWNpZmllcnMobm9kZSkge1xuICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgdGhpcy5leHBlY3QoNSk7XG4gICAgd2hpbGUgKCF0aGlzLmVhdCg4KSkge1xuICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5lYXQoMTQpKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuRGVzdHJ1Y3R1cmVOYW1lZEltcG9ydCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5leHBlY3QoMTIpO1xuICAgICAgICBpZiAodGhpcy5lYXQoOCkpIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3BlY2lmaWVyID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIGNvbnN0IGltcG9ydGVkSXNTdHJpbmcgPSB0aGlzLm1hdGNoKDEzNCk7XG4gICAgICBjb25zdCBpc01heWJlVHlwZU9ubHkgPSB0aGlzLmlzQ29udGV4dHVhbCgxMzApO1xuICAgICAgc3BlY2lmaWVyLmltcG9ydGVkID0gdGhpcy5wYXJzZU1vZHVsZUV4cG9ydE5hbWUoKTtcbiAgICAgIGNvbnN0IGltcG9ydFNwZWNpZmllciA9IHRoaXMucGFyc2VJbXBvcnRTcGVjaWZpZXIoc3BlY2lmaWVyLCBpbXBvcnRlZElzU3RyaW5nLCBub2RlLmltcG9ydEtpbmQgPT09IFwidHlwZVwiIHx8IG5vZGUuaW1wb3J0S2luZCA9PT0gXCJ0eXBlb2ZcIiwgaXNNYXliZVR5cGVPbmx5LCB1bmRlZmluZWQpO1xuICAgICAgbm9kZS5zcGVjaWZpZXJzLnB1c2goaW1wb3J0U3BlY2lmaWVyKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VJbXBvcnRTcGVjaWZpZXIoc3BlY2lmaWVyLCBpbXBvcnRlZElzU3RyaW5nLCBpc0luVHlwZU9ubHlJbXBvcnQsIGlzTWF5YmVUeXBlT25seSwgYmluZGluZ1R5cGUpIHtcbiAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKDkzKSkge1xuICAgICAgc3BlY2lmaWVyLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qge1xuICAgICAgICBpbXBvcnRlZFxuICAgICAgfSA9IHNwZWNpZmllcjtcbiAgICAgIGlmIChpbXBvcnRlZElzU3RyaW5nKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLkltcG9ydEJpbmRpbmdJc1N0cmluZywgc3BlY2lmaWVyLCB7XG4gICAgICAgICAgaW1wb3J0TmFtZTogaW1wb3J0ZWQudmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLmNoZWNrUmVzZXJ2ZWRXb3JkKGltcG9ydGVkLm5hbWUsIHNwZWNpZmllci5sb2Muc3RhcnQsIHRydWUsIHRydWUpO1xuICAgICAgaWYgKCFzcGVjaWZpZXIubG9jYWwpIHtcbiAgICAgICAgc3BlY2lmaWVyLmxvY2FsID0gdGhpcy5jbG9uZUlkZW50aWZpZXIoaW1wb3J0ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hJbXBvcnRTcGVjaWZpZXIoc3BlY2lmaWVyLCBcIkltcG9ydFNwZWNpZmllclwiLCBiaW5kaW5nVHlwZSk7XG4gIH1cbiAgaXNUaGlzUGFyYW0ocGFyYW0pIHtcbiAgICByZXR1cm4gcGFyYW0udHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgcGFyYW0ubmFtZSA9PT0gXCJ0aGlzXCI7XG4gIH1cbn1cbmNsYXNzIFBhcnNlciBleHRlbmRzIFN0YXRlbWVudFBhcnNlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGlucHV0LCBwbHVnaW5zTWFwKSB7XG4gICAgb3B0aW9ucyA9IGdldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgc3VwZXIob3B0aW9ucywgaW5wdXQpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5pbml0aWFsaXplU2NvcGVzKCk7XG4gICAgdGhpcy5wbHVnaW5zID0gcGx1Z2luc01hcDtcbiAgICB0aGlzLmZpbGVuYW1lID0gb3B0aW9ucy5zb3VyY2VGaWxlbmFtZTtcbiAgICB0aGlzLnN0YXJ0SW5kZXggPSBvcHRpb25zLnN0YXJ0SW5kZXg7XG4gICAgbGV0IG9wdGlvbkZsYWdzID0gMDtcbiAgICBpZiAob3B0aW9ucy5hbGxvd0F3YWl0T3V0c2lkZUZ1bmN0aW9uKSB7XG4gICAgICBvcHRpb25GbGFncyB8PSAxO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5hbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbikge1xuICAgICAgb3B0aW9uRmxhZ3MgfD0gMjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlKSB7XG4gICAgICBvcHRpb25GbGFncyB8PSA4O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5hbGxvd1N1cGVyT3V0c2lkZU1ldGhvZCkge1xuICAgICAgb3B0aW9uRmxhZ3MgfD0gMTY7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmFsbG93VW5kZWNsYXJlZEV4cG9ydHMpIHtcbiAgICAgIG9wdGlvbkZsYWdzIHw9IDY0O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5hbGxvd05ld1RhcmdldE91dHNpZGVGdW5jdGlvbikge1xuICAgICAgb3B0aW9uRmxhZ3MgfD0gNDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYWxsb3dZaWVsZE91dHNpZGVGdW5jdGlvbikge1xuICAgICAgb3B0aW9uRmxhZ3MgfD0gMzI7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnJhbmdlcykge1xuICAgICAgb3B0aW9uRmxhZ3MgfD0gMTI4O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy50b2tlbnMpIHtcbiAgICAgIG9wdGlvbkZsYWdzIHw9IDI1NjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuY3JlYXRlSW1wb3J0RXhwcmVzc2lvbnMpIHtcbiAgICAgIG9wdGlvbkZsYWdzIHw9IDUxMjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuY3JlYXRlUGFyZW50aGVzaXplZEV4cHJlc3Npb25zKSB7XG4gICAgICBvcHRpb25GbGFncyB8PSAxMDI0O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5lcnJvclJlY292ZXJ5KSB7XG4gICAgICBvcHRpb25GbGFncyB8PSAyMDQ4O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5hdHRhY2hDb21tZW50KSB7XG4gICAgICBvcHRpb25GbGFncyB8PSA0MDk2O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5hbm5leEIpIHtcbiAgICAgIG9wdGlvbkZsYWdzIHw9IDgxOTI7XG4gICAgfVxuICAgIHRoaXMub3B0aW9uRmxhZ3MgPSBvcHRpb25GbGFncztcbiAgfVxuICBnZXRTY29wZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIFNjb3BlSGFuZGxlcjtcbiAgfVxuICBwYXJzZSgpIHtcbiAgICB0aGlzLmVudGVySW5pdGlhbFNjb3BlcygpO1xuICAgIGNvbnN0IGZpbGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dFRva2VuKCk7XG4gICAgZmlsZS5lcnJvcnMgPSBudWxsO1xuICAgIHRoaXMucGFyc2VUb3BMZXZlbChmaWxlLCBwcm9ncmFtKTtcbiAgICBmaWxlLmVycm9ycyA9IHRoaXMuc3RhdGUuZXJyb3JzO1xuICAgIGZpbGUuY29tbWVudHMubGVuZ3RoID0gdGhpcy5zdGF0ZS5jb21tZW50c0xlbjtcbiAgICByZXR1cm4gZmlsZTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIF9vcHRpb25zO1xuICBpZiAoKChfb3B0aW9ucyA9IG9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfb3B0aW9ucy5zb3VyY2VUeXBlKSA9PT0gXCJ1bmFtYmlndW91c1wiKSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgIHRyeSB7XG4gICAgICBvcHRpb25zLnNvdXJjZVR5cGUgPSBcIm1vZHVsZVwiO1xuICAgICAgY29uc3QgcGFyc2VyID0gZ2V0UGFyc2VyKG9wdGlvbnMsIGlucHV0KTtcbiAgICAgIGNvbnN0IGFzdCA9IHBhcnNlci5wYXJzZSgpO1xuICAgICAgaWYgKHBhcnNlci5zYXdVbmFtYmlndW91c0VTTSkge1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgfVxuICAgICAgaWYgKHBhcnNlci5hbWJpZ3VvdXNTY3JpcHREaWZmZXJlbnRBc3QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBvcHRpb25zLnNvdXJjZVR5cGUgPSBcInNjcmlwdFwiO1xuICAgICAgICAgIHJldHVybiBnZXRQYXJzZXIob3B0aW9ucywgaW5wdXQpLnBhcnNlKCk7XG4gICAgICAgIH0gY2F0Y2ggKF91bnVzZWQpIHt9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc3QucHJvZ3JhbS5zb3VyY2VUeXBlID0gXCJzY3JpcHRcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhc3Q7XG4gICAgfSBjYXRjaCAobW9kdWxlRXJyb3IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG9wdGlvbnMuc291cmNlVHlwZSA9IFwic2NyaXB0XCI7XG4gICAgICAgIHJldHVybiBnZXRQYXJzZXIob3B0aW9ucywgaW5wdXQpLnBhcnNlKCk7XG4gICAgICB9IGNhdGNoIChfdW51c2VkMikge31cbiAgICAgIHRocm93IG1vZHVsZUVycm9yO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2V0UGFyc2VyKG9wdGlvbnMsIGlucHV0KS5wYXJzZSgpO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZUV4cHJlc3Npb24oaW5wdXQsIG9wdGlvbnMpIHtcbiAgY29uc3QgcGFyc2VyID0gZ2V0UGFyc2VyKG9wdGlvbnMsIGlucHV0KTtcbiAgaWYgKHBhcnNlci5vcHRpb25zLnN0cmljdE1vZGUpIHtcbiAgICBwYXJzZXIuc3RhdGUuc3RyaWN0ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcGFyc2VyLmdldEV4cHJlc3Npb24oKTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlRXhwb3J0ZWRUb2tlblR5cGVzKGludGVybmFsVG9rZW5UeXBlcykge1xuICBjb25zdCB0b2tlblR5cGVzID0ge307XG4gIGZvciAoY29uc3QgdHlwZU5hbWUgb2YgT2JqZWN0LmtleXMoaW50ZXJuYWxUb2tlblR5cGVzKSkge1xuICAgIHRva2VuVHlwZXNbdHlwZU5hbWVdID0gZ2V0RXhwb3J0ZWRUb2tlbihpbnRlcm5hbFRva2VuVHlwZXNbdHlwZU5hbWVdKTtcbiAgfVxuICByZXR1cm4gdG9rZW5UeXBlcztcbn1cbmNvbnN0IHRva1R5cGVzID0gZ2VuZXJhdGVFeHBvcnRlZFRva2VuVHlwZXModHQpO1xuZnVuY3Rpb24gZ2V0UGFyc2VyKG9wdGlvbnMsIGlucHV0KSB7XG4gIGxldCBjbHMgPSBQYXJzZXI7XG4gIGNvbnN0IHBsdWdpbnNNYXAgPSBuZXcgTWFwKCk7XG4gIGlmIChvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5wbHVnaW5zKSB7XG4gICAgZm9yIChjb25zdCBwbHVnaW4gb2Ygb3B0aW9ucy5wbHVnaW5zKSB7XG4gICAgICBsZXQgbmFtZSwgb3B0cztcbiAgICAgIGlmICh0eXBlb2YgcGx1Z2luID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG5hbWUgPSBwbHVnaW47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBbbmFtZSwgb3B0c10gPSBwbHVnaW47XG4gICAgICB9XG4gICAgICBpZiAoIXBsdWdpbnNNYXAuaGFzKG5hbWUpKSB7XG4gICAgICAgIHBsdWdpbnNNYXAuc2V0KG5hbWUsIG9wdHMgfHwge30pO1xuICAgICAgfVxuICAgIH1cbiAgICB2YWxpZGF0ZVBsdWdpbnMocGx1Z2luc01hcCk7XG4gICAgY2xzID0gZ2V0UGFyc2VyQ2xhc3MocGx1Z2luc01hcCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBjbHMob3B0aW9ucywgaW5wdXQsIHBsdWdpbnNNYXApO1xufVxuY29uc3QgcGFyc2VyQ2xhc3NDYWNoZSA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldFBhcnNlckNsYXNzKHBsdWdpbnNNYXApIHtcbiAgY29uc3QgcGx1Z2luTGlzdCA9IFtdO1xuICBmb3IgKGNvbnN0IG5hbWUgb2YgbWl4aW5QbHVnaW5OYW1lcykge1xuICAgIGlmIChwbHVnaW5zTWFwLmhhcyhuYW1lKSkge1xuICAgICAgcGx1Z2luTGlzdC5wdXNoKG5hbWUpO1xuICAgIH1cbiAgfVxuICBjb25zdCBrZXkgPSBwbHVnaW5MaXN0LmpvaW4oXCJ8XCIpO1xuICBsZXQgY2xzID0gcGFyc2VyQ2xhc3NDYWNoZS5nZXQoa2V5KTtcbiAgaWYgKCFjbHMpIHtcbiAgICBjbHMgPSBQYXJzZXI7XG4gICAgZm9yIChjb25zdCBwbHVnaW4gb2YgcGx1Z2luTGlzdCkge1xuICAgICAgY2xzID0gbWl4aW5QbHVnaW5zW3BsdWdpbl0oY2xzKTtcbiAgICB9XG4gICAgcGFyc2VyQ2xhc3NDYWNoZS5zZXQoa2V5LCBjbHMpO1xuICB9XG4gIHJldHVybiBjbHM7XG59XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5leHBvcnRzLnBhcnNlRXhwcmVzc2lvbiA9IHBhcnNlRXhwcmVzc2lvbjtcbmV4cG9ydHMudG9rVHlwZXMgPSB0b2tUeXBlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@babel+parser@7.28.0/node_modules/@babel/parser/lib/index.js\n");

/***/ })

};
;